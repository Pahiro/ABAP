<?xml version="1.0" encoding="utf-8"?>
<nugget name="MOVE_PLAN">
 <CLAS CLSNAME="ZCL_MOVE_PLAN" VERSION="1" LANGU="E" DESCRIPT="Move Plan" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSCCINCL="X" FIXPT="X" UNICODE="X" RSTAT="K" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
  <types CLSNAME="ZCL_MOVE_PLAN" CMPNAME="T_INSTANCE" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="1 " TYPTYPE="4" SRCROW1="4 " SRCCOLUMN1="6 " SRCROW2="7 " SRCCOLUMN2="24 " TYPESRC_LENG="0 " TYPESRC="BEGIN OF t_instance ,
        number   TYPE swxformabs-formnumber,
        instance TYPE REF TO zcl_move_plan,
      END   OF t_instance
"/>
  <types CLSNAME="ZCL_MOVE_PLAN" CMPNAME="T_INSTANCES" VERSION="1" LANGU="E" EXPOSURE="1" STATE="1" EDITORDER="2 " TYPTYPE="4" SRCROW1="9 " SRCCOLUMN1="6 " SRCROW2="9 " SRCCOLUMN2="50 " TYPESRC_LENG="0 " TYPESRC="t_instances TYPE STANDARD TABLE OF t_instance
"/>
  <implementing CLSNAME="ZCL_MOVE_PLAN" REFCLSNAME="IF_WORKFLOW" VERSION="1" EXPOSURE="2" STATE="1" RELTYPE="1" EDITORDER="3 "/>
  <events CLSNAME="ZCL_MOVE_PLAN" CMPNAME="CREATED" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " EVTDECLTYP="0" BCEVTCAT="00"/>
  <events CLSNAME="ZCL_MOVE_PLAN" CMPNAME="CHANGED" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " EVTDECLTYP="0" BCEVTCAT="00"/>
  <events CLSNAME="ZCL_MOVE_PLAN" CMPNAME="APPROVED" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " EVTDECLTYP="0" BCEVTCAT="00"/>
  <events CLSNAME="ZCL_MOVE_PLAN" CMPNAME="REJECTED" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " EVTDECLTYP="0" BCEVTCAT="00"/>
  <events CLSNAME="ZCL_MOVE_PLAN" CMPNAME="DELETED" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " EVTDECLTYP="0" BCEVTCAT="00"/>
  <events CLSNAME="ZCL_MOVE_PLAN" CMPNAME="DELETEERROROCCURED" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " EVTDECLTYP="0" BCEVTCAT="00"/>
  <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
  <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
  <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
  <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
  <typeUsage CLSNAME="ZCL_MOVE_PLAN" TYPEGROUP="SWFCO" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <typeUsage CLSNAME="ZCL_MOVE_PLAN" TYPEGROUP="SWHCL" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
  <forwardDeclaration>SWFCO</forwardDeclaration>
  <forwardDeclaration>SWHCL</forwardDeclaration>
  <typeClasDef CLSNAME="ZCL_MOVE_PLAN" TYPEGROUP="CL_SWF_BOR_TYPES" VERSION="1" TPUTYPE="1" EXPLICIT="X" IMPLICIT="X"/>
  <typeClasDef CLSNAME="ZCL_MOVE_PLAN" TYPEGROUP="CL_SWF_FORMABSENC" VERSION="1" TPUTYPE="1" EXPLICIT="X"/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="BPID" VERSION="1" LANGU="E" DESCRIPT="Business Partner Number" EXPOSURE="2" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BU_PARTNER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="BUILDING" VERSION="1" LANGU="E" DESCRIPT="Building (Block)" EXPOSURE="2" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="REBDXAO" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="CCEA_BPID" VERSION="1" LANGU="E" DESCRIPT="Business Partner Number" EXPOSURE="2" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BU_PARTNER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="CCEA_FIRST_NAME" VERSION="1" LANGU="E" DESCRIPT="CCEA First Name" EXPOSURE="2" STATE="1" EDITORDER="11 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="CCEA_LAST_NAME" VERSION="1" LANGU="E" DESCRIPT="CCEA Last Name" EXPOSURE="2" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="EMAIL" VERSION="1" LANGU="E" DESCRIPT="Email" EXPOSURE="2" STATE="1" EDITORDER="18 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="COMM_ID_LONG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="FIRST_NAME" VERSION="1" LANGU="E" DESCRIPT="First Name" EXPOSURE="2" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="FLOOR" VERSION="1" LANGU="E" DESCRIPT="Floor" EXPOSURE="2" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="REBDXAO" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="INSTANCE" VERSION="1" LANGU="E" DESCRIPT="Object Instace" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="3" TYPE="ZCL_MOVE_PLAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="LAST_NAME" VERSION="1" LANGU="E" DESCRIPT="Last Name" EXPOSURE="2" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="MAN_BPID" VERSION="1" LANGU="E" DESCRIPT="Business Partner Number" EXPOSURE="2" STATE="1" EDITORDER="16 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BU_PARTNER" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="MAN_FIRST_NAME" VERSION="1" LANGU="E" DESCRIPT="Manager First Name" EXPOSURE="2" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="MAN_LAST_NAME" VERSION="1" LANGU="E" DESCRIPT="Manager Last Name" EXPOSURE="2" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="MOVE_DATE" VERSION="1" LANGU="E" DESCRIPT="Date" EXPOSURE="2" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="MPID" VERSION="1" LANGU="E" DESCRIPT="Move Plan ID" EXPOSURE="2" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="REORPOMPID" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="MST_INSTANCES" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="T_INSTANCES" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="M_POR" VERSION="1" LANGU="E" DESCRIPT="Local Persistent Object Reference" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="SIBFLPOR" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="OBJ_ID" VERSION="1" LANGU="E" DESCRIPT="ID of Object" EXPOSURE="2" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="RECABUSOBJID" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="PLANNER_EMAIL" VERSION="1" LANGU="E" DESCRIPT="Planner Email" EXPOSURE="2" STATE="1" EDITORDER="17 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="COMM_ID_LONG" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="ROOM" VERSION="1" LANGU="E" DESCRIPT="Room" EXPOSURE="2" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="REBDXAO" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="T_0006" VERSION="1" LANGU="E" DESCRIPT="HR Master Record: Infotype 0006 (Addresses)" EXPOSURE="2" STATE="1" EDITORDER="19 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="ZT0006" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <attribute CLSNAME="ZCL_MOVE_PLAN" CMPNAME="URL" VERSION="1" LANGU="E" DESCRIPT="URL" EXPOSURE="2" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
  <interfaceMethod CLSNAME="ZCL_MOVE_PLAN" CPDNAME="BI_OBJECT~DEFAULT_ATTRIBUTE_VALUE">
   <source>METHOD bi_object~default_attribute_value.
*    GET REFERENCE OF me-&gt;description INTO result.
  ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOVE_PLAN" CPDNAME="BI_OBJECT~EXECUTE_DEFAULT_METHOD">
   <source>METHOD bi_object~execute_default_method.
*    TRY.
*        me-&gt;display( ).
*      CATCH cx_root.
*    ENDTRY.
  ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOVE_PLAN" CPDNAME="BI_OBJECT~RELEASE">
   <source>METHOD bi_object~release.
  ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOVE_PLAN" CPDNAME="BI_PERSISTENT~FIND_BY_LPOR">
   <source>METHOD bi_persistent~find_by_lpor.
    CREATE OBJECT result
      TYPE
      zcl_move_plan
      EXPORTING
        mpid = lpor-instid(10).

  ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOVE_PLAN" CPDNAME="BI_PERSISTENT~LPOR">
   <source>METHOD bi_persistent~lpor.
    result = me-&gt;m_por.
  ENDMETHOD.</source>
  </interfaceMethod>
  <interfaceMethod CLSNAME="ZCL_MOVE_PLAN" CPDNAME="BI_PERSISTENT~REFRESH">
   <source>METHOD bi_persistent~refresh.
  ENDMETHOD.</source>
  </interfaceMethod>
  <method CLSNAME="ZCL_MOVE_PLAN" CMPNAME="ACTIVATE_MOVE_PLAN" VERSION="1" LANGU="E" DESCRIPT="Activate Move Plan" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD activate_move_plan.
    DATA: lo_perm_occupancy TYPE REF TO if_reor_perm_occupancy_mp,
          go_busobj         TYPE REF TO if_reor_move_plan,
          lo_msglist        TYPE REF TO if_reca_message_list.
    DATA: if_in_update_task TYPE  abap_bool VALUE abap_true.
    DATA: if_force_check  TYPE  abap_bool VALUE abap_false.
    DATA: et_list TYPE re_t_msg.

    lo_msglist = cf_reca_message_list=&gt;create( ).

    CALL METHOD cf_reor_move_plan=&gt;find
      EXPORTING
        id_mpid       = me-&gt;mpid
        id_activity   = &apos;02&apos; &quot;Change - Check table TBZ0K.
        if_auth_check = abap_true
        if_enqueue    = abap_true
      RECEIVING
        ro_instance   = go_busobj
      EXCEPTIONS
        error         = 1
        OTHERS        = 2.

    IF go_busobj IS NOT INITIAL.
      lo_perm_occupancy ?= go_busobj-&gt;get_perm_occupancy( ).
      lo_perm_occupancy-&gt;activate_all( lo_msglist ).

      CALL METHOD go_busobj-&gt;set_activation(
          if_active  = &apos;X&apos;
          io_msglist = lo_msglist ).


      CALL METHOD go_busobj-&gt;store(
          if_in_update_task = if_in_update_task
          if_force_check    = if_force_check ).

      COMMIT WORK AND WAIT.

      CALL METHOD lo_msglist-&gt;get_list(
        IMPORTING
          et_list = et_list ).
    ENDIF.
  ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOVE_PLAN" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="Constructor" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOVE_PLAN" CMPNAME="CONSTRUCTOR" SCONAME="MPID" VERSION="1" LANGU="E" DESCRIPT="Move Plan ID" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="REORPOMPID"/>
   <source>METHOD constructor.
    me-&gt;mpid = mpid.
    CALL METHOD me-&gt;get_move_plan.
    m_por-instid = mpid.
    m_por-catid = &apos;CL&apos;.
    m_por-typeid = &apos;ZCL_MOVE_PLAN&apos;.
  ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOVE_PLAN" CMPNAME="CREATE" VERSION="1" LANGU="E" DESCRIPT="Create Method" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOVE_PLAN" CMPNAME="CREATE" SCONAME="MPID" VERSION="1" LANGU="E" DESCRIPT="Move Plan ID" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="0" TYPTYPE="1" TYPE="REORPOMPID"/>
   <parameter CLSNAME="ZCL_MOVE_PLAN" CMPNAME="CREATE" SCONAME="INSTANCE" VERSION="1" LANGU="E" DESCRIPT="Move Plan" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_MOVE_PLAN"/>
   <source>METHOD create.
    IF NOT mpid IS INITIAL AND instance IS INITIAL.
      CREATE OBJECT instance
        TYPE
        zcl_move_plan
        EXPORTING
          mpid = mpid.
    ENDIF.
  ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOVE_PLAN" CMPNAME="DELETE_MOVE_PLAN" VERSION="1" LANGU="E" DESCRIPT="Delete Move Plan" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD delete_move_plan.
    DATA: it_mpid TYPE ztmpid,
          wa_mpid LIKE LINE OF it_mpid.

    wa_mpid-mpid = me-&gt;mpid.
    APPEND wa_mpid TO it_mpid.

    CALL FUNCTION &apos;Z_BATCH_DEL_MP&apos;
      EXPORTING
        it_mpid = it_mpid.

  ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOVE_PLAN" CMPNAME="GET_MOVE_PLAN" VERSION="1" LANGU="E" DESCRIPT="Get Detail for the Move Plan" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD get_move_plan.
    DATA: wa_moveplan TYPE bapi_re_move_plan,
          it_target   TYPE TABLE OF bapi_re_mp_target,
          wa_target   LIKE LINE OF it_target,
          it_occupant TYPE TABLE OF bapi_re_mp_occupant,
          wa_occupant LIKE LINE OF it_occupant,
          it_occplan  TYPE TABLE OF bapi_re_mp_occplan,
          wa_occplan  LIKE LINE OF it_occplan.
    DATA: wa_pa0001  TYPE pa0001,
          wa_hrp1001 TYPE hrp1001,
          lv_kostl   TYPE kostl,
          lv_resp    TYPE reorrespobjnrdef,
          lv_ccea    TYPE char01,
          lv_empl    TYPE char01,
          lv_eauname TYPE xubname.
    DATA: lv_defcceaunam TYPE string.
    DATA: wa_address TYPE bapiaddr3.
    DATA: it_return TYPE TABLE OF bapiret2.
    DATA: wa_0006   TYPE p0006.
    DATA: lv_intreno TYPE recaintreno,
          lv_hold    TYPE recaintreno,
          lv_adrnr   TYPE ad_addrnum.
    DATA: lv_type TYPE rebdaotype.
    DATA: lv_sinstbez TYPE sinstbez,
          lv_xkbez    TYPE xkbez.
    DATA: lv_lines TYPE num4.

    CALL FUNCTION &apos;BAPI_RE_MP_GET_DETAIL&apos;
      EXPORTING
        moveplanid  = me-&gt;mpid
      IMPORTING
        move_plan   = wa_moveplan
      TABLES
        mp_occupant = it_occupant
        mp_target   = it_target
        mp_occplan  = it_occplan.

    &quot;Approvals will only be used for Single Moves, not batch.
    &quot;If a batch/manual is being used, IE. When t_0006/it_occupant has multiple entries,
    &quot;the UPDATE_HCM method will be called directly and none of the other
    &quot;attributes will be used. As is the case with all manual moves through RE80/REORMP.
    &quot;Check ZCL_IM_GOS_SRV_SELECT.
    LOOP AT it_occupant INTO wa_occupant.
      DESCRIBE TABLE it_target LINES lv_lines.
      &quot;        &quot;There&apos;s still some trouble with BAPI_RE_MP_GET_DETAIL. OLD &amp; NEW objs are set the same in OCCPLAN.
      &quot;        &quot;Rather than getting the obj from the BAPI I&apos;m getting it from VIORPO further down.
      &quot;      READ TABLE it_occplan INTO wa_occplan WITH KEY occupant = wa_occupant-occupant planning_type = &apos;I&apos;.
      &quot;
      &quot;      IF lv_lines = 1.
      &quot;        READ TABLE it_target INTO wa_target INDEX 1.
      &quot;        wa_occplan-reservation_obj_id = wa_target-reservation_obj_id.
      &quot;        wa_occplan-reservation_obj_type = wa_target-reservation_obj_type.
      &quot;      ENDIF.
      &quot;      CLEAR lv_lines.
      CONCATENATE wa_moveplan-perm_occ_date_from+6(2) &apos;-&apos;
                  wa_moveplan-perm_occ_date_from+4(2) &apos;-&apos;
                  wa_moveplan-perm_occ_date_from+0(4) INTO me-&gt;move_date.

      wa_0006-zbpnr = wa_occupant-occupant.
      me-&gt;bpid = wa_occupant-occupant.
      wa_0006-pernr = wa_0006-zbpnr+2(8).

      SELECT SINGLE usrid_long FROM pa0105 INTO me-&gt;email
        WHERE pernr = wa_0006-pernr AND
              subty = &apos;0010&apos; AND
              begda &lt;= sy-datum AND
              endda &gt;= sy-datum.
      IF sy-subrc = 4 OR me-&gt;email = &apos;&apos;. &quot;To make sure the workflow doesn&apos;t fail here.
        me-&gt;email = &apos;noemail@nedbank.co.za&apos;.
      ENDIF.

      SELECT SINGLE value FROM zconfig INTO me-&gt;planner_email
        WHERE keyfield = &apos;PLANEMAIL&apos;.

      wa_0006-begda = wa_moveplan-move_in_date.
      wa_0006-endda = wa_moveplan-perm_occ_date_to.
      wa_0006-uname = &apos;BATCHBC&apos;.

      SELECT SINGLE but000~name_first but000~name_last FROM but000
        INTO (me-&gt;first_name,me-&gt;last_name)
        WHERE partner = wa_occupant-occupant.

      SELECT SINGLE value FROM zconfig
        INTO me-&gt;url
        WHERE keyfield = &apos;APPRURL&apos;.

      &quot;Line Manager
      SELECT SINGLE * FROM pa0001 INTO wa_pa0001 &quot;Org Unit
          WHERE pernr = wa_occupant-occupant+2(8) AND
                endda &gt;= sy-datum AND
                begda &lt;= sy-datum.
      SELECT SINGLE * FROM hrp1001 INTO wa_hrp1001 &quot;Position controlling Org Unit
      WHERE otype = &apos;O&apos; AND
            objid = wa_pa0001-orgeh AND
            relat = &apos;012&apos; AND
            rsign = &apos;B&apos; AND
            endda &gt;= sy-datum AND
            begda &lt;= sy-datum.

      SELECT SINGLE * FROM hrp1001 INTO wa_hrp1001 &quot;Person in Position
       WHERE otype = &apos;S&apos; AND
             objid = wa_hrp1001-sobid AND
             relat = &apos;008&apos; AND
             rsign = &apos;A&apos; AND
             endda &gt;= sy-datum AND
             begda &lt;= sy-datum.

* @(｡◕ ‿ ◕｡)@ - Loop until line manager is found.

      IF wa_hrp1001-sobid = wa_occupant-occupant+2(8) OR sy-subrc &lt;&gt; 0.

        DATA(lv_orgeh) = wa_pa0001-orgeh.

        WHILE sy-subrc &lt;&gt; 0 OR wa_hrp1001-sobid = wa_occupant-occupant+2(8).
          SELECT SINGLE * FROM hrp1001 INTO wa_hrp1001 &quot;Org Unit above current
            WHERE otype = &apos;O&apos; AND
                  objid = lv_orgeh AND
                  relat = &apos;002&apos; AND
                  rsign = &apos;A&apos; AND
                  endda &gt;= sy-datum AND
                  begda &lt;= sy-datum.
          IF sy-subrc = 4.
            EXIT. &quot;Exit loop if no more org units are found.
          ENDIF.
          lv_orgeh = wa_hrp1001-sobid. &quot;Move new org unit into variable.

          SELECT SINGLE * FROM hrp1001 INTO wa_hrp1001 &quot;Position Above Org Unit
           WHERE objid = wa_hrp1001-sobid AND
                 relat = &apos;012&apos; AND
                 rsign = &apos;B&apos; AND
                 endda &gt;= sy-datum AND
                 begda &lt;= sy-datum.

          SELECT SINGLE * FROM hrp1001 INTO wa_hrp1001 &quot;Person in Position
            WHERE objid = wa_hrp1001-sobid AND
                  relat = &apos;008&apos; AND
                  rsign = &apos;A&apos; AND
                  endda &gt;= sy-datum AND
                  begda &lt;= sy-datum.
        ENDWHILE.
      ENDIF.

      IF sy-subrc = 0.
        CONCATENATE &apos;EE&apos; wa_hrp1001-sobid INTO me-&gt;man_bpid.
        SELECT SINGLE name_first name_last FROM but000
          INTO (me-&gt;man_first_name, me-&gt;man_last_name)
          WHERE partner = me-&gt;man_bpid.
        IF sy-subrc = 4.
          me-&gt;man_first_name = &apos;No&apos;.
          me-&gt;man_last_name = &apos;Manager&apos;.
        ENDIF.
      ELSE.

      ENDIF.
      IF wa_occplan-reservation_obj_id IS INITIAL. &quot;If it&apos;s initial, try and get it from VIORPO
        SELECT vibdao~aoid FROM viorpo
            INNER JOIN vioroo ON  vioroo~objnr = viorpo~objnroo
            INNER JOIN vibdao ON  vibdao~objnr = vioroo~objnrref
            UP TO 1 ROWS
            INTO (wa_occplan-reservation_obj_id)
             WHERE viorpo~occupant = wa_occupant-occupant AND
                   viorpo~plantype = &apos;I&apos; AND &quot;Move In
                   viorpo~mpid = me-&gt;mpid
          ORDER BY viorpo~mpid DESCENDING. &quot;For current move plan
        ENDSELECT.
*        IF sy-subrc = 4.
*          READ TABLE it_occplan INTO wa_occplan INDEX 1.
*        ENDIF.
      ENDIF.
      &quot;Cost Centre Expense Approver
      SELECT SINGLE respobjnrdef FROM vioroo
          INNER JOIN vibdao ON vibdao~objnr = vioroo~objnrref
          INTO lv_resp
          WHERE vibdao~aoid = wa_occplan-reservation_obj_id.
      DATA(lv_bukrs) = lv_resp+2(4).
      IF lv_resp IS NOT INITIAL.
        lv_kostl = lv_resp+6(14).
      ELSE. &quot;Default Deon&apos;s cost centre.
        lv_kostl = &apos;CGBS19049&apos;.
        lv_bukrs = &apos;1000&apos;.
        SELECT SINGLE value FROM zconfig INTO lv_defcceaunam
          WHERE keyfield = &apos;DEFCCEAUNA&apos;.
        SPLIT lv_defcceaunam AT &apos;|&apos; INTO me-&gt;ccea_first_name me-&gt;ccea_last_name me-&gt;ccea_bpid.
      ENDIF.

      IF lv_kostl IS NOT INITIAL AND lv_defcceaunam IS INITIAL.
        &quot; Get username
        DATA: lv_level   TYPE /opt/a_appr_level_de,
              lv_counter TYPE /opt/counter,
              lv_userid  TYPE /ors/umoid.

        SELECT SINGLE MIN( appr_level ) MIN( counter ) FROM /opt/appr_coa
          INTO (lv_level, lv_counter)
          WHERE kostl = lv_kostl AND
                comp_code = lv_bukrs.

        SELECT SINGLE opt_userid FROM /opt/appr_coa
          INTO lv_userid
          WHERE appr_level = lv_level AND
                counter = lv_counter AND
                kostl = lv_kostl AND
                comp_code = lv_bukrs.

        SELECT SINGLE sap_user_id FROM /ors/usermap &quot;Seperated select because inner join wasn&apos;t retrieving the correct entry.
          INTO lv_eauname
          WHERE opt_userid = lv_userid.

        CALL FUNCTION &apos;BAPI_USER_GET_DETAIL&apos;
          EXPORTING
            username = lv_eauname
          IMPORTING
            address  = wa_address
          TABLES
            return   = it_return.

        me-&gt;ccea_first_name = wa_address-firstname.
        me-&gt;ccea_last_name = wa_address-lastname.
        MOVE lv_eauname TO me-&gt;ccea_bpid.

        IF me-&gt;ccea_bpid IS INITIAL.
          lv_kostl = &apos;CGBS19049&apos;.
          SELECT SINGLE value FROM zconfig INTO lv_defcceaunam
            WHERE keyfield = &apos;DEFCCEAUNA&apos;.
          SPLIT lv_defcceaunam AT &apos;|&apos; INTO me-&gt;ccea_first_name me-&gt;ccea_last_name me-&gt;ccea_bpid.
        ENDIF.
      ENDIF.

      SELECT SINGLE intreno xao partaoid FROM vibdao INTO (wa_0006-zroom, wa_0006-zxaor, wa_0006-partaoid)
        WHERE aoid = wa_occplan-reservation_obj_id.
      me-&gt;room = wa_0006-zxaor.

      lv_intreno = wa_0006-zroom.

      SELECT SINGLE ooidext FROM vioroo AS off
            INNER JOIN vibdao AS arch ON arch~objnr = off~objnrref
            INTO wa_0006-zloci
            WHERE arch~intreno = lv_intreno.

      me-&gt;obj_id = wa_occplan-reservation_obj_id.

      &quot;Find an address number for any object on the Hierarchy.
      WHILE sy-subrc = 0.

        IF lv_intreno IS NOT INITIAL AND lv_adrnr IS INITIAL.
          SELECT SINGLE adrnr FROM vzobject INTO lv_adrnr
            WHERE adrobjnr = lv_intreno. &quot;Loop through until you find an address on any level.
        ENDIF.

        SELECT SINGLE parent aotype_pa FROM vibdnode
          INTO (lv_intreno, lv_type)
          WHERE intreno = lv_intreno.
        IF lv_type = &apos;03BU&apos;.
          SELECT SINGLE intreno sinstbez xao FROM vibdao
            INTO (wa_0006-zbuil, lv_sinstbez, wa_0006-zxaob)
            WHERE intreno = lv_intreno.
          me-&gt;building = wa_0006-zxaob.
          IF lv_sinstbez IS NOT INITIAL.
            SELECT SINGLE xkbez FROM tiv16
              INTO lv_xkbez
              WHERE tiv16~sinstbez = lv_sinstbez.

            SELECT SINGLE tivga~xgemeinde FROM tivga
               INTO wa_0006-zmuni
              WHERE gemeinde = lv_xkbez AND
                    tivga~spras = &apos;EN&apos;.
          ENDIF.
        ELSEIF lv_type = &apos;04FL&apos;.
          SELECT SINGLE intreno xao FROM vibdao
            INTO (wa_0006-zfloo, wa_0006-zxaof)
            WHERE intreno = lv_intreno.
          me-&gt;floor = wa_0006-zxaof.
        ENDIF.
      ENDWHILE.

      &quot;Address Detail.
      IF lv_adrnr IS NOT INITIAL.
        SELECT SINGLE city1 city2 region country house_num2 street post_code1 region house_num1 FROM adrc &quot;str_suppl1 str_suppl2 FROM adrc
          INTO (wa_0006-ort01, wa_0006-ort02, wa_0006-zstate, wa_0006-zland1, wa_0006-zmoun,wa_0006-stras,wa_0006-pstlz, wa_0006-state, wa_0006-hsnmr)&quot;, wa_0006-posta, wa_0006-locat)
          WHERE addrnumber = lv_adrnr.

        REPLACE ALL OCCURRENCES OF &apos;,&apos; IN wa_0006-stras WITH &apos;-&apos;.

        SELECT SINGLE land1 landx FROM t005t
          INTO (wa_0006-land1,wa_0006-landx)
          WHERE land1 = wa_0006-zland1 AND
                spras = &apos;EN&apos;.
        SELECT SINGLE bezei FROM t005u
          INTO wa_0006-bezei
          WHERE bland = wa_0006-zstate AND
                land1 = wa_0006-zland1 AND
                spras = &apos;EN&apos;.
      ENDIF.

      wa_0006-zplid = me-&gt;mpid.
      SELECT SINGLE mpstatus FROM viormp
        INTO wa_0006-zstat
        WHERE mpid = wa_0006-zplid.

      &quot;Hardcode for Work Address Update.
      wa_0006-infty = &apos;0006&apos;.
      wa_0006-subty = &apos;90&apos;.
      wa_0006-anssa = &apos;90&apos;.

      CASE wa_0006-zstat.
        WHEN &apos;&apos;.
          wa_0006-zstattxt = &apos;Move Planning in Process&apos;.
        WHEN &apos;1&apos;.
          wa_0006-zstattxt = &apos;Move Planning Completed&apos;.
        WHEN &apos;2&apos;.
          wa_0006-zstattxt = &apos;Move Activated&apos;.
      ENDCASE.

      APPEND wa_0006 TO me-&gt;t_0006.
    ENDLOOP.
    instance = me.
  ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOVE_PLAN" CMPNAME="RELEASE_MOVE_PLAN" VERSION="1" LANGU="E" DESCRIPT="Release Move Plan" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <source>METHOD release_move_plan.
    DATA: lo_perm_occupancy TYPE REF TO if_reor_perm_occupancy_mp,
          go_busobj         TYPE REF TO if_reor_move_plan,
          lo_msglist        TYPE REF TO if_reca_message_list.
    DATA: if_in_update_task TYPE  abap_bool VALUE abap_true.
    DATA: if_force_check  TYPE  abap_bool VALUE abap_false.
    DATA: et_list TYPE re_t_msg.

    lo_msglist = cf_reca_message_list=&gt;create( ).

    CALL METHOD cf_reor_move_plan=&gt;find
      EXPORTING
        id_mpid       = me-&gt;mpid
        id_activity   = &apos;02&apos; &quot;Change - Check table TBZ0K.
        if_auth_check = abap_true
        if_enqueue    = abap_true
      RECEIVING
        ro_instance   = go_busobj
      EXCEPTIONS
        error         = 1
        OTHERS        = 2.

    IF go_busobj IS NOT INITIAL.
      lo_perm_occupancy ?= go_busobj-&gt;get_perm_occupancy( ).
      lo_perm_occupancy-&gt;release_all( lo_msglist ).

      CALL METHOD go_busobj-&gt;store(
          if_in_update_task = if_in_update_task
          if_force_check    = if_force_check ).

      COMMIT WORK AND WAIT.

      CALL METHOD lo_msglist-&gt;get_list(
        IMPORTING
          et_list = et_list ).
    ENDIF.
  ENDMETHOD.</source>
  </method>
  <method CLSNAME="ZCL_MOVE_PLAN" CMPNAME="UPDATE_HCM" VERSION="1" LANGU="E" DESCRIPT="Update HCM System" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
   <parameter CLSNAME="ZCL_MOVE_PLAN" CMPNAME="UPDATE_HCM" SCONAME="RETURN" VERSION="1" LANGU="E" DESCRIPT="Return Parameter" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="BAPIRETURN1"/>
   <source>METHOD update_hcm.
    DATA: lv_rfc TYPE char10.
    DATA: wa_0006 TYPE p0006.
    DATA: lv_taskn TYPE string.

    SELECT SINGLE value FROM zconfig INTO lv_rfc
      WHERE keyfield = &apos;REFXHCMRFC&apos;.
    IF lv_rfc IS NOT INITIAL.

      LOOP AT me-&gt;t_0006 INTO wa_0006.
        MOVE sy-tabix TO lv_taskn.
        CONCATENATE &apos;UpdateHCM - &apos; lv_taskn INTO lv_taskn.
        CALL FUNCTION &apos;ZHCM_UPDATE_0006&apos; DESTINATION lv_rfc
          STARTING NEW TASK lv_taskn
          EXPORTING
            it0006 = wa_0006.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.</source>
  </method>
 </CLAS>
 <WDYN COMPONENT_NAME="ZEMPLOYEE_LOCATION" VERSION="A" TYPE="0" CMP_CONTROLLER="COMPONENTCONTROLLER" CMP_INTERFACE="COMPONENTINTERFACE" DISPLAY_NAME="ZEMPLOYEE_LOCATION" CONFIG_EXPL_PROP="0" CONFIG_IMPL_PROP="0" P13N_EXPL_PROP="0" P13N_IMPL_PROP="0" ASSISTANCE_CLASS="CL_WDR_DEMO_HELPER">
  <wdy_componentt COMPONENT_NAME="ZEMPLOYEE_LOCATION" LANGU="D" DESCRIPTION="Standard-Library: Selection"/>
  <wdy_componentt COMPONENT_NAME="ZEMPLOYEE_LOCATION" LANGU="E" DESCRIPTION="Standard Library: Selection"/>
  <wdy_intf_implem COMPONENT_NAME="ZEMPLOYEE_LOCATION" INTERFACE_NAME="ZIF_LOC" VERSION="I"/>
  <view_definition COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" VERSION="A" TYPE="CL_WDY_MD_VIEW" VIEW_TYPE="00" LIFESPAN="0" VIEW_CONTROLLER="DROPDOWN_BY_KEY" ROOT_UI_CONT="ROOTUIELEMENTCONTAINER" DISPLAY_NAME="DROPDOWN_BY_KEY" VISIBILITY="00">
   <wdy_viewt COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" LANGU="D" DESCRIPTION="DropDownByKey"/>
   <wdy_viewt COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" LANGU="E" DESCRIPTION="Employee Location"/>
   <wdy_iobound_plug COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" PLUG_NAME="IN" VERSION="I" PLUG_TYPE="CL_WDY_MD_INBOUND_PLUG" IN_PLUG_TYPE="0" OUT_PLUG_TYPE="0" DISPLAY_NAME="IN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" ELEMENT_POSITION="21 " UI_ELEMENT_TYPE="CL_WDY_MD_TEXT_EDIT" DISPLAY_NAME="ADDRESS" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="TEXT_EDIT" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="ADDRESS_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="ADDRESS" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1" VERSION="I" ELEMENT_POSITION="7 " UI_ELEMENT_TYPE="CL_WDY_MD_DROP_DOWN_BY_KEY" DISPLAY_NAME="DROPDOWN_BY_KEY_1" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="DROPDOWN_BY_KEY" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LABEL_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_MATRIX_HEAD_DATA" DISPLAY_NAME="DROPDOWN_BY_KEY_1_LABEL_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="MATRIX_HEAD_DATA" PARENT_NAME="DROPDOWN_BY_KEY_1_LABEL" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="DROPDOWN_BY_KEY_1_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="DROPDOWN_BY_KEY_1" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" VERSION="I" ELEMENT_POSITION="9 " UI_ELEMENT_TYPE="CL_WDY_MD_DROP_DOWN_BY_KEY" DISPLAY_NAME="DROPDOWN_BY_KEY_2" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="DROPDOWN_BY_KEY" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="DROPDOWN_BY_KEY_2_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="DROPDOWN_BY_KEY_2" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3" VERSION="I" ELEMENT_POSITION="11 " UI_ELEMENT_TYPE="CL_WDY_MD_DROP_DOWN_BY_KEY" DISPLAY_NAME="DROPDOWN_BY_KEY_3" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="DROPDOWN_BY_KEY" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="DROPDOWN_BY_KEY_3_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="DROPDOWN_BY_KEY_3" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" VERSION="I" ELEMENT_POSITION="13 " UI_ELEMENT_TYPE="CL_WDY_MD_DROP_DOWN_BY_KEY" DISPLAY_NAME="DROPDOWN_BY_KEY_4" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="DROPDOWN_BY_KEY" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="DROPDOWN_BY_KEY_4_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="DROPDOWN_BY_KEY_4" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" VERSION="I" ELEMENT_POSITION="15 " UI_ELEMENT_TYPE="CL_WDY_MD_DROP_DOWN_BY_KEY" DISPLAY_NAME="DROPDOWN_BY_KEY_5" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="DROPDOWN_BY_KEY" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="DROPDOWN_BY_KEY_5_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="DROPDOWN_BY_KEY_5" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" VERSION="I" ELEMENT_POSITION="2 " UI_ELEMENT_TYPE="CL_WDY_MD_INPUT_FIELD" DISPLAY_NAME="FROM" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="INPUT_FIELD" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="FROM_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="FROM" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" ELEMENT_POSITION="25 " UI_ELEMENT_TYPE="CL_WDY_MD_LINK_TO_URL" DISPLAY_NAME="HELP_DESK" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="LINK_TO_URL" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="HELP_DESK_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="HELP_DESK" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" ELEMENT_POSITION="26 " UI_ELEMENT_TYPE="CL_WDY_MD_LINK_TO_URL" DISPLAY_NAME="HELP_GUIDE" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="LINK_TO_URL" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE_LAYOUT_DATA" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="HELP_GUIDE_LAYOUT_DATA" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="HELP_GUIDE" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS" VERSION="I" ELEMENT_POSITION="20 " UI_ELEMENT_TYPE="CL_WDY_MD_CAPTION" DISPLAY_NAME="LABEL_ADDRESS" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="CAPTION" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS_LAYOUT_DATA" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LABEL_ADDRESS_LAYOUT_DATA" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LABEL_ADDRESS" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING" VERSION="I" ELEMENT_POSITION="10 " UI_ELEMENT_TYPE="CL_WDY_MD_LABEL" DISPLAY_NAME="LABEL_BUILDING" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="LABEL" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LABEL_BUILDING_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LABEL_BUILDING" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX" VERSION="I" ELEMENT_POSITION="8 " UI_ELEMENT_TYPE="CL_WDY_MD_LABEL" DISPLAY_NAME="LABEL_COMPLEX" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="LABEL" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LABEL_COMPLEX_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LABEL_COMPLEX" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR" VERSION="I" ELEMENT_POSITION="12 " UI_ELEMENT_TYPE="CL_WDY_MD_LABEL" DISPLAY_NAME="LABEL_FLOOR" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="LABEL" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LABEL_FLOOR_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LABEL_FLOOR" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_LABEL" DISPLAY_NAME="LABEL_FROM" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="LABEL" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LABEL_FROM_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LABEL_FROM" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION" VERSION="I" ELEMENT_POSITION="6 " UI_ELEMENT_TYPE="CL_WDY_MD_LABEL" DISPLAY_NAME="LABEL_LOCATION" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="LABEL" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LABEL_LOCATION_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LABEL_LOCATION" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM" VERSION="I" ELEMENT_POSITION="14 " UI_ELEMENT_TYPE="CL_WDY_MD_LABEL" DISPLAY_NAME="LABEL_ROOM" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="LABEL" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LABEL_ROOM_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LABEL_ROOM" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO" VERSION="I" ELEMENT_POSITION="3 " UI_ELEMENT_TYPE="CL_WDY_MD_LABEL" DISPLAY_NAME="LABEL_TO" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="LABEL" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO_LAYOUT_DATA" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LABEL_TO_LAYOUT_DATA" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LABEL_TO" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1" VERSION="I" ELEMENT_POSITION="5 " UI_ELEMENT_TYPE="CL_WDY_MD_HORIZONTAL_GUTTER" DISPLAY_NAME="LINE1" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="HORIZONTAL_GUTTER" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1_LAYOUT_DATA" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LINE1_LAYOUT_DATA" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LINE1" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2" VERSION="I" ELEMENT_POSITION="16 " UI_ELEMENT_TYPE="CL_WDY_MD_HORIZONTAL_GUTTER" DISPLAY_NAME="LINE2" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="HORIZONTAL_GUTTER" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LINE2_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LINE2" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3" VERSION="I" ELEMENT_POSITION="19 " UI_ELEMENT_TYPE="CL_WDY_MD_HORIZONTAL_GUTTER" DISPLAY_NAME="LINE3" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="HORIZONTAL_GUTTER" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LINE3_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LINE3" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4" VERSION="I" ELEMENT_POSITION="22 " UI_ELEMENT_TYPE="CL_WDY_MD_HORIZONTAL_GUTTER" DISPLAY_NAME="LINE4" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="HORIZONTAL_GUTTER" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4_LAYOUT_DATA" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="LINE4_LAYOUT_DATA" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="LINE4" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE" VERSION="I" ELEMENT_POSITION="24 " UI_ELEMENT_TYPE="CL_WDY_MD_MESSAGE_AREA" DISPLAY_NAME="MESSAGE" UI_ELEM_DEF_LIB="PATTERN" UI_ELEMENT_DEF="MESSAGE_AREA" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="MESSAGE_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="MESSAGE" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER" VERSION="I" ELEMENT_POSITION="0 " UI_ELEMENT_TYPE="CL_WDY_MD_TRANSP_CONTAINER" DISPLAY_NAME="ROOTUIELEMENTCONTAINER" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="TRANSPARENT_CONTAINER"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER_LAYOUT" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_LAYOUT" DISPLAY_NAME="ROOTUIELEMENTCONTAINER_LAYOUT" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_LAYOUT" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="LAYOUT"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON" VERSION="I" ELEMENT_POSITION="18 " UI_ELEMENT_TYPE="CL_WDY_MD_BUTTON" DISPLAY_NAME="SEARCH_BUTTON" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="BUTTON" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="SEARCH_BUTTON_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="SEARCH_BUTTON" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" VERSION="I" ELEMENT_POSITION="17 " UI_ELEMENT_TYPE="CL_WDY_MD_INPUT_FIELD" DISPLAY_NAME="SEARCH_INPUT" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="INPUT_FIELD" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="SEARCH_INPUT_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="SEARCH_INPUT" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON" VERSION="I" ELEMENT_POSITION="23 " UI_ELEMENT_TYPE="CL_WDY_MD_BUTTON" DISPLAY_NAME="SUBMIT_BUTTON" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="BUTTON" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="SUBMIT_BUTTON_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="SUBMIT_BUTTON" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" ELEMENT_POSITION="4 " UI_ELEMENT_TYPE="CL_WDY_MD_INPUT_FIELD" DISPLAY_NAME="TO" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="INPUT_FIELD" PARENT_NAME="ROOTUIELEMENTCONTAINER" AGGREGATION_NAME="CHILDREN"/>
   <wdy_ui_element COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO_LD" VERSION="I" ELEMENT_POSITION="1 " UI_ELEMENT_TYPE="CL_WDY_MD_GRID_DATA" DISPLAY_NAME="TO_LD" UI_ELEM_DEF_LIB="STANDARD" UI_ELEMENT_DEF="GRID_DATA" PARENT_NAME="TO" AGGREGATION_NAME="LAYOUT_DATA"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="COLS" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="09"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="DISPLAY_ONLY" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="IME_MODE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="READ_ONLY" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="ROWS" PROPERTY_VALUE="5"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="STATE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="350px"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" VERSION="I" PROPERTY_NAME="WRAPPING" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="03"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS_LD" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="200px"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1" VERSION="I" PROPERTY_NAME="INPUT_PROMPT" PROPERTY_VALUE="3ED475463B021ED58498DDF2382D1B6C" PropText="Select Country"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1" VERSION="I" PROPERTY_NAME="STATE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="390px"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LABEL_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LABEL_LD" VERSION="I" PROPERTY_NAME="CELL_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LABEL_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LABEL_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LABEL_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LABEL_LD" VERSION="I" PROPERTY_NAME="V_GUTTER" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="3"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" VERSION="I" PROPERTY_NAME="INPUT_PROMPT" PROPERTY_VALUE="3ED475463B021ED58498DDF580B7DB6C" PropText="Select Region"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" VERSION="I" PROPERTY_NAME="READ_ONLY" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" VERSION="I" PROPERTY_NAME="STATE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="390px"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="3"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3" VERSION="I" PROPERTY_NAME="INPUT_PROMPT" PROPERTY_VALUE="3ED475463B021ED58498DDF5B34F1B6C" PropText="Select Building"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3" VERSION="I" PROPERTY_NAME="STATE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="390px"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="3"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" VERSION="I" PROPERTY_NAME="INPUT_PROMPT" PROPERTY_VALUE="3ED475463B021ED58498DDF5E1595B6C" PropText="Select Floor"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" VERSION="I" PROPERTY_NAME="LABEL_FOR" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" VERSION="I" PROPERTY_NAME="STATE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="390px"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="3"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" VERSION="I" PROPERTY_NAME="INPUT_PROMPT" PROPERTY_VALUE="3ED475463B021ED58498DDF60B9ADB6C" PropText="Select Location"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" VERSION="I" PROPERTY_NAME="LABEL_FOR" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" VERSION="I" PROPERTY_NAME="STATE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="390px"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="3"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" VERSION="I" PROPERTY_NAME="ALIGNMENT" PROPERTY_VALUE="03"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" VERSION="I" PROPERTY_NAME="IME_MODE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" VERSION="I" PROPERTY_NAME="LENGTH" PROPERTY_VALUE="0"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" VERSION="I" PROPERTY_NAME="STATE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="CONTROL_MENU_DISABLING" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="HOTKEY" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="IMAGE_FIRST" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="REFERENCE" PROPERTY_VALUE="http://hrtools.it.nednet.co.za/ServiceDesk/?ProcessID825"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B031ED59099C9B36D4A41A1" PropText="Please click here for support"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="TYPE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_DESK_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="CONTROL_MENU_DISABLING" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="HOTKEY" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="IMAGE_FIRST" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="REFERENCE" PROPERTY_VALUE="http://intranet.nednet.co.za/sites/HR/People/HCM REM Help Guide/Help Guide.pdf"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B031ED59099D46DB65E01A1" PropText="Please click here for Input Help Guide"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="TYPE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="HELP_GUIDE_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS" VERSION="I" PROPERTY_NAME="IMAGE_FIRST" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B021EE58DBC2BAA7AA9CA66" PropText="Address:"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ADDRESS_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING" VERSION="I" PROPERTY_NAME="LABEL_FOR" PROPERTY_VALUE="DROPDOWN_BY_KEY_3"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B021ED58498DDF66D135B6C" PropText="Building"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING" VERSION="I" PROPERTY_NAME="WIDTH" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_BUILDING_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX" VERSION="I" PROPERTY_NAME="LABEL_FOR" PROPERTY_VALUE="DROPDOWN_BY_KEY_2"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B021ED58498DDF6A6061B6C" PropText="Region"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX" VERSION="I" PROPERTY_NAME="WIDTH" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_COMPLEX_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR" VERSION="I" PROPERTY_NAME="LABEL_FOR" PROPERTY_VALUE="DROPDOWN_BY_KEY_4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B021ED58498DDF6DE4D9B6C" PropText="Floor"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR" VERSION="I" PROPERTY_NAME="WIDTH" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FLOOR_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM" VERSION="I" PROPERTY_NAME="LABEL_FOR" PROPERTY_VALUE="FROM"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B031ED59099B1245C7281A1" PropText="Planned Move Date"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM" VERSION="I" PROPERTY_NAME="WIDTH" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_FROM_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION" VERSION="I" PROPERTY_NAME="LABEL_FOR" PROPERTY_VALUE="DROPDOWN_BY_KEY_1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B021ED58498DDF709445B6C" PropText="Country"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION" VERSION="I" PROPERTY_NAME="WIDTH" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_LOCATION_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM" VERSION="I" PROPERTY_NAME="LABEL_FOR" PROPERTY_VALUE="DROPDOWN_BY_KEY_3"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B021ED58498DDF73F7EDB6C" PropText="Location"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM" VERSION="I" PROPERTY_NAME="WIDTH" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_ROOM_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO" VERSION="I" PROPERTY_NAME="LABEL_FOR" PROPERTY_VALUE="TO"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B031ED59099B1AC9F9C81A1" PropText="End or Move-Out Date"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO" VERSION="I" PROPERTY_NAME="WIDTH" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="06"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LABEL_TO_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="WIDTH" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1" VERSION="I" PROPERTY_NAME="HEIGHT" PROPERTY_VALUE="01"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1" VERSION="I" PROPERTY_NAME="RULE_TYPE" PROPERTY_VALUE="01"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="100%"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE1_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2" VERSION="I" PROPERTY_NAME="HEIGHT" PROPERTY_VALUE="01"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2" VERSION="I" PROPERTY_NAME="RULE_TYPE" PROPERTY_VALUE="01"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="100%"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE2_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3" VERSION="I" PROPERTY_NAME="HEIGHT" PROPERTY_VALUE="01"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3" VERSION="I" PROPERTY_NAME="RULE_TYPE" PROPERTY_VALUE="01"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="100%"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE3_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4" VERSION="I" PROPERTY_NAME="HEIGHT" PROPERTY_VALUE="01"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4" VERSION="I" PROPERTY_NAME="RULE_TYPE" PROPERTY_VALUE="01"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="100%"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="LINE4_LAYOUT_DATA" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE" VERSION="I" PROPERTY_NAME="HISTORY_VISIBLE" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE" VERSION="I" PROPERTY_NAME="MAX_VISIBLE_MESSAGES" PROPERTY_VALUE="0"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="08"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="MESSAGE_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER" VERSION="I" PROPERTY_NAME="ARIA_LANDMARK" PROPERTY_VALUE="10"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER" VERSION="I" PROPERTY_NAME="IS_LAYOUT_CONTAINER" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER" VERSION="I" PROPERTY_NAME="SCROLLING_MODE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER" VERSION="I" PROPERTY_NAME="SCROLL_LEFT" PROPERTY_VALUE="0"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER" VERSION="I" PROPERTY_NAME="SCROLL_TOP" PROPERTY_VALUE="0"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER_LAYOUT" VERSION="I" PROPERTY_NAME="CELL_PADDING" PROPERTY_VALUE="0"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER_LAYOUT" VERSION="I" PROPERTY_NAME="CELL_SPACING" PROPERTY_VALUE="0"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER_LAYOUT" VERSION="I" PROPERTY_NAME="COL_COUNT" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER_LAYOUT" VERSION="I" PROPERTY_NAME="STRETCHED_HORIZONTALLY" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER_LAYOUT" VERSION="I" PROPERTY_NAME="STRETCHED_VERTICALLY" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER_LAYOUT" VERSION="I" PROPERTY_NAME="TAB_ORDER" PROPERTY_VALUE="01"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ROOTUIELEMENTCONTAINER_LAYOUT" VERSION="I" PROPERTY_NAME="WRAPPING" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON" VERSION="I" PROPERTY_NAME="HOTKEY" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON" VERSION="I" PROPERTY_NAME="IMAGE_FIRST" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B021ED58498DDF7E7849B6C" PropText="Search"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="07"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" VERSION="I" PROPERTY_NAME="ALIGNMENT" PROPERTY_VALUE="03"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" VERSION="I" PROPERTY_NAME="IME_MODE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" VERSION="I" PROPERTY_NAME="LENGTH" PROPERTY_VALUE="0"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" VERSION="I" PROPERTY_NAME="STATE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" VERSION="I" PROPERTY_NAME="WIDTH" PROPERTY_VALUE="390px"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="07"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON" VERSION="I" PROPERTY_NAME="DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON" VERSION="I" PROPERTY_NAME="HOTKEY" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON" VERSION="I" PROPERTY_NAME="IMAGE_FIRST" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON" VERSION="I" PROPERTY_NAME="TEXT" PROPERTY_VALUE="3ED475463B021ED58498DDF858279B6C" PropText="Submit"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="4"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="07"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" PROPERTY_NAME="ALIGNMENT" PROPERTY_VALUE="03"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" PROPERTY_NAME="CONTEXT_MENU_BEHAVIOUR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" PROPERTY_NAME="ENABLED" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" PROPERTY_NAME="IME_MODE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" PROPERTY_NAME="LENGTH" PROPERTY_VALUE="0"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" PROPERTY_NAME="READ_ONLY" PROPERTY_VALUE="X"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" PROPERTY_NAME="STATE" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" PROPERTY_NAME="TEXT_DIRECTION" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" PROPERTY_NAME="VISIBLE" PROPERTY_VALUE="02"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" VERSION="I" PROPERTY_NAME="WIDTH" PropText=""/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO_LD" VERSION="I" PROPERTY_NAME="CELL_BACKGROUND_DESIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO_LD" VERSION="I" PROPERTY_NAME="COL_SPAN" PROPERTY_VALUE="1"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO_LD" VERSION="I" PROPERTY_NAME="H_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO_LD" VERSION="I" PROPERTY_NAME="SEMANTIC_COLOR" PROPERTY_VALUE="00"/>
   <wdy_ui_property COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO_LD" VERSION="I" PROPERTY_NAME="V_ALIGN" PROPERTY_VALUE="00"/>
   <wdy_plug_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" PLUG_NAME="IN" PARAMETER_NAME="UNAME" VERSION="I" PARAM_POSITION="0 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="BNAME" DISPLAY_NAME="UNAME"/>
   <wdy_ui_ctx_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="ADDRESS" BINDING_NAME="VALUE" VERSION="I" UI_ELEM_PROPERTY="VALUE" BOUND_CTX_NODE="CONTEXT" BOUND_CTX_ATTRIB="ADDRESS"/>
   <wdy_ui_ctx_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1" BINDING_NAME="SELECTED_KEY" VERSION="I" UI_ELEM_PROPERTY="SELECTED_KEY" BOUND_CTX_NODE="CONTEXT" BOUND_CTX_ATTRIB="DROPDOWN_BY_KEY_1_ATTR"/>
   <wdy_ui_ctx_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" BINDING_NAME="READ_ONLY" VERSION="I" UI_ELEM_PROPERTY="READ_ONLY" BOUND_CTX_NODE="CONTEXT" BOUND_CTX_ATTRIB="READ_ONLY_2"/>
   <wdy_ui_ctx_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" BINDING_NAME="SELECTED_KEY" VERSION="I" UI_ELEM_PROPERTY="SELECTED_KEY" BOUND_CTX_NODE="CONTEXT" BOUND_CTX_ATTRIB="DROPDOWN_BY_KEY_2_ATTR"/>
   <wdy_ui_ctx_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3" BINDING_NAME="SELECTED_KEY" VERSION="I" UI_ELEM_PROPERTY="SELECTED_KEY" BOUND_CTX_NODE="CONTEXT" BOUND_CTX_ATTRIB="DROPDOWN_BY_KEY_3_ATTR"/>
   <wdy_ui_ctx_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" BINDING_NAME="SELECTED_KEY" VERSION="I" UI_ELEM_PROPERTY="SELECTED_KEY" BOUND_CTX_NODE="CONTEXT" BOUND_CTX_ATTRIB="DROPDOWN_BY_KEY_4_ATTR"/>
   <wdy_ui_ctx_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" BINDING_NAME="SELECTED_KEY" VERSION="I" UI_ELEM_PROPERTY="SELECTED_KEY" BOUND_CTX_NODE="CONTEXT" BOUND_CTX_ATTRIB="DROPDOWN_BY_KEY_5_ATTR"/>
   <wdy_ui_ctx_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" BINDING_NAME="VALUE" VERSION="I" UI_ELEM_PROPERTY="VALUE" BOUND_CTX_NODE="CONTEXT" BOUND_CTX_ATTRIB="FROM"/>
   <wdy_ui_ctx_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_INPUT" BINDING_NAME="VALUE" VERSION="I" UI_ELEM_PROPERTY="VALUE" BOUND_CTX_NODE="CONTEXT" BOUND_CTX_ATTRIB="SEARCH"/>
   <wdy_ui_ctx_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" BINDING_NAME="VALUE" VERSION="I" UI_ELEM_PROPERTY="VALUE" BOUND_CTX_NODE="CONTEXT" BOUND_CTX_ATTRIB="TO"/>
   <wdy_ui_evt_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_1" BINDING_NAME="ON_SELECT" VERSION="I" UI_ELEM_EVENT="ON_SELECT" BOUND_ACTION="SELECT_1"/>
   <wdy_ui_evt_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_2" BINDING_NAME="ON_SELECT" VERSION="I" UI_ELEM_EVENT="ON_SELECT" BOUND_ACTION="SELECT_2"/>
   <wdy_ui_evt_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_3" BINDING_NAME="ON_SELECT" VERSION="I" UI_ELEM_EVENT="ON_SELECT" BOUND_ACTION="SELECT_3"/>
   <wdy_ui_evt_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_4" BINDING_NAME="ON_SELECT" VERSION="I" UI_ELEM_EVENT="ON_SELECT" BOUND_ACTION="SELECT_4"/>
   <wdy_ui_evt_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="DROPDOWN_BY_KEY_5" BINDING_NAME="ON_SELECT" VERSION="I" UI_ELEM_EVENT="ON_SELECT" BOUND_ACTION="SELECT_5"/>
   <wdy_ui_evt_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="FROM" BINDING_NAME="ON_ENTER" VERSION="I" UI_ELEM_EVENT="ON_ENTER" BOUND_ACTION="DATE_FROM"/>
   <wdy_ui_evt_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SEARCH_BUTTON" BINDING_NAME="ON_ACTION" VERSION="I" UI_ELEM_EVENT="ON_ACTION" BOUND_ACTION="SEARCH"/>
   <wdy_ui_evt_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="SUBMIT_BUTTON" BINDING_NAME="ON_ACTION" VERSION="I" UI_ELEM_EVENT="ON_ACTION" BOUND_ACTION="SUBMIT"/>
   <wdy_ui_evt_bind COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="DROPDOWN_BY_KEY" ELEMENT_NAME="TO" BINDING_NAME="ON_ENTER" VERSION="I" UI_ELEM_EVENT="ON_ENTER" BOUND_ACTION="DATE_TO"/>
   <controller_definition COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" VERSION="A" CONTROLLER_TYPE="01" CONTEXT="CONTEXT" DISPLAY_NAME="DROPDOWN_BY_KEY">
    <wdy_controllert COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" LANGU="D" DESCRIPTION="DropDownByKey"/>
    <wdy_controllert COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" LANGU="E" DESCRIPTION="Employee Location"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="DATE_FROM" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="DATE_FROM" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="DATE_TO" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="DATE_TO" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="HANDLEIN" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_VIEW_NAME="DROPDOWN_BY_KEY" REF_PLUG_NAME="IN" DISPLAY_NAME="HANDLEIN" CODE_BODY="METHOD handlein.
    wd_context-&gt;set_attribute( name = &apos;UNAME&apos; value = uname ).
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONDATE_FROM" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="DATE_FROM" DISPLAY_NAME="ONACTIONDATE_FROM" CODE_BODY="METHOD onactiondate_from.
  DATA: value_set TYPE wdr_context_attr_value_list.
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.

  wd_node_info = wd_context-&gt;get_node_info( ).
  REFRESH value_set.

  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value_set = value_set ).
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONDATE_TO" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="DATE_TO" DISPLAY_NAME="ONACTIONDATE_TO" CODE_BODY="METHOD onactiondate_to .
  DATA: lv_from TYPE datum,
        lv_to   TYPE datum.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;FROM&apos;
                             IMPORTING value = lv_from ).

  wd_context-&gt;get_attribute( EXPORTING name = &apos;TO&apos;
                             IMPORTING value = lv_to ).

*  CALL FUNCTION &apos;Z_EMPLOC_DROPDOWN&apos;
*    EXPORTING
*      from      = lv_from
*      to        = lv_to
*    IMPORTING
*      hierarchy = wd_comp_controller-&gt;gt_hier.

*    wd_this-&gt;wd_get_api( )-&gt;get_message_manager( )-&gt;report_success( &apos;Date filter applied&apos; ).

  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  GET REFERENCE OF &apos;SEARCH&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  &quot; Call event handler
  CALL METHOD wd_this-&gt;onactionsearch
    EXPORTING
      wdevent = lo_event.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSEARCH" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SEARCH" DISPLAY_NAME="ONACTIONSEARCH" CODE_BODY="METHOD onactionsearch.
  DATA: lv_search TYPE string,
        lv_return TYPE string.
  DATA: it_hier TYPE TABLE OF zrehierarchy,
        wa_hier TYPE zrehierarchy.
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: lo_api_controller  TYPE REF TO if_wd_controller,
        lo_message_manager TYPE REF TO if_wd_message_manager.
  DATA: lt_country TYPE TABLE OF t005t,
        wa_country LIKE LINE OF lt_country.
  DATA: lv_count TYPE num03,
        lv_lines TYPE num03.
  DATA: lv_from TYPE datum,
        lv_to   TYPE datum,
        lv_p    TYPE rebdintrenoao.
  DATA: it_region TYPE TABLE OF t005u,
        wa_region LIKE LINE OF it_region.
  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_1&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.


  wd_context-&gt;get_attribute( EXPORTING name = &apos;SEARCH&apos;
                             IMPORTING value = lv_search ).

  wd_context-&gt;get_attribute( EXPORTING name = &apos;FROM&apos;
                             IMPORTING value = lv_from ).

  wd_node_info = wd_context-&gt;get_node_info( ).

  CALL FUNCTION &apos;Z_BETTER_DROPDOWN&apos;
    EXPORTING
      search_string = lv_search
    IMPORTING
      return        = lv_return
    TABLES
      hierarchy     = wd_comp_controller-&gt;gt_hier.

  LOOP AT wd_comp_controller-&gt;gt_hier INTO wa_hier
      WHERE aotype = &apos;05RM&apos;.
    APPEND wa_hier TO it_hier.
  ENDLOOP.

  DESCRIBE TABLE it_hier LINES lv_lines.

  IF lv_lines = 1.
    READ TABLE it_hier INTO wa_hier INDEX 1.

    value_wa-value = wa_hier-intreno.
    value_wa-text = wa_hier-xao.
    APPEND value_wa TO value_set.
    &quot;Room
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value = value_wa-value ).
    REFRESH value_set.
    &quot;Floor
    SELECT SINGLE intreno xao parent FROM zrehierarchy INTO (value_wa-value, value_wa-text, lv_p) WHERE intreno = wa_hier-parent.
    IF sy-subrc = 0.
      APPEND value_wa TO value_set.
      wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
      wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value = value_wa-value ).
      REFRESH value_set.
    ENDIF.
    &quot;Building
    SELECT SINGLE intreno xao parent FROM zrehierarchy INTO (value_wa-value, value_wa-text, lv_p) WHERE intreno = lv_p.
    IF sy-subrc = 0.
      APPEND value_wa TO value_set.
      wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).
      wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value = value_wa-value ).
      REFRESH value_set.
    ENDIF.
    &quot;Country
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos; value = wa_hier-country ).

    SELECT * FROM t005u INTO TABLE it_region
      WHERE land1 = wa_hier-country AND
            spras = &apos;EN&apos;.
    &quot;Region
    LOOP AT it_region INTO wa_region.
      value_wa-value = wa_region-bland.
      CONCATENATE wa_region-bland &apos;-&apos; wa_region-bezei INTO value_wa-text SEPARATED BY space.
      APPEND value_wa TO value_set.
    ENDLOOP.

    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value_set = value_set ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value = wa_hier-region ).

  ENDIF.

  &quot; Message section.
  lo_api_controller ?= wd_this-&gt;wd_get_api( ).
  CALL METHOD lo_api_controller-&gt;get_message_manager
    RECEIVING
      message_manager = lo_message_manager.

  IF lv_lines = 1.
    CALL METHOD lo_message_manager-&gt;report_success
      EXPORTING
        message_text = &apos;Result found.&apos;.
  ELSEIF lv_lines &gt; 1.
    CALL METHOD lo_message_manager-&gt;report_success
      EXPORTING
        message_text = &apos;Multiple results returned. Please narrow your search.&apos;.

    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
  ELSEIF lv_lines &lt; 1.
    CALL METHOD lo_message_manager-&gt;report_error_message
      EXPORTING
        message_text = &apos;No results found.&apos;.

    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                                     value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).

  ENDIF.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSELECT_1" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SELECT_1" DISPLAY_NAME="ONACTIONSELECT_1" CODE_BODY="METHOD onactionselect_1 .
  DATA lo_nd TYPE REF TO if_wd_context_node.
  DATA lo_el TYPE REF TO if_wd_context_element.
  DATA lr_event TYPE REF TO cl_wd_custom_event.

  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: wa_hier TYPE zbui_hier,
        wa_comp TYPE zloc_hier,
        wa_buil TYPE zbui_hier.
  DATA: lv_loc TYPE string,
        lv_com TYPE string.
  DATA: it_region TYPE TABLE OF t005u,
        wa_region LIKE LINE OF it_region.
  DATA: lv_count TYPE num03.

  DATA: it_selopt TYPE TABLE OF selopt,
        wa_selopt TYPE selopt.

  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_2&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                             IMPORTING value = lv_loc ).

  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                       value = &apos;&apos; ).

  CALL FUNCTION &apos;Z_BETTER_DROPDOWN_LAND&apos;
    EXPORTING
      land1     = lv_loc
    IMPORTING
      value_set = value_set.

  wd_node_info = wd_context-&gt;get_node_info( ).
  SORT value_set BY text.
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value_set = value_set ).

  &quot; Automatically select drop-down if it contains only as single entry.
  DESCRIBE TABLE value_set LINES lv_count.
  IF lv_count = 1.
    wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value = value_wa-value ).

    &quot; Call event handler
    CALL METHOD wd_this-&gt;onactionselect_2
      EXPORTING
        wdevent = lo_event.

  ELSE.
    REFRESH value_set.
    wd_node_info = wd_context-&gt;get_node_info( ).

    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
  ENDIF.
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSELECT_2" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SELECT_2" DISPLAY_NAME="ONACTIONSELECT_2" CODE_BODY="METHOD onactionselect_2 .
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: wa_hier TYPE zmun_hier,
        wa_comp TYPE zrehierarchy,
        wa_buil TYPE zrehierarchy.
  DATA: lv_cntr TYPE land1,
        lv_regi TYPE regio.
  DATA: lv_count TYPE num03.

  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_3&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                             IMPORTING value = lv_cntr ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                             IMPORTING value = lv_regi ).

  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                       value = &apos;&apos; ).

  &quot;ToDo - Display multiple threads based on region... PS. This last minute requirement screws up all of the logic!!

*  READ TABLE wd_comp_controller-&gt;gt_hier INTO wa_hier WITH KEY LOCID = lv_loc.

*  READ TABLE wa_hier-complexes INTO wa_comp WITH KEY COMPID = lv_com.

*  LOOP AT wa_comp-buildings INTO wa_buil.
  CALL FUNCTION &apos;Z_BETTER_DROPDOWN&apos;
    EXPORTING
*     SEARCH_STRING       =
      country   = lv_cntr
      region    = lv_regi
    TABLES
      hierarchy = wd_comp_controller-&gt;gt_hier.

  LOOP AT wd_comp_controller-&gt;gt_hier INTO wa_buil WHERE country = lv_cntr AND region = lv_regi.
    value_wa-value = wa_buil-intreno.
    value_wa-text = wa_buil-xao.
    APPEND value_wa TO value_set.
  ENDLOOP.

  wd_node_info = wd_context-&gt;get_node_info( ).
  SORT value_set BY text.
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).

  &quot; Automatically select drop-down if it contains only as single entry.
  DESCRIBE TABLE value_set LINES lv_count.

  IF lv_count = 1.
    wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value = value_wa-value ).

    &quot; Call event handler
    CALL METHOD wd_this-&gt;onactionselect_3
      EXPORTING
        wdevent = lo_event.
  ELSE.
    REFRESH value_set.
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
  ENDIF.
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSELECT_3" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SELECT_3" DISPLAY_NAME="ONACTIONSELECT_3" CODE_BODY="METHOD onactionselect_3 .
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: wa_hier  TYPE zmun_hier,
        wa_comp  TYPE zloc_hier,
        wa_buil  TYPE zrehierarchy,
        wa_floor TYPE zrehierarchy.
  DATA: lv_cntr TYPE land1,
        lv_regi TYPE regio,
        lv_bui  TYPE rebdintrenoao.
  DATA: lv_count TYPE num03.

  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_4&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                             IMPORTING value = lv_cntr ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                             IMPORTING value = lv_regi ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                             IMPORTING value = lv_bui ).

  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                       value = &apos;&apos; ).

  CALL FUNCTION &apos;Z_BETTER_DROPDOWN&apos;
    EXPORTING
*     SEARCH_STRING       =
      parent    = lv_bui
    TABLES
      hierarchy = wd_comp_controller-&gt;gt_hier.

  REFRESH value_set.

  LOOP AT wd_comp_controller-&gt;gt_hier INTO wa_floor.
    value_wa-value = wa_floor-intreno.
    value_wa-text = wa_floor-xao.
    APPEND value_wa TO value_set.
  ENDLOOP.

  wd_node_info = wd_context-&gt;get_node_info( ).
  SORT value_set BY text.
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).

  &quot; Automatically select drop-down if it contains only as single entry.
  DESCRIBE TABLE value_set LINES lv_count.
  IF lv_count = 1.
    wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value = value_wa-value ).

    &quot; Call event handler
    CALL METHOD wd_this-&gt;onactionselect_4
      EXPORTING
        wdevent = lo_event.
  ELSE.
    REFRESH value_set.
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
  ENDIF.
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSELECT_4" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SELECT_4" DISPLAY_NAME="ONACTIONSELECT_4" CODE_BODY="METHOD onactionselect_4 .
  TYPES: BEGIN OF t_current,
           intreno TYPE recaintreno,
           xao     TYPE rebdxao,
         END OF t_current.
  DATA: lv_current TYPE t_current.
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: wa_hier  TYPE zmun_hier,
        wa_comp  TYPE zloc_hier,
        wa_buil  TYPE zrehierarchy,
        wa_floor TYPE zrehierarchy,
        wa_room  TYPE zrehierarchy.
  DATA: lv_cntr TYPE land1,
        lv_regi TYPE regio,
        lv_bui  TYPE rebdintrenoao,
        lv_flo  TYPE rebdintrenoao.
  DATA: lv_count TYPE num03.
  DATA: lv_showall TYPE char01.
  DATA: lv_from TYPE datum.
  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_5&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;FROM&apos;
                             IMPORTING value = lv_from ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                             IMPORTING value = lv_cntr ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                             IMPORTING value = lv_regi ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                             IMPORTING value = lv_bui ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                             IMPORTING value = lv_flo ).

  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                       value = &apos;&apos; ).

  &quot;Debug
  IF sy-uname = &apos;CC615761&apos;.
    DATA: lv_x TYPE char01 VALUE &apos;X&apos;.
    WHILE lv_x = &apos;X&apos;.
      SELECT SINGLE value FROM zconfig INTO lv_x
        WHERE keyfield = &apos;DEBUG&apos;.
    ENDWHILE.
  ENDIF.

  SELECT SINGLE value FROM zconfig INTO lv_showall
    WHERE keyfield = &apos;ESSSHOWALL&apos;.

  CALL FUNCTION &apos;Z_BETTER_DROPDOWN&apos;
    EXPORTING
      from      = lv_from
      showall   = lv_showall
      parent    = lv_flo
    TABLES
      hierarchy = wd_comp_controller-&gt;gt_hier.

  REFRESH value_set.

  LOOP AT wd_comp_controller-&gt;gt_hier INTO wa_room.
    value_wa-value = wa_room-intreno.
    value_wa-text = wa_room-xao.
    APPEND value_wa TO value_set.
  ENDLOOP.
  wd_context-&gt;get_attribute( EXPORTING name = &apos;CURRENT_LOC&apos;
                             IMPORTING value = lv_current-intreno ).
  IF lv_current IS NOT INITIAL.
    SELECT SINGLE xao FROM vibdao
      INTO lv_current-xao
      WHERE intreno = lv_current-intreno.

    value_wa-value = lv_current-intreno.
    value_wa-text = lv_current-xao.
    &quot;Ensure we don&apos;t duplicate the value.
    READ TABLE value_set WITH KEY value = value_wa-value INTO DATA(value_chk).
    IF sy-subrc = 4.
      APPEND value_wa TO value_set.
    ENDIF.
    wd_context-&gt;set_attribute( name = &apos;CURRENT_LOC&apos; value = &apos;&apos; ).
  ENDIF.


  wd_node_info = wd_context-&gt;get_node_info( ).
  SORT value_set BY text.
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).

  &quot; Automatically select drop-down if it contains only as single entry.
  DESCRIBE TABLE value_set LINES lv_count.
  IF lv_count = 1.
    wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value = value_wa-value ).

    &quot; Call event handler
    CALL METHOD wd_this-&gt;onactionselect_5
      EXPORTING
        wdevent = lo_event.
  ENDIF.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSELECT_5" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SELECT_5" DISPLAY_NAME="ONACTIONSELECT_5" CODE_BODY="METHOD onactionselect_5 .
  &quot;TO DO - Display address
  DATA: lv_intreno  TYPE recaintreno,
        lv_adrnr    TYPE ad_addrnum,
        lv_housenum TYPE string,
        lv_street   TYPE string,
        lv_city     TYPE string,
        lv_region   TYPE regio,
        lv_country  TYPE land1,
        lv_postcode TYPE string.
  DATA: it_string TYPE gdv_tt_string,
        wa_string LIKE LINE OF it_string.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                             IMPORTING value = lv_intreno ).

  WHILE sy-subrc = 0.
    SELECT SINGLE parent FROM vibdnode
      INTO lv_intreno
      WHERE intreno = lv_intreno.
    IF lv_intreno IS NOT INITIAL AND lv_adrnr IS INITIAL.
      SELECT SINGLE adrnr FROM vzobject INTO lv_adrnr
        WHERE adrobjnr = lv_intreno.
    ENDIF.
  ENDWHILE.
  IF lv_adrnr IS NOT INITIAL.
    SELECT SINGLE house_num1 street city1 region country post_code1 FROM adrc
      INTO (lv_housenum, lv_street, lv_city, lv_region, lv_country, lv_postcode)
      WHERE addrnumber = lv_adrnr.
  ENDIF.
  IF lv_street IS NOT INITIAL.
    IF lv_housenum IS NOT INITIAL.
      CONCATENATE lv_housenum lv_street INTO wa_string SEPARATED BY space.
    ELSE.
      wa_string = lv_street.
    ENDIF.

    CONCATENATE wa_string &apos;,&apos; INTO wa_string.
    APPEND wa_string TO it_string.
    wa_string = lv_city.
    CONCATENATE wa_string &apos;,&apos; INTO wa_string.
    APPEND wa_string TO it_string.

    SELECT SINGLE bezei FROM t005u
      INTO wa_string
      WHERE bland = lv_region AND
            land1 = lv_country AND
            spras = &apos;EN&apos;.
    CONCATENATE wa_string &apos;,&apos; INTO wa_string.
    APPEND wa_string TO it_string.

    SELECT SINGLE landx FROM t005t
      INTO wa_string
      WHERE land1 = lv_country AND
            spras = &apos;EN&apos;.
    APPEND wa_string TO it_string.

    MOVE lv_postcode TO wa_string.
    APPEND wa_string TO it_string.
  ENDIF.
  wd_context-&gt;set_attribute( EXPORTING name = &apos;ADDRESS&apos;
                                       value = it_string ).

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSUBMIT" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SUBMIT" DISPLAY_NAME="ONACTIONSUBMIT" CODE_BODY="METHOD onactionsubmit .
  &quot;Search for existing location
  DATA: lv_perno TYPE bu_perno,
        lv_bpnr  TYPE bu_partner.
  DATA: wa_moveplan TYPE bapi_re_move_plan_dat,
        it_occupant TYPE TABLE OF bapi_re_mp_occupant_dat,
        wa_occupant LIKE LINE OF it_occupant,
        it_target   TYPE TABLE OF bapi_re_mp_target_dat,
        wa_target   LIKE LINE OF it_target,
        it_occplan  TYPE TABLE OF bapi_re_mp_occplan_dat,
        wa_occplan  LIKE LINE OF it_occplan,
        it_return   TYPE TABLE OF bapiret2.
  DATA: lv_room     TYPE rebdintrenoao,
        lv_mpid     TYPE reorpompid,
        lv_email    TYPE adr6-smtp_addr,
        lv_sobid    TYPE sobid,
        lv_currentd TYPE datum.
  DATA: lo_api_controller  TYPE REF TO if_wd_controller,
        lo_message_manager TYPE REF TO if_wd_message_manager.
  DATA: wa_return LIKE LINE OF it_return.
  DATA: lv_message TYPE string.

  lo_api_controller ?= wd_this-&gt;wd_get_api( ).
  CALL METHOD lo_api_controller-&gt;get_message_manager
    RECEIVING
      message_manager = lo_message_manager.


  wd_context-&gt;get_attribute( EXPORTING name = &apos;PERNO&apos;
                             IMPORTING value =  lv_perno ).

  CONCATENATE &apos;EE&apos; lv_perno INTO lv_bpnr.

  wa_moveplan-move_plan_text = &apos;Location Update from ESS.&apos;.
  wa_moveplan-move_plan_type = &apos;0002&apos;.
  &quot;Dates...
  wd_context-&gt;get_attribute( EXPORTING name = &apos;FROM&apos;
                             IMPORTING value =  wa_moveplan-move_date_from ).
  wa_moveplan-move_date_to = wa_moveplan-move_date_from. &quot;Same day move.
  wa_moveplan-perm_occ_date_from = wa_moveplan-move_date_from. &quot;Occupied from the move day
*  wd_context-&gt;get_attribute( EXPORTING name = &apos;TO&apos;
*                             IMPORTING value =  wa_moveplan-perm_occ_date_to ).
  &quot;Always use high-date when updating from ESS. To date disabled.
  wa_moveplan-perm_occ_date_to = &apos;99991231&apos;.
  wa_moveplan-move_out_date = wa_moveplan-move_date_from. &quot;Same day move.
  wa_moveplan-move_in_date = wa_moveplan-move_date_from + 1.

*  wa_moveplan-move_plan_status = &apos; &apos;. &quot;Move in process
  wa_moveplan-responsible = sy-uname. &quot;Should probably change to ccea.

  wa_occupant-occupant = lv_bpnr.
  wa_occupant-occupant_role = &apos;BUP003&apos;. &quot;Only employees.


  SELECT vioroo~ooidext viormp~permoccfrom FROM viorpo &quot;viorpo~occposition
    INNER JOIN viormp ON viormp~mpid = viorpo~mpid
    INNER JOIN vioroo ON  vioroo~objnr = viorpo~objnroo
    INNER JOIN vibdao ON  vibdao~objnr = vioroo~objnrref
    UP TO 1 ROWS
    INTO (wa_occupant-old_reservation_obj_id, lv_currentd) &quot;, wa_occupant-old_position
        WHERE viorpo~occupant = lv_bpnr AND
              viorpo~planstatus = &apos;&apos; AND
              viorpo~planind = &apos;&apos;
    ORDER BY viorpo~mpid DESCENDING. &quot; AND validfrom &lt;= wa_moveplan-move_date_from ). &quot;Select the latest active move.
  ENDSELECT.
  IF lv_currentd &gt;= wa_moveplan-move_date_from AND lv_currentd IS NOT INITIAL.
    lv_message = &apos;You cannot move earlier than or equal to the start date of your current location. Please rectify.&apos;.
    CALL METHOD lo_message_manager-&gt;report_error_message
      EXPORTING
        message_text = lv_message.
    EXIT.
  ENDIF.


  wa_occupant-old_reservation_obj_type = &apos;I5&apos;.
  wa_occupant-old_position = &apos;DESK&apos;.
  wa_occupant-key_date = wa_moveplan-perm_occ_date_from.
  APPEND wa_occupant TO it_occupant.

  wa_target-reservation_obj_type = &apos;I5&apos;. &quot;Always I5. (Offered Object)

  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                             IMPORTING value = lv_room ).
  IF lv_room IS NOT INITIAL.
    SELECT SINGLE oo~ooidext FROM vibdao AS ao &quot;ao~partaoid
      INNER JOIN vioroo AS oo ON oo~objnrref = ao~objnr
      INTO (wa_target-reservation_obj_id) &quot;wa_target-position,
      WHERE ao~intreno = lv_room.

    wa_target-position = &apos;DESK&apos;.

    APPEND wa_target TO it_target. &quot;Save the target details.

    wa_occplan-occupant = lv_bpnr.
    wa_occplan-occupant_role = &apos;BUP003&apos;. &quot;Only employees.
    &quot;Plan to move to desk (IN).

    wa_occplan-old_reservation_obj_type = &apos;I5&apos;.
    wa_occplan-old_reservation_obj_id = wa_occupant-old_reservation_obj_id.
    wa_occplan-old_position = &apos;DESK&apos;.

    wa_occplan-reservation_obj_type = &apos;I5&apos;.
    wa_occplan-reservation_obj_id = wa_target-reservation_obj_id.
    wa_occplan-position = wa_target-position.
    wa_occplan-planning_type = &apos;M&apos;.
*    wa_occplan-is_free = &apos;X&apos;.
    wa_occplan-position = &apos;DESK&apos;.
    wa_occplan-move_out_date = wa_moveplan-move_date_from.
    wa_occplan-move_in_date = wa_moveplan-move_date_from + 1.

    APPEND wa_occplan TO it_occplan.

    &quot;Debug
    IF sy-uname = &apos;CC615761&apos;.
      DATA: lv_x TYPE char01 VALUE &apos;X&apos;.
      WHILE lv_x = &apos;X&apos;.
        SELECT SINGLE value FROM zconfig INTO lv_x
          WHERE keyfield = &apos;DEBUG&apos;.
      ENDWHILE.
    ENDIF.
    DATA: lv_exist  TYPE viorpo-mpid,
          lv_status TYPE viormp-mpstatus.

    SELECT viorpo~mpid viormp~mpstatus  FROM viorpo
        INNER JOIN viormp ON viorpo~mpid = viormp~mpid
        UP TO 1 ROWS
        INTO (lv_exist,lv_status)
        WHERE viorpo~occupant = lv_bpnr AND
              viormp~mpstatus = &apos;&apos;
        ORDER BY viormp~mpid DESCENDING.
    ENDSELECT.

    IF lv_exist IS NOT INITIAL AND lv_status &lt;&gt; 2 AND sy-subrc = 0.
      lv_message = |You cannot create a new move plan. Currently awaiting approval for { lv_exist }.|.
      CALL METHOD lo_message_manager-&gt;report_error_message
        EXPORTING
          message_text = lv_message.
      EXIT.
    ELSE.
      CALL FUNCTION &apos;BAPI_RE_MP_CREATE&apos;
        EXPORTING
          move_plan   = wa_moveplan
        IMPORTING
          moveplanid  = lv_mpid
        TABLES
          mp_occupant = it_occupant
          mp_target   = it_target
          mp_occplan  = it_occplan
          return      = it_return.
    ENDIF.
  ELSE.
    lv_message = |No location selected. Please select one before clicking submit.|.
      CALL METHOD lo_message_manager-&gt;report_error_message
        EXPORTING
          message_text = lv_message.
  ENDIF.
  &quot;Success or failure message...
  READ TABLE it_return INTO wa_return WITH KEY type = &apos;S&apos;.
  IF sy-subrc = 4.
    READ TABLE it_return INTO wa_return WITH KEY type = &apos;E&apos;.
  ELSE.
    COMMIT WORK AND WAIT. &quot;Only save the move plan if there were no errors.
  ENDIF.

  IF wa_return-type = &apos;S&apos;.
    CALL METHOD lo_message_manager-&gt;report_success
      EXPORTING
        message_text = wa_return-message.

*    SELECT SINGLE sobid FROM hrp1001 &quot;Get line manager
*      INTO lv_sobid
*      WHERE objid = lv_perno AND
*            rsign = &apos;A&apos; AND
*            relat = &apos;002&apos;.

    DATA: lv_rfc TYPE string.

    SELECT SINGLE value FROM zconfig INTO lv_rfc
      WHERE keyfield = &apos;REFXHCMRFC&apos;.

    CALL FUNCTION &apos;Z_RE_CL_TRIGGER&apos; DESTINATION lv_rfc
      EXPORTING
        mpid = lv_mpid.

*    CALL FUNCTION &apos;Z_MOVEPLAN_APPROVAL&apos;
*      EXPORTING
**       APPR =
*        mpid = lv_mpid.

  ELSE.
    IF lv_message IS INITIAL.
      lv_message = &apos;Error! Please check that you have selected all of the required fields.&apos;.
    ENDIF.
    CALL METHOD lo_message_manager-&gt;report_error_message
      EXPORTING
        message_text = wa_return-message.
  ENDIF.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SEARCH" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SEARCH" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SELECT_1" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SELECT_1" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SELECT_2" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SELECT_2" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SELECT_3" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SELECT_3" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SELECT_4" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SELECT_4" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SELECT_5" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SELECT_5" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SUBMIT" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SUBMIT" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOAFTERACTION" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOAFTERACTION" CODE_BODY="method WDDOAFTERACTION .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOBEFOREACTION" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOBEFOREACTION" CODE_BODY="method WDDOBEFOREACTION .
*  data lo_api_controller type ref to if_wd_view_controller.
*  data lo_action         type ref to if_wd_action.

*  lo_api_controller = wd_this-&gt;wd_get_api( ).
*  lo_action = lo_api_controller-&gt;get_current_action( ).

*  if lo_action is bound.
*    case lo_action-&gt;name.
*      when &apos;...&apos;.

*    endcase.
*  endif.
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOEXIT" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOEXIT" CODE_BODY="method WDDOEXIT .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOINIT" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOINIT" CODE_BODY="METHOD wddoinit .
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: wa_hier TYPE zrehierarchy.
  DATA: lt_country TYPE TABLE OF t005t,
        wa_country LIKE LINE OF lt_country.
  DATA: lv_count TYPE num03.

  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.
  DATA: lv_from TYPE datum,
        lv_to   TYPE datum.
  DATA: it_selopt TYPE TABLE OF selopt,
        wa_selopt TYPE selopt.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_1&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  &quot;For the date selectors - Not working... Still have to press enter.
  wd_this-&gt;wd_get_api( )-&gt;register_on_enter_for_f4( register_on_enter = abap_true ).


  wd_context-&gt;get_attribute( EXPORTING name = &apos;FROM&apos;
                             IMPORTING value = lv_from ).

  wd_context-&gt;get_attribute( EXPORTING name = &apos;TO&apos;
                             IMPORTING value = lv_to ).

  CALL FUNCTION &apos;Z_BETTER_DROPDOWN_LAND&apos;
    IMPORTING
      value_set = value_set.

  wd_node_info = wd_context-&gt;get_node_info( ).
  SORT value_set BY text.
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos; value_set = value_set ).

  &quot; Automatically select drop-down if it contains only as single entry.
  DESCRIBE TABLE value_set LINES lv_count.
  IF lv_count = 1.
    wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos; value = value_wa-value ).

    &quot; Call event handler
    CALL METHOD wd_this-&gt;onactionselect_1
      EXPORTING
        wdevent = lo_event.

  ENDIF.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOMODIFYVIEW" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOMODIFYVIEW" CODE_BODY="METHOD wddomodifyview .
  &quot;Can&apos;t put in INIT because of importing parameter happening afterwards.
  &quot;Quick and dirty fix.
  DATA: lo_api_controller  TYPE REF TO if_wd_controller,
        lo_message_manager TYPE REF TO if_wd_message_manager.
  DATA: lv_init TYPE string.
  wd_context-&gt;get_attribute( EXPORTING name = &apos;INIT&apos;
                           IMPORTING value = lv_init ).

  DATA: lv_msgtxt TYPE string.
  IF lv_init IS INITIAL.
    DATA is_null TYPE wdy_boolean.
    TYPES: BEGIN OF t_screen,
             country TYPE land1,
             region  TYPE regio,
             locid   TYPE reorooidext,
             loc     TYPE rebdneighborhood,
             compid  TYPE reorooidext,
             comp    TYPE rebdneighborhood,
             buildid TYPE rebdintrenoao,
             build   TYPE rebdneighborhood,
             floid   TYPE rebdintrenoao,
             flo     TYPE rebdaonr,
             roomid  TYPE rebdintrenoao,
             room    TYPE rebdneighborhood,
             from    TYPE datum,
             to      TYPE datum,
           END OF t_screen.
    DATA: lv_uname  TYPE bname,
          lv_perno  TYPE bu_perno,
          lv_bpid   TYPE bu_partner,
          wa_screen TYPE t_screen.
    DATA: lv_comtype TYPE rebdaotype.
    DATA: lv_mpid TYPE reorpompid.
    &quot; Read existing location and display.

    lo_api_controller ?= wd_this-&gt;wd_get_api( ).
    CALL METHOD lo_api_controller-&gt;get_message_manager
      RECEIVING
        message_manager = lo_message_manager.

    wd_context-&gt;get_attribute( EXPORTING name = &apos;UNAME&apos;
                               IMPORTING value = lv_uname ).

    IF lv_uname IS INITIAL.
      SELECT SINGLE pernr FROM pa0105
        INTO lv_perno
        WHERE usrid = sy-uname
          AND subty = &apos;0001&apos;.
      lv_uname = sy-uname.
    ELSE.
      SELECT SINGLE pernr FROM pa0105
       INTO lv_perno
       WHERE usrid = lv_uname
         AND subty = &apos;0001&apos;.
    ENDIF.

    IF sy-subrc = 4.
      CONCATENATE &apos;User&apos; lv_uname
                  &apos;not found in REFX. Please contact the Real Estate Team.&apos;
                  INTO lv_msgtxt SEPARATED BY space.
      CALL METHOD lo_message_manager-&gt;report_error_message
        EXPORTING
          message_text = lv_msgtxt.
    ELSE.
      wd_context-&gt;set_attribute( name = &apos;PERNO&apos; value = lv_perno ).
    ENDIF.

    CONCATENATE &apos;EE&apos; lv_perno INTO lv_bpid.
    DATA: lv_mpstatus TYPE reorpompstatus.
    SELECT arch~intreno hed~permoccfrom hed~permoccto hed~mpstatus FROM viorpo AS occ
      INNER JOIN viormp AS hed ON hed~mpid = occ~mpid
      INNER JOIN vioroo AS off ON off~objnr = occ~objnroo
      INNER JOIN vibdao AS arch ON arch~objnr = off~objnrref
      INTO (wa_screen-roomid, wa_screen-from, wa_screen-to, lv_mpstatus)
      UP TO 1 ROWS
      WHERE occ~occupant = lv_bpid AND
            occ~plantype = &apos;I&apos;
      ORDER BY occ~mpid DESCENDING.
    ENDSELECT.

*    SELECT SINGLE arch~intreno occ~validfrom occ~validto FROM viorpo AS occ
*      INNER JOIN vioroo AS off ON off~objnr = occ~objnroo
*      INNER JOIN vibdao AS arch ON arch~objnr = off~objnrref
*      INTO (wa_screen-roomid, wa_screen-from, wa_screen-to)
*      WHERE occ~occupant = lv_bpid AND
*            occ~validto = &apos;99991231&apos; AND
*            occ~planstatus = &apos;&apos; AND
*            occ~planind = &apos;&apos; AND
*            occ~mpid = ( SELECT MAX( mpid ) FROM viorpo
*                              WHERE occupant = lv_bpid AND
*                                    planstatus = &apos;&apos; AND
*                                    planind = &apos;&apos; AND
*                                    mpid &lt;&gt; &apos;&apos; ). &quot;AND validfrom &lt;= sy-datum ). &quot;Select the latest active move.

    IF sy-subrc = 0 AND lv_mpstatus = 2. &quot;If existing location has been listed. Get the rest of the detail.
      SELECT SINGLE xao parent FROM zrehierarchy INTO (wa_screen-room, wa_screen-floid)
        WHERE intreno = wa_screen-roomid.
      SELECT SINGLE xao parent FROM zrehierarchy INTO (wa_screen-flo, wa_screen-buildid)
        WHERE intreno = wa_screen-floid.
      SELECT SINGLE xao parent country region FROM zrehierarchy INTO (wa_screen-build, wa_screen-compid, wa_screen-country, wa_screen-region)
        WHERE intreno = wa_screen-buildid.

      DATA lo_event       TYPE REF TO cl_wd_custom_event.
      DATA lt_parameters  TYPE wdr_event_parameter_list.
      DATA ls_parameters  LIKE LINE OF lt_parameters.

      wd_context-&gt;set_attribute( name = &apos;FROM&apos; value = wa_screen-from ).
      wd_context-&gt;set_attribute( name = &apos;TO&apos; value =  wa_screen-to ).
*      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos; value = wa_screen-locid ).
      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos; value = wa_screen-country ).
      &quot;Trigger dropdown filter
      CLEAR ls_parameters.
      REFRESH lt_parameters.
      ls_parameters-name = &apos;ID&apos;.
      GET REFERENCE OF &apos;SELECT_1&apos; INTO  ls_parameters-value.
      INSERT ls_parameters INTO TABLE lt_parameters.
*    &quot; Create custom event object with parameter
      CREATE OBJECT lo_event
        EXPORTING
          name       = &apos;ON_ACTION&apos;
          parameters = lt_parameters.
      &quot; Call event handler
      CALL METHOD wd_this-&gt;onactionselect_1
        EXPORTING
          wdevent = lo_event.

      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value = wa_screen-region ).
      &quot;Trigger dropdown filter
      CLEAR ls_parameters.
      REFRESH lt_parameters.
      ls_parameters-name = &apos;ID&apos;.
      GET REFERENCE OF &apos;SELECT_2&apos; INTO  ls_parameters-value.
      INSERT ls_parameters INTO TABLE lt_parameters.
*    &quot; Create custom event object with parameter
      CREATE OBJECT lo_event
        EXPORTING
          name       = &apos;ON_ACTION&apos;
          parameters = lt_parameters.
      &quot; Call event handler
      CALL METHOD wd_this-&gt;onactionselect_2
        EXPORTING
          wdevent = lo_event.

      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value = wa_screen-buildid ).
      &quot;Trigger dropdown filter
      CLEAR ls_parameters.
      REFRESH lt_parameters.
      ls_parameters-name = &apos;ID&apos;.
      GET REFERENCE OF &apos;SELECT_3&apos; INTO  ls_parameters-value.
      INSERT ls_parameters INTO TABLE lt_parameters.
*    &quot; Create custom event object with parameter
      CREATE OBJECT lo_event
        EXPORTING
          name       = &apos;ON_ACTION&apos;
          parameters = lt_parameters.
      &quot; Call event handler
      CALL METHOD wd_this-&gt;onactionselect_3
        EXPORTING
          wdevent = lo_event.

      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value = wa_screen-floid ).
      &quot;Trigger dropdown filter
      CLEAR ls_parameters.
      REFRESH lt_parameters.
      ls_parameters-name = &apos;ID&apos;.
      GET REFERENCE OF &apos;SELECT_4&apos; INTO  ls_parameters-value.
      INSERT ls_parameters INTO TABLE lt_parameters.
*    &quot; Create custom event object with parameter

      wd_context-&gt;set_attribute( name = &apos;CURRENT_LOC&apos; value = wa_screen-roomid ).

      CREATE OBJECT lo_event
        EXPORTING
          name       = &apos;ON_ACTION&apos;
          parameters = lt_parameters.
      &quot; Call event handler
      CALL METHOD wd_this-&gt;onactionselect_4
        EXPORTING
          wdevent = lo_event.

      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value = wa_screen-roomid ).

      &quot;Trigger Address
      CLEAR ls_parameters.
      REFRESH lt_parameters.
      ls_parameters-name = &apos;ID&apos;.
      GET REFERENCE OF &apos;SELECT_5&apos; INTO  ls_parameters-value.
      INSERT ls_parameters INTO TABLE lt_parameters.

*    &quot; Create custom event object with parameter
      CREATE OBJECT lo_event
        EXPORTING
          name       = &apos;ON_ACTION&apos;
          parameters = lt_parameters.
      &quot; Call event handler
      CALL METHOD wd_this-&gt;onactionselect_5
        EXPORTING
          wdevent = lo_event.

    ELSE.
      wa_screen-from = sy-datum.
      wa_screen-to = &apos;99991231&apos;.
      wd_context-&gt;set_attribute( name = &apos;FROM&apos; value = wa_screen-from ).
      wd_context-&gt;set_attribute( name = &apos;TO&apos; value =  wa_screen-to ).

      SELECT viorpo~mpid FROM viorpo
        INTO lv_mpid
        UP TO 1 ROWS
        WHERE occupant = lv_bpid
        ORDER BY mpid.
      ENDSELECT.
      IF lv_mpid IS NOT INITIAL.
        CONCATENATE &apos;User&apos; lv_uname
                      &apos;currently awaiting approval of move plan&apos; lv_mpid
                      INTO lv_msgtxt SEPARATED BY space.
        CALL METHOD lo_message_manager-&gt;report_warning
          EXPORTING
            message_text = lv_msgtxt.
      ENDIF.
    ENDIF.

    &quot; Set INIT so all this code doesn&apos;t execute again... As I said. Dirty fix.
    wd_context-&gt;set_attribute( name = &apos;INIT&apos; value = &apos;X&apos; ).
  ENDIF.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOONCONTEXTMENU" CODE_BODY="method WDDOONCONTEXTMENU .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOAFTERACTION" LANGU="D" DESCRIPTION="Meth. für aktionsunabhängige Operationen vor der Navigation"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOAFTERACTION" LANGU="E" DESCRIPTION="Method for Action-Independent Operations Before Navigation"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOBEFOREACTION" LANGU="D" DESCRIPTION="Methode zur Validierung von Benutzereingaben"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOBEFOREACTION" LANGU="E" DESCRIPTION="Method for Validation of User Input"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOEXIT" LANGU="D" DESCRIPTION="Cleanup-Methode des Controllers"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOEXIT" LANGU="E" DESCRIPTION="Controller Clean-Up Method"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOINIT" LANGU="D" DESCRIPTION="Initialisierungs-Methode des Controllers"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOINIT" LANGU="E" DESCRIPTION="Controller Initialization Method"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOMODIFYVIEW" LANGU="D" DESCRIPTION="Methode zum Modifizieren des Views vor dem Rendering"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOMODIFYVIEW" LANGU="E" DESCRIPTION="Method for modifying the view before rendering"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" LANGU="D" DESCRIPTION="Methode zum Modifizieren des Context-Menüs"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" LANGU="E" DESCRIPTION="Method for modifying the context menu"/>
    <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="HANDLEIN" PARAMETER_NAME="UNAME" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="BNAME" DISPLAY_NAME="UNAME"/>
    <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOMODIFYVIEW" PARAMETER_NAME="FIRST_TIME" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="WDY_BOOLEAN" DISPLAY_NAME="FIRST_TIME"/>
    <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOMODIFYVIEW" PARAMETER_NAME="VIEW" VERSION="I" PARAM_POSITION="2 " DECLARATION_TYPE="0" ABAP_TYPING="1" ABAP_TYPE="IF_WD_VIEW" DISPLAY_NAME="VIEW"/>
    <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" PARAMETER_NAME="CONTEXT_MENU_EVENT" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="1" ABAP_TYPE="IF_WD_CONTEXT_MENU_EVENT" DISPLAY_NAME="CONTEXT_MENU_EVENT"/>
    <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" PARAMETER_NAME="CONTEXT_MENU_MANAGER" VERSION="I" PARAM_POSITION="2 " DECLARATION_TYPE="0" ABAP_TYPING="1" ABAP_TYPE="IF_WD_CONTEXT_MENU_MANAGER" DISPLAY_NAME="CONTEXT_MENU_MANAGER"/>
    <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" PARAMETER_NAME="MENU" VERSION="I" PARAM_POSITION="3 " DECLARATION_TYPE="3" ABAP_TYPING="1" ABAP_TYPE="CL_WD_MENU" DISPLAY_NAME="MENU"/>
    <wdy_ctlr_paramt COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" LANGU="E" CMPNAME="HANDLEIN" PARAMETER_NAME="UNAME" DESCRIPTION="Username"/>
    <wdy_ctlr_usage COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CTLR_USAGE_NAME="005JC52H4D1GEW11YA1TZ3PMT" VERSION="I" USED_CONTROLLER="COMPONENTCONTROLLER"/>
    <wdy_ctx_node COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" VERSION="I" NODE_TYPE="CL_WDY_MD_CONTEXT_VALUE_NODE" NODE_POSITION="0 " COLLECTION_TYPE="03" CARDINALITY="01" SELECTION="01" SINGLETON="X" DISPLAY_NAME="CONTEXT" ABAP_TYPING="0" INIT_LEAD_SELECT="X"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="ADDRESS" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="13 " ABAP_TYPE="GDV_TT_STRING" ABAP_TYPING="0" DISPLAY_NAME="ADDRESS" VALUE_HELP_MODE="0"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="CURRENT_LOC" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="12 " ABAP_TYPE="RECAINTRENO" ABAP_TYPING="0" DISPLAY_NAME="CURRENT_LOC" VALUE_HELP_MODE="0"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="DROPDOWN_BY_KEY_1_ATTR" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="1 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="DROPDOWN_BY_KEY_1_ATTR" VALUE_HELP_MODE="0" NULLABLE="X"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="DROPDOWN_BY_KEY_2_ATTR" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="2 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="DROPDOWN_BY_KEY_2_ATTR" VALUE_HELP_MODE="0" NULLABLE="X"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="DROPDOWN_BY_KEY_3_ATTR" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="3 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="DROPDOWN_BY_KEY_3_ATTR" VALUE_HELP_MODE="0" NULLABLE="X"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="DROPDOWN_BY_KEY_4_ATTR" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="4 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="DROPDOWN_BY_KEY_4_ATTR" VALUE_HELP_MODE="0" NULLABLE="X"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="DROPDOWN_BY_KEY_5_ATTR" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="5 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="DROPDOWN_BY_KEY_5_ATTR" VALUE_HELP_MODE="0" NULLABLE="X"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="FROM" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="7 " ABAP_TYPE="DATUM" ABAP_TYPING="0" DISPLAY_NAME="FROM" VALUE_HELP_MODE="0"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="INIT" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="10 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="INIT" VALUE_HELP_MODE="0"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="PERNO" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="9 " ABAP_TYPE="BU_PERNO" ABAP_TYPING="0" DISPLAY_NAME="PERNO" VALUE_HELP_MODE="0"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="READ_ONLY_2" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="11 " ABAP_TYPE="WDY_BOOLEAN" ABAP_TYPING="0" DISPLAY_NAME="READ_ONLY_2" VALUE_HELP_MODE="0"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="SEARCH" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="6 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="SEARCH" VALUE_HELP_MODE="0"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="TO" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="8 " ABAP_TYPE="DATUM" ABAP_TYPING="0" DISPLAY_NAME="TO" VALUE_HELP_MODE="0"/>
    <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="UNAME" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="14 " ABAP_TYPE="BNAME" ABAP_TYPING="0" DISPLAY_NAME="UNAME" VALUE_HELP_MODE="0"/>
   </controller_definition>
  </view_definition>
  <view_definition COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="LOCATION" VERSION="A" TYPE="CL_WDY_MD_WINDOW" VIEW_TYPE="00" LIFESPAN="0" VIEW_CONTROLLER="LOCATION" DISPLAY_NAME="LOCATION" TITLE="3ED475463B021ED58498DE08F2D7DB6C" VISIBILITY="00">
   <view_window title="Maintain Employee Location"/>
   <wdy_iobound_plug COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="LOCATION" PLUG_NAME="IN" VERSION="I" PLUG_TYPE="CL_WDY_MD_INBOUND_PLUG" IN_PLUG_TYPE="1" OUT_PLUG_TYPE="0" DISPLAY_NAME="IN" IS_INTF_ITEM="X"/>
   <wdy_iobound_plug COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="LOCATION" PLUG_NAME="TO_DROPDOWN_BY_KEY" VERSION="I" PLUG_TYPE="CL_WDY_MD_OUTBOUND_PLUG" IN_PLUG_TYPE="0" OUT_PLUG_TYPE="0" DISPLAY_NAME="TO_DROPDOWN_BY_KEY"/>
   <wdy_plug_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="LOCATION" PLUG_NAME="IN" PARAMETER_NAME="ZVIEW" VERSION="I" PARAM_POSITION="0 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="STRING" DISPLAY_NAME="ZVIEW"/>
   <wdy_plug_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" VIEW_NAME="LOCATION" PLUG_NAME="TO_DROPDOWN_BY_KEY" PARAMETER_NAME="UNAME" VERSION="I" PARAM_POSITION="0 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="BNAME" DISPLAY_NAME="UNAME"/>
   <wdy_nav_link COMPONENT_NAME="ZEMPLOYEE_LOCATION" WINDOW_NAME="LOCATION" NAV_LINK_NAME="TO_DROPDOWN_BY_KEY_NLINK_2" VERSION="I" SOURCE_PLUG_VIEW="LOCATION" SOURCE_PLUG_NAME="TO_DROPDOWN_BY_KEY"/>
   <wdy_nav_targref COMPONENT_NAME="ZEMPLOYEE_LOCATION" WINDOW_NAME="LOCATION" NAV_LINK_NAME="TO_DROPDOWN_BY_KEY_NLINK_2" NAV_TARGREF_NAME="TO_DROPDOWN_BY_KEY_TREF_3" VERSION="I" TARGET_PLUG_VIEW="DROPDOWN_BY_KEY" TARGET_PLUG_NAME="IN" TARGET_VUSE_NAME="DROPDOWN_BY_KEY_USAGE_2"/>
   <wdy_vsh_node COMPONENT_NAME="ZEMPLOYEE_LOCATION" WINDOW_NAME="LOCATION" VSH_NODE_NAME="DROPDOWN_BY_KEY_USAGE_2" VERSION="I" VSH_NODE_TYPE="CL_WDY_MD_VIEW_USAGE" USED_VIEW="DROPDOWN_BY_KEY" DISPLAY_NAME="DROPDOWN_BY_KEY_USAGE_2"/>
   <controller_definition COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" VERSION="A" CONTROLLER_TYPE="06" CONTEXT="CONTEXT" DISPLAY_NAME="LOCATION">
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="HANDLEIN" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_VIEW_NAME="LOCATION" REF_PLUG_NAME="IN" DISPLAY_NAME="HANDLEIN" CODE_BODY="METHOD handlein .

  DATA: lt_parameters TYPE TABLE OF ihttpnvp.&quot;wdr_event_parameter_list.
  DATA: lv_uname TYPE bname.

*  DATA: lv_x TYPE char01.
*  WHILE lv_x &lt;&gt; &apos;X&apos;.
*  ENDWHILE.

  wdevent-&gt;get_data(
      EXPORTING
        name =  if_wd_application=&gt;all_url_parameters
      IMPORTING
        value = lt_parameters ).
  FIELD-SYMBOLS: &lt;param&gt; TYPE ihttpnvp.

  READ TABLE lt_parameters ASSIGNING &lt;param&gt;
                              WITH KEY name = &apos;UNAME&apos;.
  IF sy-subrc IS INITIAL AND &lt;param&gt;-value IS NOT INITIAL.
    lv_uname = &lt;param&gt;-value.
*  ELSE.
*    lv_uname = &apos;CC615761&apos;.
  ENDIF.


  CASE zview.
    WHEN &apos;DROPDOWN_BY_KEY&apos;.
      wd_this-&gt;fire_to_dropdown_by_key_plg( uname = lv_uname ).
    WHEN OTHERS.
      RAISE EXCEPTION TYPE cx_wd_general.
  ENDCASE.
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOEXIT" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOEXIT" CODE_BODY="method WDDOEXIT .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOINIT" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOINIT" CODE_BODY="method WDDOINIT .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONCLOSE" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOONCLOSE" CODE_BODY="method WDDOONCLOSE .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONOPEN" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOONOPEN" CODE_BODY="method WDDOONOPEN .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOEXIT" LANGU="D" DESCRIPTION="Cleanup-Methode des Controllers"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOEXIT" LANGU="E" DESCRIPTION="Controller Clean-Up Method"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOINIT" LANGU="D" DESCRIPTION="Initialisierungs-Methode des Controllers"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOINIT" LANGU="E" DESCRIPTION="Controller Initialization Method"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONCLOSE" LANGU="D" DESCRIPTION="Behandlung beim Schließen des Windows"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONCLOSE" LANGU="E" DESCRIPTION="Handling When Closing the Window"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONOPEN" LANGU="D" DESCRIPTION="Behandlung beim Öffnen des Windows"/>
    <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONOPEN" LANGU="E" DESCRIPTION="Handling When Opening the Window"/>
    <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="HANDLEIN" PARAMETER_NAME="ZVIEW" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="STRING" DISPLAY_NAME="ZVIEW"/>
    <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONOPEN" PARAMETER_NAME="WINDOW_DESCR" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="1" ABAP_TYPE="IF_WD_WINDOW_DESCRIPTION" DISPLAY_NAME="WINDOW_DESCR"/>
    <wdy_ctx_node COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" NODE_NAME="CONTEXT" VERSION="I" NODE_TYPE="CL_WDY_MD_CONTEXT_VALUE_NODE" NODE_POSITION="0 " COLLECTION_TYPE="03" CARDINALITY="01" SELECTION="01" SINGLETON="X" DISPLAY_NAME="CONTEXT" ABAP_TYPING="0" INIT_LEAD_SELECT="X"/>
   </controller_definition>
  </view_definition>
  <controller_definition COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" VERSION="A" CONTROLLER_TYPE="02" CONTEXT="CONTEXT" DISPLAY_NAME="COMPONENTCONTROLLER" RUNTIME_OBJECT="ZIWCI_EMPLOYEE_LOCATION">
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="GT_HIER" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_PROPERTY" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="GT_HIER" ACTION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="ZREHIERARCHY_T" READ_ONLY="X"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOAPPLICATIONSTATECHANGE" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOAPPLICATIONSTATECHANGE" CODE_BODY="method WDDOAPPLICATIONSTATECHANGE .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOBEFORENAVIGATION" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOBEFORENAVIGATION" CODE_BODY="method WDDOBEFORENAVIGATION .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOEXIT" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOEXIT" CODE_BODY="method WDDOEXIT .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOINIT" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOINIT" CODE_BODY="method WDDOINIT .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOPOSTPROCESSING" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOPOSTPROCESSING" CODE_BODY="method WDDOPOSTPROCESSING .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOAPPLICATIONSTATECHANGE" LANGU="D" DESCRIPTION="Behandlung bei Suspend und Resume einer Anwendung"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOAPPLICATIONSTATECHANGE" LANGU="E" DESCRIPTION="Handling for Suspending and Resuming an Application"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOBEFORENAVIGATION" LANGU="D" DESCRIPTION="Fehlerbehandlung vor der Navigation durch die Anwendung"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOBEFORENAVIGATION" LANGU="E" DESCRIPTION="Error Handling by Application Before Navigation"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOEXIT" LANGU="D" DESCRIPTION="Cleanup-Methode des Controllers"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOEXIT" LANGU="E" DESCRIPTION="Controller Clean-Up Method"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOINIT" LANGU="D" DESCRIPTION="Initialisierungs-Methode des Controllers"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOINIT" LANGU="E" DESCRIPTION="Controller Initialization Method"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOPOSTPROCESSING" LANGU="D" DESCRIPTION="Vorbereitung der Ausgabe"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOPOSTPROCESSING" LANGU="E" DESCRIPTION="Preparation of Output"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOAPPLICATIONSTATECHANGE" PARAMETER_NAME="STATE_CHANGE" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="1" ABAP_TYPE="IF_WD_APPLICATION_STATE_CHANGE" DISPLAY_NAME="STATE_CHANGE"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOBEFORENAVIGATION" PARAMETER_NAME="IS_CURRENT_ROOT" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="WDY_BOOLEAN" DISPLAY_NAME="IS_CURRENT_ROOT"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOEXIT" PARAMETER_NAME="REASON" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="WDR_APPL_EXIT_REASON" DISPLAY_NAME="REASON"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" CMPNAME="WDDOPOSTPROCESSING" PARAMETER_NAME="IS_CURRENT_ROOT" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="WDY_BOOLEAN" DISPLAY_NAME="IS_CURRENT_ROOT"/>
   <wdy_ctx_node COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="COMPONENTCONTROLLER" NODE_NAME="CONTEXT" VERSION="I" NODE_TYPE="CL_WDY_MD_CONTEXT_VALUE_NODE" NODE_POSITION="0 " COLLECTION_TYPE="03" CARDINALITY="01" SELECTION="01" SINGLETON="X" DISPLAY_NAME="CONTEXT" ABAP_TYPING="0" INIT_LEAD_SELECT="X" IS_INTF_ITEM="X"/>
  </controller_definition>
  <controller_definition COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" VERSION="A" CONTROLLER_TYPE="01" CONTEXT="CONTEXT" DISPLAY_NAME="DROPDOWN_BY_KEY">
   <wdy_controllert COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" LANGU="D" DESCRIPTION="DropDownByKey"/>
   <wdy_controllert COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" LANGU="E" DESCRIPTION="Employee Location"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="DATE_FROM" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="DATE_FROM" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="DATE_TO" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="DATE_TO" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="HANDLEIN" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_VIEW_NAME="DROPDOWN_BY_KEY" REF_PLUG_NAME="IN" DISPLAY_NAME="HANDLEIN" CODE_BODY="METHOD handlein.
    wd_context-&gt;set_attribute( name = &apos;UNAME&apos; value = uname ).
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONDATE_FROM" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="DATE_FROM" DISPLAY_NAME="ONACTIONDATE_FROM" CODE_BODY="METHOD onactiondate_from.
  DATA: value_set TYPE wdr_context_attr_value_list.
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.

  wd_node_info = wd_context-&gt;get_node_info( ).
  REFRESH value_set.

  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value_set = value_set ).
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONDATE_TO" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="DATE_TO" DISPLAY_NAME="ONACTIONDATE_TO" CODE_BODY="METHOD onactiondate_to .
  DATA: lv_from TYPE datum,
        lv_to   TYPE datum.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;FROM&apos;
                             IMPORTING value = lv_from ).

  wd_context-&gt;get_attribute( EXPORTING name = &apos;TO&apos;
                             IMPORTING value = lv_to ).

*  CALL FUNCTION &apos;Z_EMPLOC_DROPDOWN&apos;
*    EXPORTING
*      from      = lv_from
*      to        = lv_to
*    IMPORTING
*      hierarchy = wd_comp_controller-&gt;gt_hier.

*    wd_this-&gt;wd_get_api( )-&gt;get_message_manager( )-&gt;report_success( &apos;Date filter applied&apos; ).

  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  GET REFERENCE OF &apos;SEARCH&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  &quot; Call event handler
  CALL METHOD wd_this-&gt;onactionsearch
    EXPORTING
      wdevent = lo_event.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSEARCH" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SEARCH" DISPLAY_NAME="ONACTIONSEARCH" CODE_BODY="METHOD onactionsearch.
  DATA: lv_search TYPE string,
        lv_return TYPE string.
  DATA: it_hier TYPE TABLE OF zrehierarchy,
        wa_hier TYPE zrehierarchy.
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: lo_api_controller  TYPE REF TO if_wd_controller,
        lo_message_manager TYPE REF TO if_wd_message_manager.
  DATA: lt_country TYPE TABLE OF t005t,
        wa_country LIKE LINE OF lt_country.
  DATA: lv_count TYPE num03,
        lv_lines TYPE num03.
  DATA: lv_from TYPE datum,
        lv_to   TYPE datum,
        lv_p    TYPE rebdintrenoao.
  DATA: it_region TYPE TABLE OF t005u,
        wa_region LIKE LINE OF it_region.
  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_1&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.


  wd_context-&gt;get_attribute( EXPORTING name = &apos;SEARCH&apos;
                             IMPORTING value = lv_search ).

  wd_context-&gt;get_attribute( EXPORTING name = &apos;FROM&apos;
                             IMPORTING value = lv_from ).

  wd_node_info = wd_context-&gt;get_node_info( ).

  CALL FUNCTION &apos;Z_BETTER_DROPDOWN&apos;
    EXPORTING
      search_string = lv_search
    IMPORTING
      return        = lv_return
    TABLES
      hierarchy     = wd_comp_controller-&gt;gt_hier.

  LOOP AT wd_comp_controller-&gt;gt_hier INTO wa_hier
      WHERE aotype = &apos;05RM&apos;.
    APPEND wa_hier TO it_hier.
  ENDLOOP.

  DESCRIBE TABLE it_hier LINES lv_lines.

  IF lv_lines = 1.
    READ TABLE it_hier INTO wa_hier INDEX 1.

    value_wa-value = wa_hier-intreno.
    value_wa-text = wa_hier-xao.
    APPEND value_wa TO value_set.
    &quot;Room
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value = value_wa-value ).
    REFRESH value_set.
    &quot;Floor
    SELECT SINGLE intreno xao parent FROM zrehierarchy INTO (value_wa-value, value_wa-text, lv_p) WHERE intreno = wa_hier-parent.
    IF sy-subrc = 0.
      APPEND value_wa TO value_set.
      wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
      wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value = value_wa-value ).
      REFRESH value_set.
    ENDIF.
    &quot;Building
    SELECT SINGLE intreno xao parent FROM zrehierarchy INTO (value_wa-value, value_wa-text, lv_p) WHERE intreno = lv_p.
    IF sy-subrc = 0.
      APPEND value_wa TO value_set.
      wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).
      wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value = value_wa-value ).
      REFRESH value_set.
    ENDIF.
    &quot;Country
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos; value = wa_hier-country ).

    SELECT * FROM t005u INTO TABLE it_region
      WHERE land1 = wa_hier-country AND
            spras = &apos;EN&apos;.
    &quot;Region
    LOOP AT it_region INTO wa_region.
      value_wa-value = wa_region-bland.
      CONCATENATE wa_region-bland &apos;-&apos; wa_region-bezei INTO value_wa-text SEPARATED BY space.
      APPEND value_wa TO value_set.
    ENDLOOP.

    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value_set = value_set ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value = wa_hier-region ).

  ENDIF.

  &quot; Message section.
  lo_api_controller ?= wd_this-&gt;wd_get_api( ).
  CALL METHOD lo_api_controller-&gt;get_message_manager
    RECEIVING
      message_manager = lo_message_manager.

  IF lv_lines = 1.
    CALL METHOD lo_message_manager-&gt;report_success
      EXPORTING
        message_text = &apos;Result found.&apos;.
  ELSEIF lv_lines &gt; 1.
    CALL METHOD lo_message_manager-&gt;report_success
      EXPORTING
        message_text = &apos;Multiple results returned. Please narrow your search.&apos;.

    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
  ELSEIF lv_lines &lt; 1.
    CALL METHOD lo_message_manager-&gt;report_error_message
      EXPORTING
        message_text = &apos;No results found.&apos;.

    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                                     value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                         value = &apos;&apos; ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).

  ENDIF.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSELECT_1" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SELECT_1" DISPLAY_NAME="ONACTIONSELECT_1" CODE_BODY="METHOD onactionselect_1 .
  DATA lo_nd TYPE REF TO if_wd_context_node.
  DATA lo_el TYPE REF TO if_wd_context_element.
  DATA lr_event TYPE REF TO cl_wd_custom_event.

  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: wa_hier TYPE zbui_hier,
        wa_comp TYPE zloc_hier,
        wa_buil TYPE zbui_hier.
  DATA: lv_loc TYPE string,
        lv_com TYPE string.
  DATA: it_region TYPE TABLE OF t005u,
        wa_region LIKE LINE OF it_region.
  DATA: lv_count TYPE num03.

  DATA: it_selopt TYPE TABLE OF selopt,
        wa_selopt TYPE selopt.

  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_2&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                             IMPORTING value = lv_loc ).

  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                       value = &apos;&apos; ).

  CALL FUNCTION &apos;Z_BETTER_DROPDOWN_LAND&apos;
    EXPORTING
      land1     = lv_loc
    IMPORTING
      value_set = value_set.

  wd_node_info = wd_context-&gt;get_node_info( ).
  SORT value_set BY text.
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value_set = value_set ).

  &quot; Automatically select drop-down if it contains only as single entry.
  DESCRIBE TABLE value_set LINES lv_count.
  IF lv_count = 1.
    wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value = value_wa-value ).

    &quot; Call event handler
    CALL METHOD wd_this-&gt;onactionselect_2
      EXPORTING
        wdevent = lo_event.

  ELSE.
    REFRESH value_set.
    wd_node_info = wd_context-&gt;get_node_info( ).

    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
  ENDIF.
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSELECT_2" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SELECT_2" DISPLAY_NAME="ONACTIONSELECT_2" CODE_BODY="METHOD onactionselect_2 .
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: wa_hier TYPE zmun_hier,
        wa_comp TYPE zrehierarchy,
        wa_buil TYPE zrehierarchy.
  DATA: lv_cntr TYPE land1,
        lv_regi TYPE regio.
  DATA: lv_count TYPE num03.

  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_3&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                             IMPORTING value = lv_cntr ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                             IMPORTING value = lv_regi ).

  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                       value = &apos;&apos; ).

  &quot;ToDo - Display multiple threads based on region... PS. This last minute requirement screws up all of the logic!!

*  READ TABLE wd_comp_controller-&gt;gt_hier INTO wa_hier WITH KEY LOCID = lv_loc.

*  READ TABLE wa_hier-complexes INTO wa_comp WITH KEY COMPID = lv_com.

*  LOOP AT wa_comp-buildings INTO wa_buil.
  CALL FUNCTION &apos;Z_BETTER_DROPDOWN&apos;
    EXPORTING
*     SEARCH_STRING       =
      country   = lv_cntr
      region    = lv_regi
    TABLES
      hierarchy = wd_comp_controller-&gt;gt_hier.

  LOOP AT wd_comp_controller-&gt;gt_hier INTO wa_buil WHERE country = lv_cntr AND region = lv_regi.
    value_wa-value = wa_buil-intreno.
    value_wa-text = wa_buil-xao.
    APPEND value_wa TO value_set.
  ENDLOOP.

  wd_node_info = wd_context-&gt;get_node_info( ).
  SORT value_set BY text.
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value_set = value_set ).

  &quot; Automatically select drop-down if it contains only as single entry.
  DESCRIBE TABLE value_set LINES lv_count.

  IF lv_count = 1.
    wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value = value_wa-value ).

    &quot; Call event handler
    CALL METHOD wd_this-&gt;onactionselect_3
      EXPORTING
        wdevent = lo_event.
  ELSE.
    REFRESH value_set.
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
  ENDIF.
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSELECT_3" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SELECT_3" DISPLAY_NAME="ONACTIONSELECT_3" CODE_BODY="METHOD onactionselect_3 .
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: wa_hier  TYPE zmun_hier,
        wa_comp  TYPE zloc_hier,
        wa_buil  TYPE zrehierarchy,
        wa_floor TYPE zrehierarchy.
  DATA: lv_cntr TYPE land1,
        lv_regi TYPE regio,
        lv_bui  TYPE rebdintrenoao.
  DATA: lv_count TYPE num03.

  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_4&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                             IMPORTING value = lv_cntr ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                             IMPORTING value = lv_regi ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                             IMPORTING value = lv_bui ).

  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                                       value = &apos;&apos; ).
  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                       value = &apos;&apos; ).

  CALL FUNCTION &apos;Z_BETTER_DROPDOWN&apos;
    EXPORTING
*     SEARCH_STRING       =
      parent    = lv_bui
    TABLES
      hierarchy = wd_comp_controller-&gt;gt_hier.

  REFRESH value_set.

  LOOP AT wd_comp_controller-&gt;gt_hier INTO wa_floor.
    value_wa-value = wa_floor-intreno.
    value_wa-text = wa_floor-xao.
    APPEND value_wa TO value_set.
  ENDLOOP.

  wd_node_info = wd_context-&gt;get_node_info( ).
  SORT value_set BY text.
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value_set = value_set ).

  &quot; Automatically select drop-down if it contains only as single entry.
  DESCRIBE TABLE value_set LINES lv_count.
  IF lv_count = 1.
    wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value = value_wa-value ).

    &quot; Call event handler
    CALL METHOD wd_this-&gt;onactionselect_4
      EXPORTING
        wdevent = lo_event.
  ELSE.
    REFRESH value_set.
    wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).
  ENDIF.
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSELECT_4" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SELECT_4" DISPLAY_NAME="ONACTIONSELECT_4" CODE_BODY="METHOD onactionselect_4 .
  TYPES: BEGIN OF t_current,
           intreno TYPE recaintreno,
           xao     TYPE rebdxao,
         END OF t_current.
  DATA: lv_current TYPE t_current.
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: wa_hier  TYPE zmun_hier,
        wa_comp  TYPE zloc_hier,
        wa_buil  TYPE zrehierarchy,
        wa_floor TYPE zrehierarchy,
        wa_room  TYPE zrehierarchy.
  DATA: lv_cntr TYPE land1,
        lv_regi TYPE regio,
        lv_bui  TYPE rebdintrenoao,
        lv_flo  TYPE rebdintrenoao.
  DATA: lv_count TYPE num03.
  DATA: lv_showall TYPE char01.
  DATA: lv_from TYPE datum.
  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_5&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;FROM&apos;
                             IMPORTING value = lv_from ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos;
                             IMPORTING value = lv_cntr ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos;
                             IMPORTING value = lv_regi ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos;
                             IMPORTING value = lv_bui ).
  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos;
                             IMPORTING value = lv_flo ).

  wd_context-&gt;set_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                                       value = &apos;&apos; ).

  &quot;Debug
  IF sy-uname = &apos;CC615761&apos;.
    DATA: lv_x TYPE char01 VALUE &apos;X&apos;.
    WHILE lv_x = &apos;X&apos;.
      SELECT SINGLE value FROM zconfig INTO lv_x
        WHERE keyfield = &apos;DEBUG&apos;.
    ENDWHILE.
  ENDIF.

  SELECT SINGLE value FROM zconfig INTO lv_showall
    WHERE keyfield = &apos;ESSSHOWALL&apos;.

  CALL FUNCTION &apos;Z_BETTER_DROPDOWN&apos;
    EXPORTING
      from      = lv_from
      showall   = lv_showall
      parent    = lv_flo
    TABLES
      hierarchy = wd_comp_controller-&gt;gt_hier.

  REFRESH value_set.

  LOOP AT wd_comp_controller-&gt;gt_hier INTO wa_room.
    value_wa-value = wa_room-intreno.
    value_wa-text = wa_room-xao.
    APPEND value_wa TO value_set.
  ENDLOOP.
  wd_context-&gt;get_attribute( EXPORTING name = &apos;CURRENT_LOC&apos;
                             IMPORTING value = lv_current-intreno ).
  IF lv_current IS NOT INITIAL.
    SELECT SINGLE xao FROM vibdao
      INTO lv_current-xao
      WHERE intreno = lv_current-intreno.

    value_wa-value = lv_current-intreno.
    value_wa-text = lv_current-xao.
    &quot;Ensure we don&apos;t duplicate the value.
    READ TABLE value_set WITH KEY value = value_wa-value INTO DATA(value_chk).
    IF sy-subrc = 4.
      APPEND value_wa TO value_set.
    ENDIF.
    wd_context-&gt;set_attribute( name = &apos;CURRENT_LOC&apos; value = &apos;&apos; ).
  ENDIF.


  wd_node_info = wd_context-&gt;get_node_info( ).
  SORT value_set BY text.
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value_set = value_set ).

  &quot; Automatically select drop-down if it contains only as single entry.
  DESCRIBE TABLE value_set LINES lv_count.
  IF lv_count = 1.
    wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value = value_wa-value ).

    &quot; Call event handler
    CALL METHOD wd_this-&gt;onactionselect_5
      EXPORTING
        wdevent = lo_event.
  ENDIF.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSELECT_5" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SELECT_5" DISPLAY_NAME="ONACTIONSELECT_5" CODE_BODY="METHOD onactionselect_5 .
  &quot;TO DO - Display address
  DATA: lv_intreno  TYPE recaintreno,
        lv_adrnr    TYPE ad_addrnum,
        lv_housenum TYPE string,
        lv_street   TYPE string,
        lv_city     TYPE string,
        lv_region   TYPE regio,
        lv_country  TYPE land1,
        lv_postcode TYPE string.
  DATA: it_string TYPE gdv_tt_string,
        wa_string LIKE LINE OF it_string.

  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                             IMPORTING value = lv_intreno ).

  WHILE sy-subrc = 0.
    SELECT SINGLE parent FROM vibdnode
      INTO lv_intreno
      WHERE intreno = lv_intreno.
    IF lv_intreno IS NOT INITIAL AND lv_adrnr IS INITIAL.
      SELECT SINGLE adrnr FROM vzobject INTO lv_adrnr
        WHERE adrobjnr = lv_intreno.
    ENDIF.
  ENDWHILE.
  IF lv_adrnr IS NOT INITIAL.
    SELECT SINGLE house_num1 street city1 region country post_code1 FROM adrc
      INTO (lv_housenum, lv_street, lv_city, lv_region, lv_country, lv_postcode)
      WHERE addrnumber = lv_adrnr.
  ENDIF.
  IF lv_street IS NOT INITIAL.
    IF lv_housenum IS NOT INITIAL.
      CONCATENATE lv_housenum lv_street INTO wa_string SEPARATED BY space.
    ELSE.
      wa_string = lv_street.
    ENDIF.

    CONCATENATE wa_string &apos;,&apos; INTO wa_string.
    APPEND wa_string TO it_string.
    wa_string = lv_city.
    CONCATENATE wa_string &apos;,&apos; INTO wa_string.
    APPEND wa_string TO it_string.

    SELECT SINGLE bezei FROM t005u
      INTO wa_string
      WHERE bland = lv_region AND
            land1 = lv_country AND
            spras = &apos;EN&apos;.
    CONCATENATE wa_string &apos;,&apos; INTO wa_string.
    APPEND wa_string TO it_string.

    SELECT SINGLE landx FROM t005t
      INTO wa_string
      WHERE land1 = lv_country AND
            spras = &apos;EN&apos;.
    APPEND wa_string TO it_string.

    MOVE lv_postcode TO wa_string.
    APPEND wa_string TO it_string.
  ENDIF.
  wd_context-&gt;set_attribute( EXPORTING name = &apos;ADDRESS&apos;
                                       value = it_string ).

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="ONACTIONSUBMIT" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_CTLR_NAME="DROPDOWN_BY_KEY" REF_CMPNAME="SUBMIT" DISPLAY_NAME="ONACTIONSUBMIT" CODE_BODY="METHOD onactionsubmit .
  &quot;Search for existing location
  DATA: lv_perno TYPE bu_perno,
        lv_bpnr  TYPE bu_partner.
  DATA: wa_moveplan TYPE bapi_re_move_plan_dat,
        it_occupant TYPE TABLE OF bapi_re_mp_occupant_dat,
        wa_occupant LIKE LINE OF it_occupant,
        it_target   TYPE TABLE OF bapi_re_mp_target_dat,
        wa_target   LIKE LINE OF it_target,
        it_occplan  TYPE TABLE OF bapi_re_mp_occplan_dat,
        wa_occplan  LIKE LINE OF it_occplan,
        it_return   TYPE TABLE OF bapiret2.
  DATA: lv_room     TYPE rebdintrenoao,
        lv_mpid     TYPE reorpompid,
        lv_email    TYPE adr6-smtp_addr,
        lv_sobid    TYPE sobid,
        lv_currentd TYPE datum.
  DATA: lo_api_controller  TYPE REF TO if_wd_controller,
        lo_message_manager TYPE REF TO if_wd_message_manager.
  DATA: wa_return LIKE LINE OF it_return.
  DATA: lv_message TYPE string.

  lo_api_controller ?= wd_this-&gt;wd_get_api( ).
  CALL METHOD lo_api_controller-&gt;get_message_manager
    RECEIVING
      message_manager = lo_message_manager.


  wd_context-&gt;get_attribute( EXPORTING name = &apos;PERNO&apos;
                             IMPORTING value =  lv_perno ).

  CONCATENATE &apos;EE&apos; lv_perno INTO lv_bpnr.

  wa_moveplan-move_plan_text = &apos;Location Update from ESS.&apos;.
  wa_moveplan-move_plan_type = &apos;0002&apos;.
  &quot;Dates...
  wd_context-&gt;get_attribute( EXPORTING name = &apos;FROM&apos;
                             IMPORTING value =  wa_moveplan-move_date_from ).
  wa_moveplan-move_date_to = wa_moveplan-move_date_from. &quot;Same day move.
  wa_moveplan-perm_occ_date_from = wa_moveplan-move_date_from. &quot;Occupied from the move day
*  wd_context-&gt;get_attribute( EXPORTING name = &apos;TO&apos;
*                             IMPORTING value =  wa_moveplan-perm_occ_date_to ).
  &quot;Always use high-date when updating from ESS. To date disabled.
  wa_moveplan-perm_occ_date_to = &apos;99991231&apos;.
  wa_moveplan-move_out_date = wa_moveplan-move_date_from. &quot;Same day move.
  wa_moveplan-move_in_date = wa_moveplan-move_date_from + 1.

*  wa_moveplan-move_plan_status = &apos; &apos;. &quot;Move in process
  wa_moveplan-responsible = sy-uname. &quot;Should probably change to ccea.

  wa_occupant-occupant = lv_bpnr.
  wa_occupant-occupant_role = &apos;BUP003&apos;. &quot;Only employees.


  SELECT vioroo~ooidext viormp~permoccfrom FROM viorpo &quot;viorpo~occposition
    INNER JOIN viormp ON viormp~mpid = viorpo~mpid
    INNER JOIN vioroo ON  vioroo~objnr = viorpo~objnroo
    INNER JOIN vibdao ON  vibdao~objnr = vioroo~objnrref
    UP TO 1 ROWS
    INTO (wa_occupant-old_reservation_obj_id, lv_currentd) &quot;, wa_occupant-old_position
        WHERE viorpo~occupant = lv_bpnr AND
              viorpo~planstatus = &apos;&apos; AND
              viorpo~planind = &apos;&apos;
    ORDER BY viorpo~mpid DESCENDING. &quot; AND validfrom &lt;= wa_moveplan-move_date_from ). &quot;Select the latest active move.
  ENDSELECT.
  IF lv_currentd &gt;= wa_moveplan-move_date_from AND lv_currentd IS NOT INITIAL.
    lv_message = &apos;You cannot move earlier than or equal to the start date of your current location. Please rectify.&apos;.
    CALL METHOD lo_message_manager-&gt;report_error_message
      EXPORTING
        message_text = lv_message.
    EXIT.
  ENDIF.


  wa_occupant-old_reservation_obj_type = &apos;I5&apos;.
  wa_occupant-old_position = &apos;DESK&apos;.
  wa_occupant-key_date = wa_moveplan-perm_occ_date_from.
  APPEND wa_occupant TO it_occupant.

  wa_target-reservation_obj_type = &apos;I5&apos;. &quot;Always I5. (Offered Object)

  wd_context-&gt;get_attribute( EXPORTING name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos;
                             IMPORTING value = lv_room ).
  IF lv_room IS NOT INITIAL.
    SELECT SINGLE oo~ooidext FROM vibdao AS ao &quot;ao~partaoid
      INNER JOIN vioroo AS oo ON oo~objnrref = ao~objnr
      INTO (wa_target-reservation_obj_id) &quot;wa_target-position,
      WHERE ao~intreno = lv_room.

    wa_target-position = &apos;DESK&apos;.

    APPEND wa_target TO it_target. &quot;Save the target details.

    wa_occplan-occupant = lv_bpnr.
    wa_occplan-occupant_role = &apos;BUP003&apos;. &quot;Only employees.
    &quot;Plan to move to desk (IN).

    wa_occplan-old_reservation_obj_type = &apos;I5&apos;.
    wa_occplan-old_reservation_obj_id = wa_occupant-old_reservation_obj_id.
    wa_occplan-old_position = &apos;DESK&apos;.

    wa_occplan-reservation_obj_type = &apos;I5&apos;.
    wa_occplan-reservation_obj_id = wa_target-reservation_obj_id.
    wa_occplan-position = wa_target-position.
    wa_occplan-planning_type = &apos;M&apos;.
*    wa_occplan-is_free = &apos;X&apos;.
    wa_occplan-position = &apos;DESK&apos;.
    wa_occplan-move_out_date = wa_moveplan-move_date_from.
    wa_occplan-move_in_date = wa_moveplan-move_date_from + 1.

    APPEND wa_occplan TO it_occplan.

    &quot;Debug
    IF sy-uname = &apos;CC615761&apos;.
      DATA: lv_x TYPE char01 VALUE &apos;X&apos;.
      WHILE lv_x = &apos;X&apos;.
        SELECT SINGLE value FROM zconfig INTO lv_x
          WHERE keyfield = &apos;DEBUG&apos;.
      ENDWHILE.
    ENDIF.
    DATA: lv_exist  TYPE viorpo-mpid,
          lv_status TYPE viormp-mpstatus.

    SELECT viorpo~mpid viormp~mpstatus  FROM viorpo
        INNER JOIN viormp ON viorpo~mpid = viormp~mpid
        UP TO 1 ROWS
        INTO (lv_exist,lv_status)
        WHERE viorpo~occupant = lv_bpnr AND
              viormp~mpstatus = &apos;&apos;
        ORDER BY viormp~mpid DESCENDING.
    ENDSELECT.

    IF lv_exist IS NOT INITIAL AND lv_status &lt;&gt; 2 AND sy-subrc = 0.
      lv_message = |You cannot create a new move plan. Currently awaiting approval for { lv_exist }.|.
      CALL METHOD lo_message_manager-&gt;report_error_message
        EXPORTING
          message_text = lv_message.
      EXIT.
    ELSE.
      CALL FUNCTION &apos;BAPI_RE_MP_CREATE&apos;
        EXPORTING
          move_plan   = wa_moveplan
        IMPORTING
          moveplanid  = lv_mpid
        TABLES
          mp_occupant = it_occupant
          mp_target   = it_target
          mp_occplan  = it_occplan
          return      = it_return.
    ENDIF.
  ELSE.
    lv_message = |No location selected. Please select one before clicking submit.|.
      CALL METHOD lo_message_manager-&gt;report_error_message
        EXPORTING
          message_text = lv_message.
  ENDIF.
  &quot;Success or failure message...
  READ TABLE it_return INTO wa_return WITH KEY type = &apos;S&apos;.
  IF sy-subrc = 4.
    READ TABLE it_return INTO wa_return WITH KEY type = &apos;E&apos;.
  ELSE.
    COMMIT WORK AND WAIT. &quot;Only save the move plan if there were no errors.
  ENDIF.

  IF wa_return-type = &apos;S&apos;.
    CALL METHOD lo_message_manager-&gt;report_success
      EXPORTING
        message_text = wa_return-message.

*    SELECT SINGLE sobid FROM hrp1001 &quot;Get line manager
*      INTO lv_sobid
*      WHERE objid = lv_perno AND
*            rsign = &apos;A&apos; AND
*            relat = &apos;002&apos;.

    DATA: lv_rfc TYPE string.

    SELECT SINGLE value FROM zconfig INTO lv_rfc
      WHERE keyfield = &apos;REFXHCMRFC&apos;.

    CALL FUNCTION &apos;Z_RE_CL_TRIGGER&apos; DESTINATION lv_rfc
      EXPORTING
        mpid = lv_mpid.

*    CALL FUNCTION &apos;Z_MOVEPLAN_APPROVAL&apos;
*      EXPORTING
**       APPR =
*        mpid = lv_mpid.

  ELSE.
    IF lv_message IS INITIAL.
      lv_message = &apos;Error! Please check that you have selected all of the required fields.&apos;.
    ENDIF.
    CALL METHOD lo_message_manager-&gt;report_error_message
      EXPORTING
        message_text = wa_return-message.
  ENDIF.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SEARCH" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SEARCH" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SELECT_1" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SELECT_1" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SELECT_2" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SELECT_2" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SELECT_3" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SELECT_3" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SELECT_4" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SELECT_4" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SELECT_5" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SELECT_5" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="SUBMIT" VERSION="I" CMPTYPE="CL_WDY_MD_ACTION" CMP_POSITION="0 " VISIBILITY="0" DISPLAY_NAME="SUBMIT" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOAFTERACTION" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOAFTERACTION" CODE_BODY="method WDDOAFTERACTION .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOBEFOREACTION" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOBEFOREACTION" CODE_BODY="method WDDOBEFOREACTION .
*  data lo_api_controller type ref to if_wd_view_controller.
*  data lo_action         type ref to if_wd_action.

*  lo_api_controller = wd_this-&gt;wd_get_api( ).
*  lo_action = lo_api_controller-&gt;get_current_action( ).

*  if lo_action is bound.
*    case lo_action-&gt;name.
*      when &apos;...&apos;.

*    endcase.
*  endif.
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOEXIT" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOEXIT" CODE_BODY="method WDDOEXIT .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOINIT" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOINIT" CODE_BODY="METHOD wddoinit .
  DATA wd_node_info TYPE REF TO if_wd_context_node_info.
  DATA: value_set TYPE wdr_context_attr_value_list,
        value_wa  LIKE LINE OF value_set.
  DATA: wa_hier TYPE zrehierarchy.
  DATA: lt_country TYPE TABLE OF t005t,
        wa_country LIKE LINE OF lt_country.
  DATA: lv_count TYPE num03.

  DATA lo_event       TYPE REF TO cl_wd_custom_event.
  DATA lt_parameters  TYPE wdr_event_parameter_list.
  DATA ls_parameters  LIKE LINE OF lt_parameters.
  DATA: lv_from TYPE datum,
        lv_to   TYPE datum.
  DATA: it_selopt TYPE TABLE OF selopt,
        wa_selopt TYPE selopt.

  CLEAR ls_parameters.
  REFRESH lt_parameters.
  ls_parameters-name = &apos;ID&apos;.
  GET REFERENCE OF &apos;SELECT_1&apos; INTO  ls_parameters-value.
  INSERT ls_parameters INTO TABLE lt_parameters.
  &quot; Create custom event object with parameter
  CREATE OBJECT lo_event
    EXPORTING
      name       = &apos;ON_ACTION&apos;
      parameters = lt_parameters.

  &quot;For the date selectors - Not working... Still have to press enter.
  wd_this-&gt;wd_get_api( )-&gt;register_on_enter_for_f4( register_on_enter = abap_true ).


  wd_context-&gt;get_attribute( EXPORTING name = &apos;FROM&apos;
                             IMPORTING value = lv_from ).

  wd_context-&gt;get_attribute( EXPORTING name = &apos;TO&apos;
                             IMPORTING value = lv_to ).

  CALL FUNCTION &apos;Z_BETTER_DROPDOWN_LAND&apos;
    IMPORTING
      value_set = value_set.

  wd_node_info = wd_context-&gt;get_node_info( ).
  SORT value_set BY text.
  wd_node_info-&gt;set_attribute_value_set( name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos; value_set = value_set ).

  &quot; Automatically select drop-down if it contains only as single entry.
  DESCRIBE TABLE value_set LINES lv_count.
  IF lv_count = 1.
    wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos; value = value_wa-value ).

    &quot; Call event handler
    CALL METHOD wd_this-&gt;onactionselect_1
      EXPORTING
        wdevent = lo_event.

  ENDIF.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOMODIFYVIEW" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOMODIFYVIEW" CODE_BODY="METHOD wddomodifyview .
  &quot;Can&apos;t put in INIT because of importing parameter happening afterwards.
  &quot;Quick and dirty fix.
  DATA: lo_api_controller  TYPE REF TO if_wd_controller,
        lo_message_manager TYPE REF TO if_wd_message_manager.
  DATA: lv_init TYPE string.
  wd_context-&gt;get_attribute( EXPORTING name = &apos;INIT&apos;
                           IMPORTING value = lv_init ).

  DATA: lv_msgtxt TYPE string.
  IF lv_init IS INITIAL.
    DATA is_null TYPE wdy_boolean.
    TYPES: BEGIN OF t_screen,
             country TYPE land1,
             region  TYPE regio,
             locid   TYPE reorooidext,
             loc     TYPE rebdneighborhood,
             compid  TYPE reorooidext,
             comp    TYPE rebdneighborhood,
             buildid TYPE rebdintrenoao,
             build   TYPE rebdneighborhood,
             floid   TYPE rebdintrenoao,
             flo     TYPE rebdaonr,
             roomid  TYPE rebdintrenoao,
             room    TYPE rebdneighborhood,
             from    TYPE datum,
             to      TYPE datum,
           END OF t_screen.
    DATA: lv_uname  TYPE bname,
          lv_perno  TYPE bu_perno,
          lv_bpid   TYPE bu_partner,
          wa_screen TYPE t_screen.
    DATA: lv_comtype TYPE rebdaotype.
    DATA: lv_mpid TYPE reorpompid.
    &quot; Read existing location and display.

    lo_api_controller ?= wd_this-&gt;wd_get_api( ).
    CALL METHOD lo_api_controller-&gt;get_message_manager
      RECEIVING
        message_manager = lo_message_manager.

    wd_context-&gt;get_attribute( EXPORTING name = &apos;UNAME&apos;
                               IMPORTING value = lv_uname ).

    IF lv_uname IS INITIAL.
      SELECT SINGLE pernr FROM pa0105
        INTO lv_perno
        WHERE usrid = sy-uname
          AND subty = &apos;0001&apos;.
      lv_uname = sy-uname.
    ELSE.
      SELECT SINGLE pernr FROM pa0105
       INTO lv_perno
       WHERE usrid = lv_uname
         AND subty = &apos;0001&apos;.
    ENDIF.

    IF sy-subrc = 4.
      CONCATENATE &apos;User&apos; lv_uname
                  &apos;not found in REFX. Please contact the Real Estate Team.&apos;
                  INTO lv_msgtxt SEPARATED BY space.
      CALL METHOD lo_message_manager-&gt;report_error_message
        EXPORTING
          message_text = lv_msgtxt.
    ELSE.
      wd_context-&gt;set_attribute( name = &apos;PERNO&apos; value = lv_perno ).
    ENDIF.

    CONCATENATE &apos;EE&apos; lv_perno INTO lv_bpid.
    DATA: lv_mpstatus TYPE reorpompstatus.
    SELECT arch~intreno hed~permoccfrom hed~permoccto hed~mpstatus FROM viorpo AS occ
      INNER JOIN viormp AS hed ON hed~mpid = occ~mpid
      INNER JOIN vioroo AS off ON off~objnr = occ~objnroo
      INNER JOIN vibdao AS arch ON arch~objnr = off~objnrref
      INTO (wa_screen-roomid, wa_screen-from, wa_screen-to, lv_mpstatus)
      UP TO 1 ROWS
      WHERE occ~occupant = lv_bpid AND
            occ~plantype = &apos;I&apos;
      ORDER BY occ~mpid DESCENDING.
    ENDSELECT.

*    SELECT SINGLE arch~intreno occ~validfrom occ~validto FROM viorpo AS occ
*      INNER JOIN vioroo AS off ON off~objnr = occ~objnroo
*      INNER JOIN vibdao AS arch ON arch~objnr = off~objnrref
*      INTO (wa_screen-roomid, wa_screen-from, wa_screen-to)
*      WHERE occ~occupant = lv_bpid AND
*            occ~validto = &apos;99991231&apos; AND
*            occ~planstatus = &apos;&apos; AND
*            occ~planind = &apos;&apos; AND
*            occ~mpid = ( SELECT MAX( mpid ) FROM viorpo
*                              WHERE occupant = lv_bpid AND
*                                    planstatus = &apos;&apos; AND
*                                    planind = &apos;&apos; AND
*                                    mpid &lt;&gt; &apos;&apos; ). &quot;AND validfrom &lt;= sy-datum ). &quot;Select the latest active move.

    IF sy-subrc = 0 AND lv_mpstatus = 2. &quot;If existing location has been listed. Get the rest of the detail.
      SELECT SINGLE xao parent FROM zrehierarchy INTO (wa_screen-room, wa_screen-floid)
        WHERE intreno = wa_screen-roomid.
      SELECT SINGLE xao parent FROM zrehierarchy INTO (wa_screen-flo, wa_screen-buildid)
        WHERE intreno = wa_screen-floid.
      SELECT SINGLE xao parent country region FROM zrehierarchy INTO (wa_screen-build, wa_screen-compid, wa_screen-country, wa_screen-region)
        WHERE intreno = wa_screen-buildid.

      DATA lo_event       TYPE REF TO cl_wd_custom_event.
      DATA lt_parameters  TYPE wdr_event_parameter_list.
      DATA ls_parameters  LIKE LINE OF lt_parameters.

      wd_context-&gt;set_attribute( name = &apos;FROM&apos; value = wa_screen-from ).
      wd_context-&gt;set_attribute( name = &apos;TO&apos; value =  wa_screen-to ).
*      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos; value = wa_screen-locid ).
      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_1_ATTR&apos; value = wa_screen-country ).
      &quot;Trigger dropdown filter
      CLEAR ls_parameters.
      REFRESH lt_parameters.
      ls_parameters-name = &apos;ID&apos;.
      GET REFERENCE OF &apos;SELECT_1&apos; INTO  ls_parameters-value.
      INSERT ls_parameters INTO TABLE lt_parameters.
*    &quot; Create custom event object with parameter
      CREATE OBJECT lo_event
        EXPORTING
          name       = &apos;ON_ACTION&apos;
          parameters = lt_parameters.
      &quot; Call event handler
      CALL METHOD wd_this-&gt;onactionselect_1
        EXPORTING
          wdevent = lo_event.

      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_2_ATTR&apos; value = wa_screen-region ).
      &quot;Trigger dropdown filter
      CLEAR ls_parameters.
      REFRESH lt_parameters.
      ls_parameters-name = &apos;ID&apos;.
      GET REFERENCE OF &apos;SELECT_2&apos; INTO  ls_parameters-value.
      INSERT ls_parameters INTO TABLE lt_parameters.
*    &quot; Create custom event object with parameter
      CREATE OBJECT lo_event
        EXPORTING
          name       = &apos;ON_ACTION&apos;
          parameters = lt_parameters.
      &quot; Call event handler
      CALL METHOD wd_this-&gt;onactionselect_2
        EXPORTING
          wdevent = lo_event.

      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_3_ATTR&apos; value = wa_screen-buildid ).
      &quot;Trigger dropdown filter
      CLEAR ls_parameters.
      REFRESH lt_parameters.
      ls_parameters-name = &apos;ID&apos;.
      GET REFERENCE OF &apos;SELECT_3&apos; INTO  ls_parameters-value.
      INSERT ls_parameters INTO TABLE lt_parameters.
*    &quot; Create custom event object with parameter
      CREATE OBJECT lo_event
        EXPORTING
          name       = &apos;ON_ACTION&apos;
          parameters = lt_parameters.
      &quot; Call event handler
      CALL METHOD wd_this-&gt;onactionselect_3
        EXPORTING
          wdevent = lo_event.

      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_4_ATTR&apos; value = wa_screen-floid ).
      &quot;Trigger dropdown filter
      CLEAR ls_parameters.
      REFRESH lt_parameters.
      ls_parameters-name = &apos;ID&apos;.
      GET REFERENCE OF &apos;SELECT_4&apos; INTO  ls_parameters-value.
      INSERT ls_parameters INTO TABLE lt_parameters.
*    &quot; Create custom event object with parameter

      wd_context-&gt;set_attribute( name = &apos;CURRENT_LOC&apos; value = wa_screen-roomid ).

      CREATE OBJECT lo_event
        EXPORTING
          name       = &apos;ON_ACTION&apos;
          parameters = lt_parameters.
      &quot; Call event handler
      CALL METHOD wd_this-&gt;onactionselect_4
        EXPORTING
          wdevent = lo_event.

      wd_context-&gt;set_attribute( name = &apos;DROPDOWN_BY_KEY_5_ATTR&apos; value = wa_screen-roomid ).

      &quot;Trigger Address
      CLEAR ls_parameters.
      REFRESH lt_parameters.
      ls_parameters-name = &apos;ID&apos;.
      GET REFERENCE OF &apos;SELECT_5&apos; INTO  ls_parameters-value.
      INSERT ls_parameters INTO TABLE lt_parameters.

*    &quot; Create custom event object with parameter
      CREATE OBJECT lo_event
        EXPORTING
          name       = &apos;ON_ACTION&apos;
          parameters = lt_parameters.
      &quot; Call event handler
      CALL METHOD wd_this-&gt;onactionselect_5
        EXPORTING
          wdevent = lo_event.

    ELSE.
      wa_screen-from = sy-datum.
      wa_screen-to = &apos;99991231&apos;.
      wd_context-&gt;set_attribute( name = &apos;FROM&apos; value = wa_screen-from ).
      wd_context-&gt;set_attribute( name = &apos;TO&apos; value =  wa_screen-to ).

      SELECT viorpo~mpid FROM viorpo
        INTO lv_mpid
        UP TO 1 ROWS
        WHERE occupant = lv_bpid
        ORDER BY mpid.
      ENDSELECT.
      IF lv_mpid IS NOT INITIAL.
        CONCATENATE &apos;User&apos; lv_uname
                      &apos;currently awaiting approval of move plan&apos; lv_mpid
                      INTO lv_msgtxt SEPARATED BY space.
        CALL METHOD lo_message_manager-&gt;report_warning
          EXPORTING
            message_text = lv_msgtxt.
      ENDIF.
    ENDIF.

    &quot; Set INIT so all this code doesn&apos;t execute again... As I said. Dirty fix.
    wd_context-&gt;set_attribute( name = &apos;INIT&apos; value = &apos;X&apos; ).
  ENDIF.

ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOONCONTEXTMENU" CODE_BODY="method WDDOONCONTEXTMENU .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOAFTERACTION" LANGU="D" DESCRIPTION="Meth. für aktionsunabhängige Operationen vor der Navigation"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOAFTERACTION" LANGU="E" DESCRIPTION="Method for Action-Independent Operations Before Navigation"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOBEFOREACTION" LANGU="D" DESCRIPTION="Methode zur Validierung von Benutzereingaben"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOBEFOREACTION" LANGU="E" DESCRIPTION="Method for Validation of User Input"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOEXIT" LANGU="D" DESCRIPTION="Cleanup-Methode des Controllers"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOEXIT" LANGU="E" DESCRIPTION="Controller Clean-Up Method"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOINIT" LANGU="D" DESCRIPTION="Initialisierungs-Methode des Controllers"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOINIT" LANGU="E" DESCRIPTION="Controller Initialization Method"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOMODIFYVIEW" LANGU="D" DESCRIPTION="Methode zum Modifizieren des Views vor dem Rendering"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOMODIFYVIEW" LANGU="E" DESCRIPTION="Method for modifying the view before rendering"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" LANGU="D" DESCRIPTION="Methode zum Modifizieren des Context-Menüs"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" LANGU="E" DESCRIPTION="Method for modifying the context menu"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="HANDLEIN" PARAMETER_NAME="UNAME" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="BNAME" DISPLAY_NAME="UNAME"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOMODIFYVIEW" PARAMETER_NAME="FIRST_TIME" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="WDY_BOOLEAN" DISPLAY_NAME="FIRST_TIME"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOMODIFYVIEW" PARAMETER_NAME="VIEW" VERSION="I" PARAM_POSITION="2 " DECLARATION_TYPE="0" ABAP_TYPING="1" ABAP_TYPE="IF_WD_VIEW" DISPLAY_NAME="VIEW"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" PARAMETER_NAME="CONTEXT_MENU_EVENT" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="1" ABAP_TYPE="IF_WD_CONTEXT_MENU_EVENT" DISPLAY_NAME="CONTEXT_MENU_EVENT"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" PARAMETER_NAME="CONTEXT_MENU_MANAGER" VERSION="I" PARAM_POSITION="2 " DECLARATION_TYPE="0" ABAP_TYPING="1" ABAP_TYPE="IF_WD_CONTEXT_MENU_MANAGER" DISPLAY_NAME="CONTEXT_MENU_MANAGER"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CMPNAME="WDDOONCONTEXTMENU" PARAMETER_NAME="MENU" VERSION="I" PARAM_POSITION="3 " DECLARATION_TYPE="3" ABAP_TYPING="1" ABAP_TYPE="CL_WD_MENU" DISPLAY_NAME="MENU"/>
   <wdy_ctlr_paramt COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" LANGU="E" CMPNAME="HANDLEIN" PARAMETER_NAME="UNAME" DESCRIPTION="Username"/>
   <wdy_ctlr_usage COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" CTLR_USAGE_NAME="005JC52H4D1GEW11YA1TZ3PMT" VERSION="I" USED_CONTROLLER="COMPONENTCONTROLLER"/>
   <wdy_ctx_node COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" VERSION="I" NODE_TYPE="CL_WDY_MD_CONTEXT_VALUE_NODE" NODE_POSITION="0 " COLLECTION_TYPE="03" CARDINALITY="01" SELECTION="01" SINGLETON="X" DISPLAY_NAME="CONTEXT" ABAP_TYPING="0" INIT_LEAD_SELECT="X"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="ADDRESS" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="13 " ABAP_TYPE="GDV_TT_STRING" ABAP_TYPING="0" DISPLAY_NAME="ADDRESS" VALUE_HELP_MODE="0"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="CURRENT_LOC" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="12 " ABAP_TYPE="RECAINTRENO" ABAP_TYPING="0" DISPLAY_NAME="CURRENT_LOC" VALUE_HELP_MODE="0"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="DROPDOWN_BY_KEY_1_ATTR" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="1 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="DROPDOWN_BY_KEY_1_ATTR" VALUE_HELP_MODE="0" NULLABLE="X"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="DROPDOWN_BY_KEY_2_ATTR" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="2 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="DROPDOWN_BY_KEY_2_ATTR" VALUE_HELP_MODE="0" NULLABLE="X"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="DROPDOWN_BY_KEY_3_ATTR" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="3 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="DROPDOWN_BY_KEY_3_ATTR" VALUE_HELP_MODE="0" NULLABLE="X"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="DROPDOWN_BY_KEY_4_ATTR" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="4 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="DROPDOWN_BY_KEY_4_ATTR" VALUE_HELP_MODE="0" NULLABLE="X"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="DROPDOWN_BY_KEY_5_ATTR" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="5 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="DROPDOWN_BY_KEY_5_ATTR" VALUE_HELP_MODE="0" NULLABLE="X"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="FROM" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="7 " ABAP_TYPE="DATUM" ABAP_TYPING="0" DISPLAY_NAME="FROM" VALUE_HELP_MODE="0"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="INIT" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="10 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="INIT" VALUE_HELP_MODE="0"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="PERNO" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="9 " ABAP_TYPE="BU_PERNO" ABAP_TYPING="0" DISPLAY_NAME="PERNO" VALUE_HELP_MODE="0"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="READ_ONLY_2" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="11 " ABAP_TYPE="WDY_BOOLEAN" ABAP_TYPING="0" DISPLAY_NAME="READ_ONLY_2" VALUE_HELP_MODE="0"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="SEARCH" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="6 " ABAP_TYPE="STRING" ABAP_TYPING="0" DISPLAY_NAME="SEARCH" VALUE_HELP_MODE="0"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="TO" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="8 " ABAP_TYPE="DATUM" ABAP_TYPING="0" DISPLAY_NAME="TO" VALUE_HELP_MODE="0"/>
   <wdy_ctx_attrib COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="DROPDOWN_BY_KEY" NODE_NAME="CONTEXT" ATTRIBUTE_NAME="UNAME" VERSION="I" ATTRIBUTE_TYPE="CL_WDY_MD_CTX_VALUE_ATTRIBUTE" ATTRIB_POSITION="14 " ABAP_TYPE="BNAME" ABAP_TYPING="0" DISPLAY_NAME="UNAME" VALUE_HELP_MODE="0"/>
  </controller_definition>
  <controller_definition COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="EMPTYVIEW" VERSION="A" CONTROLLER_TYPE="01" DISPLAY_NAME="EMPTYVIEW"/>
  <controller_definition COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" VERSION="A" CONTROLLER_TYPE="06" CONTEXT="CONTEXT" DISPLAY_NAME="LOCATION">
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="HANDLEIN" VERSION="I" CMPTYPE="CL_WDY_MD_CTLR_EVENT_HANDLER" CMP_POSITION="0 " VISIBILITY="2" REF_VIEW_NAME="LOCATION" REF_PLUG_NAME="IN" DISPLAY_NAME="HANDLEIN" CODE_BODY="METHOD handlein .

  DATA: lt_parameters TYPE TABLE OF ihttpnvp.&quot;wdr_event_parameter_list.
  DATA: lv_uname TYPE bname.

*  DATA: lv_x TYPE char01.
*  WHILE lv_x &lt;&gt; &apos;X&apos;.
*  ENDWHILE.

  wdevent-&gt;get_data(
      EXPORTING
        name =  if_wd_application=&gt;all_url_parameters
      IMPORTING
        value = lt_parameters ).
  FIELD-SYMBOLS: &lt;param&gt; TYPE ihttpnvp.

  READ TABLE lt_parameters ASSIGNING &lt;param&gt;
                              WITH KEY name = &apos;UNAME&apos;.
  IF sy-subrc IS INITIAL AND &lt;param&gt;-value IS NOT INITIAL.
    lv_uname = &lt;param&gt;-value.
*  ELSE.
*    lv_uname = &apos;CC615761&apos;.
  ENDIF.


  CASE zview.
    WHEN &apos;DROPDOWN_BY_KEY&apos;.
      wd_this-&gt;fire_to_dropdown_by_key_plg( uname = lv_uname ).
    WHEN OTHERS.
      RAISE EXCEPTION TYPE cx_wd_general.
  ENDCASE.
ENDMETHOD.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOEXIT" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOEXIT" CODE_BODY="method WDDOEXIT .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOINIT" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOINIT" CODE_BODY="method WDDOINIT .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONCLOSE" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOONCLOSE" CODE_BODY="method WDDOONCLOSE .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compo COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONOPEN" VERSION="I" CMPTYPE="CL_WDY_MD_CONTROLLER_METHOD" CMP_POSITION="0 " VISIBILITY="2" DISPLAY_NAME="WDDOONOPEN" CODE_BODY="method WDDOONOPEN .
endmethod.
" ACTION_TYPE="0" ABAP_TYPING="0"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOEXIT" LANGU="D" DESCRIPTION="Cleanup-Methode des Controllers"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOEXIT" LANGU="E" DESCRIPTION="Controller Clean-Up Method"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOINIT" LANGU="D" DESCRIPTION="Initialisierungs-Methode des Controllers"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOINIT" LANGU="E" DESCRIPTION="Controller Initialization Method"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONCLOSE" LANGU="D" DESCRIPTION="Behandlung beim Schließen des Windows"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONCLOSE" LANGU="E" DESCRIPTION="Handling When Closing the Window"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONOPEN" LANGU="D" DESCRIPTION="Behandlung beim Öffnen des Windows"/>
   <wdy_ctlr_compot COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONOPEN" LANGU="E" DESCRIPTION="Handling When Opening the Window"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="HANDLEIN" PARAMETER_NAME="ZVIEW" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="0" ABAP_TYPE="STRING" DISPLAY_NAME="ZVIEW"/>
   <wdy_ctlr_param COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" CMPNAME="WDDOONOPEN" PARAMETER_NAME="WINDOW_DESCR" VERSION="I" PARAM_POSITION="1 " DECLARATION_TYPE="0" ABAP_TYPING="1" ABAP_TYPE="IF_WD_WINDOW_DESCRIPTION" DISPLAY_NAME="WINDOW_DESCR"/>
   <wdy_ctx_node COMPONENT_NAME="ZEMPLOYEE_LOCATION" CONTROLLER_NAME="LOCATION" NODE_NAME="CONTEXT" VERSION="I" NODE_TYPE="CL_WDY_MD_CONTEXT_VALUE_NODE" NODE_POSITION="0 " COLLECTION_TYPE="03" CARDINALITY="01" SELECTION="01" SINGLETON="X" DISPLAY_NAME="CONTEXT" ABAP_TYPING="0" INIT_LEAD_SELECT="X"/>
  </controller_definition>
 </WDYN>
 <PROG NAME="ZRE_BATCH_HCM_NEW" VARCL="X" SUBC="1" RSTAT="K" RMAND="200" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Batch Update HCM" LENGTH="16 "/>
    <textElement ID="S" KEY="P_DESC" ENTRY="        Move plan Description" LENGTH="29 "/>
    <textElement ID="S" KEY="P_MPID" ENTRY="        Move Plan ID" LENGTH="20 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZRE_BATCH_HCM
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*


REPORT zre_batch_hcm_new.

*INCLUDE zmoveplan_appr_incl.
TABLES: viormp.
PARAMETERS: p_desc TYPE reorpoxmp DEFAULT &apos;Batch Load of Employee Locations&apos; LOWER CASE.
SELECT-OPTIONS: p_mpid FOR viormp-mpid.
DATA: it_viormp TYPE TABLE OF viormp,
      wa_viormp LIKE LINE OF it_viormp.
DATA: it_0006   TYPE p0006_tab,
      wa_0006   LIKE LINE OF it_0006.
DATA: it_return TYPE isi_bapireturn1_tt.
DATA: lv_para TYPE string.

START-OF-SELECTION.
  SELECT SINGLE value FROM zconfig
    INTO lv_para
    WHERE keyfield = &apos;PARABATCH&apos;.
  IF sy-subrc = 4.
    lv_para = 1000.
  ENDIF.
  IF p_mpid IS INITIAL.
    SELECT * FROM viormp INTO TABLE it_viormp
     WHERE xmp = p_desc.
  ELSEIF p_desc IS INITIAL.
    SELECT * FROM viormp INTO TABLE it_viormp
     WHERE mpid IN p_mpid.
  ELSE.
    MESSAGE &apos;Please use either parameter, not both.&apos; TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
    EXIT.
  ENDIF.
  DATA: lv_rfc TYPE char10.
  SELECT SINGLE value FROM zconfig INTO lv_rfc
  WHERE keyfield = &apos;REFXHCMRFC&apos;.

  DATA: lv_count TYPE num4,
        lv_task  TYPE num4,
        lv_taskn TYPE string.
  DATA: lv_moveplan TYPE REF TO zcl_move_plan.

  LOOP AT it_viormp INTO wa_viormp.
    CREATE OBJECT lv_moveplan EXPORTING mpid = wa_viormp-mpid.
    IF lv_moveplan-&gt;t_0006 IS NOT INITIAL.
      LOOP AT lv_moveplan-&gt;t_0006 INTO wa_0006.
        APPEND wa_0006 TO it_0006.
        ADD 1 TO lv_count.
      ENDLOOP.
    ENDIF.
    FREE lv_moveplan.

    IF lv_count &gt;= lv_para.
      ADD 1 TO lv_task.
      CONCATENATE &apos;UPDATE_HCM&apos; &apos;-&apos; lv_task INTO lv_taskn SEPARATED BY space.
      CALL FUNCTION &apos;ZHCM_UPDATE_0006_BATCH&apos; DESTINATION lv_rfc
        STARTING NEW TASK lv_taskn
        PERFORMING return_info ON END OF TASK
        EXPORTING
          it0006 = it_0006.
      REFRESH it_0006.
      CLEAR lv_count.
    ENDIF.
  ENDLOOP.

  &quot;One last call for when we don&apos;t reach the limit counter.
  ADD 1 TO lv_task.
  CONCATENATE &apos;UPDATE_HCM&apos; &apos;-&apos; lv_task INTO lv_taskn SEPARATED BY space.
  CALL FUNCTION &apos;ZHCM_UPDATE_0006_BATCH&apos; DESTINATION lv_rfc
    STARTING NEW TASK lv_taskn
    PERFORMING return_info ON END OF TASK
    EXPORTING
      it0006 = it_0006.
  REFRESH it_0006.

FORM return_info USING lv_taskn TYPE string.
  DATA: it_return TYPE isi_bapireturn1_tt.

  RECEIVE RESULTS FROM FUNCTION &apos;ZHCM_UPDATE_0006_BATCH&apos;
    IMPORTING return = it_return.

  LOOP AT it_return INTO DATA(wa_return).
    WRITE:/ lv_taskn, &apos;:&apos;, wa_return-message.
  ENDLOOP.
ENDFORM.</source>
 </PROG>
 <PROG NAME="ZRE_BATCH_LOAD" VARCL="X" SUBC="1" RSTAT="K" RMAND="200" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Batch Load for Real Estate" LENGTH="26 "/>
    <textElement ID="S" KEY="LV_FILE" ENTRY="        Filename" LENGTH="16 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZRE_BATCH_LOAD
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

REPORT zre_batch_load.

TYPES: BEGIN OF t_type,
         planmovefrom TYPE string,
         planmoveto   TYPE string,
         employeebp   TYPE string,
         resobjectid  TYPE string,
       END OF t_type.

DATA: it_raw   TYPE truxs_t_text_data,
      wa_raw   LIKE LINE OF it_raw,
      ip_raw   TYPE stringtab,
      wp_raw   LIKE LINE OF ip_raw,
      it_line  TYPE TABLE OF t_type,
      ip_line  TYPE ztline,
      wp_line  LIKE LINE OF ip_line,
      wa_line  LIKE LINE OF it_line,
      lv_lines TYPE num4,
      lv_task  TYPE num4,
      lv_taskn TYPE string.
DATA: lv_para TYPE string.
DATA: lv_sfile TYPE string.

PARAMETERS: lv_file TYPE rlgrap-filename DEFAULT &apos;C:\temp\Staff_Links.csv&apos; LOWER CASE.


MOVE lv_file TO lv_sfile.

IF lv_file+0(1) &lt;&gt; &apos;/&apos;.
  CALL FUNCTION &apos;GUI_UPLOAD&apos;
    EXPORTING
      filename = lv_sfile
      filetype = &apos;ASC&apos;
    TABLES
      data_tab = it_raw.
ELSE.
  OPEN DATASET lv_sfile FOR INPUT IN TEXT MODE ENCODING DEFAULT.
  IF sy-subrc = 0.
    DO.
      READ DATASET lv_sfile INTO wa_raw.
      IF sy-subrc &lt;&gt; 0.
        EXIT.
      ENDIF.
      APPEND wa_raw TO it_raw.
    ENDDO.
  ENDIF.
  CLOSE DATASET lv_sfile.
ENDIF.

SELECT SINGLE value FROM zconfig
  INTO lv_para
  WHERE keyfield = &apos;PARABATCH&apos;.

IF sy-subrc = 4.
  lv_para = 1000.
ENDIF.

LOOP AT it_raw INTO wa_raw.
  wp_raw = wa_raw.
  APPEND wp_raw TO ip_raw.
*  wp_line-planmovefrom = wa_line-planmovefrom.
*  wp_line-planmoveto  = wa_line-planmoveto.
*  wp_line-employeebp  = wa_line-employeebp.
*  wp_line-resobjectid = wa_line-resobjectid.
*  APPEND wp_line TO ip_line.
  DESCRIBE TABLE ip_raw LINES lv_lines.
  IF lv_lines &gt;= lv_para.
    ADD 1 TO lv_task.
    CONCATENATE &apos;LOAD_MP&apos; &apos;-&apos; lv_task INTO lv_taskn SEPARATED BY space.
    WRITE:/ lv_taskn, &apos; started&apos;.
    CALL FUNCTION &apos;Z_BATCH_LOAD&apos;
      STARTING NEW TASK lv_taskn
      PERFORMING return_info ON END OF TASK
      EXPORTING
        ip_raw = ip_raw.
    REFRESH ip_raw.
  ENDIF.
ENDLOOP.

ADD 1 TO lv_task.
CONCATENATE &apos;LOAD_MP&apos; &apos;-&apos; lv_task INTO lv_taskn SEPARATED BY space.
WRITE:/ lv_taskn, &apos; started&apos;.
CALL FUNCTION &apos;Z_BATCH_LOAD&apos;
  STARTING NEW TASK lv_taskn
  PERFORMING return_info ON END OF TASK
  EXPORTING
    ip_raw = ip_raw.


FORM return_info USING lv_taskn TYPE char32.
  DATA: it_return TYPE stringtab.
  DATA: wa_log TYPE zlog.
  RECEIVE RESULTS FROM FUNCTION &apos;Z_BATCH_LOAD&apos;
    IMPORTING return = it_return.

  LOOP AT it_return INTO DATA(wa_return).
    WRITE:/ lv_taskn, &apos;:&apos;, wa_return.
    wa_log-logdate = sy-datum.
    wa_log-logtime = sy-uzeit.
    wa_log-loguser = sy-uname.
    wa_log-process = lv_taskn.
    wa_log-message = wa_return.
    wa_log-lineitem = sy-tabix.
    MODIFY zlog FROM wa_log.
  ENDLOOP.
ENDFORM.</source>
 </PROG>
 <PROG NAME="ZRE_BATCH_RELEASE" VARCL="X" SUBC="1" RSTAT="K" RMAND="200" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Batch Release &amp; Activate Moves" LENGTH="30 "/>
    <textElement ID="S" KEY="P_MPID" ENTRY="        Move Plan ID" LENGTH="20 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZRE_BATCH_RELEASE
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

REPORT zre_batch_release.
DATA: lv_mpid TYPE reorpompid.
DATA: lo_perm_occupancy TYPE REF TO if_reor_perm_occupancy_mp,
      lo_msglist        TYPE REF TO if_reca_message_list,
      go_move_plan      TYPE REF TO if_reor_move_plan,
      go_busobj         TYPE REF TO if_reor_move_plan.
DATA: if_in_update_task TYPE  abap_bool VALUE abap_true.
DATA: if_force_check  TYPE  abap_bool VALUE abap_false.
DATA: et_list TYPE re_t_msg.
DATA: wa_viormp TYPE viormp.
TABLES: viormp.
SELECT-OPTIONS: p_mpid FOR viormp-mpid.

SELECT * FROM viormp INTO wa_viormp WHERE mpid IN p_mpid.

  lv_mpid = wa_viormp-mpid.

  IF lv_mpid IS NOT INITIAL.
    lo_msglist = cf_reca_message_list=&gt;create( ).

    CALL METHOD cf_reor_move_plan=&gt;find
      EXPORTING
        id_mpid       = lv_mpid
        id_activity   = &apos;02&apos; &quot;Change - Check table TBZ0K.
        if_auth_check = abap_true
        if_enqueue    = abap_true
      RECEIVING
        ro_instance   = go_busobj
      EXCEPTIONS
        error         = 1
        OTHERS        = 2.
    IF go_busobj IS NOT INITIAL.
      lo_perm_occupancy ?= go_busobj-&gt;get_perm_occupancy( ).

      lo_perm_occupancy-&gt;release_all( lo_msglist ).

      CALL METHOD go_busobj-&gt;store(
          if_in_update_task = if_in_update_task
          if_force_check    = if_force_check ).

      COMMIT WORK AND WAIT.

      lo_perm_occupancy-&gt;activate_all( lo_msglist ).
      CALL METHOD go_busobj-&gt;set_activation(
          if_active  = &apos;X&apos;
          io_msglist = lo_msglist ).

      CALL METHOD go_busobj-&gt;store(
          if_in_update_task = if_in_update_task
          if_force_check    = if_force_check ).

      COMMIT WORK AND WAIT.

      CALL METHOD lo_msglist-&gt;get_list(
        IMPORTING
          et_list = et_list ).

      lo_msglist-&gt;free( ).

    ENDIF.
    &quot;Use the messages if you want to...
  ENDIF.

ENDSELECT.</source>
 </PROG>
 <PROG NAME="ZRE_BATCH_REFRESH" VARCL="X" SUBC="1" RSTAT="K" RMAND="200" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Batch program to refresh available hierarchy" LENGTH="44 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZRE_BATCH_REFRESH
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

REPORT ZRE_BATCH_REFRESH.
DATA: it_re TYPE TABLE OF zrehierarchy.

CALL FUNCTION &apos;Z_HIERARCHY_EXTRACT&apos;
  TABLES
    gt_re         = it_re.</source>
 </PROG>
 <PROG NAME="ZBATCH_UNLINK" VARCL="X" SUBC="1" RSTAT="K" RMAND="200" RLOAD="E" FIXPT="X" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="R" ENTRY="Unlink multiple buildings/locations" LENGTH="35 "/>
    <textElement ID="S" KEY="R_AOID" ENTRY="        Arch.Obj. ID" LENGTH="20 "/>
    <textElement ID="S" KEY="R_DEL" ENTRY="        Delete" LENGTH="14 "/>
    <textElement ID="S" KEY="R_ULK" ENTRY="        Unlink" LENGTH="14 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZBATCH_UNLINK
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
*&amp;
*&amp;---------------------------------------------------------------------*

REPORT zbatch_unlink.

TYPES: BEGIN OF t_moveplans,
*         objnr TYPE recaobjnr,
         mpid TYPE reorpompid,
       END OF t_moveplans.

DATA: it_moveplans TYPE TABLE OF t_moveplans WITH HEADER LINE.

DATA: lt_objrel_multi TYPE if_rebd_objrel_mngr=&gt;mtype_t_objrel_unlink_multi,
      ls_objrel_multi LIKE LINE OF lt_objrel_multi,
      lo_msglist      TYPE REF TO if_reca_message_list,
      lf_clear_meas   TYPE abap_bool,
      lo_objrel_trg   TYPE REF TO if_rebd_has_objrel,
      lo_bo           TYPE REF TO if_reca_bus_object,
      go_objrel_mngr  TYPE REF TO if_rebd_objrel_mngr.

DATA: if_in_update_task TYPE  abap_bool VALUE abap_true.
DATA: if_force_check  TYPE  abap_bool VALUE abap_false.

DATA: ito_busobj  TYPE  re_t_if_reca_bus_object.

DATA: io_has_objrel TYPE REF TO  if_rebd_has_objrel.
DATA: et_list TYPE re_t_object_relation.

FIELD-SYMBOLS: &lt;fs&gt; TYPE any.

TABLES: vibdao.
DATA: it_vibdao TYPE TABLE OF vibdao.
DATA: wa_vibdao TYPE vibdao.
SELECT-OPTIONS: r_aoid FOR vibdao-aoid.
*PARAMETERS: r_del RADIOBUTTON GROUP 1,
*            r_ulk RADIOBUTTON GROUP 1 DEFAULT &apos;X&apos;.
DATA: lv_objnr TYPE  recaobjnr.
DATA: wa_msg TYPE recasymsg.

SELECT * FROM vibdao INTO TABLE it_vibdao
  WHERE aoid IN r_aoid.

LOOP AT it_vibdao INTO wa_vibdao.

  CALL METHOD cf_rebd_arch_object=&gt;find_by_objnr
    EXPORTING
      id_objnr       = wa_vibdao-objnr
      id_activity    = reca1_activity-change
      if_auth_check  = abap_false
      if_enqueue     = abap_false
      if_use_archive = abap_false
    RECEIVING
      ro_instance    = io_has_objrel.
  IF io_has_objrel IS NOT INITIAL.
    &quot;Get relationship manager.
    go_objrel_mngr = io_has_objrel-&gt;get_objrel_mngr( ).
    go_objrel_mngr-&gt;set_subobject_mode( abap_true ).

    CALL METHOD go_objrel_mngr-&gt;get_list_rel_ao &quot;Get the list of linked objects
      IMPORTING
        et_list = et_list.
  ENDIF.
  &quot;This is probably bad coding, but who cares.
  &quot;Should technically loop and assign and not use the same field symbol for a structure and field.
  READ TABLE et_list ASSIGNING &lt;fs&gt; INDEX 1. &quot;We&apos;ll never have more than one link per object.
  ASSIGN COMPONENT &apos;OBJNRTRG&apos; OF STRUCTURE &lt;fs&gt; TO &lt;fs&gt;. &quot;Assign the objnr for the target

  IF sy-subrc = 0.
    CALL METHOD cf_reca_bus_object=&gt;find_by_objnr &quot;Grab the target object.
      EXPORTING
        id_objnr       = &lt;fs&gt;
        if_auth_check  = abap_true
        if_use_archive = abap_false
      RECEIVING
        ro_instance    = lo_bo
      EXCEPTIONS
        error          = 1
        OTHERS         = 2.
  ENDIF.

  lo_msglist = cf_reca_message_list=&gt;create( ). &quot;Initialize our message handler.
  lo_objrel_trg ?= lo_bo. &quot;Move our target object into the required structure.

  IF lo_objrel_trg IS NOT INITIAL. &quot;I&apos;m using the multiple unlink method so add it to our itab table.
    ls_objrel_multi-o_has_objrel = lo_objrel_trg.
    ls_objrel_multi-validfrom    = &apos;00000000&apos;.
    ls_objrel_multi-validto      = &apos;99991231&apos;.
    APPEND ls_objrel_multi TO lt_objrel_multi.
  ENDIF.

  IF lt_objrel_multi IS NOT INITIAL.
    CALL METHOD go_objrel_mngr-&gt;check_unlink_possible &quot;Here I&apos;m just checking if Unlinking our target object is possible. (Are there rooms in the building, etc.)
      EXPORTING
        io_busobj        = lo_objrel_trg
        id_objrel_from   = &apos;00000000&apos;
        id_objrel_to     = &apos;99991231&apos;
        if_ignore_period = abap_false
      EXCEPTIONS
        not_possible     = 1
        OTHERS           = 2.
    IF sy-subrc &lt;&gt; 0.
      lo_msglist-&gt;add_symsg( ).
    ELSE. &quot;If unlinking is possible, we process the unlink.
      CALL METHOD go_objrel_mngr-&gt;unlink_multiple
        EXPORTING
          it_objrel_multi         = lt_objrel_multi
          io_msglist              = lo_msglist
          if_clear_meas_if_nolink = lf_clear_meas.
    ENDIF.
  ENDIF.

  REFRESH lt_objrel_multi.
  IF io_has_objrel IS NOT INITIAL.
    &quot;Originally got stuck here because I was using the Rel. Mngr&apos;s store method. Should us the Arch Obj&apos;s method.
    CALL METHOD io_has_objrel-&gt;store(
      EXPORTING
        if_in_update_task = if_in_update_task
        if_force_check    = if_force_check
      EXCEPTIONS
        error             = 1 ).
    IF sy-subrc &lt;&gt; 0.
      lo_msglist-&gt;add_symsg( ).
      WRITE: &apos;Arch. Obj &apos;, wa_vibdao-aoid.
      WRITE 50(50) &apos;: Lower level objects exist.&apos;.
      WRITE /.
    ENDIF.
    COMMIT WORK AND WAIT.
  ENDIF.
  IF lo_msglist-&gt;is_empty( ) = abap_true.
    IF et_list IS NOT INITIAL.
      WRITE: &apos;Arch. Obj &apos;, wa_vibdao-aoid.
      WRITE 50(50) &apos;: Link was removed&apos;.
      WRITE /.
    ELSEIF et_list IS INITIAL.
      WRITE: &apos;Arch. Obj &apos;, wa_vibdao-aoid.
      WRITE 50(50) &apos;: No linked objects exists.&apos;.
      WRITE /.
    ENDIF.

    SELECT SINGLE objnr FROM vioroo INTO lv_objnr
      WHERE objnrref = wa_vibdao-objnr.

    SELECT mpid FROM viorpo
        INTO CORRESPONDING FIELDS OF TABLE it_moveplans
        WHERE objnroo = lv_objnr.

    SORT it_moveplans.
    DELETE ADJACENT DUPLICATES FROM it_moveplans.

    IF lv_objnr IS NOT INITIAL AND it_moveplans IS INITIAL.
      CALL METHOD cf_reca_bus_object=&gt;delete_by_objnr
        EXPORTING
          id_objnr          = lv_objnr
          if_force_deletion = &apos;X&apos;
          if_commit         = &apos;X&apos;
        IMPORTING
          es_info_msg       = wa_msg
        EXCEPTIONS
          error             = 4.
    ELSE.
      sy-subrc = 4.
    ENDIF.

    IF sy-subrc = 0.
      WRITE: &apos;Offered Obj &apos;, wa_vibdao-aoid.
      WRITE 50(50) &apos;: Deleted&apos;.
      WRITE /.
    ELSE.
      WRITE: &apos;Offered Obj &apos;, wa_vibdao-aoid.
      WRITE 50(50) &apos;: Delete Failed&apos;.
      WRITE /.
      LOOP AT it_moveplans.
        WRITE: &apos;Contained in Move Plan &apos;, it_moveplans-mpid.
        WRITE 50(50) &apos;: Delete Failed&apos;.
        WRITE /.
      ENDLOOP.
      REFRESH it_moveplans.
    ENDIF.
    CALL METHOD cf_reca_bus_object=&gt;delete_by_objnr
      EXPORTING
        id_objnr          = wa_vibdao-objnr
        if_force_deletion = &apos;X&apos;
        if_commit         = &apos;X&apos;
      IMPORTING
        es_info_msg       = wa_msg
      EXCEPTIONS
        error             = 4.

    IF sy-subrc = 0.
      WRITE: &apos;Arch. Obj &apos;, wa_vibdao-aoid.
      WRITE 50(50) &apos;: Deleted&apos;.
      WRITE /.
    ELSE.
      WRITE: &apos;Arch. Obj &apos;, wa_vibdao-aoid.
      WRITE 50(50) &apos;: Delete Failed&apos;.
      WRITE /.
    ENDIF.
  ELSE.
    WRITE: &apos;Arch. Obj &apos;, wa_vibdao-aoid. &quot;Will add the actual messages later.
    WRITE 50(50) &apos;: Unlinking failed&apos;.
    WRITE /.
    &quot;Will probably changes this to a write for when we process multiple objects. We don&apos;t really want a popup.
*  CALL FUNCTION &apos;RECA_GUI_MSGLIST_POPUP&apos;
*    EXPORTING
*      io_msglist = lo_msglist.
  ENDIF.
  WRITE &apos;================================================================================&apos;.

  FREE lo_objrel_trg.
  FREE go_objrel_mngr.
  FREE lo_bo.
  FREE io_has_objrel.
ENDLOOP.</source>
 </PROG>
 <FUGR SPRAS="E" AREA="ZBH1" AREAT="Britehouse Functions">
  <mainprogram NAME="SAPLZBH1" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="210" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <dynpros>
    <dynpro PROG="SAPLZBH1" DNUM="0100" FNUM="0100" BZMX="61 " BZBR="69 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="61 " NOCO="83 " VALP="0 " CUAN="G" SPRA="E" DTEXT="View maint: Overview screen ZEXCL_PERS">
     <dynprofield FNAM="TCTRL_ZEXCL_PERS" DIDX="003B" FLG1="F8" FLG2="FC" FLG3="00" FILL="T" FMB1="00" FMB2="00" LENG="0C" LINE="01" COLN="02" LTYP="E" LANF="65" LBLK="01" LREP="01" AUTH="101" AGLT="00" ADEZ="00"/>
     <dynprofield FNAM="VIM_FRAME_FIELD" DIDX="003C" FLG1="80" FLG2="02" FLG3="88" FMB1="30" FMB2="40" LENG="3C" LINE="01" COLN="00" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________________________________________________"/>
     <dynprofield FNAM="*ZEXCL_PERS-PERSK" DIDX="0005" FLG1="30" FLG2="00" FLG3="00" FMB1="30" FMB2="A0" LENG="28" LINE="01" COLN="01" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" ITYP="4" AGLT="00" ADEZ="00" STXT="ESgrp" RES1="                                       00"/>
     <dynprofield FNAM="VIM_MARKED" DIDX="0001" FLG1="80" FLG2="00" FLG3="88" FILL="C" FMB1="00" FMB2="20" LENG="01" LINE="01" COLN="00" LTYP="T" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="102" AGLT="00" ADEZ="00" STXT="_"/>
     <dynprofield FNAM="ZEXCL_PERS-PERSK" DIDX="0005" FLG1="B0" FLG2="00" FLG3="80" FMB1="30" FMB2="20" LENG="02" LINE="01" COLN="01" LTYP="T" LANF="65" LBLK="01" LREP="01" PAID="PKR" TYPE="CHAR" GRP1="KEY" ITYP="C" AGLT="04" ADEZ="00" STXT="__" RES1="                                       00"/>
     <dynprofield FNAM="VIM_POSI_PUSH" DIDX="0014" FLG1="80" FLG2="00" FLG3="88" FILL="P" FMB1="30" FMB2="00" LENG="14" LINE="3D" COLN="14" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AUTH="103" AGLT="00" ADEZ="00" STXT="____________________" RES1="                                                                                                                                                                        POSI"/>
     <dynprofield FNAM="VIM_POSITION_INFO" DIDX="001E" FLG1="80" FLG2="02" FLG3="88" FMB1="33" FMB2="00" LENG="1E" LINE="3D" COLN="29" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="______________________________"/>
     <dynprofield FNAM="OK_CODE" DIDX="0014" FLG1="80" FLG2="10" FLG3="08" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
     <dynproflowsource>PROCESS BEFORE OUTPUT.
 MODULE LISTE_INITIALISIEREN.
 LOOP AT EXTRACT WITH CONTROL
  TCTRL_ZEXCL_PERS CURSOR NEXTLINE.
   MODULE LISTE_SHOW_LISTE.
 ENDLOOP.
*
PROCESS AFTER INPUT.
 MODULE LISTE_EXIT_COMMAND AT EXIT-COMMAND.
 MODULE LISTE_BEFORE_LOOP.
 LOOP AT EXTRACT.
   MODULE LISTE_INIT_WORKAREA.
   CHAIN.
    FIELD ZEXCL_PERS-PERSK .
    MODULE SET_UPDATE_FLAG ON CHAIN-REQUEST.
   ENDCHAIN.
   FIELD VIM_MARKED MODULE LISTE_MARK_CHECKBOX.
   CHAIN.
    FIELD ZEXCL_PERS-PERSK .
    MODULE LISTE_UPDATE_LISTE.
   ENDCHAIN.
 ENDLOOP.
 MODULE LISTE_AFTER_LOOP.</dynproflowsource>
    </dynpro>
   </dynpros>
   <source>* regenerated at 29.02.2016 11:18:00 by  CC615761
*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZBH1TOP.                          &quot; Global Data
  INCLUDE LZBH1UXX.                          &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZBH1F...                          &quot; Subroutines
* INCLUDE LZBH1O...                          &quot; PBO-Modules
* INCLUDE LZBH1I...                          &quot; PAI-Modules
* INCLUDE LZBH1E...                          &quot; Events
* INCLUDE LZBH1P...                          &quot; Local class implement.
* INCLUDE LZBH1T99.                          &quot; ABAP Unit tests
  INCLUDE LZBH1F00                                . &quot; subprograms
  INCLUDE LZBH1I00                                . &quot; PAI modules
  INCLUDE LSVIMFXX                                . &quot; subprograms
  INCLUDE LSVIMOXX                                . &quot; PBO modules
  INCLUDE LSVIMIXX                                . &quot; PAI modules</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LSVIMDAT" SQLX="X" VARCL="X" SUBC="I" APPL="S" LEVL="30A" RMAND="000" RLOAD="D">
    <include_source>TABLES: e070, e071k, e071, tadir, dderr, tddat, objh. &quot;#EC NEEDED

TYPE-POOLS: cxtab, cmpwl, vimty, slctr, trwbo, scpr, slis, szadr.

CLASS: cl_abap_char_utilities DEFINITION LOAD.

* Adresspflege Übergangslösung anfang
TABLES: sadr, sadr2, sadr3, sadr4, sadr5.
DATA: sadr_keylen  TYPE i,             &quot;key length of table SADR
      sadr_namtab_read TYPE c.                              &quot;flag:

* Adresspflege Übergangslösung ende

DATA: maint_stat LIKE vimstatus.

FIELD-SYMBOLS: &lt;vim_ctotal&gt; TYPE ANY, &lt;vim_cextract&gt; TYPE ANY,
               &lt;vim_xtotal&gt; TYPE x, &lt;vim_xextract&gt; TYPE x,
               &lt;vim_total_struc&gt; TYPE ANY,
               &lt;vim_extract_struc&gt; TYPE ANY,
               &lt;vim_tot_txt_struc&gt; TYPE ANY,
               &lt;vim_ext_txt_struc&gt; TYPE ANY.
FIELD-SYMBOLS: &lt;f1&gt; TYPE ANY, &lt;name&gt; TYPE ANY, &lt;table1&gt; TYPE ANY,
               &lt;table2&gt; TYPE ANY, &lt;orig_key&gt; TYPE x,
               &lt;client&gt; TYPE ANY, &lt;vim_total_key&gt; TYPE ANY,
               &lt;vim_extract_key&gt; TYPE ANY,
               &lt;vim_xtotal_key&gt; TYPE x,
               &lt;vim_xextract_key&gt; TYPE x,
               &lt;vim_client_initial&gt; TYPE ANY.
* unicode
FIELD-SYMBOLS: &lt;table1_x&gt; TYPE x,
               &lt;table2_x&gt; TYPE x,
               &lt;f1_x&gt; TYPE x,
               &lt;table1_wa&gt; TYPE ANY,
               &lt;table1_wax&gt; TYPE x,
               &lt;f1_wax&gt; TYPE x,
               &lt;vim_corr_keyx&gt; TYPE x,
               &lt;initial_x&gt; TYPE x.
FIELD-SYMBOLS: &lt;mark&gt; TYPE ANY, &lt;action&gt; TYPE ANY,
               &lt;xmark&gt; TYPE ANY, &lt;xact&gt; TYPE ANY, &lt;initial&gt; TYPE ANY,
               &lt;status&gt; STRUCTURE vimstatus DEFAULT maint_stat,
               &lt;address_number&gt; TYPE ANY,
               &lt;user_exit_field&gt; TYPE ANY,                  &quot;#EC NEEDED
               &lt;replace_field&gt; TYPE ANY,
               &lt;vim_begdate&gt;     LIKE sy-datum,
               &lt;vim_new_begdate&gt; LIKE sy-datum,
               &lt;vim_enddate&gt;     LIKE sy-datum.
FIELD-SYMBOLS: &lt;vim_enddate_mask&gt; TYPE ANY,
               &lt;vim_mainkey_mask&gt; TYPE ANY,
               &lt;vim_prtfky_wa&gt; TYPE ANY, &lt;vim_prtfky_extract&gt; TYPE ANY,
               &lt;vim_prtfky_total&gt; TYPE ANY,
               &lt;vim_begdate_mask&gt; TYPE ANY,
               &lt;vim_collapsed_keyx&gt; TYPE x,
               &lt;vim_collapsed_logkeyx&gt; TYPE x.
FIELD-SYMBOLS: &lt;vim_collapsed_key_afx&gt; TYPE x,
               &lt;vim_merged_keyx&gt; TYPE x,
               &lt;vim_total_address_number&gt; TYPE ANY,
               &lt;vim_addr_handle_x&gt; TYPE x.
* Unicode
FIELD-SYMBOLS:
  &lt;vim_h_mkey&gt; TYPE x, &lt;vim_h_old_mkey&gt; TYPE x,
  &lt;vim_h_coll_mkey&gt; TYPE x, &lt;vim_h_merged_key&gt; TYPE x,
  &lt;vim_h_coll_bfkey&gt; TYPE x, &lt;vim_h_coll_logkey&gt; TYPE x,
  &lt;vim_f1_beforex&gt; TYPE x, &lt;vim_f1_afterx&gt; TYPE x,
  &lt;vim_mkey_beforex&gt; TYPE x, &lt;vim_mkey_afterx&gt; TYPE x.
FIELD-SYMBOLS:
  &lt;vim_tot_mkey_beforex&gt; TYPE x, &lt;vim_tot_mkey_afterx&gt; TYPE x,
  &lt;vim_ext_mkey_beforex&gt; TYPE x, &lt;vim_ext_mkey_afterx&gt; TYPE x,
  &lt;vim_old_mkey_beforex&gt; TYPE x, &lt;vim_old_mkey_afterx&gt; TYPE x,
  &lt;vim_collapsed_mkey_bfx&gt; TYPE x.
* for downward-compatibility only:
FIELD-SYMBOLS:
  &lt;vim_f1_before&gt;, &lt;vim_f1_after&gt;,                          &quot;#EC NEEDED
  &lt;vim_mkey_before&gt;, &lt;vim_mkey_after&gt;,                      &quot;#EC NEEDED
  &lt;vim_tot_mkey_before&gt;, &lt;vim_tot_mkey_after&gt;,              &quot;#EC NEEDED
  &lt;vim_ext_mkey_before&gt;, &lt;vim_ext_mkey_after&gt;,              &quot;#EC NEEDED
  &lt;vim_old_mkey_before&gt;, &lt;vim_old_mkey_after&gt;,              &quot;#EC NEEDED
  &lt;vim_collapsed_key_af&gt;, &lt;vim_collapsed_logkey&gt;,           &quot;#EC NEEDED
  &lt;vim_merged_key&gt;, &lt;vim_collapsed_key&gt;.                    &quot;#EC NEEDED
*
FIELD-SYMBOLS: &lt;subsetfield&gt; TYPE ANY,
               &lt;rdonlyfield&gt; TYPE ANY,                      &quot;#EC NEEDED
               &lt;value&gt; TYPE ANY,
               &lt;state&gt; STRUCTURE vimstatus DEFAULT maint_stat,
               &lt;vim_tctrl&gt; TYPE cxtab_control, &lt;vim_sellist&gt; TYPE table,
               &lt;vim_ck_sellist&gt; TYPE table,
               &lt;vim_field_value&gt; TYPE ANY,                  &quot;#EC NEEDED
               &lt;vim_scrform_name&gt; TYPE ANY,
               &lt;vim_auth_sellist&gt; TYPE table.
FIELD-SYMBOLS: &lt;table1_text&gt; TYPE ANY, &lt;table1_xtext&gt; TYPE x,
               &lt;total_text&gt; TYPE ANY, &lt;extract_text&gt; TYPE ANY,
               &lt;vim_xtotal_text&gt; TYPE x, &lt;vim_xextract_text&gt; TYPE x,
               &lt;action_text&gt; TYPE ANY,
               &lt;xact_text&gt; TYPE ANY,
               &lt;extract_enti&gt; TYPE ANY, &lt;vim_xextract_enti&gt; TYPE x,
               &lt;textkey&gt; TYPE ANY, &lt;initial_textkey&gt; TYPE ANY,
               &lt;textkey_x&gt; TYPE x, &lt;initial_textkey_x&gt; TYPE x,
               &lt;text_initial&gt; TYPE ANY, &lt;text_initial_x&gt; TYPE x,
               &lt;vim_text_enddate&gt; TYPE ANY.
FIELD-SYMBOLS: &lt;vim_texttab&gt; TYPE table,               &quot;SW Texttransl ..
*                            Type VIM_TAB_US/ .. /VIM_TAB_UL
               &lt;vim_read_langus&gt; TYPE table. &quot;SW Texttransl
*----------------------------------------------------------------------*
* Declaration of types                                                 *
*----------------------------------------------------------------------*
TYPES: vim_ko200_tab_type TYPE TABLE OF ko200.
TYPES: BEGIN OF state_vector,
         type(1)   TYPE c,             &quot; E=Einstufig Z=Zweistufig
         action(1) TYPE c,             &quot; S=Anz., U=Änd., A=Hinzuf., T=Tr
         mode(1)   TYPE c,             &quot; L=Liste, D=Detail
         data(1)   TYPE c, &quot; G=gesamt, X=Extract, D=Geloeschte
         mark(1)   TYPE c,             &quot; M=Markiert,  =Nicht Markiert
         delete(1) TYPE c,             &quot; D=Gelöscht,  =Nicht Gelöscht
         fill1(1)  TYPE c,             &quot;filler, not used
         fill2(1)  TYPE c,                                  &quot;     - &quot; -
       END OF state_vector.
TYPES: vim_tabkey TYPE tabl4096,
       BEGIN OF vim_tabkey_c,
        line(255) TYPE c,
       END OF vim_tabkey_c.
TYPES: BEGIN OF vim_ck_selcond,
         field LIKE vimnamtab-bastabfld,
         operator(2) TYPE c,
         hk1(1) TYPE c,
         value LIKE vimsellist-value,
         hk2(1) TYPE c,
         and LIKE vimsellist-and_or,
       END OF vim_ck_selcond.
TYPES: vimexclfldtab TYPE STANDARD TABLE OF vimexclfld
                          WITH DEFAULT KEY  INITIAL SIZE 10,
       BEGIN OF vimexclfldtabsline,
         viewname LIKE tvdir-tabname,
         excl_pos_tab TYPE vimexclfldtab,
         excl_rpl_tab TYPE vimexclfldtab,
         excl_que_tab TYPE vimexclfldtab,
       END OF vimexclfldtabsline,
       vimexclfldtabs TYPE SORTED TABLE OF vimexclfldtabsline
                           WITH UNIQUE KEY viewname,
       BEGIN OF vim_delim_entr_tl, &quot;indizes of delim. entries
         index1 TYPE i,            &quot;entries with mainkey in total
         index2 TYPE i,
         index3 TYPE i,            &quot;current entry in extract in
                                   &quot;collapsed mode
         index_corr(1) TYPE c,
       END OF vim_delim_entr_tl.
TYPES: BEGIN OF vim_collapsed_mkeys_tl,&quot;collapsed mainkeys
         mkey_bf TYPE vim_tabkey_c,
         mainkey TYPE vim_tabkey_c,
         log_key TYPE vim_tabkey_c,
       END OF vim_collapsed_mkeys_tl,
       BEGIN OF vim_merged_entr_tl,    &quot;merged entries
         new_key TYPE vim_tabkey,
         merged_key TYPE vim_tabkey,
         new_begdate TYPE d,
         new_enddate TYPE d,
         merged_begdate TYPE d,
         merged_enddate TYPE d,
       END OF vim_merged_entr_tl.
TYPES: BEGIN OF vim_ale_keyspec_objs,
         oname LIKE objh-objectname,
         otype LIKE objh-objecttype,
       END OF vim_ale_keyspec_objs,
       vim_flds_tab_type TYPE TABLE OF fieldname,           &quot;fieldlist
       vimnamtab_type TYPE TABLE OF vimnamtab.

* Definitionen für Texterfassung in mehreren Sprachen  &quot;SW Texttransl ..
CONSTANTS:
      ultra_short_tab TYPE i VALUE 32,
      very_short_tab TYPE i VALUE 48,
      short_tab TYPE i VALUE 64,
      middle_tab TYPE i VALUE 128,
      long_tab TYPE i VALUE 256,
      very_long_tab TYPE i VALUE 512,
      ultra_long_tab TYPE i VALUE 4096,
      vim_max_keylen_show TYPE i VALUE 120,                 &quot;#EC NEEDED
      vim_max_textfields TYPE i VALUE 8,   &quot;Anzahl Textfelder auf D0100
      vim_max_keyfields TYPE i VALUE 10.   &quot;  &quot;    Keyfelder   &quot;     &quot;

TYPES: vim_line_ul(ultra_long_tab)  TYPE c,
       vim_line_vl(very_long_tab)   TYPE c,
       vim_line_l(long_tab)         TYPE c,
       vim_line_m(middle_tab)       TYPE c,
       vim_line_s(short_tab)        TYPE c,
       vim_line_vs(very_short_tab)  TYPE c,
       vim_line_us(ultra_short_tab) TYPE c,

       vim_tab_ul  TYPE vim_line_ul OCCURS 0,
       vim_tab_vl  TYPE vim_line_vl OCCURS 0,
       vim_tab_l   TYPE vim_line_l OCCURS 0,
       vim_tab_m   TYPE vim_line_m OCCURS 0,
       vim_tab_s   TYPE vim_line_s OCCURS 0,
       vim_tab_vs  TYPE vim_line_vs OCCURS 0,
       vim_tab_us  TYPE vim_line_us OCCURS 0.

TYPES: BEGIN OF vim_variable_tab,
         valid_idx LIKE sy-index,      &quot; Index der gefüllten Tabelle
         tab_us TYPE vim_tab_us,       &quot; falls benutzt -&gt; valid_idx = 2
         tab_vs TYPE vim_tab_vs,       &quot;     &quot;                &quot;     = 3
         tab_s  TYPE vim_tab_s,
         tab_m  TYPE vim_tab_m,
         tab_l  TYPE vim_tab_l,
         tab_vl TYPE vim_tab_vl,
         tab_ul TYPE vim_tab_ul,
        END OF vim_variable_tab.

TYPES: BEGIN OF vim_tabdata_record,
         viewname   LIKE tvdir-tabname,
         sel_langus LIKE t002-spras OCCURS 0,
         all_langus(1) TYPE c,
         tabdata    TYPE vim_variable_tab,
       END OF vim_tabdata_record.

* lok. Hilfsvariable für Absprung in Langtextpflege über User-Exit
DATA: vim_internal_ltext_call(1) TYPE c.              &quot;.. SW Texttransl

* flags for ALS activation status
DATA: als_active(25) TYPE c,
      als_enabled(25) TYPE c.
* ALS declarations
DATA: als_sel_langus LIKE H_T002 OCCURS 0 WITH HEADER LINE,
      als_langus_selected(1) TYPE c.

*----------------------------------------------------------------------*
* Declaration of constants                                             *
*----------------------------------------------------------------------*
CONSTANTS:
      read(4) TYPE c VALUE &apos;READ&apos;,
      edit(4) TYPE c VALUE &apos;EDIT&apos;,
      read_and_edit(4) TYPE c VALUE &apos;RDED&apos;,
      vim_read_text(4) TYPE c VALUE &apos;RTXT&apos;,                 &quot;SW Textimp
        &quot; FCODE: Einlesen + zusätzl. Lesen der Texttab in allen Sprachen
      save(4) TYPE c VALUE &apos;SAVE&apos;,
      reset_list(4) TYPE c VALUE &apos;ORGL&apos;,
      reset_entry(4) TYPE c VALUE &apos;ORGD&apos;,
      switch_to_show_mode(4) TYPE c VALUE &apos;ANZG&apos;,
      switch_to_update_mode(4) TYPE c VALUE &apos;AEND&apos;.
CONSTANTS:
      switch_transp_to_upd_mode(4) TYPE c VALUE &apos;TRAE&apos;,
      get_another_view(4) TYPE c VALUE &apos;ATAB&apos;,
      back(4) TYPE c VALUE &apos;BACK&apos;,
      end(4) TYPE c VALUE &apos;ENDE&apos;,
      canc(4) TYPE c VALUE &apos;ABR &apos;,                          &quot;#EC NEEDED
      transport(4) VALUE &apos;TRSP&apos;,
      subset(1) TYPE c VALUE &apos;S&apos;,
      authority TYPE sychar01 VALUE &apos;A&apos;,
      ddic_marks(2)   TYPE c VALUE &apos;XB&apos;, &quot;ddic marks for ddic-flag
      vim_subset_marks(2) TYPE c VALUE &apos;SB&apos;, &quot;subset marks for ddic-flag
      vim_subset_marks_mult(4) TYPE c VALUE &apos;SBMA&apos;.         &quot;#EC NEEDED
      &quot;including authority
CONSTANTS:                                                     &quot;and mult
      rdonly(1) TYPE c VALUE &apos;R&apos;,
      vim_hidden(1) TYPE c VALUE &apos;H&apos;,                        &quot;#EC NEEDED
      adrnbr(1) TYPE c VALUE &apos;A&apos;,
      usrexi(1) TYPE c VALUE &apos;X&apos;,
      client_length LIKE sy-fdpos VALUE &apos;3&apos;, &quot;#EC STR_NUM  &quot;in characters
      vim_datum_length LIKE sy-fdpos VALUE &apos;8&apos;, &quot;#EC STR_NUM
      vim_spras_length LIKE sy-fdpos VALUE &apos;1&apos;, &quot;#EC STR_NUM
      fname_length  TYPE i VALUE &apos;30&apos;,  &quot;#EC STR_NUM  &quot;max. fieldname length
      compl_form_offs LIKE sy-fdpos VALUE &apos;6&apos;, &quot;#EC STR_NUM
      corr_form_offs LIKE sy-fdpos VALUE &apos;11&apos;. &quot;#EC STR_NUM
CONSTANTS:
      transporter LIKE tadir-pgmid VALUE &apos;R3TR&apos;, &quot;name of transport pgm
      transp_object LIKE tadir-object VALUE &apos;TABU&apos;, &quot;object to transport
      vim_view_type LIKE e071k-mastertype VALUE &apos;VDAT&apos;,
      vim_clus_type LIKE e071k-mastertype VALUE &apos;CDAT&apos;,
      vim_tran_type LIKE e071k-mastertype VALUE &apos;TDAT&apos;,
      vim_deleted_key LIKE tadir-pgmid VALUE &apos;(DL)&apos;,
      vim_unlockable_object LIKE e071k-mastertype VALUE &apos;(UO)&apos;,
      vim_lockable_object LIKE e071k-mastertype VALUE &apos;(LO)&apos;,
      vim_long_objname LIKE e071k-objname VALUE &apos;(?TABKEY?)&apos;.
CONSTANTS:
      vim_71k_name_length TYPE i VALUE &apos;30&apos;, &quot;#EC STR_NUM
      vim_transport_denied(1) TYPE c VALUE &apos;V&apos;,
      bc_transport_denied(1) TYPE c VALUE &apos;Y&apos;, &quot;No trsp at bc_set act.
      sortflag_with_existency LIKE e071k-sortflag VALUE &apos;2&apos;,
      sortflag_without_existency LIKE e071k-sortflag VALUE &apos;3&apos;,
      e071_objfunc LIKE e071-objfunc VALUE &apos;K&apos;,
      state_vect_prefix(7) TYPE c VALUE &apos;STATUS_&apos;,
      state_vect_prefix_length TYPE i VALUE &apos;7&apos;, &quot;#EC STR_NUM
      sap_cust_classes(2) TYPE c VALUE &apos;EG&apos;,    &quot;tabclasses to check
      sap_only_classes(1) TYPE c VALUE &apos;S&apos;,                 &quot;      -&quot;-
      sap_cust_ctrl_classes(1) TYPE c VALUE &apos;E&apos;,            &quot;      -&quot;-
      no_transport_classes(1) TYPE c VALUE &apos;L&apos;,             &quot;       -&quot;-
      no_transport_log_classes(1) TYPE c VALUE &apos;W&apos;,&quot;   -&quot;-
      application_delivery_classes(1) TYPE c VALUE &apos;A&apos;.
CONSTANTS:
      customizing_delivery_classes(3) TYPE c VALUE &apos;CEG&apos;,
      nbrd_texts_prefix(10) TYPE c VALUE &apos;SVIM_TEXT_&apos;,
      nbrd_texts_prefix_length TYPE i VALUE &apos;10&apos;, &quot;#EC STR_NUM
      master_fpool(8) TYPE c VALUE &apos;SAPLSVIM&apos;,
      vim_position_info_len TYPE i VALUE &apos;30&apos;, &quot;#EC STR_NUM  &quot;length of dynpro field
      vim_position_info_lg1 TYPE i VALUE &apos;13&apos;, &quot;#EC STR_NUM &quot;length of &apos;Eintrag&apos;
      vim_position_info_lg2 TYPE i VALUE &apos;6&apos;,  &quot;#EC STR_NUM  &quot;length of &apos;von&apos;
      vim_position_info_lg3 TYPE i VALUE &apos;10&apos;, &quot;#EC STR_NUM  &quot;max length of entry nbr.
      vim_reset(1) TYPE c VALUE &apos;O&apos;.
CONSTANTS:
      vim_replace(1) TYPE c VALUE &apos;R&apos;,
      vim_upgrade(1) TYPE c VALUE &apos;U&apos;,
      vim_direct_upgrade(1) TYPE c VALUE &apos;C&apos;,
      vim_undelete(1) TYPE c VALUE &apos;D&apos;,
      vim_delimit(1) TYPE c VALUE &apos;G&apos;,
      vim_delete(1) TYPE c VALUE &apos;L&apos;,
      vim_extedit(1) TYPE c VALUE &apos;E&apos;,                        &quot;#EC NEEDED
      vim_import(1) TYPE c VALUE &apos;I&apos;,                         &quot;#EC NEEDED
      vim_import_no_dialog TYPE c VALUE &apos;D&apos;,                  &quot;#EC NEEDED
      vim_import_with_dialog TYPE c VALUE &apos;H&apos;.
CONSTANTS:
      vim_time_dep_dpl_modif_form(30) TYPE c
                                  VALUE &apos;TIME_DEPENDENT_DISPLAY_MODIF&apos;,
      vim_view(1) TYPE c VALUE &apos;V&apos;,    &quot;OBJH-type for views
      vim_tabl(1) TYPE c VALUE &apos;S&apos;,    &quot;OBJH-type for tables
      vim_clst(1) TYPE c VALUE &apos;C&apos;,    &quot;OBJH-type for clusters
      vim_tran(1) TYPE c VALUE &apos;T&apos;,    &quot;OBJH-type for transact.
      vim_logo(1) TYPE c VALUE &apos;L&apos;,    &quot;OBJH-type for TLOGO-obj.
      vim_cust(4) TYPE c VALUE &apos;CUST&apos;, &quot;OBJ-category CUST
      vim_syst(4) TYPE c VALUE &apos;SYST&apos;. &quot;OBJ-category SYST
CONSTANTS:
      vim_cust_syst(4) TYPE c VALUE &apos;CUSY&apos;,    &quot;OBJ-category CUSY
      vim_appl(4) TYPE c VALUE &apos;APPL&apos;, &quot;OBJ-category APPL
      vim_noact(1) TYPE c VALUE &apos;N&apos;,   &quot;client state: no action
      vim_log(1)   TYPE c VALUE &apos;1&apos;,   &quot;client state: log chngs.
      vim_locked(1) TYPE c VALUE &apos;2&apos;,  &quot;client state: no chngs.
      vim_local_clnt(1) TYPE c VALUE &apos;3&apos;,      &quot;client state: no transp.
      vim_nocliindep_cust(1) TYPE c VALUE &apos;1&apos;, &quot;client state: ....
      vim_noreposichanges(1) TYPE c VALUE &apos;2&apos;, &quot;client state: ....
      vim_noreposiandcust(1) TYPE c VALUE &apos;3&apos;. &quot;client state: ....
CONSTANTS:
      vim_frm_text_upd_flag(19) TYPE c VALUE &apos;SET_TXT_UPDATE_FLAG&apos;,
      vim_frm_fill_textkey(19) TYPE c VALUE &apos;FILL_TEXTTAB_KEY_UC&apos;,
*      vim_frm_fill_textkey(16) TYPE c VALUE &apos;FILL_TEXTTAB_KEY&apos;,
      vim_max_trsp_keylength TYPE i VALUE &apos;120&apos;, &quot;#EC STR_NUM
      vim_max_trsp_identical_key TYPE i VALUE &apos;119&apos;, &quot;#EC STR_NUM
      vim_char_inttypes(5) TYPE c VALUE &apos;CDNST&apos;, &quot;char types for transp.
      vim_not_importable TYPE objimp VALUE &apos;1&apos;.

CONSTANTS:
* Type
  einstufig(1)       TYPE c VALUE &apos;E&apos;,
  zweistufig(1)      TYPE c VALUE &apos;Z&apos;,
* Action
  anzeigen(1)        TYPE c VALUE &apos;S&apos;,
  aendern(1)         TYPE c VALUE &apos;U&apos;,
  vim_ds_loeschen(1) TYPE c VALUE &apos;D&apos;,             &quot;MF BCSet-DS loeschen
  hinzufuegen(1)     TYPE c VALUE &apos;A&apos;,
  kopieren(1)        TYPE c VALUE &apos;C&apos;,
  profil_hinzufuegen TYPE c VALUE &apos;R&apos;,                      &quot;UFprofile
  transportieren(1)  TYPE c VALUE &apos;T&apos;,
  pruefen(1)         TYPE c VALUE &apos;P&apos;,
  zurueckholen(1)    TYPE c VALUE &apos;Z&apos;,
  task_add(1)        TYPE c VALUE &apos;E&apos;,
  task_del(1)        TYPE c VALUE &apos;F&apos;.
* Data
CONSTANTS:
  gesamtdaten(1)     TYPE c VALUE &apos;G&apos;,
  auswahldaten(1)    TYPE c VALUE &apos;X&apos;,
* Mark
  markiert(1)        TYPE c VALUE &apos;M&apos;,
  nicht_markiert(1)  TYPE c VALUE &apos; &apos;,
* Mode
  detail_bild(1)     TYPE c VALUE &apos;D&apos;,
  list_bild(1)       TYPE c VALUE &apos;L&apos;,
* Delete
  geloescht(1)       TYPE c VALUE &apos;D&apos;,
  nicht_geloescht(1) TYPE c VALUE &apos; &apos;,
* selected
  by_field_contents(1) TYPE c VALUE &apos;I&apos;,
* time dependent objects: display mode
  expanded(1)          TYPE c VALUE &apos; &apos;,                &quot;#EC NEEDED
  collapsed(1)         TYPE c VALUE &apos;C&apos;,                &quot;#EC NEEDED
  collapsed_displd(1)  TYPE c VALUE &apos;D&apos;.                &quot;#EC NEEDED
* others
CONSTANTS:
  update_geloescht(1) TYPE c VALUE &apos;Y&apos;,
  neuer_geloescht(1)  TYPE c VALUE &apos;X&apos;,
  dummy_geloescht(1)  TYPE c VALUE &apos;Z&apos;,
  neuer_eintrag(1)    TYPE c VALUE &apos;N&apos;,
  uebergehen(1)       TYPE c VALUE &apos;*&apos;,
  leer(1)             TYPE c VALUE &apos;L&apos;,
  original(1)         TYPE c VALUE &apos; &apos;,
  bcset_only(1)       TYPE c VALUE &apos;B&apos;.      &quot;Show only data from bcset

CONSTANTS: vim_scrform_domain LIKE dd03p-domname VALUE &apos;TDFORM&apos;,
           vim_delim_date_domain LIKE dd03p-domname VALUE &apos;DATUM&apos;,
           vim_begdate_dtel1 LIKE dd03p-rollname VALUE &apos;BEGDATUM&apos;,
           vim_begdate_dtel2 LIKE dd03p-rollname VALUE &apos;BEGDA&apos;,
           vim_begdate_dtel3 LIKE dd03p-rollname VALUE &apos;ISH_BEGDT&apos;,
           vim_begdate_dtel4 LIKE dd03p-rollname VALUE &apos;VIM_BEGDA&apos;,
           vim_enddate_dtel1 LIKE dd03p-rollname VALUE &apos;ENDDATUM&apos;,
           vim_enddate_dtel2 LIKE dd03p-rollname VALUE &apos;ENDDA&apos;,
           vim_enddate_dtel3 LIKE dd03p-rollname VALUE &apos;ISH_ENDDT&apos;,
           vim_enddate_dtel4 LIKE dd03p-rollname VALUE &apos;VIM_ENDDA&apos;.
CONSTANTS: BEGIN OF vim_adrnbr_domains,
             dom1 LIKE dd03p-domname VALUE &apos;ADRNR&apos;,
             dom2 LIKE dd03p-domname VALUE &apos;CADRNR&apos;,
             dom3 LIKE dd03p-domname VALUE &apos;AD_ADDRNUM&apos;,
           END OF vim_adrnbr_domains,
           vim_addr_e071k_master TYPE sobj_name VALUE &apos;ADDRESS&apos;,
                                                &quot;UF688403/2000
           vim_addr_e071k_master_46 TYPE sobj_name VALUE &apos;ADDRESS_4.6&apos;.
&quot;UF688403/2000


CONSTANTS: vim_sbscr_prog LIKE d020s-prog VALUE &apos;SAPLSVCM&apos;, &quot;#EC NEEDED
           vim_sbscr_dnum LIKE d020s-dnum VALUE &apos;0101&apos;,     &quot;#EC NEEDED
           vim_locked_in_corr LIKE vimstatus-corr_nbr VALUE &apos;LOCKED&apos;,
           vim_dummy_mainkey TYPE c VALUE &apos;K&apos;,
           vim_no_mkey_not_procsd(1) TYPE c VALUE &apos;X&apos;,
           vim_no_mkey_procsd_patt(2) TYPE c VALUE &apos;XY&apos;,
           vim_no_mkey_not_procsd_patt(2) TYPE c VALUE &apos;YX&apos;,
           vim_source_entry(1) TYPE c VALUE &apos;O&apos;,
           vim_clidep(1) TYPE x VALUE &apos;02&apos;,
           vim_auth_initial_check(1) TYPE c VALUE &apos;I&apos;,
           vim_auth_switch_to_update_mode(1) TYPE c VALUE &apos;U&apos;,
           vim_auth_requested_check(1) TYPE c VALUE &apos;R&apos;.

CONSTANTS: vim_tb_read_single_form(23) TYPE c
                                  VALUE &apos;TABLE_READ_SINGLE_ENTRY&apos;.
DATA:      compl_formname(30) TYPE c VALUE &apos;COMPL_&apos;,
           corr_formname(30) TYPE c VALUE &apos;CORR_MAINT_&apos;,
           BEGIN OF vim_read_single_form,
            prefix(18) TYPE c VALUE &apos;READ_SINGLE_ENTRY_&apos;,
            viewname LIKE tvdir-tabname,
           END OF vim_read_single_form,
           BEGIN OF vim_read_single_form_40,
            prefix(12) TYPE c VALUE &apos;READ_SINGLE_&apos;,
            viewname LIKE tvdir-tabname,
           END OF vim_read_single_form_40.

* state fields
DATA: status TYPE state_vector,
* BEGIN OF STATUS,
*   TYPE(1)   TYPE C VALUE &apos;2&apos;,        &quot; E=Einstufig Z=Zweistufig
*   ACTION(1) TYPE C VALUE &apos;U&apos;,   &quot; S=Anz., U=Änd., A=Hinzuf.,T=Tr
*   MODE(1)   TYPE C VALUE &apos;L&apos;,   &quot; L=Liste, D=Detail
*   DATA(1)   TYPE C VALUE &apos;G&apos;,   &quot; G=gesamt, X=Extract, D=Geloeschte
*   MARK(1)   TYPE C VALUE &apos; &apos;,        &quot; M=Markiert,  =Nicht Markiert
*   DELETE(1) TYPE C VALUE &apos; &apos;,        &quot; D=Gelöscht,  =Nicht Gelöscht
*   FILL1(1)  TYPE C VALUE &apos; &apos;,        &quot;filler, not used
*   FILL2(1)  TYPE C VALUE &apos; &apos;,        &quot;     - &quot; -
* END OF STATUS,

  BEGIN OF title,
   action(1) TYPE c VALUE &apos;U&apos;,    &quot; S=Anzeigen, U=Ändern, H=Hinzufügen
   mode(1)   TYPE c VALUE &apos;L&apos;,         &quot; L=Liste, D=Detail
   data(1)   TYPE c VALUE &apos;G&apos;,    &quot; G=Gesamt, X=Extrakt, D=Geloeschte
  END OF title.

* data containers and description
************************************************************************
DATA:  vim_for_alignment_only TYPE f,   &quot;never remove!!!
       vim_view_wax TYPE tabl8000,
       vim_ctabkeylen TYPE sy-fleng.    &quot;key length in characters

* other fields
DATA:
  vim_ale_keyspec_check(1) TYPE c,     &quot;Flag: .......
  vim_sync_keyspec_check(1) TYPE c,     &quot;Flag: keys locked by sync
  vim_sync_key_lock(1) TYPE c,  &quot;Flag: current dataset locked by sync
  vim_sync_key_lock_del(1) TYPE c, &quot;Flag: current dataset locked by sync
  vim_sctm_sourcesys TYPE logsys, &quot;Logic system to maintain locked data
  vim_ale_keyspec_objtab TYPE vim_ale_keyspec_objs OCCURS 1
                              WITH HEADER LINE,
  vim_delim_expa_excluded(1) TYPE c,   &quot;Flag: .....
  vim_auth_event(1) TYPE c,
  vim_auth_action(1) TYPE c.
DATA:
  vim_auth_rc LIKE sy-subrc, &quot;0-ok, 4-show only, 8-no_authority-&gt;exit
  vim_auth_msgid LIKE sy-msgid,
  vim_auth_msgno LIKE sy-msgno,
  vim_auth_msgv1 LIKE sy-msgv1,
  vim_auth_msgv2 LIKE sy-msgv2,
  vim_auth_msgv3 LIKE sy-msgv3,
  vim_auth_msgv4 LIKE sy-msgv4,
  vim_no_warning_for_cliindep(1) TYPE c, &quot;Flag: ......
  vim_begdate_is_ro(1) TYPE c, &quot;Flag: nokey-datefield is readonly
  vim_addr_field_selection LIKE addr1_fsel-fisel,  &quot;for ADDR_DIALOG_PREPA
  vim_addr_keywords LIKE addr1_keyw,    &quot;  - &quot; -
  vim_addr_titlebar LIKE sy-title,     &quot;  - &quot; -
  vim_addr_chng_deflt_comm_types LIKE addr_comm,   &quot;  - &quot; -
  vim_addr_frame_text LIKE addr_frame,  &quot;  - &quot; -
  vim_addr_excluded_functions LIKE vimexclfun     &quot;  - &quot; -
                              OCCURS 0 WITH HEADER LINE,
  vim_upgr_address_number LIKE addr1_sel-addrnumber.
DATA:
  vim_skip_adr_maint TYPE xfeld,                            &quot;UF120400
  vim_texttab_is_ro(1) TYPE c,
  vim_system_type(10) TYPE c,          &quot;SAP/CUSTOMER
  vim_nbr_of_scrfrm_pointers TYPE i,
  vim_enq_s_u_rc LIKE sy-subrc,
  vim_addr_e071k_tab LIKE TABLE OF e071k INITIAL SIZE 0,
  vim_addr_e071_tab LIKE TABLE OF e071 INITIAL SIZE 0,
  vim_tsadrv LIKE tsadrv,              &quot;Addresses: TSADRV-entry
  vim_addr_group LIKE tsadrv-addr_group,
  vim_addr_basetable LIKE dd03l-tabname,
  vim_addr_bastab_field LIKE dd03l-fieldname.
DATA:
  vim_show_consistency_alert(1) TYPE c VALUE &apos;X&apos;,
  vim_import_testmode(1) TYPE c,
  vim_import_forcemode(1) TYPE c,
  vim_import_profile(1) TYPE c,        &quot;Profilimport
  vim_profile_errorkey LIKE scpracpr-tablekey,
  vim_abort_saving(1) TYPE c,          &quot; &apos;X&apos; -&gt; Sichern abbrechen
  vim_import_no_message(1) TYPE c,
  vim_single_entry_function TYPE vimty_tcode,
  vim_single_entry_ins_key_input LIKE tvdir-flag,
  vim_import_mode_active(1) TYPE c.
DATA:
  vim_last_logged_message TYPE vimty_message,
  vim_copy_call_level TYPE i,
  vim_nr_entries_to_copy TYPE i,       &quot;SW 510129/1999
  vim_no_dialog(1) TYPE c,             &quot;flag:......
  vim_modify_screen(1) TYPE c,         &quot;Modul-lokales Flag
  vim_object LIKE vimdesc-viewname,
  vim_objfield LIKE vimnamtab-viewfield,
  vim_results_of_ext_mod LIKE vimmodres,
  vim_called_by_cluster(1) TYPE c,
  vim_calling_cluster TYPE vcl_name,
  vim_enqueue_range(1) TYPE c,
  vim_view_name LIKE vimdesc-viewname.
DATA:
  replace_mode(1) TYPE c,
  vim_restore_mode(1) TYPE c,
  vim_external_mode(1) TYPE c,
  vim_extcopy_mode(1) TYPE c,
  vim_special_mode(1) TYPE c,          &quot;O-reset,R-replace,U-upgrade
  vim_special_adjust_mode(1) TYPE c,
  vim_adjust_middle_level_mode(1) TYPE c,
  maint_mode TYPE c,
  update_flag(1) TYPE c VALUE &apos; &apos;,
  adrnbr_roflag(1) TYPE c VALUE &apos; &apos;.
DATA:
  block_sw    TYPE c VALUE &apos; &apos;,
  block_1     LIKE sy-tabix,
  block_2     LIKE sy-tabix,
  liste       LIKE d020s-dnum,
  detail      LIKE d020s-dnum,
  returncode  LIKE ocus-returncode,                         &quot;#EC NEEDED
  viewtitle   LIKE ocus-tabtitle,                           &quot;#EC NEEDED
  tablen      LIKE ocus-tablen,                             &quot;#EC NEEDED
  keylen      LIKE ocus-keylen,                             &quot;#EC NEEDED
  anzahl      TYPE i,
  answer(1)   TYPE c,
  neuer(1)    TYPE c VALUE &apos;N&apos;,
  ok_code     LIKE sy-ucomm,           &quot;(4) type c,    SW, wg Controls
  function    LIKE sy-ucomm,           &quot;(4) type c,
  relation(2) TYPE c VALUE &apos;EQ&apos;,                              &quot;#EC NEEDED
  counter LIKE sy-fdpos.
DATA:
  mark_extract TYPE i,
  mark_total   TYPE i,
  l LIKE sy-tabix,
  o TYPE i,
  old_nl LIKE sy-tabix,                                     &quot;GKPR - 0001009660
  pos TYPE i,
  refcnt TYPE i,
  newcnt TYPE i,
  orgcnt TYPE i,
  last_view_info LIKE dd02v-tabname,
  vim_last_objh_view LIKE dd02v-tabname,
  vim_act_dynp_view LIKE dd02v-tabname,
  vim_ale_edit_lock(1) TYPE c,                              &quot;flag:.....
  vim_sync_edit_lock(1) TYPE c,
  vim_ale_msgid LIKE sy-msgid,
  vim_ale_msgno LIKE sy-msgno,
  vim_ale_msgv1 LIKE sy-msgv1,
  vim_ale_msgv2 LIKE sy-msgv2,
  vim_ale_msgv3 LIKE sy-msgv3,
  vim_ale_msgv4 LIKE sy-msgv4.
DATA:                                                       &quot;#EC NEEDED
  last_corr_number LIKE e070-trkorr,
  fill_extr_first_proc TYPE c,       &quot;flag: Fill_extract first time proc
* F(30) TYPE C,  &quot;4.0 name extension &quot;max. Länge ABAP-Feldnamen: 30 Zchn
  f LIKE d021s-fnam,
* SUBSETID_RECEIVED TYPE C,          &quot;flag: subset ID already received
  e071k_tab_modified TYPE c,          &quot;flag:                 &quot;#EC NEEDED
  sel_field_for_replace(30) TYPE c,    &quot;field selected for replace
*  sel_field_for_replace_l(30) TYPE c,  &quot;field selected for replace long
* XB H655767
  sel_field_for_replace_l(40) type c,  &quot;field selected for replace long
* CORR_NBR LIKE TADIR-KORRNUM,       &quot;current corr.nbr
  corr_nbr LIKE e070-trkorr,           &quot;current corr.nbr
  master_type LIKE tadir-object VALUE &apos;TABU&apos;, &quot;master object to transp.
  master_name LIKE tadir-obj_name,     &quot;name of object to transport
  vim_client_state LIKE t000-cccoractiv,   &quot; state of client for transport
  get_corr_keytab(1) TYPE c,           &quot;Flag: keytab is to read
  last_ext_modif_view LIKE tvdir-tabname,                   &quot;flag:
  deta_mark_safe(1) TYPE c,
  ignored_entries_exist(1) TYPE c,                          &quot;flag:
  corr_action(1) TYPE c,             &quot;current action for UPDATE_CORR_KEY
  replace_texttable_field(1) TYPE c, &quot;flag: replace function for textfld
  nbrd_texts_alr_read(1) TYPE c.     &quot;flag: texts from SVIM already read
DATA:
  svim_text_001(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_002(35) TYPE c,            &quot;numbered text of SVIM &quot;#EC NEEDED
  svim_text_003(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_004(35) TYPE c,            &quot;numbered text of SVIM &quot;#EC NEEDED
  svim_text_005(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_006(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_007(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_008(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_009(36) TYPE c,            &quot;numbered text of SVIM
  svim_text_010(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_011(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_012(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_013(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_014(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_015(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_016(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_017(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_018(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_019(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_020(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_021(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_022(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_023(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_024(35) TYPE c,            &quot;numbered text of SVIM &quot;#EC NEEDED
  svim_text_025(35) TYPE c,            &quot;numbered text of SVIM &quot;#EC NEEDED
  svim_text_026(35) TYPE c,            &quot;numbered text of SVIM &quot;#EC NEEDED
  svim_text_027(13) TYPE c,            &quot;numbered text of SVIM
  svim_text_028(06) TYPE c,            &quot;numbered text of SVIM
  svim_text_029(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_030(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_031(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_032(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_033(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_034(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_035(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_036(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_037(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_038(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_039(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_040(35) TYPE c,            &quot;numbered text of SVIM
  svim_text_041(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_042(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_043(40) TYPE c,            &quot;numbered text of SVIM &quot;#EC NEEDED
  svim_text_044(40) TYPE c,            &quot;numbered text of SVIM &quot;#EC NEEDED
  svim_text_045(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_046(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_104(19) TYPE c,            &quot;numbered text of SVIM
  svim_text_p01(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_p02(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_p03(20) TYPE c,            &quot;numbered text of SVIM
  svim_text_prb(40) TYPE c,            &quot;numbered text of SVIM
  svim_text_prc(40) TYPE c,            &quot;numbered text of SVIM
  svim_text_pre(40) TYPE c,            &quot;numbered text of SVIM &quot;#EC NEEDED
  svim_text_prf(70) TYPE c,            &quot;numbered text of SVIM &quot;#EC NEEDED
  svim_text_prg(70) TYPE c,            &quot;numbered text of SVIM &quot;#EC NEEDED
  svim_text_pri(40) TYPE c,            &quot;numbered text of SVIM
  svim_text_prj(40) TYPE c,            &quot;numbered text of SVIM
  svim_text_det(40) TYPE c.            &quot;numbered text of SVIM

DATA:
      TCTRL_MEREP_801T TYPE TABLE OF merep_801T,
      TCTRL_MEREP_807 TYPE TABLE OF merep_807.
DATA:
  vim_marked(1) TYPE c,                &quot;mark-checkbox field
  vim_frame_field LIKE dd25v-ddtext,   &quot;name of frame (subset fields only)
  vim_position_info(42) TYPE c,        &quot;field for &apos;entry x of y&apos;
  vim_position_info_mask(42) TYPE c, &quot;mask for field for &apos;entry x of y&apos;
  vim_fpool_name LIKE trdir-name,                             &quot;#EC NEEDED
  vim_posi_push(25) TYPE c,          &quot;push button to posit on list scrn
  temporal_delimitation_happened TYPE c,                    &quot;flag: ....
  vim_mkey_after_exists(1) TYPE c,                          &quot;flag: ....
  vim_no_mainkey_exists(1) TYPE c,                          &quot;flag: ....
  nbr_of_added_dummy_entries TYPE i,   &quot;for function NEWL: ...
  vim_next_screen LIKE tvdir-liste,    &quot;next screen number
  vim_leave_screen(1) TYPE c,          &quot;flag: leave screen necessary
  vim_prtfky_assigned(1) TYPE c,                            &quot;flag...
* VIM_EXTRACT_MODIFIED(1) TYPE C,    &quot;flag...
  vim_temp_delim_alr_checked(1) TYPE c,                     &quot;flag...
  vim_ignore_collapsed_mainkeys(1) TYPE c,                  &quot;flag...
  vim_corr_obj_viewname LIKE tvdir-tabname.
DATA:
  vim_last_source_system LIKE tadir-srcsystem,
  vim_slct_functiontext(40) TYPE c,&quot;HCG HW711274              &quot;#EC NEEDED
  vim_comp_menue_text(40) TYPE c,
  vim_key_alr_checked(1) TYPE c,       &quot;flag: .....
  vim_keyrange_alr_checked(1) TYPE c,  &quot;flag: .....
  vim_prt_fky_flds_updated(1) TYPE c,  &quot;flag: .....
  vim_exit_11_12_active(1) TYPE c,     &quot;flag: .....
  BEGIN OF vim_default_rfc_dest,       &quot;global vector for default
    viewname LIKE tvdir-tabname,       &quot;RFC-destination
    rfcdest LIKE rfcdes-rfcdest,
  END OF vim_default_rfc_dest.
DATA:
  BEGIN OF vim_default_upgr_clnt,      &quot;global vector for default
    viewname LIKE tvdir-tabname,        &quot;client for upgrade
    client LIKE sy-mandt,
  END OF vim_default_upgr_clnt,
  vim_title_name LIKE vimdesc-ddtext,
  vim_tabctrl_active(1) TYPE c,
  vim_tc_cols TYPE cxtab_column,
  vim_local_char1(1) TYPE c.           &quot;Modul-lok. Hilfsvariable  &quot;#EC NEEDED

* data for time-dependent routines (VCX)
FIELD-SYMBOLS: &lt;key_date&gt; TYPE ANY.
DATA: BEGIN OF d0001_field_tab OCCURS 10,
        begin TYPE d, end TYPE d, mark(1) TYPE c,
      END OF d0001_field_tab,
      d0001_cursor TYPE i,
      BEGIN OF d0001_status,
        type(1)   TYPE c,
        action(1) TYPE c,
        mode(1)   TYPE c,
        data(1)   TYPE c,
        mark(1)   TYPE c,
        delete(1) TYPE c,
        fill1(1)  TYPE c,              &quot;filler, not used
        fill2(1)  TYPE c,                                   &quot;     - &quot; -
        spec_mode TYPE c,
      END OF d0001_status.
DATA: d0001_input_flag(1) TYPE c,
      vim_mainkey TYPE vim_tabkey_c,   &quot;field for mainkey (prt. forkey)
      current_date TYPE d,
      date_to_delimit TYPE d,
      date_to_posit TYPE d,
      vim_old_viewkey TYPE vim_tabkey_c,
      date_safe TYPE d,
      vim_old_st_selected(1) TYPE c,
      BEGIN OF vim_memory_id_1,  &quot;memory-ID for vim_collapsed_entries
        viewname LIKE vimdesc-viewname,
        user     LIKE sy-uname,
      END OF vim_memory_id_1.
DATA: BEGIN OF vim_memory_id_2,  &quot;memory-ID for date subscreen data
        viewname LIKE vimdesc-viewname,
        user     LIKE sy-uname,
      END OF vim_memory_id_2,
      vim_date_mask(8) TYPE c VALUE &apos;++++++++&apos;,
      vim_coll_mkeys_first(1) TYPE c,
      vim_merge_begin TYPE i,
      vim_merge_end TYPE i,
      vim_begdate_entered(1) TYPE c,
      BEGIN OF vim_begdate_name,
        tabname LIKE vimdesc-viewname,
        dash(1) TYPE c VALUE &apos;-&apos;,
        fieldname LIKE vimnamtab-viewfield,
      END OF  vim_begdate_name.
DATA: BEGIN OF vim_enddate_name,
        tabname LIKE vimdesc-viewname,
        dash(1) TYPE c VALUE &apos;-&apos;,
        fieldname LIKE vimnamtab-viewfield,
      END OF  vim_enddate_name,
      vim_last_coll_mainkeys_ix TYPE i,
      vim_coll_mainkeys_beg_ix TYPE i VALUE 1,
      check_all_keyr_scnd_time(1) TYPE c, &quot;Flag: .........
      vim_tdep_title(19) TYPE c.
CONSTANTS: vim_init_date TYPE d VALUE &apos;00000000&apos;.         &quot;#EC VALUE_OK


* data for navigation within internal tables
DATA:
  aktuell(10) TYPE n,
  maximal(10) TYPE n,
  index     LIKE sy-tabix,
  exind     LIKE sy-tabix,
  mandant   LIKE sy-mandt,
  curline   LIKE sy-tabix,             &quot;Cursor-Position in Tab. &quot;#EC NEEDED
  curpage   LIKE sy-tabix VALUE 1,     &quot;aktuelle Seite          &quot;#EC NEEDED
  firstline LIKE sy-tabix VALUE 1,
  nextline  LIKE sy-tabix VALUE 1,
                            &quot;Pos. erste Zeile der akt. Seite in Tab.
  anz_lines LIKE sy-tabix,             &quot;Anzahl vorhandener Tab.-Zeilen  &quot;#EC NEEDED
  anz_pages LIKE sy-tabix,             &quot;Anzahl vorhandener Tab.-Seiten
  maxlines  LIKE sy-tabix,             &quot;Anzahl vorhandener Tab.-Zeilen
  destpage  LIKE sy-tabix,  &quot;Seite, auf die geblättert werden soll
  looplines LIKE sy-tabix.  &quot;Anzahl Step-loop-Zeilen im Dynpro

* declarations for activating bc-sets                 &quot;UF profile
TYPES: BEGIN OF vim_pr_tab_type,
                recnumber LIKE scprvals-recnumber,
                action TYPE char1,
                keys_fix,                                   &quot;#EC NEEDED
                align TYPE f,
                keys(1024) TYPE x,
                txt_in_sy_langu_exsts TYPE xfeld,
                align2 TYPE f,
                textrecord TYPE vim_line_ul,
       END OF vim_pr_tab_type.
TYPES: BEGIN OF vim_pr_fields_type,
                recnumber LIKE scprvals-recnumber,
                keys_fix(1),
                fields TYPE vimty_fields_tab_type,
       END OF vim_pr_fields_type,
       vimsellist_type TYPE TABLE OF vimsellist,
       BEGIN OF  bc_key_type,   &quot;HCG like e072k but tabkey 255
          trkorr like e071k-trkorr,
          pgmid like e071k-pgmid,
          object like e071k-object,
          objname like e071k-objname,
          as4pos like e071k-as4pos,
          mastertype like e071k-mastertype,
          mastername like e071k-mastername,
          viewname like e071k-viewname,
          objfunc like e071k-objfunc,
          bc_tabkey like scpractr-tabkey,
          sortflag like e071k-sortflag,
          flag like e071k-flag,
          lang like e071k-lang,
          activity like e071k-activity,
       END OF bc_key_type,
       bc_keytab_type type table of bc_key_type,
* For managing entries coming from bc-sets
vim_bc_tab_logs type table of scpractr,
vim_bc_del_records type table of scprreca,
vim_bc_values_lang_type type table of scpr_vall.
DATA:  vim_pr_fields TYPE TABLE OF vim_pr_fields_type INITIAL SIZE 15,
       vim_pr_fields_wa TYPE vim_pr_fields_type,
       vim_coming_from_img,                                 &quot;#EC NEEDED &quot;&apos;Y&apos;: coming from IMG, &apos;N&apos;: not
       vim_pr_tab TYPE TABLE OF vim_pr_tab_type,
       vim_profile_values TYPE TABLE OF scpr_vals INITIAL SIZE 50,
       vim_bc_entry_list TYPE vimty_bc_entry_list_ttype,
       vim_bc_entry_list_wa TYPE vimty_bc_entry_list_type,
       vim_pr_activating, vim_bc_keys_fix(3),               &quot;#EC NEEDED
       vim_set_from_bc_pbo,
       vim_bc_chng_allowed TYPE xfeld, &quot;fix bc-set values modifiable
       vim_pr_records TYPE i.    &quot;number of activated profile records
DATA:  vim_actlinks TYPE vimdesc-viewname. &quot;View: actlinks are valid for
DATA:  vim_actopts TYPE scpractopt, &quot;Activation options at BC-SET import
       vim_bcset_id TYPE scpr_id.                        &quot;Name of BC-SET
* field attributes in profiles
CONSTANTS: vim_profile_fix(3)    VALUE &apos;FIX&apos;,
           vim_profile_fixkey(3) VALUE &apos;FKY&apos;,
           vim_profile_use(3)    VALUE &apos;USE&apos;,
           vim_profile_key(3)    VALUE &apos;KEY&apos;,
           vim_profile_usekey(3) VALUE &apos;UKY&apos;,                &quot;#EC NEEDED
           vim_profile_var(3)    VALUE &apos;VAR&apos;,               &quot;824950
* for flag KEYS_FIX
           vim_pr_error    VALUE &apos;E&apos;,                       &quot;key error
           vim_pr_open     VALUE &apos;O&apos;,  &quot;no key field fix
           vim_pr_some_fix VALUE &apos;S&apos;,                       &quot;some fix
           vim_pr_all_fix  VALUE &apos;A&apos;,  &quot;all key fields fix
* others
           vim_pr_into_view VALUE &apos;V&apos;,
           vim_profile_found VALUE &apos;X&apos;,
           vim_pr_imp_unchecked VALUE &apos;Y&apos;,
           vim_writing_bc_imp_log VALUE &apos;W&apos;.
DATA:      vim_pr_stat_txt_me LIKE smp_dyntxt,  &quot;dynamic texts for dynpro
           vim_pr_stat_txt_ch LIKE smp_dyntxt,
           vim_pr_stat_txt_ta LIKE smp_dyntxt,
           vim_pr_stat_txt_or LIKE smp_dyntxt.
* internal tables
DATA: vim_adj_header LIKE vimdesc OCCURS 1,
      vim_adj_namtab LIKE vimnamtab OCCURS 0,
      vim_adj_dbasellist LIKE vimsellist OCCURS 0.
DATA: vim_locked_addresses LIKE SORTED TABLE OF adrc-addrnumber
                           WITH UNIQUE KEY table_line
                           INITIAL SIZE 10
                           WITH HEADER LINE.

DATA: BEGIN OF vim_addresses_to_save OCCURS 10,
        viewname LIKE tvdir-tabname,
        addrnumber LIKE adrc-addrnumber,
        handle LIKE addr1_dia-handle,
      END OF vim_addresses_to_save.

DATA: BEGIN OF textpool_tab OCCURS 30.                       &quot;textpool
        INCLUDE STRUCTURE textpool.
DATA: END OF textpool_tab.

DATA: BEGIN OF exclude_tab OCCURS 10,   &quot;fields to exclude from repl
        field LIKE d021s-fnam,         &quot;functions (old version)
      END OF exclude_tab.

DATA: excl_rpl_tab TYPE vimexclfldtab  &quot;fields to exclude from repl
        WITH HEADER LINE,
      excl_que_tab TYPE vimexclfldtab  &quot;fields to exclude from query
        WITH HEADER LINE,
      excl_pos_tab TYPE vimexclfldtab  &quot;fields to exclude from posit
        WITH HEADER LINE,
      vim_excl_xxx_tab_safe TYPE vimexclfldtabs &quot;safe for all excl tabs
        WITH HEADER LINE.

DATA: BEGIN OF vim_corr_objtab OCCURS 10.       &quot;transport objects on the
        INCLUDE STRUCTURE e071.       &quot;vim-object level
DATA:   lockable(1) TYPE c,
      END OF vim_corr_objtab.

DATA: BEGIN OF vim_corr_entryobjtab OCCURS 10.  &quot;transport objects &quot;#EC NEEDED
        INCLUDE STRUCTURE ko200.       &quot;on the vim-obj-entries level
DATA:   lockable(1) TYPE c,
      END OF vim_corr_entryobjtab.

DATA: BEGIN OF e071k_tab OCCURS 100.    &quot;keys of changed entries
        INCLUDE STRUCTURE e071k.       &quot;(used as parameter for VIEWPROC)
DATA: END OF e071k_tab.

DATA: vim_alv_fcat TYPE slis_t_fieldcat_alv,  &quot;ABAP List Viewer
*      vim_alv_excluding TYPE slis_t_extab,
*      vim_alv_special_groups TYPE slis_t_sp_group_alv,
*      vim_alv_sort TYPE slis_t_sortinfo_alv,
*      vim_alv_sel_hide TYPE slis_sel_hide_alv,
      vim_alv_events TYPE slis_t_event,
*      vim_alv_event_exit TYPE slis_t_event_exit,
      vim_alv_print TYPE slis_print_alv,
      vim_alv_layout TYPE slis_layout_alv,
      vim_alv_variant LIKE disvariant,
      vim_var_save, vim_var_default, vim_alv_value_length TYPE intlen,
      vim_alv_called_by TYPE char30,
      alv_value_tab TYPE TABLE OF tabl8000 INITIAL SIZE 500.
*DATA: BEGIN OF alv_value_tab OCCURS 1,
*      line(4096),
*      END OF alv_value_tab.

DATA: align_value_tab TYPE f,                                       &quot;#EC NEEDED
      BEGIN OF value_tab OCCURS 1,     &quot;Printing with ALV ==&gt;
        line(4096),                                         &quot;
      END OF value_tab.                                      &quot;obsolete

DATA: BEGIN OF structure_table OCCURS 20.   &quot;Printing with ALV ==&gt;
        INCLUDE STRUCTURE dfies.                           &quot;
DATA: END OF structure_table.                               &quot;obsolete

DATA: vim_list_header TYPE slis_t_listheader. &quot;List header for ALV-list

DATA: vim_delim_entries TYPE STANDARD TABLE  &quot;indizes of delim. entries
        OF vim_delim_entr_tl WITH DEFAULT KEY INITIAL SIZE 10
        WITH HEADER LINE.

DATA: BEGIN OF vim_sval_tab OCCURS 1.  &quot;fields for POPUP_GET_VALUES
        INCLUDE STRUCTURE sval.
DATA: END OF vim_sval_tab.

DATA: vim_collapsed_mainkeys TYPE STANDARD TABLE  &quot;collapsed mainkeys
        OF vim_collapsed_mkeys_tl WITH DEFAULT KEY INITIAL SIZE 1
        WITH HEADER LINE.

DATA: vim_merged_entries TYPE STANDARD TABLE      &quot;merged entries
        OF vim_merged_entr_tl WITH DEFAULT KEY INITIAL SIZE 1
        WITH HEADER LINE.

DATA: BEGIN OF vim_copied_indices OCCURS 10,
        ix LIKE sy-tabix, ex_ix LIKE sy-tabix, level TYPE i,
      END OF vim_copied_indices.

DATA: vim_wheretab LIKE vimwheretb OCCURS 10,
      imp_results TYPE slctr_tables_keys WITH HEADER LINE.

* Datencontainer für Texttabelle in mehreren Sprachen     &quot;SW Texttransl
DATA: vim_texttab_container TYPE vim_tabdata_record OCCURS 0
      WITH HEADER LINE,  &quot;da &apos;read table .. assigning &lt;fs&gt;&apos; nicht unterst
      vim_texttab_container_index LIKE sy-tabix,
      vim_d0100_fdescr_ini TYPE vimty_screen_fdescr_tab.

RANGES: mark_functions FOR sy-ucomm,   &quot;fct. which need marked entries
        adrnbr_domain FOR sadr-adrnr,  &quot;domains for address numbers
        exted_functions FOR sy-ucomm,  &quot;fct. used by external edit
        vim_guid_domain FOR vimnamtab-domname,  &quot;domains for GUIDs
        vim_begda_types FOR dd03p-rollname,  &quot;types for time-dependence
        vim_endda_types FOR dd03p-rollname.  &quot;types for time-dependence

* constants for documentation &apos;User Instructions&apos;
CONSTANTS: vim_docu_prog LIKE iwreferenc-programm VALUE &apos;SAPLSVIM&apos;,
           vim_docu_extension LIKE iwreferenc-spec_text
                   VALUE &apos;SM30 USER INTERFACE&apos;.

* Konstanten für Dynpro
CONSTANTS: vim_template_dynpro TYPE x VALUE &apos;20&apos;,  &quot; Vorlagedynpro
           vim_standard_dynpro TYPE x VALUE &apos;C0&apos;.               &quot;#EC NEEDED
            &quot; Komprimierung ein

* Organisation criteria (linedependent authorisations)
DATA:  vim_oc_inst TYPE REF TO cl_viewfields_org_crit.

* Backup for DBA_SELLIST
DATA  vim_dba_sel_kept TYPE svorg_vimsellist_type.              &quot;#EC NEEDED

Data  addr_comp TYPE c.

DATA  vim_first_recnum TYPE scprvals-recnumber.

* Handling of GUID&apos;s while Copying in View Cluster.
DATA: vim_guid_copy TYPE C.

*Suppression of transport dialogs in view maintenance
DATA: vim_no_dialog_req TYPE sap_bool,
      vim_cts_messages  TYPE cts_messages.</include_source>
   </include>
   <include NAME="LSVIMF04" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;      Form  LOGS_ANALYSE
*&amp;---------------------------------------------------------------------*
*       Analyses table logs concerning the current maintenance view by
*       calling report RSVTPROT
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM logs_analyse.

  RANGES: sel_obj FOR objh-objectname,
          sel_type FOR objh-objecttype.

  sel_obj-sign = sel_type-sign = &apos;I&apos;.
  sel_obj-option = sel_type-option = &apos;EQ&apos;.
  IF vim_called_by_cluster NE space.
    sel_type-low = vim_clst.
    sel_obj-low = vim_calling_cluster.
  ELSE.
    sel_obj-low = x_header-viewname.
    IF x_header-bastab NE space
     AND x_header-maintview = x_header-viewname.
* table but no table-variant
      sel_type-low = vim_tabl.
    ELSE.
* view, view-variant, or table variant
      sel_type-low = vim_view.
    ENDIF.
  ENDIF.
  APPEND sel_obj. APPEND sel_type.
  SUBMIT rsvtprot VIA SELECTION-SCREEN USING SELECTION-SCREEN 1010
                  WITH cusobj IN sel_obj
                  WITH stype IN sel_type
                  WITH acc_arch = &apos; &apos; AND RETURN.
ENDFORM.                               &quot; LOGS_ANALYSE</include_source>
   </include>
   <include NAME="LSVIMF05" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM SHOW_FUNCTION_DOCU                                       *
*---------------------------------------------------------------------*
FORM SHOW_FUNCTION_DOCU.
  CALL FUNCTION &apos;IWB_HTML_HELP_OBJECT_SHOW&apos;
       EXPORTING
*         DEVCLASS                    =
*         TCODE                       =
            PROGRAM                     = VIM_DOCU_PROG
*         DYNPRONR                    =
            EXTENSION                   = VIM_DOCU_EXTENSION
*    IMPORTING
*         ACTION                      =
       EXCEPTIONS
            OBJECT_NOT_FOUND            = 1
            RFC_ERROR                   = 2
            NO_PROFIL_PARAMETER         = 3
            IMPORT_PARAMETER_IS_INVALID = 4
            OTHERS                      = 5.

* CALL FUNCTION &apos;DSYS_SHOW&apos;
*      EXPORTING
**          APPLICATION        = &apos;SO70&apos;
*           DOKCLASS           = &apos;WINH&apos;
**          DOKLANGU           = SY-LANGU
*           DOKNAME            = &apos;CATAB.HLP&apos;
*           DOKTITLE           = &apos; &apos;
*           HOMETEXT           = &apos; &apos;
*           OUTLINE            = &apos; &apos;
*           VIEWNAME           = &apos;STANDARD&apos;
*           Z_ORIGINAL_OUTLINE = &apos; &apos;
*           CALLED_FROM_SO70   = &apos; &apos;
*      IMPORTING
*           APPL               =
*           PF03               =
*           PF15               =
*           PF12               =
*      EXCEPTIONS
*           CLASS_UNKNOWN      = 1
*           OBJECT_NOT_FOUND   = 2
*           OTHERS             = 3.
  IF SY-SUBRC NE 0.
    MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF06" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM UPDATE_STATUS                                            *
*---------------------------------------------------------------------*
FORM UPDATE_STATUS.
  MOVE: STATUS-DATA TO &lt;STATUS&gt;-ST_DATA,
        STATUS-MODE TO &lt;STATUS&gt;-ST_MODE,
        STATUS-DELETE TO &lt;STATUS&gt;-ST_DELETE,
        STATUS-ACTION TO &lt;STATUS&gt;-ST_ACTION,
        TITLE         TO &lt;STATUS&gt;-TITLE,
*       L             TO &lt;STATUS&gt;-CUR_LINE,
        FIRSTLINE     TO &lt;STATUS&gt;-FIRSTLINE,
        MAXLINES      TO &lt;STATUS&gt;-MAXLINES,
        F             TO &lt;STATUS&gt;-CUR_FIELD,
        O             TO &lt;STATUS&gt;-CUR_OFFSET,
        MARK_EXTRACT  TO &lt;STATUS&gt;-MK_XT,
        MARK_TOTAL    TO &lt;STATUS&gt;-MK_TO,
        FUNCTION      TO &lt;STATUS&gt;-FCODE.
  IF L EQ 0.
    MOVE 1 TO &lt;STATUS&gt;-CUR_LINE.
  ELSE.
    MOVE L TO &lt;STATUS&gt;-CUR_LINE.
  ENDIF.
ENDFORM.                               &quot;UPDATE_STATUS</include_source>
   </include>
   <include NAME="LSVIMF07" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_SINGLE_ENTRY_FILL_SELLIST                            *
*---------------------------------------------------------------------*
* fill sellist in case of single entry maintenance                    *
*---------------------------------------------------------------------*
FORM vim_single_entry_fill_sellist.
  DATA: countx TYPE i, nam_ix TYPE i.
  FIELD-SYMBOLS: &lt;h1&gt;.

  LOOP AT x_namtab WHERE keyflag NE space AND texttabfld EQ space.
    CHECK x_header-clidep EQ space OR sy-tabix GT 1.
    nam_ix = sy-tabix.
    assign component x_namtab-viewfield of structure &lt;table1&gt; to &lt;h1&gt;.
*    ASSIGN &lt;TABLE1&gt;+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH) TO &lt;H1&gt;.
    READ TABLE dpl_sellist WITH KEY viewfield = x_namtab-viewfield
                                    operator  = &apos;EQ&apos;
                                    negation  = space.
    IF sy-subrc NE 0.
      CLEAR dpl_sellist.
      dpl_sellist-viewfield = x_namtab-viewfield.
      dpl_sellist-operator  = &apos;EQ&apos;.
      dpl_sellist-and_or    = &apos;AND&apos;.
      dpl_sellist-tabix     = nam_ix.
      APPEND dpl_sellist.
    ENDIF.
    countx = sy-tabix. CLEAR dpl_sellist-converted.
    dpl_sellist-ddic = &apos;S&apos;. CLEAR dpl_sellist-value.
    CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
         EXPORTING
              value_intern = &lt;h1&gt;
              tabname      = x_header-maintview
              fieldname    = x_namtab-viewfield
*              inttype      = x_namtab-inttype
*              datatype     = x_namtab-datatype
*              decimals     = x_namtab-decimals
*              convexit     = x_namtab-convexit
*              sign         = x_namtab-sign
              outputlen    = x_namtab-outputlen
              intlen       = x_namtab-flength
         IMPORTING
              value_extern = dpl_sellist-value.
    IF dpl_sellist-value EQ space.
      dpl_sellist-initial = &apos;X&apos;.
    ELSE.
      CLEAR dpl_sellist-initial.
    ENDIF.
    MODIFY dpl_sellist INDEX countx.
    x_namtab-readonly = &apos;S&apos;. MODIFY x_namtab.
  ENDLOOP.
  ASSIGN dpl_sellist[] TO &lt;vim_ck_sellist&gt;.
  x_header-subsetflag = x_header-selection = &apos;X&apos;.
  MODIFY x_header INDEX 1.
  PERFORM init_subset_keyfields.
ENDFORM.                               &quot;vim_single_entry_fill_sellist</include_source>
   </include>
   <include NAME="LSVIMF08" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_SET_IMP_RESULTS                                      *
*---------------------------------------------------------------------*
* (re)set result of import for current entry                          *
*---------------------------------------------------------------------*
* VALUE(VSIR_KEY)    ---&gt; key of current entry                        *
* VALUE(VSIR_ACTION) ---&gt; action happened to current entry            *
*                         - GELOESCHT OR UPDATE_GELOESCHT -&gt; deleted  *
*                         - AENDERN                       -&gt; updated  *
*                         - NEUER_EINTRAG                 -&gt; inserted *
*                         - ORIGINAL                      -&gt; unchanged*
*                         - SLCTR_IMP_ERROR               -&gt; error    *
*---------------------------------------------------------------------*
FORM vim_set_imp_results USING value(vsir_key)
                               value(vsir_action) LIKE tvdir-flag.
  DATA: vsir_xkey TYPE vim_tabkey_c, vsir_xkeylen TYPE i,
        vsir_rc TYPE i,
        vsir_ix TYPE i.

  PERFORM vim_set_impres_header.
  PERFORM vim_convert_tabkey USING vsir_key vsir_xkey vsir_xkeylen.
  imp_results-tabkey = vsir_xkey.
  READ TABLE imp_results WITH KEY objtab = imp_results-objtab
                                  tabkey = imp_results-tabkey.
  vsir_rc = sy-subrc. vsir_ix = sy-tabix.
  CLEAR imp_results-import.
  CASE vsir_action.
    WHEN geloescht OR update_geloescht.
      imp_results-import-deleted = 1.
    WHEN aendern.
      imp_results-import-updated = 1.
    WHEN neuer_eintrag.
      imp_results-import-inserted = 1.
    WHEN original.
      imp_results-import-unchanged = 1.
    WHEN OTHERS.
      imp_results-import-errors = 1.
  ENDCASE.
  IF vsir_rc NE 0.
    APPEND imp_results.
  ELSE.
    MODIFY imp_results INDEX vsir_ix.
  ENDIF.
ENDFORM.                               &quot;vim_set_imp_reults</include_source>
   </include>
   <include NAME="LSVIMF09" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_PROCESS_MESSAGE                                      *
*---------------------------------------------------------------------*
* process message depending on dialog mode                            *
*---------------------------------------------------------------------*
* VALUE(PM_ID)          ---&gt; ID of message to send                    *
* VALUE(PM_ONLINE_TYPE) ---&gt; message type used for online mode        *
* VALUE(PM_BATCH_TYPE)  ---&gt; message type used for batch mode         *
* VALUE(PM_NBR)         ---&gt; number of message to send                *
* VALUE(PM_V1)          ---&gt; first mesage variable                    *
* VALUE(PM_V2)          ---&gt; second mesage variable                   *
* VALUE(PM_V3)          ---&gt; third mesage variable                    *
* VALUE(PM_V4)          ---&gt; fourth mesage variable                   *
*---------------------------------------------------------------------*
FORM VIM_PROCESS_MESSAGE USING VALUE(PM_ID) LIKE SY-MSGID
                           VALUE(PM_ONLINE_TYPE) LIKE SY-MSGTY
                           VALUE(PM_BATCH_TYPE) LIKE SY-MSGTY
                           VALUE(PM_NBR)  LIKE SY-MSGNO
                           VALUE(PM_V1) LIKE SY-MSGV1
                           VALUE(PM_V2) LIKE SY-MSGV2
                           VALUE(PM_V3) LIKE SY-MSGV3
                           VALUE(PM_V4) LIKE SY-MSGV4.

  DATA: I_TYPE LIKE SPROT_U-SEVERITY, I_MSGTY LIKE SY-MSGTY,
        I_MSGNO LIKE SY-MSGNO,
        objtype TYPE ob_typ, objname TYPE ob_object.

  IF VIM_NO_DIALOG NE SPACE.           &quot;no dialog - write protocol
    I_TYPE = I_MSGTY = PM_BATCH_TYPE. I_MSGNO = PM_NBR.
    IF VIM_IMPORT_PROFILE = &apos;X&apos;.        &quot;Profilimport
      IF vim_called_by_cluster NE &apos;X&apos;.
         objname = VIM_VIEW_NAME.
        IF x_header-bastab EQ space.
        objtype = &apos;V&apos;.
      ELSE.
        objtype = &apos;S&apos;.
      ENDIF.
      ELSE.
        objname = vim_calling_cluster.
        objtype = &apos;C&apos;.
      ENDIF.
      CALL FUNCTION &apos;SCPR_PROT_DATA_WRITE&apos;
          EXPORTING
            act_id           = VIM_ACTOPTS-ACT_ID
            bcset_id         = VIM_BCSET_ID
            objectname       = objname
*           tablename        = object
*           tabletype        = tabtype
            tablekey         = VIM_PROFILE_ERRORKEY
            msgid            = PM_ID
            msgty            = I_TYPE
            msgno            = I_MSGNO
            var1             = PM_V1
            var2             = PM_V2
            var3             = PM_V3
            var4             = PM_V4
            objecttype       = objtype.
    ELSE.
      TRANSLATE I_TYPE USING &apos;I S &apos;.
      CALL FUNCTION &apos;LCT_MESSAGE&apos;
         EXPORTING
              IV_MSGID  = PM_ID
              IV_MSGTY  = I_TYPE
              IV_MSGNO  = I_MSGNO
              IV_MSGV1  = PM_V1
              IV_MSGV2  = PM_V2
              IV_MSGV3  = PM_V3
              IV_MSGV4  = PM_V4
              IV_DIALOG = SPACE.
    ENDIF.
    VIM_LAST_LOGGED_MESSAGE-ID = PM_ID.
    VIM_LAST_LOGGED_MESSAGE-TYPE = I_MSGTY.
    VIM_LAST_LOGGED_MESSAGE-NBR = PM_NBR.
    VIM_LAST_LOGGED_MESSAGE-V1 = PM_V1.
    VIM_LAST_LOGGED_MESSAGE-V2 = PM_V2.
    VIM_LAST_LOGGED_MESSAGE-V3 = PM_V3.
    VIM_LAST_LOGGED_MESSAGE-V4 = PM_V4.
    IF VIM_IMPORT_NO_MESSAGE EQ SPACE.
      MESSAGE ID PM_ID TYPE I_MSGTY NUMBER PM_NBR &quot;to raise exception
                WITH PM_V1 PM_V2 PM_V3 PM_V4.
    ENDIF.
  ELSE.                                &quot;with dialog - use pm_online_type
    I_MSGTY = PM_ONLINE_TYPE.
    MESSAGE ID PM_ID TYPE I_MSGTY NUMBER PM_NBR
              WITH PM_V1 PM_V2 PM_V3 PM_V4.
  ENDIF.                               &quot;vim_no_dialog eq space
ENDFORM.                               &quot;vim_process_message
*---------------------------------------------------------------------*
*       FORM VIM_BC_PROCESS_MESSAGE
*
*---------------------------------------------------------------------*
* process message depending on dialog mode                            *
*---------------------------------------------------------------------*
* VALUE(PM_ID)          ---&gt; ID of message to send                    *
* VALUE(PM_ONLINE_TYPE) ---&gt; message type used for online mode        *
* VALUE(PM_BATCH_TYPE)  ---&gt; message type used for batch mode         *
* VALUE(PM_NBR)         ---&gt; number of message to send                *
* VALUE(PM_V1)          ---&gt; first mesage variable                    *
* VALUE(PM_V2)          ---&gt; second mesage variable                   *
* VALUE(PM_V3)          ---&gt; third mesage variable                    *
* VALUE(PM_V4)          ---&gt; fourth mesage variable                   *
*---------------------------------------------------------------------*
FORM vim_bc_process_message USING value(pm_id) LIKE sy-msgid
                           value(pm_online_type) LIKE sy-msgty        &quot;#EC NEEDED
                           value(pm_batch_type) LIKE sy-msgty
                           value(pm_nbr)  LIKE sy-msgno
                           value(pm_v1) LIKE sy-msgv1
                           value(pm_v2) LIKE sy-msgv2
                           value(pm_v3) LIKE sy-msgv3
                           value(pm_v4) LIKE sy-msgv4
                           value(objtype) TYPE ob_typ.

  DATA: i_type LIKE sprot_u-severity, i_msgty LIKE sy-msgty,
        i_msgno LIKE sy-msgno.

  i_type = i_msgty = pm_batch_type. i_msgno = pm_nbr.

  CALL FUNCTION &apos;SCPR_PROT_DATA_WRITE&apos;
      EXPORTING
        act_id           = vim_actopts-act_id
        bcset_id         = vim_bcset_id
        objectname       = vim_view_name
*       tablename        = object
*       tabletype        = tabtype
        tablekey         = vim_profile_errorkey
        msgid            = pm_id
        msgty            = i_type
        msgno            = i_msgno
        var1             = pm_v1
        var2             = pm_v2
        var3             = pm_v3
        var4             = pm_v4
        objecttype       = objtype.
  vim_last_logged_message-id = pm_id.
  vim_last_logged_message-type = i_msgty.
  vim_last_logged_message-nbr = pm_nbr.
  vim_last_logged_message-v1 = pm_v1.
  vim_last_logged_message-v2 = pm_v2.
  vim_last_logged_message-v3 = pm_v3.
  vim_last_logged_message-v4 = pm_v4.
  IF vim_import_no_message EQ space.
    MESSAGE ID pm_id TYPE i_msgty NUMBER pm_nbr &quot;to raise exception
              WITH pm_v1 pm_v2 pm_v3 pm_v4.
  ENDIF.
ENDFORM.                               &quot;vim_bc_process_message</include_source>
   </include>
   <include NAME="LSVIMF0A" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM X_REFRESH_TCTRL                                          *
*---------------------------------------------------------------------*
* refresh table control (external call)                               *
*---------------------------------------------------------------------*
* VALUE(XE_NAME)   ---&gt; name of view/table to process                 *
* VALUE(XE_SCREEN) ---&gt; screen to refresh from                        *
*---------------------------------------------------------------------*
FORM X_REFRESH_TCTRL USING VALUE(XRT_NAME) LIKE VIMDESC-VIEWNAME
                           VALUE(XRT_SCREEN) LIKE VIMDESC-LISTE.
  DATA: XRT_CONTROL_NAME(16) TYPE C VALUE &apos;TCTRL_&apos;.

  XRT_CONTROL_NAME+6 = XRT_NAME.
  REFRESH CONTROL XRT_CONTROL_NAME FROM SCREEN XRT_SCREEN.
ENDFORM.                               &quot;x_refresh_tctrl</include_source>
   </include>
   <include NAME="LSVIMF0B" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  CHECK_MODIFY_MERGED_ENTRIES                             *
*&amp;--------------------------------------------------------------------*
* check if changed entry is to be merged and if so do it
* merging functionality has never been finished                       *
*&amp;--------------------------------------------------------------------*
* &lt;-- SY-SUBRC: 0 - ok, merge, others: don&apos;t merge                    *
*&amp;--------------------------------------------------------------------*
*FORM CHECK_MODIFY_MERGED_ENTRIES USING VALUE(ENTRY_IN).
*  LOCAL: TOTAL, &lt;TABLE1&gt;.
*  DATA: REC TYPE I VALUE 8.
*  &lt;F1&gt; = ENTRY_IN. &lt;VIM_ENDDATE_MASK&gt; = VIM_DATE_MASK.
*  LOOP AT VIM_MERGED_ENTRIES WHERE NEW_KEY CP &lt;F1&gt;. &quot;Achtung !!!!!!
*    READ TABLE TOTAL WITH KEY VIM_MERGED_ENTRIES-MERGED_KEY
*                     BINARY SEARCH.
*    IF SY-SUBRC EQ 0.
*      &lt;TABLE1&gt; = TOTAL.
*      &lt;VIM_BEGDATE_MASK&gt; = VIM_DATE_MASK.
*      &lt;VIM_ENDDATE_MASK&gt; = VIM_DATE_MASK.
*      IF ENTRY_IN CP &lt;TABLE1&gt;. &quot;entry can be merged. &quot;ACHTUNG!!
*        CLEAR REC.
*        TOTAL = ENTRY_IN.
*        VIM_MERGED_ENTRIES-MERGED_KEY = &lt;VIM_TOTAL_KEY&gt;.
*
*
*
*
*      ENDIF.
*    ENDIF.
*  ENDLOOP.
*ENDFORM.                               &quot;check_modify_merged_entries</include_source>
   </include>
   <include NAME="LSVIMF0C" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  DELETE_FROM_MAINKEY_TAB                                 *
*&amp;--------------------------------------------------------------------*
* delete entry from mainkey_tab.                                      *
*&amp;--------------------------------------------------------------------*
FORM delete_from_mainkey_tab.
  LOOP AT vim_collapsed_mainkeys.
    CHECK &lt;vim_h_coll_mkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
*  LOOP AT VIM_COLLAPSED_MAINKEYS WHERE MAINKEY EQ &lt;F1&gt;.
    DELETE vim_collapsed_mainkeys.
  ENDLOOP.
ENDFORM.                               &quot;delete_from_mainkey_tab</include_source>
   </include>
   <include NAME="LSVIMF0D" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BUILD_MAINKEY_TAB_2                                     *
*&amp;--------------------------------------------------------------------*
* build mainkey tab for display modification - part two               *
*&amp;--------------------------------------------------------------------*
FORM BUILD_MAINKEY_TAB_2.
  APPEND VIM_COLLAPSED_MAINKEYS.
  MOVE: X_HEADER-VIEWNAME TO VIM_MEMORY_ID_1-VIEWNAME,
        SY-UNAME          TO VIM_MEMORY_ID_1-USER.
  EXPORT VIM_COLLAPSED_MAINKEYS TO MEMORY ID VIM_MEMORY_ID_1.
ENDFORM.                               &quot;build_mainkey_tab_2</include_source>
   </include>
   <include NAME="LSVIMF0G" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BUILD_MAINKEY_TAB_1                                     *
*&amp;--------------------------------------------------------------------*
* build mainkey tab for display modification - part one               *
* merge identical entries for same mainkey into one entry
* assumptions: TOTAL is sorted ascending by &lt;VIM_TOTAL_KEY&gt;
*              Now, with unicode: sorted by &lt;VIM_TOTAL_KEYX&gt;
*&amp;--------------------------------------------------------------------*
FORM build_mainkey_tab_1.
  DATA: date_safe TYPE d, date_safe_1 TYPE d, date_safe_2 TYPE d,
        date_safe_3 TYPE d.

  date_safe = &lt;vim_begdate&gt;.           &quot;TOTAL
  date_safe_1 = &lt;vim_enddate&gt;.         &quot;TOTAL
  date_safe_2 = &lt;vim_new_begdate&gt;.                          &quot;&lt;TABLE1&gt;
  date_safe_3 = &lt;vim_enddate_mask&gt;.                         &quot;&lt;TABLE1&gt;
  &lt;vim_begdate&gt; = &lt;vim_enddate&gt; = &lt;vim_new_begdate&gt; =
                  &lt;vim_enddate_mask&gt; = &apos;99999999&apos;.
  IF &lt;vim_xtotal&gt; NE &lt;table1_x&gt;.
    MOVE: date_safe   TO &lt;vim_begdate&gt;,
          date_safe_1 TO &lt;vim_enddate&gt;,
          date_safe_2 TO &lt;vim_new_begdate&gt;,
          date_safe_3 TO &lt;vim_enddate_mask&gt;.
    IF vim_no_mainkey_exists EQ vim_no_mkey_not_procsd OR
       &lt;vim_tot_mkey_beforex&gt; NE &lt;vim_f1_beforex&gt;.
*       &lt;vim_tot_mkey_before&gt; NE &lt;vim_f1_before&gt; OR
*       ( vim_mkey_after_exists NE space AND
*         &lt;vim_tot_mkey_after&gt; NE &lt;vim_f1_after&gt; ).
      IF vim_coll_mkeys_first EQ space.
        APPEND vim_collapsed_mainkeys.
        CLEAR vim_collapsed_mainkeys-log_key.
      ELSE.
        CLEAR vim_coll_mkeys_first.
      ENDIF.
      &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
      &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*      vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
*      vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
* If the position &lt;= 0, the &lt;vim_collapsed_mkey_bfx&gt; shouldn&apos;t be
* assigned. XB am 27.03.2002 CSN int1332679 2002
    ELSEIF vim_mkey_after_exists NE space AND
         &lt;vim_tot_mkey_afterx&gt; NE &lt;vim_f1_afterx&gt;.
      IF vim_coll_mkeys_first EQ space.
        APPEND vim_collapsed_mainkeys.
        CLEAR vim_collapsed_mainkeys-log_key.
      ELSE.
        CLEAR vim_coll_mkeys_first.
      ENDIF.
      &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
*      &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*      vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
*      vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
    ELSE.
      IF x_header-delmdtflag EQ &apos;E&apos; AND &lt;vim_begdate&gt; LE sy-datum AND
       &lt;vim_enddate&gt; GE sy-datum OR x_header-delmdtflag EQ &apos;B&apos; AND
       &lt;vim_begdate&gt; GE sy-datum AND &lt;vim_enddate&gt; LE sy-datum.
        &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
* change xb 12.06.02 begin--------------------------------------------
        if &lt;vim_collapsed_mkey_bfx&gt; NE &lt;vim_tot_mkey_beforex&gt;.
          &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
        endif.
* change xb 12.06.02 ***********************************************
*        vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
*        vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
      ENDIF.
    ENDIF.
* end correction XB am 27.03.2002 CSN int1332679 2002
    &lt;table1_x&gt; = &lt;vim_xtotal&gt;.
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_procsd_patt.
  ELSE.
    MOVE: date_safe   TO &lt;vim_begdate&gt;,
          date_safe_1 TO &lt;vim_enddate&gt;,
          date_safe_2 TO &lt;vim_new_begdate&gt;,
          date_safe_3 TO &lt;vim_enddate_mask&gt;.
    IF x_header-delmdtflag EQ &apos;E&apos; AND &lt;vim_begdate&gt; LE sy-datum AND
      &lt;vim_enddate&gt; GE sy-datum OR x_header-delmdtflag EQ &apos;B&apos; AND
      &lt;vim_begdate&gt; GE sy-datum AND &lt;vim_enddate&gt; LE sy-datum.
      &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
* change xb 12.06.02 begin--------------------------------------------
      if &lt;vim_collapsed_mkey_bfx&gt; NE &lt;vim_tot_mkey_beforex&gt;.
        &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
      endif.
* change xb 12.06.02 ***********************************************

*      vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
*      vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
    ENDIF.
  ENDIF.

ENDFORM.                               &quot;build_mainkey_tab_1</include_source>
   </include>
   <include NAME="LSVIMF0H" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BUILD_MAINKEY_TAB_0                                     *
*&amp;--------------------------------------------------------------------*
* build mainkey tab for display modification - part one               *
*&amp;--------------------------------------------------------------------*
FORM BUILD_MAINKEY_TAB_0.
  CLEAR: VIM_MAINKEY, VIM_MERGED_ENTRIES, VIM_COLLAPSED_MAINKEYS,
         &lt;TABLE1&gt;, VIM_MERGE_BEGIN, VIM_MERGE_END.
  TRANSLATE VIM_NO_MAINKEY_EXISTS USING VIM_NO_MKEY_NOT_PROCSD_PATT.
  REFRESH: VIM_COLLAPSED_MAINKEYS,
           VIM_MERGED_ENTRIES.
  VIM_COLL_MKEYS_FIRST = &apos;X&apos;.
ENDFORM.                               &quot;build_mainkey_tab_0</include_source>
   </include>
   <include NAME="LSVIMF0I" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BUILD_MAINKEY_TAB                                       *
*&amp;--------------------------------------------------------------------*
* build mainkey tab for display modification - all parts              *
*&amp;--------------------------------------------------------------------*
FORM BUILD_MAINKEY_TAB.
  PERFORM BUILD_MAINKEY_TAB_0.
  LOOP AT TOTAL.
    PERFORM BUILD_MAINKEY_TAB_1.
  ENDLOOP.
  PERFORM BUILD_MAINKEY_TAB_2.
ENDFORM.                               &quot;build_mainkey_tab</include_source>
   </include>
   <include NAME="LSVIMF0J" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      FORM COLLAPSE                                                 *
*&amp;--------------------------------------------------------------------*
* collapse                                                            *
*&amp;--------------------------------------------------------------------*
FORM collapse USING value(c_begin_ix) TYPE i value(c_end_ix) TYPE i.
  LOCAL: extract.
  DATA: first(1) TYPE c VALUE &apos;X&apos;, hf_ind TYPE i, hf_ind2 TYPE i,
        act_ix TYPE i.

  LOOP AT total.
    act_ix = sy-tabix.
    PERFORM select USING &lt;status&gt;-selected.
    CHECK sy-subrc EQ 0.
    CHECK &lt;vim_tot_mkey_beforeX&gt; EQ &lt;vim_mkey_beforeX&gt; AND
          ( vim_mkey_after_exists EQ space OR
            &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*    CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*          ( vim_mkey_after_exists EQ space OR
*            &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
    IF first NE space.
* Changed from XB. 12.06.02 BCEK060520/BCEK060521
      &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
*      vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
      if &lt;vim_collapsed_mkey_bfx&gt; ne &lt;vim_tot_mkey_beforex&gt;.
        &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*      vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
      endif.
      hf_ind = act_ix.
      CLEAR first.
    ENDIF.
* Changed from XB. 12.06.02 End.

    IF x_header-delmdtflag EQ &apos;E&apos;.
      CHECK &lt;vim_begdate&gt; LE sy-datum AND
            &lt;vim_enddate&gt; GE sy-datum.
    ELSE.
      CHECK &lt;vim_begdate&gt; GE sy-datum AND
            &lt;vim_enddate&gt; LE sy-datum.
    ENDIF.
    &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
* changed from Xue. End.
    if &lt;vim_collapsed_mkey_bfx&gt; ne &lt;vim_tot_mkey_beforex&gt;.
      &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
    endif.
*    vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
*    &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*    vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.

* Change from Xue. End.
    hf_ind = act_ix.
    EXIT.
  ENDLOOP.
  READ TABLE vim_collapsed_mainkeys                         &quot;#EC WARNOK
                                with key &lt;vim_collapsed_keyx&gt;
*                                WITH KEY vim_collapsed_mainkeys-mainkey
                                BINARY SEARCH
                                TRANSPORTING NO FIELDS.
  INSERT vim_collapsed_mainkeys INDEX sy-tabix.
  vim_delim_entries-index1 = hf_ind.
  vim_delim_entries-index2 = c_begin_ix.
  vim_delim_entries-index3 = c_begin_ix.
  vim_delim_entries-index_corr = &apos;X&apos;.
  APPEND vim_delim_entries.
  hf_ind2 = c_begin_ix + 1.
  CLEAR vim_delim_entries.
  LOOP AT extract FROM hf_ind2 TO c_end_ix.
    vim_delim_entries-index3 = sy-tabix.
    APPEND vim_delim_entries.
  ENDLOOP.
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
ENDFORM.                               &quot;collapse</include_source>
   </include>
   <include NAME="LSVIMF0K" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  TIME_DEPENDENT_DISPLAY_MODIF.                           *
*&amp;--------------------------------------------------------------------*
* process display modification (collapse/expand)                      *
*&amp;--------------------------------------------------------------------*
FORM time_dependent_display_modif.
  DATA: ex_ix TYPE i, modif_mode(1) TYPE c, first(1) TYPE c,   &quot;#EC NEEDED
        ex_begin TYPE i, ex_end TYPE i, key_safe TYPE vrsdat1000,
        to_ix TYPE i, rc like sy-subrc.
  READ TABLE extract INDEX nextline.
  key_safe = &lt;vim_xextract_key&gt;.
  CLEAR vim_mainkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  LOOP AT extract.
    ex_ix = sy-tabix.
    IF vim_no_mainkey_exists EQ vim_no_mkey_not_procsd OR
       &lt;vim_ext_mkey_beforex&gt; NE &lt;vim_mkey_beforex&gt; OR
       ( vim_mkey_after_exists NE space AND
         &lt;vim_ext_mkey_afterx&gt; NE &lt;vim_mkey_afterx&gt; ).
*       &lt;vim_ext_mkey_before&gt; NE &lt;vim_mkey_before&gt; OR
*       ( vim_mkey_after_exists NE space AND
*         &lt;vim_ext_mkey_after&gt; NE &lt;vim_mkey_after&gt; ).
      ex_end = sy-tabix - 1.
      IF modif_mode EQ &apos;C&apos;.
        PERFORM collapse USING ex_begin ex_end.
        modif_mode = &apos;X&apos;.
      ENDIF.                           &quot;modif_mode eq collapse
      ex_begin = ex_ix.
      &lt;vim_h_mkey&gt; = &lt;vim_xextract_key&gt;.
*      vim_mainkey = &lt;vim_extract_key&gt;.
      TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_procsd_patt.
    ENDIF.                             &quot;new mainkey in extract.
    CHECK &lt;xmark&gt; EQ markiert.
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
    &lt;mark&gt; = nicht_markiert. SUBTRACT 1 FROM mark_total.
    MODIFY total INDEX sy-tabix.
    SUBTRACT 1 FROM mark_extract.
    IF modif_mode CO &apos; X&apos;.
      rc = 4.
      LOOP AT vim_collapsed_mainkeys.
        check &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_mkey_beforex&gt;.
*      WHERE mkey_bf EQ &lt;vim_mkey_before&gt;.
        IF vim_mkey_after_exists NE space.
          CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_mkey_afterx&gt;.
        ENDIF.
        DELETE vim_collapsed_mainkeys.
        clear rc.
        EXIT.
      ENDLOOP.
      IF rc EQ 0.
* entry in collapsed mode -&gt; expand
        modif_mode = &apos;E&apos;.
      ELSE.
* entry in expanded mode -&gt; collapse
        modif_mode = &apos;C&apos;.
      ENDIF.
    ENDIF.
    IF modif_mode = &apos;E&apos;.
      CLEAR vim_delim_entries.
      vim_delim_entries-index3 = ex_ix.
      APPEND vim_delim_entries.
      CLEAR vim_delim_entries-index3.
      vim_delim_entries-index_corr = &apos;X&apos;.
      LOOP AT total.
        CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
              ( vim_mkey_after_exists EQ space OR
                &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*        CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*              ( vim_mkey_after_exists EQ space OR
*                &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
        to_ix = sy-tabix.
        PERFORM select USING &lt;status&gt;-selected.
        CHECK sy-subrc EQ 0.
        vim_delim_entries-index1 = to_ix.
        vim_delim_entries-index2 = ex_ix.
        APPEND vim_delim_entries.
      ENDLOOP.
      modif_mode = &apos;X&apos;.
    ENDIF.
  ENDLOOP.
  IF modif_mode EQ &apos;C&apos;.
    CLEAR vim_delim_entries.
    PERFORM collapse USING ex_begin maxlines.
  ENDIF.
  PERFORM after_temporal_delimitation.
  &lt;vim_xextract_key&gt; = key_safe.
  READ TABLE extract WITH KEY &lt;vim_ext_mkey_beforex&gt;.       &quot;#EC WARNOK
*  READ TABLE extract WITH KEY &lt;vim_ext_mkey_before&gt;.
  IF sy-subrc EQ 0.
    nextline = sy-tabix.
  ELSE.
    nextline = 1.
  ENDIF.
* ENDIF.
ENDFORM.                               &quot;time_dependent_display_modif</include_source>
   </include>
   <include NAME="LSVIMF0L" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form DELIMITATION                                             *
*&amp;--------------------------------------------------------------------*
* process temporal delimitation of marked EXTRACT entries             *
*&amp;--------------------------------------------------------------------*
FORM DELIMITATION.
  LOCAL: &lt;TABLE1&gt;, &lt;TABLE1_TEXT&gt;.
  DATA: D_RC(1) TYPE C.
* request date to delimit
  CALL FUNCTION &apos;POPUP_GET_VALUES&apos;
       EXPORTING
            POPUP_TITLE     = SVIM_TEXT_036
            START_COLUMN    = &apos;10&apos;
            START_ROW       = &apos;10&apos;
       IMPORTING
            RETURNCODE      = D_RC
       TABLES
            FIELDS          = VIM_SVAL_TAB
       EXCEPTIONS
            ERROR_IN_FIELDS = 01.
  IF SY-SUBRC NE 0. RAISE GET_VALUES_ERROR. ENDIF.          &quot;#EC FB_RAIS_EX
  CHECK D_RC NE &apos;A&apos;.
  READ TABLE VIM_SVAL_TAB INDEX 1.
  VIM_SPECIAL_MODE = VIM_DELIMIT.
  CLEAR: COUNTER, VIM_OLD_VIEWKEY.
  TRANSLATE VIM_NO_MAINKEY_EXISTS USING VIM_NO_MKEY_NOT_PROCSD_PATT.

* Event 28 AFter Entering Delimitation Date                   &quot;CG 7/2001
  if x_header-frm_af_edd NE SPACE.
    PERFORM (x_header-frm_af_edd) IN PROGRAM (x_header-fpoolname).
  endif.

  PERFORM KOPIERE.
  IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE.
    REFRESH VIM_DELIM_ENTRIES. CLEAR TEMPORAL_DELIMITATION_HAPPENED.
  ENDIF.
  CLEAR: VIM_SPECIAL_MODE.
ENDFORM.                               &quot;delimitation</include_source>
   </include>
   <include NAME="LSVIMF0M" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form CONSISTENCY_PRT_FRKY_FIELDS                              *
*&amp;--------------------------------------------------------------------*
* make sure, that part. forkey table fields are consistent            *
*&amp;--------------------------------------------------------------------*
FORM consistency_prt_frky_fields
                               USING value(cpff_alert) LIKE tvdir-flag.
  DATA:  prtfky_field_changed(1) TYPE c, cur_mkey_found(1) TYPE c,
         count TYPE i, offs TYPE i,                                        &quot;#EC NEEDED
         formname(19) TYPE c VALUE &apos;FILL_TEXTTAB_KEY_UC&apos;.
  FIELD-SYMBOLS: &lt;dummy1&gt;.
  LOCAL: total, extract.

  CHECK status-action NE anzeigen.
  CHECK &lt;status&gt;-upd_flag NE space.
  MOVE: &lt;f1_x&gt; TO &lt;vim_xtotal_key&gt;,
        vim_date_mask TO &lt;vim_enddate_mask&gt;,
        &lt;f1_x&gt; TO &lt;vim_h_mkey&gt;,
*        &lt;f1&gt; TO &lt;vim_mainkey_mask&gt;,
        &lt;vim_xtotal_key&gt; TO &lt;f1_x&gt;.
*  vim_mainkey = &lt;f1&gt;.
  IF x_header-selection EQ space.
    LOOP AT total.
      CHECK &lt;vim_xtotal_key&gt; NE &lt;f1_x&gt; AND
            &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
            ( vim_mkey_after_exists EQ space OR
              &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*      CHECK &lt;vim_total_key&gt; NE &lt;f1&gt; AND
*            &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*            ( vim_mkey_after_exists EQ space OR
*              &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
      MOVE 99 TO count.
      EXIT.
    ENDLOOP.
  ELSE.
    MOVE 99 TO count.
  ENDIF.
  IF count EQ 99. &quot;other entries for mainkey (may be) exist
* selections exist or
* prüfen: wurden Texte verändert ?????
* falls aktueller Text leer und hinzufügen --&gt; text aus Extract nehmen
    IF vim_prtfky_assigned CO &apos; Y&apos;.
* partial foreign key not assigned or VIM_PROCESS_ASSIGNS already
* processed
      CLEAR count.
      LOOP AT x_namtab WHERE prtfrkyfld NE space.
        CHECK x_namtab-readonly EQ space.
        IF vim_prtfky_assigned EQ space.
          IF x_header-bastab EQ space             &quot;view
           OR x_header-texttbexst EQ space        &quot;no texttable
           OR x_namtab-texttabfld EQ space.       &quot;no texttabfield
* not a texttablefield in a table &amp; texttable
            ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
*            ASSIGN &lt;table1&gt;+x_namtab-position(x_namtab-flength)
                    TO &lt;vim_prtfky_wa&gt;.
          ELSE.
            ASSIGN: COMPONENT x_namtab-viewfield
                     OF STRUCTURE &lt;table1_text&gt;
*            offs = x_namtab-position - x_header-tablen.
*            ASSIGN &lt;table1_text&gt;+offs(x_namtab-flength)
                     TO &lt;vim_prtfky_wa&gt;.
          ENDIF.
        ENDIF.
        IF x_header-bastab EQ space               &quot;view
           OR x_header-texttbexst EQ space        &quot;no texttable
           OR x_namtab-texttabfld EQ space.       &quot;no texttabfield
          ASSIGN: COMPONENT x_namtab-viewfield
                   OF STRUCTURE &lt;vim_total_struc&gt;
                   TO &lt;vim_prtfky_total&gt;,
                  COMPONENT x_namtab-viewfield
                   OF STRUCTURE &lt;vim_extract_struc&gt;
                   TO  &lt;vim_prtfky_extract&gt;.
* not a texttablefield in a table &amp; texttable
        ELSE.
          ASSIGN: COMPONENT x_namtab-viewfield
                    OF STRUCTURE &lt;vim_tot_txt_struc&gt;
                     TO &lt;vim_prtfky_total&gt;,
                    COMPONENT x_namtab-viewfield
                     OF STRUCTURE &lt;vim_ext_txt_struc&gt;
                     TO  &lt;vim_prtfky_extract&gt;.
        ENDIF.
*        ASSIGN: total+x_namtab-position(x_namtab-flength)
*                                 TO &lt;vim_prtfky_total&gt;,
*                extract+x_namtab-position(x_namtab-flength)
*                                 TO &lt;vim_prtfky_extract&gt;.
        CLEAR prtfky_field_changed.
        IF status-action EQ hinzufuegen OR status-action EQ kopieren OR
           vim_special_mode EQ vim_upgrade.
          CLEAR cur_mkey_found.
          LOOP AT total.               &quot;            current mainkey.
            CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
                  ( vim_mkey_after_exists EQ space OR
                    &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*            CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*                  ( vim_mkey_after_exists EQ space OR
*                    &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
            cur_mkey_found = &apos;X&apos;. EXIT.
          ENDLOOP.
          IF cur_mkey_found NE space.
            IF &lt;vim_prtfky_wa&gt; IS INITIAL. &quot;no entry -&gt; use exist. value
              MOVE &lt;vim_prtfky_total&gt; TO &lt;vim_prtfky_wa&gt;.
              TRANSLATE &lt;status&gt;-upd_flag USING &apos;EY&apos;.
              IF &lt;status&gt;-upd_flag EQ &apos;Y&apos;.
                PERFORM (formname) IN PROGRAM (sy-repid)
                                   USING &lt;table1&gt; &lt;table1_text&gt;.
              ENDIF.
            ELSEIF &lt;vim_prtfky_wa&gt; NE &lt;vim_prtfky_total&gt;.
              MOVE &apos;X&apos; TO prtfky_field_changed.
            ENDIF.
          ENDIF.
        ELSEIF &lt;vim_prtfky_wa&gt; NE &lt;vim_prtfky_extract&gt;.
          MOVE &apos;X&apos; TO prtfky_field_changed.
        ENDIF.
        ADD 1 TO count.
      ENDLOOP.
      IF count EQ 1.
        MOVE &apos;X&apos; TO vim_prtfky_assigned.
      ENDIF.
    ELSE.     &quot; vim_prtfky_assigned = &apos;X&apos;
      IF status-action EQ hinzufuegen OR status-action EQ kopieren OR
         vim_special_mode EQ vim_upgrade.
        LOOP AT total.                 &quot;            current mainkey.
          CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
                ( vim_mkey_after_exists EQ space OR
                  &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*          CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*                ( vim_mkey_after_exists EQ space OR
*                  &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
          cur_mkey_found = &apos;X&apos;. EXIT.
        ENDLOOP.
        IF cur_mkey_found NE space.
          IF &lt;vim_prtfky_wa&gt; IS INITIAL. &quot;no entry -&gt; use exist. value
            MOVE &lt;vim_prtfky_total&gt; TO &lt;vim_prtfky_wa&gt;.
            TRANSLATE &lt;status&gt;-upd_flag USING &apos;EY&apos;.
            IF &lt;status&gt;-upd_flag EQ &apos;Y&apos;.
              PERFORM (formname) IN PROGRAM (sy-repid)
                                 USING &lt;table1&gt; &lt;table1_text&gt;.
            ENDIF.
          ELSEIF &lt;vim_prtfky_wa&gt; NE &lt;vim_prtfky_total&gt;.
            MOVE &apos;X&apos; TO prtfky_field_changed.
          ENDIF.
        ENDIF.
      ELSEIF &lt;vim_prtfky_wa&gt; NE &lt;vim_prtfky_extract&gt;.
        MOVE &apos;X&apos; TO prtfky_field_changed.
      ENDIF.
    ENDIF.
*  if verändert.
    IF prtfky_field_changed NE space.
      IF cpff_alert NE space.
        sy-msgv1 = svim_text_030.
        sy-msgv2 = &lt;vim_mainkey_mask&gt;. TRANSLATE sy-msgv2 USING &apos;+ &apos;.
        IF x_header-clidep NE space.
          SHIFT sy-msgv2 BY client_length PLACES.
        ENDIF.
        count = strlen( sy-msgv2 ).
        ASSIGN sy-msgv2(count) TO &lt;dummy1&gt;.
        REPLACE &apos;&amp;&apos; WITH &lt;dummy1&gt; INTO sy-msgv1.
        CALL FUNCTION &apos;POPUP_TO_CONFIRM_WITH_MESSAGE&apos;
          EXPORTING
            diagnosetext1  = svim_text_031
            diagnosetext2  = svim_text_032
            diagnosetext3  = svim_text_033
            textline1      = svim_text_034
            textline2      = svim_text_035
            titel          = sy-msgv1
            cancel_display = space
          IMPORTING
            answer         = answer.
      ELSE.
        answer = &apos;J&apos;.
      ENDIF.
      IF answer EQ &apos;A&apos;.
        answer = &apos;N&apos;.
      ENDIF.
      CASE answer.
*       WHEN &apos;A&apos;. &quot;cancel --&gt; what to do ? same as NO ?
        WHEN &apos;J&apos;.                      &quot;yes, change all
          IF status-action EQ hinzufuegen OR status-action EQ kopieren.
            PERFORM check_key.
          ELSEIF ( x_header-customauth CO sap_cust_ctrl_classes OR
                   vim_ale_keyspec_check NE space OR
                   vim_sync_keyspec_check NE space ).
            PERFORM check_allowed_keyranges.
          ENDIF.
          LOOP AT total.
            CHECK &lt;vim_xtotal_key&gt; NE &lt;f1_x&gt; AND
                  &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
                  ( vim_mkey_after_exists EQ space OR
                    &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*            CHECK &lt;vim_total_key&gt; NE &lt;f1&gt; AND
*                  &lt;vim_tot_mkey_before&gt; EQ &lt;vim_mkey_before&gt; AND
*                  ( vim_mkey_after_exists EQ space OR
*                    &lt;vim_tot_mkey_after&gt; EQ &lt;vim_mkey_after&gt; ).
*         move der entsprech. Felder --&gt; gemäß X_NAMTAB, zum PBO füllen
            IF vim_prtfky_assigned CO &apos; Y&apos;.
              LOOP AT x_namtab WHERE prtfrkyfld NE space.
                IF vim_prtfky_assigned EQ space.
                  IF x_header-bastab EQ space          &quot;view
                   OR x_header-texttbexst EQ space     &quot;no texttable
                   OR x_namtab-texttabfld EQ space.    &quot;no texttabfield
* not a texttablefield in a table &amp; texttable
                    ASSIGN: COMPONENT x_namtab-viewfield
                       OF STRUCTURE &lt;table1&gt;
                       TO &lt;vim_prtfky_wa&gt;,
                     COMPONENT x_namtab-viewfield
                      OF STRUCTURE &lt;vim_total_struc&gt;
                      TO &lt;vim_prtfky_total&gt;.
                  ELSE.
                    ASSIGN: COMPONENT x_namtab-viewfield
                             OF STRUCTURE &lt;table1_text&gt;
                             TO &lt;vim_prtfky_wa&gt;,
                            COMPONENT x_namtab-viewfield
                             OF STRUCTURE &lt;vim_tot_txt_struc&gt;
                             TO &lt;vim_prtfky_total&gt;.
                  ENDIF.
                ENDIF.
*                  IF x_header-bastab EQ space OR
*                     x_header-texttbexst EQ space OR
*                     x_namtab-texttabfld EQ space.
*                    ASSIGN &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                              TO &lt;vim_prtfky_wa&gt;.
*                  ELSE.
*                    offs = x_namtab-position - x_header-tablen.
*                    ASSIGN &lt;table1_text&gt;+offs(x_namtab-flength)
*                                              TO &lt;vim_prtfky_wa&gt;.
*                  ENDIF.
*                ENDIF.
*                ASSIGN total+x_namtab-position(x_namtab-flength)
*                                         TO &lt;vim_prtfky_total&gt;.
                MOVE &lt;vim_prtfky_wa&gt; TO &lt;vim_prtfky_total&gt;.
              ENDLOOP.
            ELSE.
              MOVE &lt;vim_prtfky_wa&gt; TO &lt;vim_prtfky_total&gt;.
            ENDIF.
            MODIFY total.
            READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.   &quot;#EC WARNOK
            IF sy-subrc EQ 0.
              MOVE total TO extract.
              MODIFY extract INDEX sy-tabix.
            ENDIF.
          ENDLOOP.
          vim_prt_fky_flds_updated = &apos;X&apos;.
        WHEN &apos;N&apos;.
*       text aus Extract bzw. Total (hinzuf.) nehmen
          IF vim_prtfky_assigned CO &apos; Y&apos;.
            LOOP AT x_namtab WHERE prtfrkyfld NE space.
              IF vim_prtfky_assigned EQ space.
                IF x_header-bastab EQ space             &quot;view
                 OR x_header-texttbexst EQ space        &quot;no texttable
               OR x_namtab-texttabfld EQ space.       &quot;no texttabfield
* not a texttablefield in a table &amp; texttable
                  ASSIGN: COMPONENT x_namtab-viewfield
                       OF STRUCTURE &lt;table1&gt;
                       TO &lt;vim_prtfky_wa&gt;,
                     COMPONENT x_namtab-viewfield
                      OF STRUCTURE &lt;vim_total_struc&gt;
                      TO &lt;vim_prtfky_total&gt;,
                     COMPONENT x_namtab-viewfield
                      OF STRUCTURE &lt;vim_extract_struc&gt;
                      TO  &lt;vim_prtfky_extract&gt;.
                ELSE.
                  ASSIGN: COMPONENT x_namtab-viewfield
                           OF STRUCTURE &lt;table1_text&gt;
                           TO &lt;vim_prtfky_wa&gt;,
                          COMPONENT x_namtab-viewfield
                           OF STRUCTURE &lt;vim_tot_txt_struc&gt;
                           TO &lt;vim_prtfky_total&gt;,
                          COMPONENT x_namtab-viewfield
                           OF STRUCTURE &lt;vim_ext_txt_struc&gt;
                           TO  &lt;vim_prtfky_extract&gt;.
                ENDIF.
              ENDIF.
*                IF x_header-bastab EQ space OR
*                   x_header-texttbexst EQ space OR
*                   x_namtab-texttabfld EQ space.
*                  ASSIGN &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                            TO &lt;vim_prtfky_wa&gt;.
*                ELSE.
*                  offs = x_namtab-position - x_header-tablen.
*                  ASSIGN &lt;table1_text&gt;+offs(x_namtab-flength)
*                                            TO &lt;vim_prtfky_wa&gt;.
*                ENDIF.
*              ENDIF.
*              ASSIGN: total+x_namtab-position(x_namtab-flength)
*                                       TO &lt;vim_prtfky_total&gt;,
*                      extract+x_namtab-position(x_namtab-flength)
*                                       TO &lt;vim_prtfky_extract&gt;.
              IF status-action EQ hinzufuegen OR
                 status-action EQ kopieren OR
                 vim_special_mode EQ vim_upgrade.
                MOVE &lt;vim_prtfky_total&gt; TO &lt;vim_prtfky_wa&gt;.
              ELSE.
                MOVE &lt;vim_prtfky_extract&gt; TO &lt;vim_prtfky_wa&gt;.
              ENDIF.
            ENDLOOP.
          ELSE.
            IF status-action EQ hinzufuegen OR
               status-action EQ kopieren OR
               vim_special_mode EQ vim_upgrade.
              MOVE &lt;vim_prtfky_total&gt; TO &lt;vim_prtfky_wa&gt;.
            ELSE.
              MOVE &lt;vim_prtfky_extract&gt; TO &lt;vim_prtfky_wa&gt;.
            ENDIF.
          ENDIF.
          IF ( x_header-bastab EQ space OR  &quot;view or no texttab and..
               x_header-texttbexst EQ space ) AND
             &lt;table1_x&gt; EQ &lt;vim_xextract&gt;.     &quot;..no change
            CLEAR &lt;status&gt;-upd_flag.
          ELSEIF x_header-bastab NE space AND &quot;bastab with texttab and
                 x_header-texttbexst NE space AND
                 &lt;table1_xtext&gt; EQ &lt;vim_xextract_text&gt;.
* no change of text
            TRANSLATE &lt;status&gt;-upd_flag USING &apos;XET &apos;.
          ENDIF.
      ENDCASE.
    ENDIF. &quot;vim_prtfky_field_changed ne space
  ENDIF. &quot;COUNT eq 99   other entries for mainkey (may be) exist
ENDFORM.                               &quot;consistency_prt_frky_fields</include_source>
   </include>
   <include NAME="LSVIMF0N" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  TEMP_DELIM_DETERMINE_ACTION                             *
*&amp;--------------------------------------------------------------------*
* determine action flag                                               *
*&amp;--------------------------------------------------------------------*
FORM TEMP_DELIM_DETERMINE_ACTION USING VALUE(TDDA_INDEX) TDDA_ACT
                                                         TDDA_ACT_TXT.
  LOCAL: TOTAL.
  READ TABLE TOTAL INDEX TDDA_INDEX.
  IF &lt;ACTION&gt; EQ NEUER_GELOESCHT.
    TDDA_ACT = NEUER_EINTRAG.
  ELSE.
    TDDA_ACT = AENDERN.
  ENDIF.
  IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
    IF &lt;ACTION_TEXT&gt; EQ NEUER_GELOESCHT.
      TDDA_ACT_TXT = NEUER_EINTRAG.
    ELSE.
      TDDA_ACT_TXT = AENDERN.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;temp_delim_determine_action</include_source>
   </include>
   <include NAME="LSVIMF0O" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form TEMPORAL_DELIMITATION                                    *
*&amp;--------------------------------------------------------------------*
* process temporal delimitation                                       *
*&amp;--------------------------------------------------------------------*
FORM temporal_delimitation.
  constants: highdate TYPE d VALUE &apos;99991231&apos;.
  DATA: entries_exist(1) TYPE c,
        enddate_safe TYPE d, act(1) TYPE c, act_txt(1) TYPE c,   &quot;#EC NEEDED
        hf TYPE i,                                               &quot;#EC NEEDED
        date_safe TYPE d,                                        &quot;#EC NEEDED
        ok_code_safe LIKE ok_code, function_safe LIKE function,
        delim_entr_safe TYPE STANDARD TABLE OF vim_delim_entr_tl
         WITH DEFAULT KEY INITIAL SIZE 10,
        collapsed_mkeys_safe TYPE STANDARD TABLE
         OF vim_collapsed_mkeys_tl WITH DEFAULT KEY INITIAL SIZE 1,
        merged_entr_safe TYPE STANDARD TABLE      &quot;merged entries
         OF vim_merged_entr_tl WITH DEFAULT KEY INITIAL SIZE 1.

  CHECK x_header-delmdtflag NE space.
* check if dates entered properly
  IF ( &lt;vim_new_begdate&gt; is initial OR
     &lt;vim_enddate_mask&gt; EQ vim_init_date ) AND
     status-mode EQ list_bild.         &quot;only on list screen
    MESSAGE e127(sv).&quot;Bitte den Gültigkeitsbereich eingrenzen
  ENDIF.
* process delimitation
  IF x_header-clidep NE space.
    MOVE sy-mandt TO &lt;client&gt;.
  ENDIF.
  IF &lt;xact&gt; NE leer AND neuer NE &apos;J&apos; AND status-delete NE geloescht AND
     ( status-action NE kopieren AND vim_special_mode EQ space OR
       vim_special_mode EQ vim_delimit ).
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
    CHECK sy-subrc EQ 0.
  ELSE. &quot;entry is new (input, copy, undelete, reset, replace, upgrade)
    IF status-mode EQ list_bild.           &quot;only on list screen
      IF x_header-delmdtflag EQ &apos;E&apos; AND    &quot;end date is key field
         &lt;vim_new_begdate&gt; GT &lt;vim_enddate_mask&gt;.
        MESSAGE e045(sv). &quot;Bitte ein Beginn-Datum angeben, das vor dem
      ELSEIF x_header-delmdtflag EQ &apos;B&apos; AND    &quot;begin date is key field
             &lt;vim_new_begdate&gt; LT &lt;vim_enddate_mask&gt;.
        MESSAGE e046(sv). &quot;Bitte ein Ende-Datum angeben, das nach dem be
      ENDIF.
    ENDIF.
    LOOP AT total.
      CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
            ( vim_mkey_after_exists EQ space OR
              &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ).
*      CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_f1_before&gt; AND
*            ( vim_mkey_after_exists EQ space OR
*              &lt;vim_tot_mkey_after&gt; EQ &lt;vim_f1_after&gt; ).
      MOVE &apos;X&apos; TO entries_exist.
      EXIT.
    ENDLOOP.
    CHECK entries_exist NE space.
    MOVE: &lt;table2_x&gt; TO &lt;vim_xtotal&gt;,
          &lt;vim_enddate_mask&gt; TO &lt;vim_enddate&gt;.
    IF x_header-delmdtflag EQ &apos;E&apos;.
      MOVE highdate TO &lt;vim_begdate&gt;.
    ELSE.
      CLEAR &lt;vim_begdate&gt;.
    ENDIF.
  ENDIF.
  CHECK &lt;vim_new_begdate&gt; NE &lt;vim_begdate&gt;.
* check allowed keyranges
  IF x_header-customauth CO sap_cust_ctrl_classes OR
     vim_ale_keyspec_check NE space OR
     vim_sync_keyspec_check NE space.
    PERFORM check_allowed_keyranges.
  ENDIF.
  IF x_header-delmdtflag EQ &apos;E&apos;.       &quot;end date is key field
    IF &lt;vim_new_begdate&gt; GT &lt;vim_enddate&gt;.
      MESSAGE e045(sv). &quot;Bitte ein Beginn-Datum angeben, das vor dem End
    ELSEIF &lt;vim_new_begdate&gt; LT &lt;vim_begdate&gt;.
      PERFORM temp_delim_del_overld_entries USING &lt;vim_new_begdate&gt;
                                                  &lt;vim_enddate&gt;.
    ELSE.
      &lt;vim_enddate&gt; = &lt;vim_new_begdate&gt; - 1.
      IF x_header-texttbexst NE space AND
         x_header-ptfrkyexst EQ space.
        PERFORM vim_temp_delim_texttab
          USING &lt;vim_enddate_mask&gt; &lt;vim_xextract_key&gt;. &quot;SW Texttransl
        IF x_header-bastab NE space.
          MOVE: &lt;vim_enddate&gt; TO &lt;vim_text_enddate&gt;,
                neuer_eintrag TO &lt;action_text&gt;.
        ENDIF.
      ENDIF.
      READ TABLE total WITH KEY &lt;vim_xtotal_key&gt; BINARY SEARCH  &quot;#EC WARNOK
                                                TRANSPORTING NO FIELDS.
*      READ TABLE total WITH KEY &lt;vim_total_key&gt; BINARY SEARCH
*                                                TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        &lt;action&gt; = neuer_eintrag.
        &lt;mark&gt; = nicht_markiert.       &quot;new entries are never marked
        INSERT total INDEX sy-tabix.
      ELSE.
* entry MUST be a deleted one
        MESSAGE w121(sv). &quot;Gelöschter Eintrag wird zurückgeholt und ggf.
        PERFORM temp_delim_determine_action USING sy-tabix act act_txt.
        &lt;action&gt; = act.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
          &lt;action_text&gt; = act_txt.
        ENDIF.
        MODIFY total INDEX sy-tabix.
      ENDIF.
    ENDIF.
  ELSE.                                &quot;begin date is key field
    IF &lt;vim_new_begdate&gt; LT &lt;vim_enddate&gt;.
      MESSAGE e046(sv). &quot;Bitte ein Ende-Datum angeben, das nach dem begi
    ELSEIF &lt;vim_new_begdate&gt; GT &lt;vim_begdate&gt;.
      PERFORM temp_delim_del_overld_entries USING &lt;vim_new_begdate&gt;
                                                  &lt;vim_enddate&gt;.
    ELSE.
      &lt;vim_begdate&gt; = &lt;vim_new_begdate&gt;.
      IF x_header-bastab NE space AND x_header-texttbexst NE space AND
         x_header-ptfrkyexst EQ space.
        IF &lt;action_text&gt; EQ original.
          MOVE aendern   TO &lt;action_text&gt;.
        ENDIF.
      ENDIF.
      IF &lt;action&gt; EQ original.
        &lt;action&gt; = aendern.
      ENDIF.
      MODIFY total INDEX sy-tabix.
      total = extract.
      &lt;vim_enddate&gt; = &lt;vim_new_begdate&gt; + 1.
      &lt;action&gt; = &lt;xact&gt; = neuer_eintrag.
      IF x_header-bastab NE space AND x_header-texttbexst NE space AND
         x_header-ptfrkyexst EQ space.
        MOVE: &lt;vim_enddate&gt; TO &lt;vim_text_enddate&gt;,
              neuer_eintrag TO &lt;action_text&gt;,
              neuer_eintrag TO &lt;xact_text&gt;.
      ENDIF.
      anz_pages = sy-tabix + 1.
      INSERT total INDEX anz_pages.
    ENDIF.
  ENDIF.                               &quot;x_header-delmdtflag eq &apos;E&apos;
  IF temporal_delimitation_happened EQ &apos;N&apos;.
    CLEAR temporal_delimitation_happened. EXIT.
  ENDIF.
  IF temporal_delimitation_happened NE &apos;G&apos;.
    MOVE sy-tabix TO anz_pages.
    LOOP AT vim_delim_entries WHERE index1 GE anz_pages.
      ADD 1 TO vim_delim_entries-index1.
      MODIFY vim_delim_entries.
    ENDLOOP.
    MOVE: anz_pages TO vim_delim_entries-index1,
          nextline  TO vim_delim_entries-index2,
          space     TO vim_delim_entries-index3.
    APPEND vim_delim_entries.
    MOVE &apos;X&apos; TO temporal_delimitation_happened.
  ENDIF.
  IF &lt;xact&gt; NE leer AND neuer NE &apos;J&apos; AND status-delete NE geloescht AND
     ( status-action NE kopieren AND vim_special_mode EQ space OR
       vim_special_mode EQ vim_delimit ).
    IF x_header-adrnbrflag NE space.
* if entry contains address number: ask if new address is wanted
      CALL FUNCTION &apos;POPUP_TO_DECIDE&apos;                       &quot;#EC FB_OLDED
           EXPORTING
                defaultoption = &apos;1&apos;
                titel         = svim_text_037
                textline1     = svim_text_038
                textline2     = svim_text_039
                textline3     = svim_text_040
                text_option1  = svim_text_041
                text_option2  = svim_text_042
           IMPORTING
                answer        = answer.
      CASE answer.
        WHEN &apos;A&apos;. EXIT.
        WHEN &apos;2&apos;.                      &quot;clear old address number
          CLEAR &lt;address_number&gt;.
        WHEN OTHERS.                   &quot;copy old address
* not yet possible
      ENDCASE.
    ENDIF.
    IF x_header-guidflag &lt;&gt; space.
      PERFORM vim_make_guid USING space.
    ENDIF.
* if user exit for hidden fields exists: perform exit routine
    IF x_header-frm_h_flds NE space.
      PERFORM (x_header-frm_h_flds) IN PROGRAM.
    ENDIF.
* if user exit for new entries exists: perform exit routine
    IF x_header-frm_on_new NE space.
      PERFORM (x_header-frm_on_new) IN PROGRAM.
    ENDIF.
* if entry contains address number: call address maintain
    IF x_header-adrnbrflag NE space AND answer EQ &apos;2&apos;.
      PERFORM address_maintain.
    ENDIF.
* if user exit after delimitation exists: perform exit routine
    IF x_header-frm_af_dlm NE space.
      delim_entr_safe = vim_delim_entries[].
      collapsed_mkeys_safe = vim_collapsed_mainkeys[].
      merged_entr_safe = vim_merged_entries[].
      IF status-mode EQ detail_bild.
        ok_code_safe = ok_code. function_safe = function.
      ENDIF.
      PERFORM (x_header-frm_af_dlm) IN PROGRAM.
      MOVE delim_entr_safe TO vim_delim_entries[].
      MOVE collapsed_mkeys_safe TO vim_collapsed_mainkeys[].
      MOVE merged_entr_safe TO vim_merged_entries[].
      IF status-mode EQ detail_bild.
        MOVE: ok_code_safe TO ok_code, function_safe TO function.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;temp_delimitation</include_source>
   </include>
   <include NAME="LSVIMF0P" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  TEMP_DELIM_UNDELETE                                     *
*&amp;--------------------------------------------------------------------*
* process undelete of non-selected entries due to temp. delimitation  *
*&amp;--------------------------------------------------------------------*
* TDU_ENDDA --&gt; enddate to display during warning                     *
* TDU_ACT   --&gt; value of action flag                                  *
* TDU_ACT_TXT --&gt; value of action flag for text table                 *
* TDU_IX    --&gt; index of entry to modify in TOTAL                     *
* COUNTER   &lt;-&gt; (global) number of undeleted entries                  *
* SY-SUBRC  &lt;-- (global) 0 - curr. entry undeleted, others - new entry*
*&amp;--------------------------------------------------------------------*
FORM temp_delim_undelete USING value(tdu_endda) value(tdu_begda)
                               tdu_act tdu_act_txt tdu_ix.
  LOCAL: total.
  DATA: trans_pattern(6) TYPE c, rec TYPE i, ix TYPE i.

  CLEAR tdu_ix.
  READ TABLE total WITH KEY &lt;vim_xtotal_key&gt; BINARY SEARCH. &quot;#EC WARNOK
  IF sy-subrc EQ 0. &quot;new entry already exists - must be a deleted
    &quot;by previous temporal delimitation one
    IF &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ neuer_geloescht OR
       &lt;action&gt; EQ update_geloescht.
      tdu_ix = sy-tabix.
      READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.         &quot;#EC WARNOK
      rec = sy-subrc. ix = sy-tabix.
      IF sy-subrc EQ 0 AND &lt;xact&gt; EQ markiert.
        SUBTRACT 1 FROM mark_extract.
      ELSE.
        MOVE tdu_endda TO &lt;vim_enddate_mask&gt;.
        IF vim_special_mode EQ vim_reset.
          MESSAGE i120(sv).&quot;Es werden weitere Einträge zurückgeholt
        ELSE.
          MESSAGE w120(sv).&quot;Es werden weitere Einträge zurückgeholt
        ENDIF.
      ENDIF.
      ADD 1 TO counter.
      IF rec EQ 0.                     &quot;read table extract subrc
        sy-fdpos = vim_delim_entries-index3.
        vim_delim_entries-index3 = ix.
        APPEND vim_delim_entries.
        vim_delim_entries-index3 = sy-fdpos.
      ENDIF.
      MOVE: geloescht TO trans_pattern,
              original TO trans_pattern+1(1),
            neuer_geloescht TO trans_pattern+2(1),
              neuer_eintrag TO trans_pattern+3(1),
            update_geloescht TO trans_pattern+4(1),
              aendern TO trans_pattern+5(1).
      TRANSLATE &lt;action&gt; USING trans_pattern.
      MOVE &lt;action&gt; TO tdu_act.
      IF x_header-bastab NE space AND
         x_header-texttbexst NE space.
        TRANSLATE &lt;action_text&gt; USING trans_pattern.
        MOVE &lt;action_text&gt; TO tdu_act_txt.
      ENDIF.
      IF tdu_begda NE &lt;vim_begdate&gt;.   &quot;udl entry will be modified
        MOVE: original TO trans_pattern, aendern TO trans_pattern+1.
        TRANSLATE: tdu_act USING trans_pattern,
                   tdu_act_txt USING trans_pattern.
      ENDIF.
    ENDIF.                             &quot;current entry is a deleted one
    CLEAR sy-subrc.
  ENDIF.                               &quot;sy-subrc eq 0
ENDFORM.                               &quot;temp_delim_undelete</include_source>
   </include>
   <include NAME="LSVIMF0Q" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  TEMP_DELIM_DEL_OVERLED_ENTRIES                          *
*&amp;--------------------------------------------------------------------*
* delete entries with overlaying time ranges                          *
*---------------------------------------------------------------------*
* BEGDATE ---&gt; E: new begin date /B: new end date                     *
* ENDDATE ---&gt; E: end date /B: begin date                             *
*&amp;--------------------------------------------------------------------*
FORM temp_delim_del_overld_entries USING value(begdate) TYPE d
                                         value(enddate) TYPE d.
  LOCAL: extract, &lt;table1&gt;.
  DATA: first(1) TYPE c VALUE &apos;X&apos;, overlayed(1) TYPE c, cur_ix TYPE i,
        date_increment TYPE i, enddate_safe(8) TYPE c, new_ix TYPE i,
        trans_pattern(6) TYPE c, act_safe, mark_safe, act_txt_safe, &quot;#EC TYPES_MISS
        enddate_safe2(8) TYPE c, act, act_txt, hf TYPE i,   &quot;#EC NEEDED
                                                        &quot;#EC TYPES_MISS
        key_safe LIKE vim_merged_entries-new_key, date_safe TYPE d, &quot;#EC NEEDED
*        old_key TYPE vim_line_ul,
        old_keyx TYPE vrsdat1000.

  IF vim_temp_delim_alr_checked NE space.
    CLEAR first.
  ENDIF.
  LOOP AT total.
    CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
          ( vim_mkey_after_exists EQ space OR
            &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ).
    IF vim_special_mode NE vim_upgrade AND
       vim_special_mode NE vim_reset AND
       vim_special_mode NE vim_replace.
      CHECK &lt;vim_enddate&gt; NE enddate.
    ENDIF.
    CHECK &lt;action&gt; NE geloescht AND
          &lt;action&gt; NE neuer_geloescht AND
          &lt;action&gt; NE update_geloescht.
    CLEAR overlayed.
    IF x_header-delmdtflag EQ &apos;E&apos;.     &quot;end date is key field
      CHECK &lt;vim_enddate&gt; GE begdate AND &lt;vim_begdate&gt; LE enddate.
      IF &lt;vim_begdate&gt; GE begdate AND &lt;vim_enddate&gt; LT enddate.
        MOVE &apos;F&apos; TO overlayed. &quot;whole old entry is overlayed by new one
      ELSEIF &lt;vim_begdate&gt; LT begdate AND &lt;vim_enddate&gt; GT enddate.
        MOVE &apos;M&apos; TO overlayed. &quot;middle of old entry is overl. by new one
      ELSEIF &lt;vim_begdate&gt; LE enddate AND &lt;vim_enddate&gt; GT enddate.
        MOVE &apos;P&apos; TO overlayed. &quot;part of old entry is overlayed by new on
      ELSEIF &lt;vim_begdate&gt; EQ begdate AND &lt;vim_enddate&gt; EQ enddate.
        temporal_delimitation_happened = &apos;N&apos;. EXIT. &quot;no delim required
      ELSEIF &lt;vim_enddate&gt; EQ enddate.
        MOVE &apos;E&apos; TO overlayed. &quot;end of old entry is overlayed by new one
      ENDIF.
      MOVE -1 TO date_increment.
    ELSE.                              &quot;begin date is key field
      CHECK &lt;vim_enddate&gt; LE begdate AND &lt;vim_begdate&gt; GE enddate. &quot;entr
      IF &lt;vim_begdate&gt; LE begdate AND &lt;vim_enddate&gt; GT enddate.
        MOVE &apos;F&apos; TO overlayed. &quot;whole old entry is overlayed by new one
      ELSEIF &lt;vim_enddate&gt; LT enddate AND &lt;vim_begdate&gt; GT begdate.
        MOVE &apos;M&apos; TO overlayed. &quot;middle of old entry is overl. by new one
      ELSEIF &lt;vim_enddate&gt; LE enddate AND &lt;vim_begdate&gt; GT enddate.
        MOVE &apos;P&apos; TO overlayed. &quot;part of old entry is overlayed by new on
      ELSEIF &lt;vim_begdate&gt; EQ begdate AND &lt;vim_enddate&gt; EQ enddate.
        temporal_delimitation_happened = &apos;N&apos;. EXIT. &quot;no delim required
      ELSEIF &lt;vim_enddate&gt; EQ enddate.
        MOVE &apos;E&apos; TO overlayed. &quot;begin of old entry is overlayed by new o
      ENDIF.
      MOVE 1 TO date_increment.
    ENDIF.                             &quot;x_header-delmdtflag eq &apos;E&apos;
    IF first NE space.
      IF vim_special_mode NE vim_reset.
        MESSAGE w047(sv). &quot;Überlagerte Sätze werden gelöscht
      ELSE.
        MESSAGE i047(sv). &quot;Überlagerte Sätze werden gelöscht
      ENDIF.
      CLEAR first.
    ENDIF.
    cur_ix = sy-tabix.
    CLEAR vim_delim_entries.
    READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.           &quot;#EC WARNOK
*    READ TABLE extract WITH KEY total.
    IF sy-subrc EQ 0.
      MOVE sy-tabix TO vim_delim_entries-index3.
      IF overlayed NE &apos;P&apos; AND overlayed NE &apos;M&apos; AND overlayed NE &apos;E&apos;.
        APPEND vim_delim_entries.
      ENDIF.
    ENDIF.
    IF overlayed EQ space OR overlayed EQ &apos;F&apos;.
* delete old entry which is overlayed
      MOVE: original TO trans_pattern, geloescht TO trans_pattern+1(1),
            aendern  TO trans_pattern+2(1), update_geloescht
                                                 TO trans_pattern+3(1),
            neuer_eintrag TO trans_pattern+4(1), neuer_geloescht
                                                 TO trans_pattern+5(1).
      TRANSLATE &lt;action&gt; USING trans_pattern.
      IF x_header-bastab NE space AND x_header-texttbexst NE space AND
         x_header-ptfrkyexst EQ space.
        TRANSLATE &lt;action_text&gt; USING trans_pattern.
      ENDIF.
      IF &lt;mark&gt; EQ markiert.
        &lt;mark&gt; = nicht_markiert.
        SUBTRACT 1 FROM mark_total.
      ENDIF.
      MODIFY total.
    ENDIF. &quot;overlayed eq space or overlayed eq &apos;F&apos;
    IF overlayed EQ space OR overlayed EQ &apos;M&apos; OR overlayed EQ &apos;E&apos;.
* create new entry due to delimitation
      IF overlayed EQ &apos;M&apos;.
        MOVE: &lt;vim_enddate&gt; TO enddate_safe, &lt;action&gt; TO act_safe,
              &lt;mark&gt; TO mark_safe.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
          MOVE &lt;action_text&gt; TO act_txt_safe.
        ENDIF.
      ENDIF.
      CLEAR hf.
      old_keyx = &lt;vim_xtotal_key&gt;.                 &quot;SW Texttransl
*      old_key = total.
      &lt;vim_enddate&gt; = begdate + date_increment.
      IF x_header-delmdtflag EQ &apos;E&apos;.                        &quot;ACHACHADI 1317455
        CHECK &lt;vim_enddate&gt; GE &lt;vim_begdate&gt;.               &quot;aro 070798
      ELSEIF x_header-delmdtflag EQ &apos;B&apos;.
        CHECK &lt;vim_enddate&gt; LE &lt;vim_begdate&gt;.
      ENDIF.                                                &quot;ACHACHADI 1317455
      &lt;action&gt; = neuer_eintrag.
      &lt;mark&gt; = nicht_markiert.
      IF x_header-texttbexst NE space AND
         x_header-ptfrkyexst EQ space.
        PERFORM vim_temp_delim_texttab
                 USING enddate old_keyx.  &quot;SW Texttransl
        IF x_header-bastab NE space.
          MOVE: &lt;vim_enddate&gt; TO &lt;vim_text_enddate&gt;,
                neuer_eintrag TO &lt;action_text&gt;.
        ENDIF.
      ENDIF.
      IF vim_special_mode NE space.    &quot;special mode
        PERFORM temp_delim_undelete USING &lt;vim_enddate_mask&gt;
                                          &lt;vim_begdate&gt;
                                          act act_txt new_ix.
        IF new_ix NE 0.
          MOVE act TO &lt;action&gt;.
          IF x_header-bastab NE space AND x_header-texttbexst NE space.
            MOVE act_txt TO &lt;action_text&gt;.
          ENDIF.
          MODIFY total INDEX new_ix.
        ENDIF.
      ENDIF.                           &quot;special mode
      IF vim_special_mode EQ space OR sy-subrc NE 0.
        IF x_header-delmdtflag EQ &apos;E&apos;. &quot;end date is key field
          new_ix = cur_ix. INSERT total.
        ELSE.                          &quot;begin date is key field
          new_ix = cur_ix + 1. INSERT total INDEX new_ix.
        ENDIF.                         &quot;x_header-delmdtflag eq &apos;E&apos;
      ENDIF.
      IF vim_special_mode NE vim_undelete AND
         vim_delim_entries-index3 NE 0.
        vim_delim_entries-index1 = new_ix.
        vim_delim_entries-index2 = vim_delim_entries-index3.
        sy-fdpos = vim_delim_entries-index3.
        CLEAR vim_delim_entries-index3.
        APPEND vim_delim_entries.
        vim_delim_entries-index3 = sy-fdpos.
      ENDIF.                           &quot;no undelete mode
    ENDIF. &quot;overlayed eq space or overlayed eq &apos;M&apos;
    IF overlayed EQ &apos;P&apos; OR overlayed EQ &apos;M&apos;.
      IF overlayed EQ &apos;M&apos;.
        MOVE: enddate_safe TO &lt;vim_enddate&gt;, act_safe TO &lt;action&gt;,
              mark_safe TO &lt;mark&gt;.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
          MOVE act_txt_safe TO &lt;action_text&gt;.
        ENDIF.
      ENDIF.
      CLEAR hf.
      &lt;vim_begdate&gt; = enddate - date_increment.
      MOVE: original TO trans_pattern, aendern TO trans_pattern+1(1).
      TRANSLATE &lt;action&gt; USING trans_pattern.
      IF &lt;mark&gt; EQ markiert.
        &lt;mark&gt; = nicht_markiert.
        SUBTRACT 1 FROM mark_total.
      ENDIF.
      MODIFY total.
      IF vim_delim_entries-index3 NE 0.
        vim_delim_entries-index1 = cur_ix.
        vim_delim_entries-index2 = vim_delim_entries-index3.
        APPEND vim_delim_entries.
      ENDIF.
    ENDIF. &quot;overlayed eq &apos;P&apos; or overlayed eq &apos;M&apos;
  ENDLOOP.
  MOVE &apos;G&apos; TO temporal_delimitation_happened.
ENDFORM.                               &quot;temp_delim_del_overled_entries</include_source>
   </include>
   <include NAME="LSVIMF0R" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  CHECK_DELIM_NEW_ENTRY                                   *
*&amp;--------------------------------------------------------------------*
* check new entry for delimitation (called from validity period sbscr)*
*---------------------------------------------------------------------*
* BEGDATE ---&gt; E: new begin date /B: new end date                     *
* ENDDATE ---&gt; E: end date /B: begin date                             *
*&amp;--------------------------------------------------------------------*
FORM check_delim_new_entry USING value(begdate) value(enddate).
  LOOP AT total.
    CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
          ( vim_mkey_after_exists EQ space OR
            &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ).
    CHECK &lt;vim_enddate&gt; NE enddate.
    CHECK &lt;action&gt; NE geloescht AND
          &lt;action&gt; NE neuer_geloescht AND
          &lt;action&gt; NE update_geloescht.
    IF x_header-delmdtflag EQ &apos;E&apos;.     &quot;end date is key field
      CHECK &lt;vim_enddate&gt; GE begdate AND &lt;vim_begdate&gt; LE enddate.
    ELSE.                              &quot;begin date is key field
      CHECK &lt;vim_enddate&gt; LE begdate AND &lt;vim_begdate&gt; GE enddate. &quot;entr
    ENDIF.                             &quot;x_header-delmdtflag eq &apos;E&apos;
    IF vim_special_mode NE vim_reset.
      MESSAGE w047(sv). &quot;Überlagerte Sätze werden gelöscht
    ELSE.
      MESSAGE i047(sv). &quot;Überlagerte Sätze werden gelöscht
    ENDIF.
    EXIT.
  ENDLOOP.
ENDFORM.                               &quot;check_delim_new_entry</include_source>
   </include>
   <include NAME="LSVIMF0S" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  AFTER_TEMPORAL_DELIMITATION                             *
*&amp;--------------------------------------------------------------------*
* fill EXTRACT with new due to temporal delimitation entries          *
*---------------------------------------------------------------------*
*                                                                     *
*&amp;--------------------------------------------------------------------*
FORM after_temporal_delimitation.
  LOCAL: extract, &lt;table1&gt;.                                 &quot;#EC *
  DATA: index_safe TYPE i, rec TYPE i.
  DATA: extract_wa_loc(8096) TYPE c, date_loc TYPE d,
        index_start TYPE i, index_stop TYPE i,
        key_before_loc(256) TYPE c.
  FIELD-SYMBOLS: &lt;extract_wax_loc&gt; TYPE x, &lt;date_loc&gt; TYPE d,
                 &lt;key_beforex_loc&gt; TYPE x.
  LOOP AT vim_delim_entries WHERE index3 NE space.          &quot;#EC *
    DELETE extract INDEX vim_delim_entries-index3.
    MOVE vim_delim_entries-index3 TO index_safe.
    IF vim_special_mode EQ vim_reset.
      SUBTRACT 1 FROM &lt;status&gt;-maxlines.
      IF &lt;status&gt;-st_mode EQ detail_bild AND
         &lt;status&gt;-cur_line GE vim_delim_entries-index3.
        SUBTRACT 1 FROM &lt;status&gt;-cur_line.
      ENDIF.
    ELSE.
      SUBTRACT 1 FROM maxlines.
    ENDIF.
    IF vim_delim_entries-index1 NE 0.
      CLEAR vim_delim_entries-index3.
      MODIFY vim_delim_entries.                             &quot;#EC *
    ENDIF.
    LOOP AT vim_delim_entries WHERE index2 GT index_safe
                                OR  index3 GT index_safe.   &quot;#EC *
      IF vim_delim_entries-index2 GT index_safe.
        SUBTRACT 1 FROM vim_delim_entries-index2.
      ENDIF.
      IF vim_delim_entries-index3 GT index_safe.
        SUBTRACT 1 FROM vim_delim_entries-index3.
      ENDIF.
      MODIFY vim_delim_entries.                             &quot;#EC *
    ENDLOOP.
  ENDLOOP.
  CLEAR extract.
  LOOP AT vim_delim_entries WHERE index3 EQ space.          &quot;#EC *
    READ TABLE total INDEX vim_delim_entries-index1.        &quot;#EC *
    MOVE total TO extract.
    IF x_header-delmdtflag EQ &apos;E&apos; AND &lt;vim_begdate&gt; LE sy-datum AND
       &lt;vim_enddate&gt; GE sy-datum OR x_header-delmdtflag EQ &apos;B&apos; AND
       &lt;vim_begdate&gt; GE sy-datum AND &lt;vim_enddate&gt; LE sy-datum.
      rec = 8.
      LOOP AT vim_collapsed_mainkeys.                       &quot;#EC *
        CHECK &lt;vim_collapsed_mkey_bfx&gt; EQ &lt;vim_tot_mkey_beforex&gt;.
*                WHERE mkey_bf EQ &lt;vim_tot_mkey_before&gt;.
        IF vim_mkey_after_exists NE space.
          CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_tot_mkey_afterx&gt;.
*          CHECK &lt;vim_collapsed_key_af&gt; EQ &lt;vim_tot_mkey_after&gt;.
        ENDIF.
        READ TABLE extract WITH KEY &lt;vim_collapsed_keyx&gt;    &quot;#EC WARNOK
*        READ TABLE extract WITH KEY &lt;vim_collapsed_key&gt;
                           TRANSPORTING NO FIELDS.          &quot;#EC *
        IF sy-subrc EQ 0.
          MODIFY extract INDEX sy-tabix.                    &quot;#EC *
          CLEAR rec.
        ENDIF.
        IF &lt;vim_collapsed_keyx&gt; NE &lt;vim_xtotal_key&gt;.
*        IF vim_collapsed_mainkeys-mainkey NE &lt;vim_total_key&gt;.
          &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
*          vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
          &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*          vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
          MODIFY vim_collapsed_mainkeys.                    &quot;#EC *
        ENDIF.
        EXIT.
      ENDLOOP.
      CHECK rec NE 0.
    ELSE.
      PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                 space &lt;vim_begdate&gt;.
      CHECK sy-subrc LT 8.
    ENDIF.
*******&quot;HCG HW664505 new index calcualtion for insert extract BEGIN*****
    READ TABLE extract WITH KEY &lt;vim_ext_mkey_beforex&gt; TRANSPORTING         &quot;#EC WARNOK
                    NO FIELDS.&quot;To check if key_before exists in extract
    IF vim_import_profile EQ space AND sy-subrc EQ 0.
      ASSIGN extract_wa_loc TO &lt;extract_wax_loc&gt; CASTING.
      &lt;extract_wax_loc&gt; = &lt;vim_xextract&gt;.               &quot;save new entry
      LOOP AT x_namtab WHERE keyflag EQ &apos;X&apos;
                         AND domname EQ vim_delim_date_domain
                         AND ( rollname IN vim_begda_types OR
                               rollname IN vim_endda_types ).
      ENDLOOP.                         &quot;Only one entry should be found
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                      &lt;vim_extract_struc&gt; TO &lt;date_loc&gt;.
      MOVE &lt;date_loc&gt; TO date_loc.                   &quot;date of new entry
      ASSIGN key_before_loc TO &lt;key_beforex_loc&gt; CASTING.
      &lt;key_beforex_loc&gt; = &lt;vim_ext_mkey_beforex&gt;.       &quot;save new entry
      READ TABLE extract WITH KEY &lt;vim_ext_mkey_beforex&gt;.   &quot;#EC WARNOK
      index_start = sy-tabix.
      index_stop = index_start - 1.
      LOOP AT extract FROM index_start.
        IF &lt;key_beforex_loc&gt; = &lt;vim_ext_mkey_beforex&gt;.
          index_stop = index_stop + 1.
        ELSE.
          EXIT.
        ENDIF.
      ENDLOOP.
      READ TABLE extract INDEX index_start.
      IF x_namtab-rollname IN vim_endda_types.       &quot;ENDDA is keyfield
        IF &lt;date_loc&gt; &gt; date_loc.
          &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
          INSERT extract INDEX index_start.
        ELSE.
          LOOP AT extract FROM index_start.
            IF &lt;date_loc&gt; &gt; date_loc OR sy-tabix = index_stop.
              IF &lt;date_loc&gt; &gt; date_loc.
                &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
              ELSE.              &quot;reached index_stop and insert behind
                &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
                sy-tabix = sy-tabix + 1.
              ENDIF.
              INSERT extract INDEX sy-tabix.
              EXIT.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ELSE.                                          &quot;BEGDA is keyfield
        IF &lt;date_loc&gt; &lt; date_loc.
          &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
          INSERT extract INDEX index_start.
        ELSE.
          LOOP AT extract FROM index_start.
            IF &lt;date_loc&gt; &lt; date_loc OR sy-tabix = index_stop.
              IF date_loc &lt; date_loc.                                     &quot;#EC BOOL_OK
                &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
              ELSE.            &quot;reached index_stop and insert behind
                &lt;vim_xextract&gt; = &lt;extract_wax_loc&gt;.
                sy-tabix = sy-tabix + 1.
              ENDIF.
                INSERT extract INDEX sy-tabix.
                EXIT.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ENDIF.
      ELSE.
        INSERT extract INDEX vim_delim_entries-index2.      &quot;#EC *
      ENDIF.
*******&quot;HCG HW664505 new index calcualtion for insert extract END*******
      ADD 1 TO maxlines.
      MOVE vim_delim_entries-index2 TO index_safe.
      LOOP AT vim_delim_entries WHERE index2 GE index_safe. &quot;#EC *
        IF vim_delim_entries-index2 EQ index_safe.
          CHECK vim_delim_entries-index_corr NE space.
        ENDIF.
        ADD 1 TO vim_delim_entries-index2.
        MODIFY vim_delim_entries.                           &quot;#EC *
      ENDLOOP.
    ENDLOOP.
    REFRESH vim_delim_entries.
  ENDFORM.                               &quot;after_temporal_delimitation.</include_source>
   </include>
   <include NAME="LSVIMF0T" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  X_CALL_SCREEN                                           *
*&amp;--------------------------------------------------------------------*
* external call of specified view maintenance screen                  *
*&amp;--------------------------------------------------------------------*
FORM X_CALL_SCREEN USING VALUE(XCS_SCREEN) LIKE D020S-DNUM.
  CALL SCREEN XCS_SCREEN.
ENDFORM.                               &quot;x_call_screen</include_source>
   </include>
   <include NAME="LSVIMF0U" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form X_CALL_VIEWMAINTENANCE                                   *
*&amp;--------------------------------------------------------------------*
* external call of view maintenance                                   *
*&amp;--------------------------------------------------------------------*
* --&gt; XCV_USE_LCL_TBL:  &apos;X&apos; Datencontainer XCV_TOTAL und XCV_EXTRACT
*                       sind nicht struktueriert und nicht vom Typ X
*                       =&gt; Daten müssen in lokale Container umgesetzt
*                       werden.
* --&gt; XCV_IMP_SPECMODE: &apos;P&apos; Profilimport/
*                       &apos;T&apos; Testmodus Import/&apos;F&apos; Forcemodus Import /
*                       &apos;B&apos; T + F Import
*&amp;--------------------------------------------------------------------*
FORM x_call_viewmaintenance USING
                                value(xcv_use_lcl_tbl) LIKE tvdir-flag
                                value(xcv_import) LIKE tvdir-flag
                                xcv_corrnbr LIKE e070-trkorr
                                value(xcv_fcode) TYPE vimty_tcode
                                value(xcv_action) LIKE tvdir-flag
                                value(xcv_name) TYPE vimty_tablename
                                value(xcv_tot_name) TYPE c
                                value(xcv_ext_name) TYPE c
                                value(xcv_upgr_dest) LIKE rfcdes-rfcdest
                                value(xcv_upgr_clnt) LIKE sy-mandt
                                xcv_upd_requ LIKE tvdir-flag
                                xcv_e071k TYPE table
                                xcv_dba_sel TYPE table
                                xcv_dpl_sel TYPE table
                                xcv_excufc TYPE table
                                xcv_extract TYPE table
                                xcv_total TYPE table
                                xcv_header TYPE table
                                xcv_namtab TYPE table
                                xcv_last_command TYPE vimty_tcode
                                xcv_last_act_entry LIKE sy-tabix
                                xcv_results LIKE vimmodres
                                xcv_imp_results TYPE slctr_tables_keys
                                value(xcv_imp_specmode) LIKE tvdir-flag
                                value(xcv_cmp_slcnds) LIKE tvdir-flag.

  DATA: xcv_return TYPE i, xcv_i_fcode TYPE vimty_tcode,                   &quot;#EC NEEDED
        line_name(30) TYPE c, length TYPE i, tabtype TYPE ob_typ,
        header_wa_loc TYPE vimdesc,
        BEGIN OF tabline,
          line(4096) TYPE c,
        END OF tabline.
  FIELD-SYMBOLS: &lt;total&gt; TYPE table, &lt;extract&gt; TYPE table,
                 &lt;tabline&gt; TYPE ANY, &lt;tabline_x&gt; TYPE x,
                 &lt;tabline2&gt; TYPE ANY, &lt;tabline2_x&gt; TYPE x,
                 &lt;header&gt; TYPE vimdesc.
  LOCAL: vim_import_mode_active, vim_no_dialog, vim_import_testmode,
         vim_import_forcemode.          &quot;SW  wg. Rekurs. im Cluster

  vim_no_dialog = xcv_import. TRANSLATE vim_no_dialog USING &apos;H DX&apos;.
  IF xcv_imp_specmode = &apos;P&apos;.           &quot;Profilimp
    vim_import_profile = &apos;X&apos;.
  ENDIF.
  vim_import_testmode = xcv_imp_specmode.
  TRANSLATE vim_import_testmode USING &apos;TXBXF P &apos;.
  vim_import_forcemode = xcv_imp_specmode.
  TRANSLATE vim_import_forcemode USING &apos;T BXFXP &apos;.
  IF xcv_use_lcl_tbl NE space.
    ASSIGN: (xcv_tot_name) TO &lt;total&gt;, (xcv_ext_name) TO &lt;extract&gt;.
    IF xcv_use_lcl_tbl NE &apos;L&apos;.         &quot;use not _only_ local tables
      READ TABLE xcv_header ASSIGNING &lt;header&gt; CASTING INDEX 1.
      IF &lt;header&gt;-bastab NE space AND &lt;header&gt;-texttbexst NE space.
        length = &lt;header&gt;-after_tabc + &lt;header&gt;-aft_txttbc
                 + 3 * cl_abap_char_utilities=&gt;charsize.
      ELSE.
        length = &lt;header&gt;-after_tabc
                 + 2 * cl_abap_char_utilities=&gt;charsize.
      ENDIF.
      SEARCH xcv_tot_name FOR &apos;[&apos; IN CHARACTER MODE.
      MOVE xcv_tot_name(sy-fdpos) TO line_name.
      ASSIGN: (line_name) TO &lt;tabline2&gt;,
              &lt;tabline2&gt; TO &lt;tabline2_x&gt; CASTING.
      REFRESH: &lt;total&gt;, &lt;extract&gt;.
      LOOP AT xcv_total ASSIGNING &lt;tabline&gt;.
        ASSIGN &lt;tabline&gt; TO &lt;tabline_x&gt; CASTING.
        MOVE &lt;tabline_x&gt; TO &lt;tabline2_x&gt;(length).
        APPEND &lt;tabline2&gt; TO &lt;total&gt;.
      ENDLOOP.
      LOOP AT xcv_extract ASSIGNING &lt;tabline&gt;.
        ASSIGN &lt;tabline&gt; TO &lt;tabline_x&gt; CASTING.
        MOVE &lt;tabline_x&gt; TO &lt;tabline2_x&gt;(length).
        APPEND &lt;tabline2&gt; TO &lt;extract&gt;.
      ENDLOOP.
*      &lt;total&gt; = xcv_total. &lt;extract&gt; = xcv_extract.
    ENDIF.
  ELSE.
    ASSIGN: xcv_total TO &lt;total&gt;, xcv_extract TO &lt;extract&gt;.
  ENDIF.
  vim_import_mode_active = xcv_import. xcv_i_fcode = xcv_fcode.
  IF xcv_import NE space AND xcv_fcode NE &apos;SAVE&apos;.
  ELSEIF xcv_import NE space AND xcv_fcode EQ &apos;SAVE&apos;.       &quot;SW
    imp_results[] = xcv_imp_results[].                      &quot;SW
  ELSEIF xcv_fcode EQ &apos;INS&apos; OR xcv_fcode EQ &apos;DEL&apos; OR
         xcv_fcode EQ &apos;UPD&apos; OR xcv_fcode EQ &apos;SHOW&apos;.
    vim_single_entry_function = xcv_fcode. xcv_i_fcode = &apos;EDIT&apos;.
  ENDIF.
  IF xcv_import EQ &apos;D&apos; AND xcv_fcode EQ &apos;SAVE&apos;.
    vim_import_no_message = &apos;X&apos;.
  ENDIF.
  CALL FUNCTION &apos;VIEW_MAINTENANCE_LOW_LEVEL&apos;
    EXPORTING
      corr_number                 = xcv_corrnbr
      fcode                       = xcv_i_fcode
      view_action                 = xcv_action
      view_name                   = xcv_name
      rfc_destination_for_upgrade = xcv_upgr_dest
      client_for_upgrade          = xcv_upgr_clnt
      complex_selconds_used       = xcv_cmp_slcnds
    IMPORTING
      last_act_entry              = xcv_last_act_entry
      ucomm                       = xcv_last_command
      update_required             = xcv_upd_requ
      corr_number                 = xcv_corrnbr
    TABLES
      corr_keytab                 = xcv_e071k
      dba_sellist                 = xcv_dba_sel
      dpl_sellist                 = xcv_dpl_sel
      excl_cua_funct              = xcv_excufc
      extract                     = &lt;extract&gt;
      total                       = &lt;total&gt;
      x_header                    = xcv_header
      x_namtab                    = xcv_namtab
    EXCEPTIONS
      function_not_found          = 1
      missing_corr_number         = 2
      no_value_for_subset_ident   = 3
      saving_correction_failed    = 4.
*  IF xcv_import NE space AND
*     ( sy-subrc NE 0 OR
*       xcv_fcode EQ save AND &lt;status&gt;-upd_flag NE space ).
* &quot;HCG BC-Set: sy-subrc NE 0 -&gt; always error message in log
  IF ( xcv_import NE space OR vim_import_profile NE space ) AND
     ( sy-subrc NE 0 OR
       xcv_fcode EQ save AND &lt;status&gt;-upd_flag NE space ).
    IF sy-msgid NE space.
      vim_import_no_message = &apos;X&apos;.
      IF vim_import_profile = &apos;X&apos;.
        READ TABLE xcv_header INTO header_wa_loc INDEX 1.
        IF header_wa_loc-bastab EQ space.
          tabtype = &apos;V&apos;.
        ELSE.
          tabtype = &apos;S&apos;.
        ENDIF.
        PERFORM vim_bc_process_message USING sy-msgid &apos;I&apos; &apos;E&apos; sy-msgno
                        sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 tabtype.
      ELSE.
        PERFORM vim_process_message USING sy-msgid &apos;I&apos; &apos;E&apos; sy-msgno
                       sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
      CLEAR vim_import_no_message.
    ENDIF.
*   IF XCV_IMPORT NE SPACE.
    LOOP AT imp_results.
      IF imp_results-import-inserted NE 0.
        imp_results-import-errors = imp_results-import-inserted.
        CLEAR imp_results-import-inserted.
      ELSEIF imp_results-import-updated NE 0.
        imp_results-import-errors = imp_results-import-updated.
        CLEAR imp_results-import-updated.
      ELSEIF imp_results-import-deleted NE 0.
        imp_results-import-errors = imp_results-import-deleted.
        CLEAR imp_results-import-deleted.
      ENDIF.
      MODIFY imp_results.
    ENDLOOP.
  ELSEIF xcv_import EQ space AND xcv_fcode EQ &apos;READ&apos; AND
         sy-subrc NE 0.                &quot;probably called by VIEW_GET_DATA
    IF sy-subrc EQ 2. &quot;probably individual authority check failed
      MESSAGE i053(sv) RAISING no_authority.
    ELSE.                              &quot;other error
      MESSAGE i037(sv) WITH view_name RAISING no_viewmaint_tool.
    ENDIF.
  ENDIF.
  IF xcv_fcode EQ &apos;EXED&apos; OR xcv_fcode EQ &apos;DEL&apos;.
    xcv_results = vim_results_of_ext_mod.
  ELSEIF xcv_fcode EQ read.
    DESCRIBE TABLE &lt;total&gt; LINES xcv_results-nbr_of_upd.
  ELSEIF xcv_fcode EQ save AND xcv_import EQ &apos;D&apos;.
    CLEAR vim_import_no_message.
  ENDIF.
  IF xcv_use_lcl_tbl NE space AND xcv_use_lcl_tbl NE &apos;L&apos;.
    REFRESH: xcv_total, xcv_extract.
    ASSIGN: tabline TO &lt;tabline2_x&gt; CASTING.
    LOOP AT &lt;total&gt; ASSIGNING &lt;tabline&gt;.
      ASSIGN &lt;tabline&gt; TO &lt;tabline_x&gt; CASTING.
      MOVE &lt;tabline_x&gt; TO &lt;tabline2_x&gt;(length).
      APPEND tabline TO xcv_total.
    ENDLOOP.
    LOOP AT &lt;extract&gt; ASSIGNING &lt;tabline&gt;.
      ASSIGN &lt;tabline&gt; TO &lt;tabline_x&gt; CASTING.
      MOVE &lt;tabline_x&gt; TO &lt;tabline2_x&gt;(length).
      APPEND tabline TO xcv_extract.
    ENDLOOP.
*    MOVE: &lt;total&gt; TO xcv_total, &lt;extract&gt; TO xcv_extract.
  ENDIF.
  CLEAR vim_single_entry_function.                          &quot;SW
  IF xcv_import NE space.
    xcv_imp_results = imp_results[].
    REFRESH imp_results.                                    &quot;SW
  ENDIF.
ENDFORM.                               &quot;x_call_viewmaintenance</include_source>
   </include>
   <include NAME="LSVIMF0V" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_RESTORE_LOCAL_MEMORY                                 *
*&amp;--------------------------------------------------------------------*
* restore local memory of function pool (for external call)           *
*&amp;--------------------------------------------------------------------*
FORM VIM_RESTORE_LOCAL_MEMORY.
  DATA: H_NAME(31) TYPE C VALUE &apos;*&apos;, H_STATE(30) VALUE &apos;STATUS_&apos;.

  VIEW_NAME = X_HEADER-VIEWNAME.
  IF X_HEADER-BASTAB EQ SPACE.
    H_NAME+1 = X_HEADER-MAINTVIEW. H_STATE+7 = X_HEADER-MAINTVIEW.
    ASSIGN: (X_HEADER-MAINTVIEW) TO &lt;TABLE1&gt;, (H_NAME) TO &lt;INITIAL&gt;,
            (H_STATE) TO &lt;STATUS&gt;.
  ENDIF.
  VIM_RESTORE_MODE = &apos;X&apos;.
  PERFORM INITIALISIEREN.
  VIEW_ACTION = &lt;STATUS&gt;-ST_ACTION. TRANSLATE VIEW_ACTION USING &apos;CUAU&apos;.
  PERFORM JUSTIFY_ACTION_MODE.
  MOVE: VIEW_ACTION TO MAINT_MODE,
        &lt;STATUS&gt;-CORR_NBR TO CORR_NBR,
        &lt;STATUS&gt;-FCODE TO FUNCTION.
  PERFORM CALL_DYNPRO.
ENDFORM.                               &quot;vim_restore_local_memory</include_source>
   </include>
   <include NAME="LSVIMF0W" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_APPEND_GLOBAL_TABLE                                  *
*&amp;--------------------------------------------------------------------*
* set global field value (for external call)                          *
*&amp;--------------------------------------------------------------------*
FORM VIM_APPEND_GLOBAL_TABLE USING VALUE(NAME_OF_TABLE) TYPE C
                                   VALUE(BASE_TABLE) LIKE TVDIR-FLAG
                                   VALUE(TABLEN) LIKE VIMDESC-TABLEN
                                   VALUE(ENTRY_TO_APPEND)
                                   VALUE(ACT_FLAG) LIKE TVDIR-FLAG
                                   VALUE(MRK_FLAG) LIKE TVDIR-FLAG
                                   VALUE(TXTACT_FLAG) LIKE TVDIR-FLAG
                                   VAGT_RETURN LIKE SY-SUBRC.
  DATA: WA(4096) TYPE C, DUM TYPE I.
  FIELD-SYMBOLS: &lt;TABLE&gt; TYPE TABLE, &lt;ENTRY&gt;.
  ASSIGN (NAME_OF_TABLE) TO &lt;TABLE&gt;.
  IF SY-SUBRC EQ 0.
    WA = ENTRY_TO_APPEND.
    WA+TABLEN(1) = ACT_FLAG. DUM = TABLEN + 1.
    WA+DUM(1) = MRK_FLAG. ADD 1 TO DUM.
    IF BASE_TABLE NE SPACE.
      WA+DUM(1) = TXTACT_FLAG. ADD 1 TO DUM.
    ENDIF.
    ASSIGN WA(DUM) TO &lt;ENTRY&gt;.
    APPEND &lt;ENTRY&gt; TO &lt;TABLE&gt;.
  ENDIF.
  VAGT_RETURN = SY-SUBRC.
ENDFORM.                               &quot;vim_append_globall_table</include_source>
   </include>
   <include NAME="LSVIMF0X" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_SET_GLOBAL_FIELD_VALUE                               *
*&amp;--------------------------------------------------------------------*
* set global field value (for external call)                          *
*&amp;--------------------------------------------------------------------*
FORM VIM_SET_GLOBAL_FIELD_VALUE USING VALUE(NAME_OF_FIELD_TO_SET) TYPE C
                                      VALUE(TYPE_OF_FIELD_TO_SET) TYPE C
                                      VALUE(VALUE_TO_SET)
                                      VSGFV_RETURN LIKE SY-SUBRC.

  FIELD-SYMBOLS: &lt;FIELD&gt;.
  ASSIGN (NAME_OF_FIELD_TO_SET) TO &lt;FIELD&gt; TYPE TYPE_OF_FIELD_TO_SET.
  IF SY-SUBRC EQ 0.
    &lt;FIELD&gt; = VALUE_TO_SET.
  ENDIF.
  VSGFV_RETURN = SY-SUBRC.
ENDFORM.                               &quot;vim_set_global_field_value</include_source>
   </include>
   <include NAME="LSVIMF0Y" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_GET_GLOBAL_FIELD_VALUE                               *
*&amp;--------------------------------------------------------------------*
* get global field value (for external call)                          *
*&amp;--------------------------------------------------------------------*
FORM vim_get_global_field_value USING value(name_of_field_to_get) TYPE c
                                      value(type_of_field_to_get) TYPE c
                                      field_value
                                      vggfv_return LIKE sy-subrc.

  FIELD-SYMBOLS: &lt;field&gt; TYPE ANY.
  ASSIGN (name_of_field_to_get) TO &lt;field&gt;
   CASTING TYPE (type_of_field_to_get).
  IF sy-subrc EQ 0.
    field_value = &lt;field&gt;.
  ENDIF.
  vggfv_return = sy-subrc.
ENDFORM.                               &quot;vim_get_global_field_value</include_source>
   </include>
   <include NAME="LSVIMF0Z" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_GET_GLOBAL_TABLE                                     *
*&amp;--------------------------------------------------------------------*
* get global field table (for external call)                          *
*&amp;--------------------------------------------------------------------*
FORM vim_get_global_table USING value(name_of_table_to_get) TYPE c
                                table_out TYPE ANY TABLE
                                vggt_return LIKE sy-subrc.

  FIELD-SYMBOLS: &lt;table&gt; TYPE ANY TABLE.
  ASSIGN (name_of_table_to_get) TO &lt;table&gt;.
  IF sy-subrc EQ 0.                                         &quot;#EC PF_ACT_GLO
    table_out = &lt;table&gt;.
  ENDIF.
  vggt_return = sy-subrc.
ENDFORM.                               &quot;vim_get_global_field_value</include_source>
   </include>
   <include NAME="LSVIMF10" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  LISTE_EXIT_COMMAND                                      *
*&amp;--------------------------------------------------------------------*
* handle exit commands on list screen                                 *
*&amp;--------------------------------------------------------------------*
FORM LISTE_EXIT_COMMAND.
  CASE OK_CODE.
    WHEN &apos;ABR &apos;.
      FUNCTION = OK_CODE.
      CLEAR OK_CODE.
      CASE VIM_SPECIAL_MODE.
        WHEN VIM_REPLACE.
          CLEAR VIM_ACT_DYNP_VIEW. SET SCREEN 0. LEAVE SCREEN.
        WHEN VIM_DELETE.
          SET SCREEN 0. LEAVE SCREEN.
        WHEN VIM_UPGRADE.
*         CLEAR: VIM_SPECIAL_MODE, MAXLINES. LEAVE SCREEN.
          CLEAR VIM_ACT_DYNP_VIEW. NEUER = &apos;N&apos;.
          SET SCREEN 0. LEAVE SCREEN.
        WHEN OTHERS.
          PERFORM LISTE_ABBRECHEN.
      ENDCASE.
    WHEN &apos;IGN &apos;.
      CASE VIM_SPECIAL_MODE.
        WHEN VIM_REPLACE.
          CLEAR VIM_ACT_DYNP_VIEW. SET SCREEN 0. LEAVE SCREEN.
        WHEN VIM_DELETE.
          SET SCREEN 0. LEAVE SCREEN.
*       WHEN VIM_UPGRADE.  &quot;impossible
*         CLEAR OK_CODE. LEAVE SCREEN.
        WHEN VIM_UPGRADE.
          CLEAR VIM_ACT_DYNP_VIEW. NEUER = &apos;N&apos;.
          SET SCREEN 0. LEAVE SCREEN.
        WHEN OTHERS.
          LOOP AT SCREEN.
            SCREEN-ACTIVE = 0.
            MODIFY SCREEN.
          ENDLOOP.
      ENDCASE.
      NEUER = &apos;N&apos;.
      CLEAR &lt;STATUS&gt;-UPD_FLAG.
  ENDCASE.
ENDFORM.                               &quot;liste_exit_command.</include_source>
   </include>
   <include NAME="LSVIMF11" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BEFORE_LEAVING_FRAME_FUNCTION.                          *
*&amp;--------------------------------------------------------------------*
* do all the things necessary before leaving the frame function unit  *
*&amp;--------------------------------------------------------------------*
FORM before_leaving_frame_function
                        USING value(exit_form) LIKE vimdesc-frm_bf_end.

  DATA: prc TYPE sy-subrc, dummy TYPE c, dummi TYPE i.                   &quot;#EC NEEDED

  IF &lt;status&gt;-corr_enqud NE space.
    CALL FUNCTION &apos;DEQUEUE_E_TRKORR&apos;
      EXPORTING
        trkorr = &lt;status&gt;-corr_nbr.
*             X_TRKORR = E02.
    CLEAR &lt;status&gt;-corr_enqud.
  ENDIF.
  CLEAR &lt;status&gt;-corr_nbr.
  CLEAR &lt;status&gt;-order_nbr.                    &quot; Note 1483942 PATIDARP
  CLEAR &lt;status&gt;-initializd.
  CLEAR &lt;initial&gt;. &lt;vim_client_initial&gt; = sy-mandt.
  IF ( maint_mode EQ anzeigen OR maint_mode EQ transportieren ) AND
     vim_corr_obj_viewname NE space.
    CLEAR vim_corr_obj_viewname.
  ENDIF.
  PERFORM vim_reset_texttab USING view_name.        &quot;SW Texttransl
  CALL FUNCTION &apos;VIEW_RESET_LANGUAGES&apos;.&quot;SW Texttransl
  CLEAR: als_active, als_enabled, als_langus_selected. &quot;Clear ALS flags
  REFRESH als_sel_langus.
  IF exit_form NE space.
    PERFORM (exit_form) IN PROGRAM.
  ENDIF.
  CLEAR function.
  FREE vim_bc_entry_list.
  CLEAR vim_actlinks.
  CLEAR: &lt;status&gt;-bcfixnochg, vim_bc_chng_allowed,
         &lt;status&gt;-bcfixdelinfosent.
** test getting profiles: begin
*  IF SY-UNAME = &apos;FRENZELU&apos; OR SY-UNAME = &apos;ROSENTHAL&apos;    &quot;UF Profile
*   OR SY-UNAME = &apos;BUEHLERM&apos;.
*    CALL FUNCTION &apos;SCPR_MEMORY_DELETE&apos;.
*  ENDIF.
** test getting profiles: end
  CLEAR vim_oc_inst.
*  refresh vim_dba_sel_kept.                              &quot;UF210200
*delete after_nonkey flag in check_range.
  PERFORM check_range IN PROGRAM saplsvix
             USING space 0 &apos;E&apos; space space space
             CHANGING dummy prc.
ENDFORM.                               &quot;before_leaving_frame_function</include_source>
   </include>
   <include NAME="LSVIMF12" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  BEFORE_LEAVING_EXT                                      *
*&amp;--------------------------------------------------------------------*
* do all the things necessary before leaving - external call          *
*&amp;--------------------------------------------------------------------*
FORM BEFORE_LEAVING_EXT USING VALUE(VIEWNAME) LIKE VIMDESC-VIEWNAME
                              VALUE(MAINTVIEW) LIKE VIMDESC-MAINTVIEW
                              VALUE(EXIT_FORM) LIKE VIMDESC-FRM_BF_END.
* START OF CHANGE DUTTAN 13.01.2009
* Incresing the length of variable NAME.
*  DATA: NAME(20) TYPE C VALUE &apos;STATUS_&apos;.
  DATA: NAME(40) TYPE C VALUE &apos;STATUS_&apos;.
* END OF CHANGE.
  FIELD-SYMBOLS: &lt;BLE_STATUS&gt;.

  ASSIGN &lt;STATUS&gt; TO &lt;BLE_STATUS&gt;.
* NAME+7 = VIEWNAME.
  NAME+7 = MAINTVIEW.                  &quot;Subviews
  ASSIGN (NAME) TO &lt;STATUS&gt;.
  IF VIM_CORR_OBJ_VIEWNAME NE VIEWNAME.
    CLEAR MAINT_MODE.
  ELSE.
    MAINT_MODE = &lt;STATUS&gt;-ST_ACTION.
  ENDIF.
  PERFORM BEFORE_LEAVING_FRAME_FUNCTION USING EXIT_FORM.
  ASSIGN &lt;BLE_STATUS&gt; TO &lt;STATUS&gt;.
ENDFORM.                               &quot;before_leaving_ext</include_source>
   </include>
   <include NAME="LSVIMF13" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form AFTER_SAVING                                             *
*&amp;--------------------------------------------------------------------*
* process after-treatment of saving                                   *
*&amp;--------------------------------------------------------------------*
FORM after_saving.
  DATA: dummy.
  DATA  e071_loctab TYPE vim_ko200_tab_type.

  IF x_header-texttbexst &lt;&gt; space AND  &quot;SW Texttransl ..
     vim_abort_saving EQ space.
    IF x_header-frm_tl_upd NE space.
      PERFORM (x_header-frm_tl_upd) IN PROGRAM.
    ELSE.
      PERFORM vim_texttab_db_update.
    ENDIF.
  ENDIF.                               &quot;.. TEXTTRANSL
  IF vim_abort_saving = space AND vim_called_by_cluster = space.
    PERFORM vim_add_img_notices_pai USING &apos;S&apos;
                                    CHANGING dummy.
  ENDIF.
  IF x_header-frm_af_sav NE space.
    PERFORM (x_header-frm_af_sav) IN PROGRAM.
  ENDIF.
*    Call synchronizer
  IF vim_abort_saving EQ space.
    REFRESH e071_loctab.
    APPEND e071 TO e071_loctab.
    PERFORM vim_synchronizer_call
                  USING e071_loctab[]
                        corr_keytab[]
                        &apos;X&apos;.
  ENDIF.
  IF &lt;status&gt;-selected CO &apos;NUD&apos;.
    CLEAR &lt;status&gt;-selected.
  ENDIF.
  IF vim_abort_saving = space AND vim_import_profile NE space.
* build up BC-Set import log
    PERFORM vim_bc_logs_put CHANGING vim_bc_entry_list.
  ENDIF.
  CLEAR vim_abort_saving.
* log end of database changes
  CALL FUNCTION &apos;VIEW_WRITE_CHANGELOG_HEADER&apos;
    EXPORTING
      viewname = x_header-viewname
      bastab   = x_header-bastab
      begin    = space
      clidep   = x_header-clidep.
  TRANSLATE vim_adjust_middle_level_mode USING &apos;XLSL&apos;.
ENDFORM.                               &quot;after_saving</include_source>
   </include>
   <include NAME="LSVIMF14" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form PREPARE_SAVING                                           *
*&amp;--------------------------------------------------------------------*
* prepare saving of changed data in data base                         *
*&amp;--------------------------------------------------------------------*
* &lt;-- SY-SUBRC: 0 - ok, save, others: - don&apos;t save                    *
* SY-SUBRC soll abgelöst werden durch:
* &lt;-- VIM_ABORT_SAVING: space -&gt; save, others -&gt; don&apos;t save
*&amp;--------------------------------------------------------------------*
FORM prepare_saving.
  DATA: rc LIKE sy-subrc,
        ps_addr_ref LIKE addr_ref,
        ps_transp_addrs(1) TYPE c,
        ps_e071k_tab LIKE e071k OCCURS 0,
        ps_tot_ix TYPE i,
        ps_ko200 LIKE ko200,
        ps_addrrc LIKE szad_field-returncode,                      &quot;#EC NEEDED
        ps_ko200_tab LIKE ko200 OCCURS 0, addr_e071 LIKE e071,
        addr_e071k LIKE e071k, dummy TYPE char1,                   &quot;#EC NEEDED
        ps_addr_errtab LIKE addr_error OCCURS 0 WITH HEADER LINE,  &quot;#EC NEEDED
        new_addr_group TYPE ad_group, object_key TYPE ad_objkey,
        handle_c TYPE ad_handle.
  DATA  e071_loctab TYPE vim_ko200_tab_type.

  FIELD-SYMBOLS: &lt;object_key_x&gt; TYPE x, &lt;addr_key&gt; TYPE x,
                 &lt;handle_x&gt; TYPE x.

  IF vim_adjust_middle_level_mode EQ subset.
    x_header[] = vim_adj_header.
    READ TABLE x_header INDEX 1.
    x_namtab[] = vim_adj_namtab.
  ENDIF.
  CLEAR vim_abort_saving.
  IF &lt;status&gt;-upd_checkd EQ space.
    PERFORM check_upd.
  ENDIF.
  IF &lt;status&gt;-upd_flag NE space.
    IF maint_mode EQ aendern.
      CLEAR sy-subrc.
      IF x_header-frm_bf_sav NE space.
        PERFORM (x_header-frm_bf_sav) IN PROGRAM.
*       CHECK SY-SUBRC EQ 0. &quot;if sy-subrc ne 0 don&apos;t save -&gt; exit
        IF sy-subrc &lt;&gt; 0 OR vim_abort_saving NE space.
          vim_abort_saving = &apos;X&apos;. sy-subrc = 8.
          EXIT.
        ENDIF.
      ENDIF.
      IF x_header-texttbexst &lt;&gt; space.
        PERFORM vim_set_texttab_action_delete.          &quot;SW Texttransl
      ENDIF.
      IF vim_client_state IS INITIAL OR
       ( vim_called_by_cluster &lt;&gt; space AND       &quot;SW  CSS 80009987/1998
          vim_client_state = vim_noact ).
        CALL FUNCTION &apos;VIEW_GET_CLIENT_STATE&apos;
          IMPORTING
            transp_state = vim_client_state.
      ENDIF.
    ENDIF.
    PERFORM vim_bc_logs_maintain USING x_header
                                       vim_import_profile
                                 CHANGING vim_bc_entry_list.
   IF ( vim_no_dialog EQ space OR vim_import_mode_active NE space ) AND
        ( vim_client_state EQ vim_log OR maint_mode EQ transportieren ).
      IF corr_nbr NE space AND corr_nbr NE &lt;status&gt;-corr_nbr.
        &lt;status&gt;-corr_nbr = corr_nbr.
      ENDIF.
      IF maint_mode EQ transportieren.
        IF &lt;status&gt;-corr_nbr EQ space.
          PERFORM request_corr_number.
          IF x_header-flag NE vim_transport_denied AND
             vim_actopts-transp_off NE bc_transport_denied AND
             &lt;status&gt;-l_corr_nbr NE &lt;status&gt;-corr_nbr.
            PERFORM prepare_corr.
          ENDIF.
        ENDIF.
      ELSE.
        PERFORM check_transp_objs_for_maint USING rc.
        IF rc NE 0.
          RAISE missing_corr_number.
        ENDIF.
        IF x_header-flag NE vim_transport_denied AND
           vim_actopts-transp_off NE bc_transport_denied.
          PERFORM prepare_corr.
          PERFORM update_corr.
        ENDIF.
      ENDIF.
      PERFORM corr_upd.
*    elseif not VIM_BC_ENTRY_LIST is initial.
* fill corr_keytab for bc-set import log
*      perform vim_bc_fill_corr_keytab.
    ENDIF.
    IF vim_import_testmode NE space.   &quot;testrun for import
      CLEAR &lt;status&gt;-upd_flag.         &quot;do not save if testrun happens
      vim_import_no_message = &apos;X&apos;.
      PERFORM vim_process_message USING &apos;SV&apos; &apos;I&apos; &apos;I&apos; &apos;154&apos;
                                        space space space space.
      CLEAR vim_import_no_message.
    ELSE.
* log begin of database changes
      CALL FUNCTION &apos;VIEW_WRITE_CHANGELOG_HEADER&apos;
        EXPORTING
          viewname = x_header-viewname
          bastab   = x_header-bastab
          begin    = &apos;X&apos;
          clidep   = x_header-clidep.
* save addresses.
      IF x_header-adrnbrflag EQ &apos;N&apos;.   &quot;only new technique
        ASSIGN: object_key TO &lt;object_key_x&gt; CASTING,
                ps_addr_ref-appl_key TO &lt;addr_key&gt; CASTING.
        IF ( maint_mode EQ transportieren OR
             vim_client_state EQ vim_log ) AND
           x_header-flag NE vim_transport_denied AND
           vim_actopts-transp_off NE bc_transport_denied.
          IF x_header-flag EQ space.   &quot;standard logging required
            LOOP AT vim_addr_e071_tab INTO addr_e071.
              addr_e071-trkorr = &lt;status&gt;-corr_nbr.
              MODIFY vim_addr_e071_tab FROM addr_e071.
              ps_ko200 = addr_e071.
              APPEND ps_ko200 TO ps_ko200_tab.
            ENDLOOP.
            ps_transp_addrs = &apos;X&apos;.
          ENDIF.
        ENDIF.
        LOOP AT vim_addresses_to_save
                                  WHERE viewname EQ x_header-viewname.
*          &lt;f1_x&gt; = vim_addresses_to_save-handle.
          &lt;f1_x&gt; = &lt;vim_addr_handle_x&gt;.
          READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.   &quot;#EC WARNOK
          ps_tot_ix = sy-tabix.
          object_key = vim_addresses_to_save-handle.
          IF &lt;action&gt; NE geloescht AND &lt;action&gt; NE neuer_geloescht AND
             &lt;action&gt; NE update_geloescht.
* save adress
            REFRESH ps_e071k_tab.
            APPEND LINES OF vim_addr_e071k_tab TO ps_e071k_tab.
            IF vim_addresses_to_save-addrnumber CP &apos;@NEW*&apos;.
* new address
              ps_addr_ref-appl_table = vim_tsadrv-tablename.
              ps_addr_ref-appl_field = vim_tsadrv-fieldname.
              ps_addr_ref-appl_key   = object_key.
              ps_addr_ref-addr_group = vim_addr_group.
              ps_addr_ref-owner = &apos;X&apos;.

* Start Note 1482993 PATIDARP
              IF addr_comp = &apos;X&apos;.
                ASSIGN vim_addresses_to_save-handle TO &lt;handle_x&gt; CASTING.
                handle_c = &lt;handle_x&gt;(140).
              ELSE.
                handle_c = vim_addresses_to_save-handle.
              ENDIF.
*              CLEAR addr_comp.                         n1531106
* End  Note 1482993 PATIDARP
              CALL FUNCTION &apos;ADDR_NUMBER_GET&apos;
                   EXPORTING
                       address_handle    = handle_c                   &quot; Note 1482993 PATIDARP
                        address_reference = ps_addr_ref
*                     PERSONAL_ADDRESS           = &apos; &apos;
*                     NUMBERRANGE_NUMBER         = &apos;01&apos;
                        generate_transport_entries = ps_transp_addrs
*                     OWNER                      = &apos;X&apos;
                        table_name  = vim_addr_basetable
                        field_name  = vim_addr_bastab_field
                        objkey      = object_key
                   IMPORTING
                      address_number = vim_addresses_to_save-addrnumber
*                     RETURNCODE_NUMBERRANGE     =
                   TABLES
                        e071k_tab                  = ps_e071k_tab
                   EXCEPTIONS
                        address_handle_not_exist   = 1
                        internal_error             = 2
                        parameter_error            = 3.
              IF sy-subrc NE 0.
                MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                           sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
                RAISE saving_correction_failed.
              ENDIF.
            ELSE.
* existing address
              IF ps_transp_addrs NE space.
                CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
                  EXPORTING
                    addrnumber = vim_addresses_to_save-addrnumber
                    table_name = vim_addr_basetable
                    field_name = vim_addr_bastab_field
                    objkey     = object_key
                  TABLES
                    e071k_tab  = ps_e071k_tab.
              ENDIF.
            ENDIF.                       &quot;new address
          &lt;vim_total_address_number&gt; = vim_addresses_to_save-addrnumber.
            TRANSLATE &lt;action&gt; USING &apos; U&apos;.
            READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;    &quot;#EC WARNOK
                               TRANSPORTING NO FIELDS.
            IF sy-subrc EQ 0.
              extract = total. MODIFY extract INDEX sy-tabix.
            ENDIF.
            MODIFY total INDEX ps_tot_ix.
            IF ps_transp_addrs NE space.
              CALL FUNCTION &apos;VIM_TR_OBJECTS_INSERT&apos;
                EXPORTING
                  WI_ORDER                      = &lt;status&gt;-order_nbr
*               IMPORTING
*                 WE_ORDER                      =
*                 WE_TASK                       =
                TABLES
                  wt_ko200                      = ps_ko200_tab
                  WT_E071K                      = ps_e071k_tab
                EXCEPTIONS
                  OTHERS                        = 8
                        .
*              IF sy-subrc &lt;&gt; 0.
** Implement suitable error handling here
*              ENDIF.

*              CALL FUNCTION &apos;TR_OBJECTS_INSERT&apos;
*                EXPORTING
*                  wi_order = &lt;status&gt;-order_nbr
*                TABLES
*                  wt_ko200 = ps_ko200_tab
*                  wt_e071k = ps_e071k_tab
*                EXCEPTIONS
*                  OTHERS   = 8.
              IF sy-subrc NE 0.
                MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                           sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
                RAISE saving_correction_failed.
              ENDIF.
            ENDIF.
            CALL FUNCTION &apos;ADDR_SINGLE_SAVE&apos;
                 EXPORTING
                    address_number         = &lt;vim_total_address_number&gt;
*                   PERSON_NUMBER          = &apos; &apos;
*                   ADDRESS_TYPE           = 1
*                   EXECUTE_IN_UPDATE_TASK = &apos; &apos;
                 EXCEPTIONS
                      address_not_exist      = 1
                      person_not_exist       = 2
                      address_number_missing = 3
                      reference_missing      = 4
                      internal_error         = 5
                      database_error         = 6
                      parameter_error        = 7.
            IF sy-subrc NE 0.
              MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                         sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
              RAISE saving_correction_failed.
            ENDIF.
            CALL FUNCTION &apos;ADDR_DEQUEUE&apos;
              EXPORTING
                address_number    = &lt;vim_total_address_number&gt;
              EXCEPTIONS                                    &quot;#EC FB_RC
                address_not_exist = 1
                internal_error    = 2
                OTHERS            = 3.
          ELSEIF &lt;action&gt; EQ neuer_geloescht.
* reset address (UF557286/2000)
            CALL FUNCTION &apos;ADDR_SINGLE_RESET&apos;
              EXPORTING
                address_handle         = vim_addresses_to_save-handle
              EXCEPTIONS
*               NUMBER_NOT_FOUND       = 1
*               HANDLE_NOT_FOUND       = 2
*               PARAMETER_ERROR        = 3
                internal_error         = 1
                OTHERS                 = 0.
            IF sy-subrc = 1.
              MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ENDIF.
          ENDIF.
          DELETE vim_addresses_to_save.
        ENDLOOP.                       &quot;at vim_addresses to save.
* Delete addresses (temporary: put address into address-groups CADE or
* ZADE)
        IF vim_addr_group = &apos;CA01&apos;.
          new_addr_group = &apos;CADE&apos;.
        ELSEIF vim_addr_group = &apos;ZA01&apos;.
          new_addr_group = &apos;ZADE&apos;.
        ENDIF.
        IF NOT new_addr_group IS INITIAL.
          LOOP AT total.
            CHECK
             ( &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ update_geloescht )
             AND &lt;vim_total_address_number&gt; NP &apos;@NEW*&apos;.
            &lt;object_key_x&gt; = &lt;f1_x&gt;.
            IF ps_transp_addrs NE space.
              REFRESH ps_e071k_tab.
              APPEND LINES OF vim_addr_e071k_tab TO ps_e071k_tab.
              CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
                EXPORTING
                  addrnumber = &lt;vim_total_address_number&gt;
                  table_name = vim_addr_basetable
                  field_name = vim_addr_bastab_field
                  objkey     = object_key
                TABLES
                  e071k_tab  = ps_e071k_tab.
              CALL FUNCTION &apos;TR_OBJECTS_INSERT&apos;
                EXPORTING
                  wi_order = &lt;status&gt;-order_nbr
                TABLES
                  wt_ko200 = ps_ko200_tab
                  wt_e071k = ps_e071k_tab
                EXCEPTIONS
                  OTHERS   = 8.
              IF sy-subrc NE 0.
                MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                           sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
                RAISE saving_correction_failed.
              ENDIF.
            ENDIF.
*            PS_ADDR_REF-APPL_TABLE = vim_tsadrv-TABLENAME.
*            PS_ADDR_REF-APPL_FIELD = vim_tsadrv-FIELDNAME.
*            PS_ADDR_REF-APPL_KEY   = &lt;VIM_TOTAL_KEY&gt;.
*            PS_ADDR_REF-ADDR_GROUP = VIM_ADDR_GROUP.
*            PS_ADDR_REF-OWNER = &apos;X&apos;.
*            CALL FUNCTION &apos;ADDR_DELETE&apos;
*                 EXPORTING
**                   ADDRESS_HANDLE      = &apos; &apos;
*                      ADDRESS_NUMBER      = &lt;VIM_TOTAL_ADDRESS_NUMBER&gt;
*                      ADDRESS_REFERENCE   = PS_ADDR_REF
**                   DATE_FROM           = &apos;00010101&apos;
*                 IMPORTING
*                      RETURNCODE          = PS_ADDRRC
*                 TABLES
*                      ERROR_TABLE         = PS_ADDR_ERRTAB
*                 EXCEPTIONS
*                      ADDRESS_NOT_EXIST   = 1
*                      PARAMETER_ERROR     = 2
*                      INTERNAL_ERROR      = 3
*                      REFERENCE_NOT_EXIST = 4.
*            IF SY-SUBRC NE 0.
            IF NOT &lt;vim_total_address_number&gt; IS INITIAL.
              CALL FUNCTION &apos;ADDR_GROUP_CHANGE&apos;
                   EXPORTING
                        address_number    = &lt;vim_total_address_number&gt;
*                    ADDRESS_HANDLE    = &apos; &apos;
                        new_address_group = new_addr_group
                   EXCEPTIONS
                        address_not_exist = 1
                        parameter_error   = 2
                        internal_error    = 3
                        OTHERS            = 4.
              IF sy-subrc = 1.
              ELSEIF sy-subrc = 2.
                MESSAGE i298(am) WITH new_addr_group.
*   Adreßgruppe &amp; nicht definiert, Löschvormerkung für Adresse nicht mög
                RAISE saving_correction_failed.
              ELSEIF sy-subrc &lt;&gt; 0.
                MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
                RAISE saving_correction_failed.
              ENDIF.
*            ENDIF.
*            IF PS_ADDRRC NE SPACE.
*              LOOP AT PS_ADDR_ERRTAB.
*                MESSAGE ID PS_ADDR_ERRTAB-MSG_ID TYPE &apos;I&apos;
*                        NUMBER PS_ADDR_ERRTAB-MSG_NUMBER WITH
*                        PS_ADDR_ERRTAB-MSG_VAR1 PS_ADDR_ERRTAB-MSG_VAR2
*                       PS_ADDR_ERRTAB-MSG_VAR3 PS_ADDR_ERRTAB-MSG_VAR4.
*              ENDLOOP.
*              IF PS_ADDRRC EQ &apos;E&apos;.
*                RAISE SAVING_CORRECTION_FAILED.
*              ENDIF.
*            ENDIF.
              CALL FUNCTION &apos;ADDR_SINGLE_SAVE&apos;
                   EXPORTING
                    address_number         = &lt;vim_total_address_number&gt;
*                   PERSON_NUMBER          = &apos; &apos;
*                   ADDRESS_TYPE           = 1
*                   EXECUTE_IN_UPDATE_TASK = &apos; &apos;
                   EXCEPTIONS
                        address_not_exist      = 1
                        person_not_exist       = 2
                        address_number_missing = 3
                        reference_missing      = 4
                        internal_error         = 5
                        database_error         = 6
                        parameter_error        = 7.
              IF sy-subrc NE 0 AND  sy-subrc NE 1.
                MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                           sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
                RAISE saving_correction_failed.
              ENDIF.
            ENDIF.            &quot;not &lt;vim_total_address_number&gt; is initial
          ENDLOOP.                                          &quot;at total
        ENDIF.                         &quot;new_addr_group not initial
        CLEAR sy-subrc.
      ENDIF.                           &quot;x_header-adrnbrflag eq &apos;N&apos;.
    ENDIF.                             &quot;vim_import_testmode ne space.
  ELSE.
    IF vim_adjust_middle_level_mode EQ space.
      MESSAGE s043(sv).
      IF function = save AND vim_called_by_cluster = space.
        PERFORM vim_add_img_notices_pai USING &apos;S&apos;
                                        CHANGING dummy.
      ENDIF.
    ELSE.
      vim_adjust_middle_level_mode = &apos;L&apos;.
    ENDIF.
  ENDIF.                               &quot;&lt;status&gt;-upd_flag ne space
  IF maint_mode EQ transportieren.
* call synchronizer also for transp mode &quot;HCG int. message 1832131/2003
* after saving not processed in this case.
    REFRESH e071_loctab.
    APPEND e071 TO e071_loctab.
    PERFORM vim_synchronizer_call
                  USING e071_loctab[]
                        corr_keytab[]
                        &apos;X&apos;.
  ENDIF.
ENDFORM.                               &quot;prepare_saving</include_source>
   </include>
   <include NAME="LSVIMF15" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  MOVE_EXTRACT_TO_VIEW_WA                                 *
*&amp;--------------------------------------------------------------------*
* move EXTRACT entry to view-/table-/texttable-workarea               *
*&amp;--------------------------------------------------------------------*
FORM move_extract_to_view_wa.

  MOVE &lt;vim_extract_struc&gt; TO &lt;table1&gt;.
*  MOVE EXTRACT TO &lt;TABLE1&gt;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
*    MOVE &lt;extract_text&gt; TO &lt;table1_text&gt;.
    MOVE &lt;vim_xextract_text&gt; TO &lt;table1_xtext&gt;.
  ENDIF.
ENDFORM.                               &quot;move_extract_to_view_wa.</include_source>
   </include>
   <include NAME="LSVIMF16" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_IMP_CALL_SCREEN                                      *
*&amp;--------------------------------------------------------------------*
* ...                                                                 *
*&amp;--------------------------------------------------------------------*
FORM vim_imp_call_screen USING vics_screen LIKE d020s-dnum.
  DATA: program LIKE sy-repid, import_action LIKE sy-msgv4,
        key_safe1 LIKE sy-msgv1, key_safe2 LIKE sy-msgv2,
        key_safe3 LIKE sy-msgv3, key_safe TYPE vim_tabkey_c,
        vics_xkeylen TYPE i.           &quot;, vics_int_entsafe(4096) TYPE c.
  LOCAL: imp_results.                  &quot;SW  wg. rek. Aufruf im Cluster

  FIELD-SYMBOLS: &lt;res_tabkey&gt; TYPE x, &lt;errkey&gt; TYPE x.

  ASSIGN: imp_results-tabkey TO &lt;res_tabkey&gt; CASTING,
          vim_profile_errorkey TO &lt;errkey&gt; CASTING.
  CLEAR vim_view_wax.
  IF vim_import_mode_active NE space.
*    VICS_INT_ENTSAFE = &lt;TABLE1&gt;.
    &lt;table1_wax&gt; = &lt;table1_x&gt;.
    PERFORM vim_set_impres_header.
    PERFORM vim_convert_tabkey USING &lt;f1_x&gt; key_safe vics_xkeylen.
*    imp_results-tabkey = &lt;f1&gt;.
    &lt;res_tabkey&gt; = &lt;f1_x&gt;.
    key_safe1 = key_safe.
    IF vics_xkeylen GT 50.
      key_safe2 = key_safe+50.
      IF vics_xkeylen GT 100.
        key_safe3 = key_safe+100.
      ENDIF.
    ENDIF.
    IF vim_called_by_cluster = &apos;X&apos;.                         &quot;SW
      CONCATENATE &apos;(&apos; view_name &apos;)&apos; INTO key_safe3.         &quot;SW
    ENDIF.                                                  &quot;SW
    IF status-action EQ hinzufuegen.
      import_action = &apos;INS&apos;.
    ELSEIF function EQ &apos;DELE&apos;.
      import_action = &apos;DEL&apos;.
    ELSEIF status-action EQ aendern.
      import_action = &apos;UPD&apos;.
    ENDIF.
    CLEAR: imp_results-import, vim_last_logged_message.
    IF vim_import_profile = &apos;X&apos;.
*      vim_profile_errorkey = &lt;f1&gt;.
      &lt;errkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
    ELSE.
      vim_import_no_message = &apos;X&apos;.
      PERFORM vim_process_message USING &apos;SV&apos; &apos;S&apos; &apos;S&apos; &apos;150&apos; key_safe1
                                      key_safe2 key_safe3 import_action.
    ENDIF.
  ENDIF.
  IF vim_import_mode_active EQ space OR vim_no_dialog EQ space.
    CALL SCREEN vics_screen.
  ELSE.
    program = sy-repid. CLEAR vim_import_no_message.
    CALL FUNCTION &apos;VIEW_CALL_SCREEN&apos;
         EXPORTING
              screen_number = vics_screen
              program       = program
         EXCEPTIONS
              error_message = 1.
    IF sy-subrc NE 0.
      CLEAR vim_act_dynp_view.
      IF vim_last_logged_message-id NE sy-msgid OR
         vim_last_logged_message-nbr NE sy-msgno.
        vim_import_no_message = &apos;X&apos;.
        PERFORM vim_process_message USING sy-msgid sy-msgty sy-msgty
                                          sy-msgno sy-msgv1 sy-msgv2
                                          sy-msgv3 sy-msgv4.
      ENDIF.
      IF vim_import_forcemode EQ space.
        ok_code = &apos;IGN &apos;. neuer = &apos;N&apos;.
      ELSE.                            &quot;force mode
*        &lt;table1&gt; = vics_int_entsafe.
        &lt;table1_x&gt; = &lt;table1_wax&gt;.
        CASE import_action.
          WHEN &apos;UPD&apos;.
            &lt;status&gt;-upd_flag = &apos;X&apos;. neuer = &apos;N&apos;.
            PERFORM update_tab.
          WHEN &apos;INS&apos;.
            &lt;status&gt;-upd_flag = &apos;X&apos;. neuer = &apos;J&apos;.
            PERFORM update_tab.
          WHEN &apos;DEL&apos;.
            READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH  &quot;#EC WARNOK
                                             TRANSPORTING NO FIELDS.
            IF sy-subrc EQ 0.
              PERFORM logical_delete_from_total USING sy-tabix.
            ENDIF.
        ENDCASE.
      ENDIF.
    ENDIF.
    IF vim_import_profile = &apos;X&apos;.
      CLEAR vim_profile_errorkey.
    ELSE.
      vim_import_no_message = &apos;X&apos;.
      PERFORM vim_process_message USING &apos;SV&apos; &apos;S&apos; &apos;S&apos; &apos;151&apos; key_safe1
                                      key_safe2 key_safe3 import_action.
    ENDIF.
    CLEAR vim_import_no_message.
  ENDIF.
  IF vim_import_mode_active NE space.
    IF ok_code EQ &apos;IGN &apos; OR function EQ &apos;ABR &apos;. &quot;error
      imp_results-import-errors = 1.
    ENDIF.
    IF ok_code NE &apos;IGN&apos; AND function NE &apos;ABR&apos; OR
       vim_import_forcemode NE space.
      CASE import_action.
        WHEN &apos;UPD&apos;. imp_results-import-updated = 1.
        WHEN &apos;INS&apos;. imp_results-import-inserted = 1.
        WHEN &apos;DEL&apos;. imp_results-import-deleted = 1.
      ENDCASE.
    ENDIF.
    APPEND imp_results.
  ENDIF.
ENDFORM.                               &quot;vim_imp_call_screen</include_source>
   </include>
   <include NAME="LSVIMF17" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_CONVERT_TABKEY                                       *
*&amp;--------------------------------------------------------------------*
* ...                                                                 *
*&amp;--------------------------------------------------------------------*
FORM vim_convert_tabkey USING value(vct_key_int) TYPE x
                                    vct_key_ext TYPE vim_tabkey_c
                                    vct_xkeylen TYPE i.
  FIELD-SYMBOLS: &lt;h1&gt;, &lt;h2&gt;.
  CLEAR vct_xkeylen.
  &lt;f1_wax&gt; = vct_key_int.
  LOOP AT x_namtab WHERE keyflag NE space AND texttabfld EQ space.
    CHECK x_namtab-position LT x_header-keylen.
*    ASSIGN: vct_key_int+x_namtab-position(x_namtab-flength) TO &lt;h1&gt;,
*            vct_key_ext+vct_xkeylen(x_namtab-outputlen) TO &lt;h2&gt;.
    ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1_wa&gt;
             TO &lt;h1&gt;,
            vct_key_ext+vct_xkeylen(x_namtab-outputlen) TO &lt;h2&gt;.
    IF ( x_namtab-inttype NE &apos;C&apos; AND x_namtab-inttype NE &apos;N&apos; )&quot;SW
       OR x_namtab-convexit NE space.
      CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
           EXPORTING
                value_intern = &lt;h1&gt;
                tabname      = x_header-maintview
                fieldname    = x_namtab-viewfield
*                inttype      = x_namtab-inttype
*                datatype     = x_namtab-datatype
*                decimals     = x_namtab-decimals
*                convexit     = x_namtab-convexit
*                sign         = x_namtab-sign
                outputlen    = x_namtab-outputlen
                intlen       = x_namtab-flength
           IMPORTING
                value_extern = &lt;h2&gt;.
    ELSE.
      &lt;h2&gt; = &lt;h1&gt;.
    ENDIF.
    ADD x_namtab-outputlen TO vct_xkeylen.
  ENDLOOP.
ENDFORM.                               &quot;vim_convert_tabkey</include_source>
   </include>
   <include NAME="LSVIMF18" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_SET_IMPRES_HEADER                                    *
*&amp;--------------------------------------------------------------------*
* ...                                                                 *
*&amp;--------------------------------------------------------------------*
FORM VIM_SET_IMPRES_HEADER.
  IF VIM_CALLED_BY_CLUSTER EQ SPACE.
    IMP_RESULTS-OBJTAB-OBJECT-OBJECTNAME = X_HEADER-VIEWNAME.
    IF X_HEADER-VIEWNAME &lt;&gt; X_HEADER-MAINTVIEW.             &quot;Subviews ..
      CLEAR IMP_RESULTS-OBJTAB-OBJECT-OBJECTTYPE.
    ELSE.
      IMP_RESULTS-OBJTAB-OBJECT-OBJECTTYPE = X_HEADER-BASTAB.
    ENDIF.                             &quot;.. Subviews
    TRANSLATE IMP_RESULTS-OBJTAB-OBJECT-OBJECTTYPE USING &apos; VXS&apos;.
  ELSE.
    IMP_RESULTS-OBJTAB-OBJECT-OBJECTNAME = VIM_CALLING_CLUSTER.
    IMP_RESULTS-OBJTAB-OBJECT-OBJECTTYPE = &apos;C&apos;.
  ENDIF.
  IF X_HEADER-BASTAB NE SPACE.
    IMP_RESULTS-OBJTAB-TABNAME = X_HEADER-MAINTVIEW.
    IF X_HEADER-VIEWNAME &lt;&gt; X_HEADER-MAINTVIEW.             &quot;Subviews ..
      IMP_RESULTS-OBJTAB-VIEWNAME = X_HEADER-VIEWNAME.
    ELSE.                              &quot;.. Subviews
      CLEAR IMP_RESULTS-OBJTAB-VIEWNAME.
    ENDIF.
  ELSE.
    IMP_RESULTS-OBJTAB-TABNAME = X_HEADER-ROOTTAB.
    IMP_RESULTS-OBJTAB-VIEWNAME = X_HEADER-VIEWNAME.
  ENDIF.
  IMP_RESULTS-KEYLEN = X_HEADER-KEYLEN.                     &quot;SW
  IMP_RESULTS-GENKEYLEN = X_HEADER-KEYLEN.                  &quot;SW
ENDFORM.                               &quot;vim_set_impres_header</include_source>
   </include>
   <include NAME="LSVIMF19" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  VIM_MODIFY_VIEW_ENTRY                                   *
*&amp;--------------------------------------------------------------------*
* update/insert entry, process all checks                             *
*&amp;--------------------------------------------------------------------*
FORM vim_modify_view_entry USING value(vmve_exix) TYPE i
                                 vmve_rc TYPE i.
  DATA: h_ix TYPE i, h_act(1) TYPE c, hact2(1) TYPE c,                 &quot;#EC NEEDED
        fieldname TYPE fnam_____4.
  FIELD-SYMBOLS: &lt;guid&gt; TYPE ANY, &lt;old_guid&gt; TYPE ANY,
                 &lt;guid_wa&gt; TYPE ANY,
                 &lt;extract_val&gt; TYPE ANY, &lt;total_val&gt; TYPE ANY.
  CLEAR vmve_rc.
  nextline = exind = vmve_exix.
* new: transfer of changed entries from EXTRACT into TOTAL via dynps
* ... first: handle read-only fields and subset fields
  IF x_header-subsetflag NE space OR
     x_header-rdonlyflag NE space OR
     x_header-adrnbrflag NE space.
    IF &lt;xact&gt; NE neuer_eintrag.
      READ TABLE total WITH KEY &lt;vim_xextract_key&gt;          &quot;#EC WARNOK
                       BINARY SEARCH.
      h_act = &lt;action&gt;.
    ELSE.
      h_act = &lt;xact&gt;.
    ENDIF.
    LOOP AT x_namtab WHERE readonly EQ rdonly
                       OR  ( readonly EQ subset AND
                             keyflag EQ space ).
      ASSIGN COMPONENT x_namtab-viewfield
       OF STRUCTURE &lt;vim_extract_struc&gt; TO &lt;extract_val&gt;.
      CHECK sy-subrc = 0.
      IF &lt;xact&gt; NE neuer_eintrag.
        ASSIGN COMPONENT x_namtab-viewfield
         OF STRUCTURE &lt;vim_total_struc&gt; TO &lt;total_val&gt;.
        IF sy-subrc = 0.
          &lt;extract_val&gt; = &lt;total_val&gt;.
        ENDIF.
*        extract+x_namtab-position(x_namtab-flength) =
*            total+x_namtab-position(x_namtab-flength).
      ELSE.
        ASSIGN COMPONENT x_namtab-viewfield
         OF STRUCTURE &lt;initial&gt; TO &lt;total_val&gt;.
        IF sy-subrc = 0.
          &lt;extract_val&gt; = &lt;total_val&gt;.
        ENDIF.
*        extract+x_namtab-position(x_namtab-flength) =
*            &lt;initial&gt;+x_namtab-position(x_namtab-flength).
      ENDIF.
    ENDLOOP.
    IF sy-subrc EQ 0.
      hact2 = &lt;xact&gt;. &lt;xact&gt; = h_act.
      MODIFY extract INDEX vmve_exix.
      &lt;xact&gt; = hact2.
    ENDIF.
  ENDIF.
  PERFORM move_extract_to_view_wa.
* ... second: handle address number and GUID
  CLEAR vim_upgr_address_number.
  IF x_header-adrnbrflag NE space.
    IF x_header-adrnbrflag = &apos;N&apos;.
      vim_upgr_address_number = &lt;address_number&gt;.
    ENDIF.
    IF &lt;xact&gt; NE neuer_eintrag.
      &lt;address_number&gt; = &lt;vim_total_address_number&gt;.
    ELSE.
      CLEAR &lt;address_number&gt;.
    ENDIF.
  ENDIF.
  IF x_header-guidflag &lt;&gt; space AND &lt;xact&gt; &lt;&gt; neuer_eintrag.
* update only, GUID will be set in UPDATE_TAB for new entries
    LOOP AT x_namtab WHERE domname IN vim_guid_domain.
      CONCATENATE x_header-maintview x_namtab-viewfield
       INTO fieldname SEPARATED BY &apos;-&apos;.
      ASSIGN COMPONENT x_namtab-viewfield
       OF STRUCTURE &lt;vim_extract_struc&gt; TO &lt;guid&gt;.
      ASSIGN COMPONENT x_namtab-viewfield
       OF STRUCTURE &lt;vim_total_struc&gt; TO &lt;old_guid&gt;.
*      ASSIGN extract+x_namtab-position(x_namtab-flength) TO &lt;guid&gt;
*       CASTING TYPE (fieldname).
*      ASSIGN total+x_namtab-position(x_namtab-flength) TO &lt;old_guid&gt;
*       CASTING TYPE (fieldname).
      IF &lt;guid&gt; IS INITIAL AND &lt;old_guid&gt; IS INITIAL.
* no GUID-value imported from remote system and GUID not yet set in
* current entry
        PERFORM vim_make_guid USING x_namtab-viewfield.
        ASSIGN (fieldname) TO &lt;guid_wa&gt; CASTING TYPE (fieldname).
        &lt;guid&gt; = &lt;guid_wa&gt;.
* (including event 27)
      ELSEIF &lt;guid&gt; IS INITIAL.
* use old GUID
        &lt;guid&gt; = &lt;old_guid&gt;.
        IF x_header-frm_af_uid &lt;&gt; space.
          PERFORM (x_header-frm_af_uid) IN PROGRAM (x_header-fpoolname)
                                    USING &lt;old_guid&gt;
                                    CHANGING &lt;guid&gt;
                                             &lt;vim_extract_struc&gt;.
* Condition always FALSE - Internal Message 0001699060 - ACHACHADI
*        ELSEIF x_header-frm_af_uid &lt;&gt; space.                        &quot;#EC BOOL_OK
** overwrite old GUID with GUID from remote client... or not?
*          PERFORM (x_header-frm_af_uid) IN PROGRAM (x_header-fpoolname)
*                                    USING &lt;old_guid&gt;
*                                    CHANGING &lt;guid&gt;
*                                             &lt;vim_extract_struc&gt;.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDIF.
  IF &lt;xact&gt; EQ neuer_eintrag.
    status-action = hinzufuegen.
    &lt;vim_extract_struc&gt; = &lt;initial&gt;.
    IF x_header-bastab NE space AND
       x_header-texttbexst NE space.
      &lt;vim_xextract_text&gt; = &lt;text_initial_x&gt;.
    ENDIF.
    &lt;xact&gt; = leer.
  ELSE.
    status-action = aendern. &lt;xact&gt; = h_act.
  ENDIF.
  MODIFY extract INDEX vmve_exix.
* ...third: call screen a la replace
  CASE status-type.
    WHEN einstufig.
      PERFORM vim_imp_call_screen USING liste.
    WHEN zweistufig.
      IF &lt;xact&gt; EQ leer.
        neuer = &apos;J&apos;.
      ENDIF.
      PERFORM process_detail_screen USING &apos;C&apos;.
  ENDCASE.
  status-action = &lt;status&gt;-st_action = aendern.
  IF ok_code EQ &apos;IGN &apos;. vmve_rc = 4. CLEAR ok_code. EXIT. ENDIF.
  IF function EQ &apos;ABR &apos;. vmve_rc = 8. CLEAR function. EXIT. ENDIF.
ENDFORM.                               &quot;vim_modify_view_entry</include_source>
   </include>
   <include NAME="LSVIMF1A" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  VIM_PROCESS_VIEW_ENTRY                                  *
*&amp;--------------------------------------------------------------------*
* process current function for view entry                             *
*&amp;--------------------------------------------------------------------*
FORM VIM_PROCESS_VIEW_ENTRY USING VALUE(VPVE_EXIX) TYPE I
                                  VALUE(VPVE_OKCODE) LIKE OK_CODE
                                  VPVE_RC TYPE I.
  DATA: FUNCTION_SAFE LIKE FUNCTION.
  CLEAR VPVE_RC.
  NEXTLINE = EXIND = VPVE_EXIX.
  FUNCTION_SAFE = FUNCTION.
  FUNCTION = OK_CODE = VPVE_OKCODE.
  PERFORM MOVE_EXTRACT_TO_VIEW_WA.
  CASE STATUS-TYPE.
    WHEN EINSTUFIG.
*     CALL SCREEN LISTE.
      PERFORM VIM_IMP_CALL_SCREEN USING LISTE.
    WHEN ZWEISTUFIG.
*     PERFORM MOVE_EXTRACT_TO_VIEW_WA.
      PERFORM PROCESS_DETAIL_SCREEN USING &apos;C&apos;.
  ENDCASE.
  IF OK_CODE EQ &apos;IGN &apos;. VPVE_RC = 4. CLEAR OK_CODE. EXIT. ENDIF.
  IF FUNCTION EQ &apos;ABR &apos;. VPVE_RC = 8. CLEAR FUNCTION. EXIT. ENDIF.
  FUNCTION = FUNCTION_SAFE.
ENDFORM.                               &quot;vim_process_view_entry</include_source>
   </include>
   <include NAME="LSVIMF1B" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form VIM_RESTORE_SUBSET_CONDS                                 *
*&amp;--------------------------------------------------------------------*
* restore subset conditions                                           *
*&amp;--------------------------------------------------------------------*
FORM vim_restore_subset_conds.
  DATA: hi TYPE i.
  FIELD-SYMBOLS: &lt;ifield&gt; TYPE ANY.
  LOOP AT dpl_sellist WHERE ddic CO vim_subset_marks.
    hi = sy-tabix.
    READ TABLE x_namtab INDEX dpl_sellist-tabix.
    ASSIGN COMPONENT x_namtab-viewfield
     OF STRUCTURE &lt;vim_extract_struc&gt; TO &lt;ifield&gt;.
*    ASSIGN EXTRACT+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH) TO &lt;IFIELD&gt;.
    CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
         EXPORTING
              value_intern = &lt;ifield&gt;
              tabname      = x_header-maintview
              fieldname    = x_namtab-viewfield
              outputlen    = x_namtab-outputlen
              intlen       = x_namtab-flength
         IMPORTING
              value_extern = dpl_sellist-value.
    CLEAR dpl_sellist-converted.
    IF dpl_sellist-value IS INITIAL. dpl_sellist-initial = &apos;X&apos;. ENDIF.
    MODIFY dpl_sellist INDEX hi.
  ENDLOOP.
  dba_sellist[] = dpl_sellist[].
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF1C" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form UPGRADE                                                  *
*&amp;--------------------------------------------------------------------*
* process upgrade                                                     *
*---------------------------------------------------------------------*
* U_MODE --&gt; &apos; &apos; - client 000, &apos;O&apos; - other client, others - remote sys*
*---------------------------------------------------------------------*
FORM upgrade USING value(u_mode) TYPE c.
  DATA: u_kind, u_update_happened, trans_pattern(8) TYPE c,   &quot;#EC NEEDED
        hf TYPE i, u_client LIKE sy-mandt, u_tabind LIKE sy-tabix,   &quot;#EC NEEDED
        u_it000 LIKE vim_t000 OCCURS 10, u_title(40) TYPE c,         &quot;#EC NEEDED
        u_remote_sys LIKE rfcdes-rfcdest, u_t000 LIKE vim_t000,      &quot;#EC NEEDED
        u_counter TYPE i, u_del_cnt TYPE i, u_rc TYPE i, hf1 TYPE i,
        u_funcsafe(4) TYPE c, u_txt_fu_beg TYPE i, u_txt_fu_lg TYPE i,  &quot;#EC NEEDED
        u_newversion(1) TYPE c VALUE &apos;X&apos;, u_mark_entries(1) TYPE c,     &quot;#EC NEEDED
        u_action(1) TYPE c, u_specmode_safe(1) TYPE c,               &quot;#EC NEEDED
        u_called_from(1) TYPE c, u_oc_exst LIKE ntab_cmp-flag,
        u_sellist TYPE vimsellist_type, sellines TYPE i.
  CONSTANTS: u_text_frm(30) TYPE c VALUE &apos;FILL_TEXTTAB_KEY&apos;.             &quot;#EC NEEDED
  FIELD-SYMBOLS: &lt;u_f1&gt; TYPE x, &lt;u_sellist&gt; TYPE vimsellist_type,
                 &lt;w_sellist&gt; TYPE vimsellist.

* data and field symbols for copying the extract to and from
* the compare tool container:
  DATA:
    cmp_container_ref    TYPE REF TO data,
    cmp_container_wa_ref TYPE REF TO data,
    extract_len          TYPE i,
    subrc_buf            TYPE sy-subrc.
  FIELD-SYMBOLS:
    &lt;cmp_cont&gt;    TYPE STANDARD TABLE,
    &lt;cmp_cont_wa&gt; TYPE ANY,
    &lt;x_dummy&gt;     TYPE x.

  READ TABLE excl_cua_funct WITH KEY function = &apos;CMPR&apos;.
  IF sy-subrc EQ 0.                    &quot;upgrade is not allowed
    MESSAGE s001(sv).
    EXIT.
  ENDIF.
* upgrade with client 0 only if current client &lt;&gt; 000
* upgrade with other clients only if objects are clientdependent
  IF u_mode EQ space AND sy-mandt EQ &apos;000&apos; OR  &quot;upgrade with client 000
     ( u_mode EQ space OR u_mode EQ &apos;O&apos; ) AND
     x_header-clidep EQ space.
    MESSAGE s001(sv).
    EXIT.
  ENDIF.
* send warning if address number could be changed
  IF status-action EQ aendern AND
   ( x_header-adrnbrflag NE space AND x_header-adrnbrflag &lt;&gt; &apos;N&apos; ).
    PERFORM set_pf_status USING &apos;ERROR&apos;.
    MESSAGE i139(sv). &quot;Adreßdaten werden nicht übernommen
    PERFORM set_pf_status USING status.
  ENDIF.
  CLEAR: u_client, u_remote_sys.
  IF u_mode EQ space.
    u_client = &apos;000&apos;.
  ELSEIF u_mode EQ &apos;O&apos;.
    IF vim_default_upgr_clnt-client NE space AND
       vim_default_upgr_clnt-viewname EQ x_header-viewname.
      u_client = vim_default_upgr_clnt-client.
    ENDIF.
  ELSE.
    IF vim_default_rfc_dest-rfcdest NE space AND
       vim_default_rfc_dest-viewname EQ x_header-viewname.
      u_remote_sys = vim_default_rfc_dest-rfcdest.
    ENDIF.
  ENDIF.
  IF vim_special_mode EQ vim_direct_upgrade.
    function = &apos;ABR&apos;.                  &quot;avoid processing detail screen
    PERFORM fill_extract. CLEAR function.
    u_specmode_safe = vim_special_mode.
    ASSIGN dba_sellist[] TO &lt;u_sellist&gt;.
  ELSE.
    ASSIGN &lt;vim_ck_sellist&gt; TO &lt;u_sellist&gt;.
  ENDIF.
  vim_special_mode = vim_upgrade.
  MOVE: geloescht TO trans_pattern, aendern TO trans_pattern+1(1),
        neuer_geloescht TO trans_pattern+2(1),
        neuer_eintrag   TO trans_pattern+3(1),
        update_geloescht TO trans_pattern+4(1),
        aendern         TO trans_pattern+5(1),
        original  TO trans_pattern+6(1),
        aendern TO trans_pattern+7(1).
  IF x_header-bastab EQ space.         &quot;view
    u_kind = &apos;V&apos;.
  ELSE.
    IF x_header-texttbexst EQ space.   &quot;base table
      u_kind = &apos;T&apos;.
    ELSE.                              &quot;base table with text table
      u_kind = &apos;X&apos;.
    ENDIF.
  ENDIF.

* Add collapsed or merged timedep. entries
  IF x_header-delmdtflag NE space.
    DESCRIBE TABLE vim_collapsed_mainkeys LINES hf.
    DESCRIBE TABLE vim_merged_entries.
    IF sy-tfill GT 0 OR hf GT 0.
      vim_ignore_collapsed_mainkeys = &apos;X&apos;.
      PERFORM fill_extract.
      CLEAR vim_ignore_collapsed_mainkeys.
    ENDIF.
  ENDIF.
  IF ( vim_system_type NE &apos;SAP&apos; AND sy-mandt EQ &apos;000&apos; )
   OR x_header-importable = vim_not_importable.
    u_action = anzeigen.
  ELSE.
    u_action = status-action.
  ENDIF.
  TRANSLATE u_action USING &apos;SCUA&apos;.
  IF vim_adjust_middle_level_mode NE space.
    TRANSLATE u_action USING &apos;Aa&apos;.
  ENDIF.
  u_called_from = vim_special_adjust_mode.
  TRANSLATE u_called_from USING &apos; VSFXF&apos;.
  IF NOT vim_oc_inst IS INITIAL.
* data access restricted?
    IF ( u_action = &apos;C&apos;
         AND NOT vim_oc_inst-&gt;oc_selcrit_read_tab IS INITIAL )
     OR ( &apos;Aa&apos; CS u_action
          AND NOT vim_oc_inst-&gt;oc_selcrit_maint_tab IS INITIAL ).
      u_oc_exst = &apos;X&apos;.
    ENDIF.
  ENDIF.
  APPEND LINES OF &lt;u_sellist&gt; TO u_sellist.
  DELETE u_sellist WHERE from_auth &lt;&gt; space
   AND ddic &lt;&gt; &apos;S&apos; AND ddic &lt;&gt; &apos;B&apos;.
  IF sy-subrc = 0.
    DESCRIBE TABLE u_sellist LINES sellines.
    IF sellines GT 0.
      READ TABLE u_sellist INDEX sellines ASSIGNING &lt;w_sellist&gt;.
      CLEAR &lt;w_sellist&gt;-and_or.
    ENDIF.
  ENDIF.

* copy extract to compare tool container
  DESCRIBE FIELD extract LENGTH extract_len IN BYTE MODE.
  IF extract_len &lt;= 64.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl64.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl64.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  ELSEIF extract_len &lt;= 256.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl256.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl256.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  ELSEIF extract_len &lt;= 1024.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl1024.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl1024.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  ELSEIF extract_len &lt;= 4096.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl4096.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl4096.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  ELSEif extract_len &lt;= 8192.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl8192.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl8192.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  else.
    CREATE DATA cmp_container_ref TYPE TABLE OF tbl32000.
    ASSIGN cmp_container_ref-&gt;* TO &lt;cmp_cont&gt;.
    CREATE DATA cmp_container_wa_ref TYPE tbl32000.
    ASSIGN cmp_container_wa_ref-&gt;* TO &lt;cmp_cont_wa&gt;.
  ENDIF.

  ASSIGN &lt;cmp_cont_wa&gt; TO &lt;x_dummy&gt; CASTING.
  LOOP AT extract.
    CLEAR &lt;x_dummy&gt;.
    &lt;x_dummy&gt; = &lt;vim_xextract&gt;.
    APPEND &lt;cmp_cont_wa&gt; TO &lt;cmp_cont&gt;.
  ENDLOOP.

  CALL FUNCTION &apos;SCT1_VIEW_COMPARE_AND_ADJUST&apos;
       EXPORTING
            iv_view_name              = x_header-maintview  &quot;VIEWNAME
*             IV_VIEW_VARIANT    =
            iv_kind                   = u_kind
            iv_mode                   = u_action
*             IV_LANGUAGE        = SY-LANGU
*             IV_CLIENT_REMOTE   = U_CLIENT
            iv_rfc_destination        = u_remote_sys
            iv_called_from            = u_called_from
            iv_data_access_restricted = u_oc_exst
       IMPORTING
            ev_update          = u_update_happened
            ev_mark_entries    = u_mark_entries
       TABLES
            it_header          = x_header
            it_namtab          = x_namtab
            it_sellist         = u_sellist
            ct_box             = &lt;cmp_cont&gt;
       EXCEPTIONS
            canceled           = 1
            wrong_parameter    = 2
            compare_error      = 3
            OTHERS             = 4.
  subrc_buf = sy-subrc.

* copy compare tool container back to extract
  REFRESH extract.
  LOOP AT &lt;cmp_cont&gt; ASSIGNING &lt;cmp_cont_wa&gt;.
    ASSIGN &lt;cmp_cont_wa&gt; TO &lt;x_dummy&gt; CASTING.
    &lt;vim_xextract&gt; = &lt;x_dummy&gt;(extract_len).
    APPEND extract.
  ENDLOOP.

  sy-subrc = subrc_buf.
  IF sy-subrc GT 01.
    MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*    MESSAGE s135(sv).                        n1528173
    sy-subrc = 01.
  ENDIF.
  IF status-action EQ anzeigen AND u_update_happened NE space.
    sy-subrc = 1.
  ENDIF.
  CASE sy-subrc.
    WHEN 0.
      IF u_update_happened NE space.
* transfer changed entries from EXTRACT into TOTAL
        CLEAR: u_counter, u_del_cnt. replace_mode = &apos;X&apos;.
        DESCRIBE TABLE extract LINES maxlines.
* 1st: handle deleted entries
        LOOP AT extract.
          IF &lt;xact&gt; EQ original.
            DELETE extract. CONTINUE.
          ENDIF.
          CHECK &lt;xact&gt; EQ geloescht OR &lt;xact&gt; EQ neuer_geloescht OR
                &lt;xact&gt; EQ update_geloescht.
          hf = sy-tabix.
          READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
* Condition Redundant - Internal Message  0001699060 - ACHACHADI
*          IF sy-subrc NE 0 OR ( sy-subrc EQ 0 AND  &quot;#EC BOOL_OK
          IF &lt;action&gt; EQ &lt;xact&gt; .
            DELETE extract. CONTINUE.
          ENDIF.
          &lt;mark&gt; = markiert. ADD 1 TO mark_total.
          MODIFY total INDEX sy-tabix.
          &lt;xmark&gt; = markiert. ADD 1 TO mark_extract.
          MODIFY extract.
          IF vim_special_adjust_mode EQ subset.
            PERFORM vim_restore_subset_conds.
          ENDIF.
          PERFORM vim_process_view_entry USING hf &apos;DELE&apos; u_rc.
          CHECK u_rc NE 4.
          IF u_rc EQ 8.
            EXIT.
          ENDIF.
          ADD: counter TO u_del_cnt, 1 TO u_counter.
        ENDLOOP.
        IF u_counter GT u_del_cnt.
          SUBTRACT u_del_cnt FROM u_counter.
          MESSAGE i116(sv) WITH u_counter. &quot;&amp; Einträge konnten nicht g
        ENDIF.
        CLEAR u_counter.
        IF status-type EQ einstufig.
          CLEAR: ok_code, function.
        ELSE.
          function = ok_code = &apos;COMP&apos;.
        ENDIF.
* 2nd: handle changed entries
        ASSIGN &lt;vim_xtotal&gt;(x_header-tablen) TO &lt;u_f1&gt;.
        LOOP AT extract.
          IF &lt;xact&gt; NE aendern AND &lt;xact&gt; NE neuer_eintrag.
            DELETE extract. CONTINUE.
          ENDIF.
          hf = sy-tabix.
          READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
          IF sy-subrc EQ 0.            &quot;entry exists in current client
            IF extract EQ total. &quot;no changes -&gt; delete and continue
              DELETE extract. CONTINUE.
            ELSEIF &lt;xact&gt; EQ neuer_eintrag AND &quot;new entry exists and
                &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ neuer_geloescht OR
                 &lt;action&gt; EQ update_geloescht.&quot;entry deleted in cur clnt
              status-delete = geloescht. &quot; -&gt; first undelete it
              &lt;xact&gt; = &lt;action&gt;. MODIFY extract. u_funcsafe = function.
              IF vim_special_adjust_mode EQ subset.
                PERFORM vim_restore_subset_conds.
              ENDIF.
              PERFORM vim_mark_and_process USING hf &apos;UNDO&apos; hf1 u_rc.
              CLEAR status-delete. function = u_funcsafe.
              vim_special_mode = vim_upgrade.
              CHECK u_rc NE 4.
              IF u_rc EQ 8.
                EXIT.
              ENDIF.
              READ TABLE extract INDEX hf.
              READ TABLE total WITH KEY &lt;vim_xextract_key&gt;  &quot;#EC WARNOK
                                                      BINARY SEARCH.
              IF &lt;u_f1&gt; EQ &lt;table2_x&gt;.   &quot;no changes after undo
                DELETE extract. CONTINUE.&quot;delete &amp; continue
              ELSE.
                &lt;xact&gt; = aendern. MODIFY extract.
              ENDIF.
            ELSEIF &lt;u_f1&gt; EQ &lt;table2_x&gt;. &quot;no changes -&gt; delete and cont
              DELETE extract. CONTINUE.
            ELSEIF &lt;xact&gt; EQ neuer_eintrag AND &lt;action&gt; EQ original.
              &lt;xact&gt; = aendern. MODIFY extract.
            ENDIF.
          ENDIF.                       &quot;sy-subrc eq 0.
          IF vim_special_adjust_mode EQ subset.
            PERFORM vim_restore_subset_conds.
          ENDIF.
          PERFORM vim_modify_view_entry USING hf u_rc.
          CHECK u_rc NE 4.
          IF u_rc EQ 8.
            EXIT.
          ENDIF.
          IF u_mark_entries NE space.  &quot;mark ajusted entries
            READ TABLE total WITH KEY &lt;vim_xtotal_key&gt; BINARY SEARCH  &quot;#EC WARNOK
                             TRANSPORTING NO FIELDS.
            IF &lt;mark&gt; EQ nicht_markiert.
              &lt;mark&gt; = markiert. ADD 1 TO mark_total.
              MODIFY total INDEX sy-tabix.
              ADD 1 TO mark_extract.
            ENDIF.
          ENDIF.
          extract = total.
          MODIFY extract.
          ADD 1 TO u_counter.
        ENDLOOP.
        IF temporal_delimitation_happened NE space.
          REFRESH vim_delim_entries.
          CLEAR temporal_delimitation_happened.
        ENDIF.
        status-data = title-data = auswahldaten.
        nextline = l = 1.
        IF u_del_cnt NE 0 AND u_counter NE 0.
          MESSAGE s140(sv) &quot;&amp;1 Einträge geloescht, &amp;2 Einträge übernom
            WITH u_del_cnt u_counter.
        ELSEIF u_del_cnt NE 0.
          MESSAGE s011(sv) WITH u_del_cnt. &quot;Anzahl gelöschter Einträge
        ELSE.
          MESSAGE s012(sv) WITH u_counter. &quot;Anzahl veränderter Einträg
        ENDIF.
        CLEAR replace_mode.
      ELSE.                            &quot;no update happened
        IF x_header-delmdtflag NE space.
          PERFORM fill_extract. &quot;consider collapsed or merged entries
        ENDIF.
      ENDIF.                           &quot;u_update_happend ne space
      DESCRIBE TABLE extract LINES maxlines.
      nextline = 1.
      IF vim_special_adjust_mode NE space.
        CLEAR: vim_special_mode, vim_special_adjust_mode,
               &lt;status&gt;-upd_flag, maxlines, &lt;status&gt;-maxlines.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        IF vim_adjust_middle_level_mode NE space.
          function = &apos;SAVE&apos;.
        ENDIF.
      ENDIF.
    WHEN 1. &quot;ignore changes in EXTRACT --&gt; restore EXTRACT from TOTAL
      IF vim_special_adjust_mode NE space.
        CLEAR: vim_special_mode, vim_special_adjust_mode,
               &lt;status&gt;-upd_flag, maxlines, &lt;status&gt;-maxlines.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        IF vim_adjust_middle_level_mode NE space.
          function = &apos;SAVE&apos;.
        ENDIF.
      ENDIF.
      PERFORM fill_extract.
    WHEN OTHERS. RAISE upgrade_view_failed.                 &quot;#EC FB_RAIS_EX
  ENDCASE.
  CLEAR vim_special_mode.
ENDFORM.                               &quot; UPGRADE</include_source>
   </include>
   <include NAME="LSVIMF1D" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  PROCESS_AFTER_ENTRY_RESET                               *
*&amp;--------------------------------------------------------------------*
*                                                                     *
*---------------------------------------------------------------------*
FORM PROCESS_AFTER_ENTRY_RESET.
  IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE.
    PERFORM AFTER_TEMPORAL_DELIMITATION.
    CLEAR TEMPORAL_DELIMITATION_HAPPENED.
  ENDIF.
  PERFORM CHECK_UPD.
  IF X_HEADER-FRM_AF_ORG NE SPACE.
    PERFORM (X_HEADER-FRM_AF_ORG) IN PROGRAM (SY-REPID).
  ENDIF.
ENDFORM.                               &quot;process_after_entry_reset</include_source>
   </include>
   <include NAME="LSVIMF1E" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  PROCESS_ENTRY_RESET                                     *
*&amp;--------------------------------------------------------------------*
* refresh entry from database                                         *
*---------------------------------------------------------------------*
* --&gt; PER_INDEX current index for modifying EXTRACT                   *
*---------------------------------------------------------------------*
FORM PROCESS_ENTRY_RESET USING VALUE(PER_INDEX) TYPE I.
  DATA: PRT_FRKY_SAFE(255) TYPE C, PER_HF TYPE I,
        REFCNT_SAFE TYPE I.

  REFCNT_SAFE = REFCNT.
  PERFORM MOVE_EXTRACT_TO_VIEW_WA.
  IF &lt;XACT&gt; NE ORIGINAL OR             &quot;SW Texttransl
     ( X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE
                                AND &lt;XACT_TEXT&gt; NE ORIGINAL ).

*   check if the &lt;vim_prtfky_wa&gt; is assigned. If the field belong
*   EZN &amp; KEY, the field will be assinged.
    IF vim_prtfky_assigned NE &apos; &apos;.          &quot;XB 07.2002 BCEK061635
      IF X_HEADER-PTFRKYEXST NE SPACE.
        MOVE &lt;VIM_PRTFKY_WA&gt; TO PRT_FRKY_SAFE.
      ENDIF.
    ENDIF.

    IF X_HEADER-FRM_RP_ORG NE SPACE.
      PERFORM (X_HEADER-FRM_RP_ORG) IN PROGRAM (SY-REPID).
    ELSE.
      IF X_HEADER-BASTAB NE SPACE.
        PERFORM (VIM_TB_READ_SINGLE_FORM) IN PROGRAM (SY-REPID).
      ELSE.
        PER_HF = STRLEN( X_HEADER-MAINTVIEW ).
        IF PER_HF LE 10.
          MOVE X_HEADER-MAINTVIEW TO VIM_READ_SINGLE_FORM-VIEWNAME.
          PERFORM (VIM_READ_SINGLE_FORM) IN PROGRAM.
        ELSE.
          MOVE X_HEADER-MAINTVIEW TO VIM_READ_SINGLE_FORM_40-VIEWNAME.
          PERFORM (VIM_READ_SINGLE_FORM_40) IN PROGRAM.
        ENDIF.
      ENDIF.
    ENDIF.
    IF SY-SUBRC NE 0.
      IF X_HEADER-FRM_RP_ORG EQ SPACE.
        RAISE IMPOSSIBLE_ERROR.        &quot;entry not found
      ENDIF.
    ELSE.

*   check if the &lt;vim_prtfky_wa&gt; is assigned. If the field belong
*   EZN &amp; KEY, the field will be assinged.
      IF vim_prtfky_assigned NE &apos; &apos;.          &quot;XB 07.2002  BCEK061635
        IF X_HEADER-PTFRKYEXST NE SPACE AND                      &quot;SW
           &lt;VIM_PRTFKY_WA&gt; NE PRT_FRKY_SAFE.
          PERFORM CONSISTENCY_PRT_FRKY_FIELDS USING &apos;X&apos;.
        ENDIF.
      ENDIF.

      IF X_HEADER-DELMDTFLAG NE SPACE.
        PERFORM TEMPORAL_DELIMITATION.
      ENDIF.
      PERFORM MODIFY_TABLES USING PER_INDEX.
      IF PER_INDEX NE 0.
        ADD 1 TO REFCNT.
      ENDIF.
    ENDIF.

  ENDIF.                               &quot;SW Texttransl ..
  IF X_HEADER-TEXTTBEXST &lt;&gt; SPACE.     &quot;SW Texttransl ..
    IF X_HEADER-FRM_TL_ORG NE SPACE.
      PERFORM (X_HEADER-FRM_TL_ORG) IN PROGRAM (SY-REPID).
    ELSE.
      PERFORM VIM_READ_TEXTTAB_ENTRY.
    ENDIF.
    IF REFCNT_SAFE = REFCNT AND SY-SUBRC = 0.
      ADD 1 TO REFCNT.
      CLEAR &lt;STATUS&gt;-UPD_FLAG.
      IF &lt;XMARK&gt; EQ MARKIERT.
        SUBTRACT: 1 FROM &lt;STATUS&gt;-MK_XT,
                  1 FROM &lt;STATUS&gt;-MK_TO.
        &lt;XMARK&gt; = NICHT_MARKIERT.
        IF PER_INDEX &lt;&gt; 0.
          MODIFY EXTRACT INDEX PER_INDEX.
        ENDIF.
        READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH. &quot;#EC WARNOK
        &lt;MARK&gt; = NICHT_MARKIERT.
        MODIFY TOTAL INDEX SY-TABIX.
      ENDIF.
    ENDIF.
  ENDIF.                               &quot;.. Texttransl
ENDFORM.                               &quot;process_entry_reset</include_source>
   </include>
   <include NAME="LSVIMF1F" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  RESET_ENTRIES                                           *
*&amp;--------------------------------------------------------------------*
* restore the last saved version for the marked entries of EXTRACT    *
*---------------------------------------------------------------------*
* --&gt; RE_MODE requested mode: L - all marked entries, D - single entry*
*---------------------------------------------------------------------*
FORM RESET_ENTRIES USING VALUE(RE_MODE).
  DATA: TEXTTAB_MOD(1) TYPE C.         &quot;SW Texttransl

  VIM_SPECIAL_MODE = VIM_RESET.
  CASE RE_MODE.
    WHEN LIST_BILD.
      MOVE: 0 TO REFCNT, 0 TO NEWCNT, 0 TO ORGCNT.
      LOOP AT EXTRACT.
        CLEAR TEXTTAB_MOD.
        CHECK &lt;XMARK&gt; EQ MARKIERT.
        MOVE SY-TABIX TO INDEX.
        ADD 1 TO NEWCNT.
        CHECK &lt;XACT&gt; NE NEUER_EINTRAG.
        ADD 1 TO ORGCNT.
        IF X_HEADER-TEXTTBEXST &lt;&gt; SPACE.             &quot;SW Texttransl ..
          PERFORM VIM_TEXTTAB_MODIF_FOR_KEY CHANGING TEXTTAB_MOD.
        ENDIF.
        IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
          CHECK &lt;XACT&gt; NE ORIGINAL OR &lt;XACT_TEXT&gt; NE ORIGINAL
                                   OR TEXTTAB_MOD = &apos;X&apos;.
        ELSE.
          CHECK &lt;XACT&gt; NE ORIGINAL OR TEXTTAB_MOD = &apos;X&apos;.
        ENDIF.
        PERFORM PROCESS_ENTRY_RESET USING INDEX.
      ENDLOOP.
      NEWCNT = NEWCNT - ORGCNT.
      ORGCNT = ORGCNT - REFCNT.
      IF ORGCNT EQ 0 AND NEWCNT EQ 0.
        MESSAGE S016(SV) WITH REFCNT.
      ELSE.
        IF ORGCNT NE 0 AND NEWCNT NE 0.
          MESSAGE S040(SV) WITH REFCNT ORGCNT NEWCNT.
        ELSE.
          IF ORGCNT NE 0.
            MESSAGE S041(SV) WITH REFCNT ORGCNT.
          ELSE.
            MESSAGE S042(SV) WITH REFCNT NEWCNT.
          ENDIF.
        ENDIF.
      ENDIF.
      PERFORM PROCESS_AFTER_ENTRY_RESET.
    WHEN DETAIL_BILD.
      READ TABLE EXTRACT INDEX NEXTLINE. &quot;Extract-WA i.VCL-Kontext n. ok
      PERFORM PROCESS_ENTRY_RESET USING NEXTLINE.
      MESSAGE S017(SV).
      PERFORM PROCESS_AFTER_ENTRY_RESET.
      CLEAR VIM_OLD_VIEWKEY.
      TRANSLATE VIM_NO_MAINKEY_EXISTS USING VIM_NO_MKEY_NOT_PROCSD_PATT.
  ENDCASE.
  CLEAR VIM_SPECIAL_MODE.
ENDFORM.                               &quot;reset_entries</include_source>
   </include>
   <include NAME="LSVIMF1G" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form CHECK_ALLOWED_KEYRANGES                                  *
*&amp;--------------------------------------------------------------------*
* check new entries fitting allowed keyranges                         *
*---------------------------------------------------------------------*
*                                                                     *
*&amp;--------------------------------------------------------------------*
FORM check_allowed_keyranges.
  DATA: roottab_key LIKE e071k-tabkey,
        tablename LIKE vimdesc-viewname,
        allowed,
        mess_type(1) TYPE c VALUE &apos;W&apos;,
        ale_msgty(1) TYPE c VALUE &apos;E&apos;, ale_msgno LIKE sy-msgno,
        ale_msgid LIKE sy-msgid, ale_msgv1 LIKE sy-msgv1,
        ale_msgv2 LIKE sy-msgv2, ale_msgv3 LIKE sy-msgv3,
        ale_msgv4 LIKE sy-msgv4,
        roottab_row TYPE REF TO data,
        keytab_loc TYPE TABLE OF tbl8096,
        keytab_wa LIKE LINE OF keytab_loc,
        keytab_wa2 LIKE LINE OF keytab_loc,
        allowed_keys TYPE TABLE OF tbl8096,
        sctm_fill_cache, viewtype,
        p_roottab_keylen TYPE i.                            &quot;XB H651706


  FIELD-SYMBOLS: &lt;key_x&gt; TYPE x, &lt;h_old_mkey2&gt; TYPE x,
                 &lt;roottab_row_x&gt; TYPE x,
                 &lt;f_field1&gt; TYPE ANY,
                 &lt;f_field2&gt; TYPE ANY,
                 &lt;roottab_row&gt; TYPE ANY.

  CHECK vim_keyrange_alr_checked EQ space.
* check synchronizer keyspecific stuff
  IF vim_sync_keyspec_check NE space.
    sctm_fill_cache = &apos;X&apos;.
    IF x_header-bastab EQ space.
      viewtype = &apos;V&apos;.
    ELSE.
      viewtype = &apos;S&apos;.
    ENDIF.
    REFRESH keytab_loc.
    REFRESH allowed_keys.
    keytab_wa-line =  &lt;f1_x&gt;.
    APPEND keytab_wa TO keytab_loc.             &quot;Table with 1 line only
    CALL FUNCTION &apos;SCTM_CHECK_VIEW_KEY&apos;
      EXPORTING
        viewname              = x_header-viewname
        viewtype              = viewtype
        bcset                 = vim_bcset_id  &quot;if NE space: BC-set act
        fill_cache            = sctm_fill_cache
*     IMPORTING               &quot;HCG: Already set in justify_action_mode
*       EDIT_FLAG           = vim_sync_edit_lock
*       KESPEC_FLAG         = vim_sync_keyspec_check
      TABLES
        query_tab             = keytab_loc
        allowed_tab           = allowed_keys
      EXCEPTIONS
        no_sync_present       = 1
        old_sync_system       = 2
        OTHERS                = 3.
    IF sy-subrc &lt;&gt; 0.     &quot;Ignore check_result but no message to user
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      allowed = &apos;X&apos;.
      CLEAR vim_sync_key_lock_del.     &quot;If no connection: open all
    ELSE.
      CLEAR keytab_wa2-line.
      READ TABLE allowed_keys INTO keytab_wa2 INDEX 1.
      IF keytab_wa-line(x_header-keylen) NE
         keytab_wa2-line(x_header-keylen).  &quot;Key is not changeable
        allowed = &apos;A&apos;. ale_msgno = &apos;182&apos;. ale_msgid = &apos;SV&apos;.
        MOVE vim_sctm_sourcesys TO ale_msgv1.
        vim_sync_key_lock_del = &apos;X&apos;.
      ELSE.
        allowed = &apos;X&apos;.
        CLEAR vim_sync_key_lock_del.
      ENDIF.
    ENDIF.
  ENDIF.
* check ALE keyspecific stuff
  IF vim_ale_keyspec_check NE space AND allowed NE &apos;A&apos;. &quot;HCG HW 718225
    ASSIGN roottab_key TO &lt;key_x&gt; CASTING.
    &lt;key_x&gt; = &lt;f1_x&gt;. allowed = &apos;X&apos;.
    LOOP AT vim_ale_keyspec_objtab.
      CALL FUNCTION &apos;ALE_EDIT_KEY_CHECK&apos;
        EXPORTING
          objecttype          = vim_ale_keyspec_objtab-otype
          objectname          = vim_ale_keyspec_objtab-oname
          objectkey           = roottab_key
        EXCEPTIONS
          key_no_maintainance = 1.
      IF sy-subrc NE 0.
        allowed = &apos;A&apos;. ale_msgno = sy-msgno. ale_msgid = sy-msgid.
        ale_msgv1 = sy-msgv1. ale_msgv2 = sy-msgv2.
        ale_msgv3 = sy-msgv3. ale_msgv4 = sy-msgv4.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.
  IF allowed &lt;&gt; &apos;A&apos;.                               &quot;329818/2001
    vim_keyrange_alr_checked = &apos;X&apos;.                &quot;329818/2001
  ENDIF.
* check namespace
  IF ( vim_ale_keyspec_check EQ space AND
       vim_sync_keyspec_check EQ space ) OR
     ( x_header-customauth CO sap_cust_ctrl_classes AND
       allowed CO &apos; X&apos; ).
    IF vim_import_profile EQ space. &quot;Skip namespace check in BC-Set Akt
      IF x_header-bastab EQ space.       &quot;view
        MOVE x_header-roottab TO tablename.
      ELSE.                              &quot;base table
        MOVE x_header-viewname TO tablename.
      ENDIF.
      ASSIGN roottab_key TO &lt;key_x&gt; CASTING.
* XB H617717B
* rerange the roottab content from view (&lt;table1&gt;).
      IF x_header-bastab EQ space.       &quot;view
        CREATE DATA roottab_row TYPE (x_header-roottab).
        ASSIGN roottab_row-&gt;* TO &lt;roottab_row&gt;.
        ASSIGN &lt;roottab_row&gt; TO &lt;roottab_row_x&gt; CASTING.
        LOOP AT x_namtab.
          CHECK x_namtab-primtabkey &lt;&gt; 0.
          ASSIGN COMPONENT x_namtab-viewfield
              OF STRUCTURE &lt;table1&gt; TO &lt;f_field1&gt;.
          ASSIGN COMPONENT x_namtab-primtabkey
              OF STRUCTURE &lt;roottab_row&gt; TO &lt;f_field2&gt;.
          &lt;f_field2&gt; = &lt;f_field1&gt;.
        ENDLOOP.
*XB H651706B
        PERFORM vim_get_trspkeylen
                 USING x_header-roottab
                 CHANGING p_roottab_keylen.
        IF x_header-generictrp &lt;&gt; space.
          MOVE &lt;roottab_row_x&gt;(x_header-maxtrkeyln) TO &lt;key_x&gt;.
        ELSE.
          MOVE &lt;roottab_row_x&gt;(p_roottab_keylen) TO &lt;key_x&gt;.
*XB H651706E
        ENDIF.
      ELSE.                     &quot;base table no change the sequence
        IF x_header-generictrp &lt;&gt; space.
          MOVE &lt;f1_x&gt;(x_header-maxtrkeyln) TO &lt;key_x&gt;.
        ELSE.
          MOVE &lt;f1_x&gt;(x_header-keylen) TO &lt;key_x&gt;.
        ENDIF.
      ENDIF.
* XB H617717E
*    IF x_header-generictrp &lt;&gt; space.
*      MOVE &lt;f1_x&gt;(x_header-maxtrkeyln) TO &lt;key_x&gt;.
*    ELSE.
*      MOVE &lt;f1_x&gt;(x_header-keylen) TO &lt;key_x&gt;.
*    ENDIF.
      CALL FUNCTION &apos;CHECK_CUSTOMER_NAMES&apos;
        EXPORTING
          tablename   = tablename
          tablekey    = roottab_key
        IMPORTING
          key_allowed = allowed.
    ENDIF.                   &quot;No BC-Set activation       &quot;HCG HW 718225
  ENDIF.

  IF allowed CO &apos; A&apos;.
    EXPORT vimviewname FROM x_header-viewname TO MEMORY ID sy-uname.
    IF x_header-delmdtflag NE space AND status-mode EQ detail_bild.
      mess_type = &apos;S&apos;.
    ELSEIF allowed EQ &apos;A&apos;.
      mess_type = ale_msgty.
      PERFORM set_pf_status USING &apos;ERROR&apos;.
    ENDIF.
    IF neuer EQ &apos;J&apos;.                   &quot;add mode
      IF x_header-delmdtflag &lt;&gt; space.
        ASSIGN &lt;vim_h_old_mkey&gt;(x_header-keylen) TO &lt;h_old_mkey2&gt;.
        IF &lt;h_old_mkey2&gt; = &lt;f1_x&gt;.
*      IF x_header-delmdtflag NE space AND &lt;f1&gt; EQ vim_old_viewkey.
          CHECK check_all_keyr_scnd_time EQ space. &quot;simul. of warning
        ENDIF.
      ENDIF.
*     MESSAGE E019(SV). &quot;Bitte den Schlüssel aus dem zulässigen Namensra
      CLEAR: vim_keyrange_alr_checked, vim_key_alr_checked.
      IF allowed NE &apos;A&apos;.
        MESSAGE ID &apos;SV&apos; TYPE mess_type NUMBER &apos;019&apos;.
      ELSE.
        MESSAGE ID ale_msgid TYPE mess_type NUMBER ale_msgno WITH
          ale_msgv1 ale_msgv2 ale_msgv3 ale_msgv4.
      ENDIF.
      IF x_header-delmdtflag NE space.
        IF status-mode EQ detail_bild.
          &lt;h_old_mkey2&gt; = &lt;f1_x&gt;.
*          vim_old_viewkey = &lt;f1&gt;.
          check_all_keyr_scnd_time = allowed.    &quot;simulation of warning
          TRANSLATE check_all_keyr_scnd_time USING &apos; XA &apos;.
          TRANSLATE neuer USING &apos;JX&apos;.
          CLEAR: function, ok_code. LEAVE SCREEN.
        ENDIF.
        &lt;h_old_mkey2&gt; = &lt;f1_x&gt;.
*        vim_old_viewkey = &lt;f1_x&gt;.
        check_all_keyr_scnd_time = &apos;X&apos;.&quot;simulation of warning
      ENDIF.
    ELSE.                              &quot;update mode.
      IF allowed NE &apos;A&apos;.
        IF vim_special_mode EQ vim_delete.
          mess_type = &apos;S&apos;.
        ELSE.
          mess_type = &apos;W&apos;.
        ENDIF.
        IF vim_system_type NE &apos;SAP&apos;.
          MESSAGE ID &apos;SV&apos; TYPE mess_type NUMBER &apos;117&apos;.
        ELSE.
*       MESSAGE W136(SV). &quot;Vorsicht bei Änderungen, Eintrag gehört dem K
          MESSAGE ID &apos;SV&apos; TYPE mess_type NUMBER &apos;136&apos;.
        ENDIF.
      ELSE.
        IF vim_special_mode EQ vim_delete.
          mess_type = &apos;S&apos;.
        ELSE.
          mess_type = ale_msgty.
        ENDIF.
        MESSAGE ID ale_msgid TYPE mess_type NUMBER ale_msgno WITH
          ale_msgv1 ale_msgv2 ale_msgv3 ale_msgv4.
      ENDIF.
    ENDIF.
    sy-subrc = 8.
  ELSE.
    CLEAR sy-subrc.
  ENDIF.
ENDFORM.                    &quot;check_allowed_keyranges</include_source>
   </include>
   <include NAME="LSVIMF1H" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form BUILD_VALTAB_HFIELDS                                     *
*&amp;--------------------------------------------------------------------*
* build value tab ignoring hidden fields using structure table        *
*&amp;--------------------------------------------------------------------*
FORM build_valtab_hfields.

  DATA: fieldname TYPE fnam_____4.
  FIELD-SYMBOLS: &lt;value&gt; TYPE ANY, &lt;valfld&gt; TYPE ANY,
                 &lt;value_tab&gt; TYPE x.
  CLEAR value_tab.
  ASSIGN value_tab TO &lt;value_tab&gt; CASTING.
  LOOP AT structure_table.
    IF x_header-bastab NE space AND x_header-texttbexst NE space AND
       structure_table-tabname EQ x_header-texttab.
* texttabfield
      ASSIGN COMPONENT structure_table-fieldname
       OF STRUCTURE &lt;vim_ext_txt_struc&gt; TO &lt;value&gt;.
*     READ TABLE x_namtab WITH KEY viewfield = structure_table-fieldname
*                                        texttabfld = &apos;X&apos;.
    ELSE.
* viewfield
      LOOP AT x_namtab WHERE viewfield = structure_table-fieldname AND
                        ( texttabfld = space OR keyflag = space ).
        ASSIGN COMPONENT structure_table-fieldname
         OF STRUCTURE &lt;vim_extract_struc&gt; TO &lt;value&gt;.
        EXIT.
      ENDLOOP.
    ENDIF.
    CHECK &lt;value&gt; IS ASSIGNED.
    CONCATENATE structure_table-tabname structure_table-fieldname
     INTO fieldname SEPARATED BY &apos;-&apos;.
    ASSIGN &lt;value_tab&gt;+structure_table-offset(structure_table-intlen)
     TO &lt;valfld&gt; CASTING TYPE (fieldname).
    MOVE &lt;value&gt; TO &lt;valfld&gt;.
*    CHECK sy-subrc EQ 0.
*    MOVE extract+x_namtab-position(x_namtab-flength)
*     TO value_tab+structure_table-offset(structure_table-intlen).
  ENDLOOP.
  APPEND value_tab.
ENDFORM.                               &quot;build_valtab_hfields</include_source>
   </include>
   <include NAME="LSVIMF1J" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  MARK_IGNORED_ENTRIES                                    *
*&amp;--------------------------------------------------------------------*
* Wiederherstellen der Markierungen für &apos;übergangene&apos; Einträge        *
*---------------------------------------------------------------------*
FORM MARK_IGNORED_ENTRIES CHANGING MIE_NUMBER.
  DATA: TRANSLATION_MASK(2) TYPE C, H_IX LIKE SY-TABIX.

  CHECK IGNORED_ENTRIES_EXIST NE SPACE.
  MOVE: UEBERGEHEN TO TRANSLATION_MASK,
        MARKIERT   TO TRANSLATION_MASK+1(1).
  IF STATUS-MODE EQ LIST_BILD.
    CLEAR MIE_NUMBER.
    LOOP AT TOTAL.
      CHECK &lt;MARK&gt; EQ UEBERGEHEN.
      ADD 1 TO MIE_NUMBER.
      READ TABLE EXTRACT WITH KEY &lt;vim_xTOTAL_key&gt; BINARY SEARCH.&quot;#EC WARNOK
      IF SY-SUBRC EQ 0.
        TRANSLATE &lt;XMARK&gt; USING TRANSLATION_MASK.
        MODIFY EXTRACT INDEX SY-TABIX.
      ENDIF.
      TRANSLATE &lt;MARK&gt; USING TRANSLATION_MASK.
      MODIFY TOTAL.
    ENDLOOP.
  ELSE.
    MOVE DETA_MARK_SAFE TO TRANSLATION_MASK+1(1).
    READ TABLE EXTRACT INDEX NEXTLINE.
    CHECK sy-subrc = 0.                          &quot;UF HW 490645
    MOVE SY-TABIX TO H_IX.
    READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.&quot;#EC WARNOK
    TRANSLATE &lt;MARK&gt; USING TRANSLATION_MASK.
    MODIFY TOTAL INDEX SY-TABIX.
    TRANSLATE &lt;XMARK&gt; USING TRANSLATION_MASK.
    MODIFY EXTRACT INDEX H_IX.
    MIE_NUMBER = 1.
  ENDIF.
  IF mie_number &gt; 0.
    CLEAR IGNORED_ENTRIES_EXIST.
  ENDIF.
ENDFORM.                               &quot; MARK_IGNORED_ENTRIES</include_source>
   </include>
   <include NAME="LSVIMF1K" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form DELETE_CHECK_KEYRANGE                                    *
*&amp;--------------------------------------------------------------------*
* check keyrange for delete                                           *
*---------------------------------------------------------------------*
FORM delete_check_keyrange.
  LOCAL: extract, total, &lt;table1&gt;.
  DATA: dck_specmode_safe LIKE vim_special_mode.

  CLEAR sy-subrc.
  CHECK x_header-customauth CO sap_cust_ctrl_classes OR
        vim_ale_keyspec_check NE space OR
        vim_sync_keyspec_check NE space.
  dck_specmode_safe = vim_special_mode.
  PERFORM move_extract_to_view_wa.
  IF status-mode EQ list_bild.
    vim_special_mode = vim_delete.
  ELSE.
    CLEAR vim_special_mode.
  ENDIF.
  CLEAR vim_keyrange_alr_checked.
  PERFORM check_allowed_keyranges.
  IF sy-subrc NE 0. &quot;vim_import_profile check in check_allowed_keyranges
    IF status-mode EQ list_bild.
      CASE status-type.
        WHEN einstufig.
          CALL SCREEN liste.
          IF ok_code EQ &apos;IGN &apos;. function = ok_code. ENDIF.
        WHEN zweistufig.
          PERFORM process_detail_screen USING &apos;C&apos;.
          status-mode = list_bild.
      ENDCASE.
    ENDIF.
    IF vim_ale_keyspec_check NE space OR  &quot;never delete ALE-locked or
       vim_sync_key_lock_del NE space.    &quot;SYNC-locked keys HW 718225
      function = &apos;IGN &apos;.
    ENDIF.
    CLEAR: sy-subrc, ok_code.
    CASE function.
      WHEN &apos;IGN &apos;. sy-subrc = 4.
      WHEN &apos;ABR &apos;. sy-subrc = 8.
    ENDCASE.
  ENDIF.
* CLEAR VIM_SPECIAL_MODE.
  vim_special_mode = dck_specmode_safe.
  function = &apos;DELE&apos;.
ENDFORM.                               &quot;delete_check_keyrange</include_source>
   </include>
   <include NAME="LSVIMF1L" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      FORM LOESCHEN                                                 *
*&amp;--------------------------------------------------------------------*
* Behandeln der Funktion &apos;DELE&apos;                                       *
*---------------------------------------------------------------------*
FORM LOESCHEN.
  DATA: NUMBER_OF_IGN_ENTR TYPE I, KEY_SAFE type VIM_tabKEY,
        L_IGN_ENTR_EX(1) TYPE C.
  IF STATUS-ACTION NE AENDERN AND STATUS-ACTION NE HINZUFUEGEN.
    MESSAGE I001(SV).
    EXIT.
  ENDIF.
  IF STATUS-MODE EQ DETAIL_BILD.
*   IF STATUS-ACTION EQ HINZUFUEGEN AND &lt;XACT&gt; NE NEUER_EINTRAG.
    IF STATUS-ACTION EQ HINZUFUEGEN AND NEUER EQ &apos;J&apos;.
      MOVE &lt;INITIAL&gt; TO &lt;TABLE1&gt;.
      IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
        MOVE &lt;TEXT_INITIAL&gt; TO &lt;TABLE1_TEXT&gt;.
      ENDIF.
      IF  &lt;TABLE1&gt; is INITIAL.
        MESSAGE s413(sv).
      else.
        MESSAGE S013(SV).
      endif.
      CLEAR &lt;STATUS&gt;-UPD_FLAG.
      EXIT.
    ENDIF.
    MOVE &lt;XMARK&gt; TO DETA_MARK_SAFE.
    IF X_HEADER-DELMDTFLAG NE SPACE.
      PERFORM CHECK_IF_ENTRY_IS_TO_DISPLAY USING &apos;L&apos; &lt;VIM_xEXTRACT_KEY&gt;
                                                 SPACE &lt;VIM_BEGDATE&gt;.
      NUMBER_OF_IGN_ENTR = SY-SUBRC.
      KEY_SAFE = &lt;VIM_xEXTRACT_KEY&gt;.
    ENDIF.
    IF X_HEADER-DELMDTFLAG EQ SPACE OR NUMBER_OF_IGN_ENTR LT 8.
      READ TABLE EXTRACT INDEX NEXTLINE.
    ELSE.
      MOVE KEY_SAFE TO &lt;VIM_xEXTRACT_KEY&gt;.
      READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH. &quot;#EC WARNOK
      EXTRACT = TOTAL.
    ENDIF.
  ENDIF.
  IF X_HEADER-FRM_BF_DEL NE SPACE.
    PERFORM (X_HEADER-FRM_BF_DEL) IN PROGRAM (SY-REPID).
  ENDIF.
  IF VIM_CALLED_BY_CLUSTER NE SPACE.
    PERFORM VIM_STORE_STATE_INFO.
    CALL FUNCTION &apos;VIEWCLUSTER_DELETE_DEPENDENT&apos;
      EXPORTING
        VIEW_NAME         = X_HEADER-VIEWNAME
        STATUS_MODE       = STATUS-MODE
        WORKAREA          = EXTRACT
        NO_DIALOG         = VIM_EXTERNAL_MODE
      IMPORTING
        IGN_ENTRIES_EXIST = L_IGN_ENTR_EX.
    IF L_IGN_ENTR_EX NE SPACE.
      IGNORED_ENTRIES_EXIST = L_IGN_ENTR_EX.
    ENDIF.
  ENDIF.
  IF STATUS-MODE EQ LIST_BILD.
    PERFORM LISTE_LOESCHE.
  ELSE.
*   IF &lt;STATUS&gt;-DISPL_MODE EQ EXPANDED.
*     READ TABLE EXTRACT INDEX NEXTLINE.
*   ELSE.
*     READ TABLE TOTAL WITH KEY &lt;F1&gt; BINARY SEARCH.
*     EXTRACT = TOTAL.
*   ENDIF.
    IF &lt;XMARK&gt; NE UEBERGEHEN.
      PERFORM DELETE_CHECK_KEYRANGE.
      IF SY-SUBRC EQ 0.
        PERFORM DETAIL_LOESCHE.
      ELSE.
        COUNTER = 0.
      ENDIF.
    ELSE.
      COUNTER = 0.
    ENDIF.
  ENDIF.
  IF VIM_SPECIAL_MODE EQ VIM_UPGRADE AND COUNTER EQ 0.
    FUNCTION = OK_CODE = &apos;IGN &apos;.
  ENDIF.
  IF X_HEADER-FRM_AF_DEL NE SPACE.
    PERFORM (X_HEADER-FRM_AF_DEL) IN PROGRAM (SY-REPID).
  ELSE.
    IF IGNORED_ENTRIES_EXIST NE SPACE.
      PERFORM MARK_IGNORED_ENTRIES CHANGING NUMBER_OF_IGN_ENTR.
      CHECK VIM_SPECIAL_MODE NE VIM_UPGRADE.
      IF NUMBER_OF_IGN_ENTR EQ 1.
        MESSAGE S115(SV). &quot;Eintrag konnte nicht gelöscht werden
      ELSEIF NUMBER_OF_IGN_ENTR GT 1.
        MESSAGE S116(SV) WITH NUMBER_OF_IGN_ENTR.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; LOESCHEN</include_source>
   </include>
   <include NAME="LSVIMF1M" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form ZURUECKHOLEN                                             *
*&amp;--------------------------------------------------------------------*
* Behandeln der Funktion &apos;UNDO&apos;                                       *
*---------------------------------------------------------------------*
FORM zurueckholen.

  DATA: number_of_ign_entr TYPE i, key_safe TYPE tabl1024,
        z_ign_entr_ex(1) TYPE c, z_specmode_safe(1) TYPE c.

  IF status-action NE aendern OR status-delete NE geloescht.
    MESSAGE i001(sv).
    EXIT.
  ENDIF.
  CLEAR counter. z_specmode_safe = vim_special_mode.
  vim_special_mode = vim_undelete.
  IF status-mode EQ detail_bild.
    MOVE &lt;xmark&gt; TO deta_mark_safe.
    IF x_header-delmdtflag NE space.
      PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xextract_key&gt;
                                                 space &lt;vim_begdate&gt;.
      number_of_ign_entr = sy-subrc.
      key_safe = &lt;vim_xextract_key&gt;.
    ENDIF.
*   IF &lt;STATUS&gt;-DISPL_MODE EQ EXPANDED.
    IF x_header-delmdtflag EQ space OR number_of_ign_entr LT 8.
      READ TABLE extract INDEX nextline.
    ELSE.
      READ TABLE total WITH KEY key_safe BINARY SEARCH.     &quot;#EC WARNOK
      extract = total.
    ENDIF.
  ENDIF.
  IF x_header-frm_bf_udl NE space.
    PERFORM (x_header-frm_bf_udl) IN PROGRAM (sy-repid).
  ENDIF.
  IF vim_called_by_cluster NE space.
    PERFORM vim_store_state_info.
    CALL FUNCTION &apos;VIEWCLUSTER_UNDO_DEPENDENT&apos;
         EXPORTING
              view_name         = x_header-viewname
              status_mode       = status-mode
              workarea          = extract
              no_dialog         = vim_external_mode
         IMPORTING
              ign_entries_exist = z_ign_entr_ex.
    IF z_ign_entr_ex NE space.
      ignored_entries_exist = z_ign_entr_ex.
    ENDIF.
  ENDIF.
  IF status-mode EQ list_bild.
    PERFORM liste_zurueckholen.
  ELSE.
    IF &lt;xmark&gt; NE uebergehen.
      PERFORM detail_zurueckholen.
    ENDIF.
  ENDIF.
  IF replace_mode NE space AND counter EQ 0.
    function = ok_code = &apos;IGN &apos;.
  ENDIF.
  IF x_header-frm_af_udl NE space.
    PERFORM (x_header-frm_af_udl) IN PROGRAM (sy-repid).
  ELSE.
    IF ignored_entries_exist NE space.
      PERFORM mark_ignored_entries CHANGING number_of_ign_entr.
      IF replace_mode EQ space.
        IF number_of_ign_entr EQ 1.
          MESSAGE s113(sv). &quot;Eintrag konnte nicht zurückgeholt werden
        ELSEIF number_of_ign_entr GT 1.
          MESSAGE s114(sv) WITH number_of_ign_entr.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
* CLEAR VIM_SPECIAL_MODE.
  vim_special_mode = z_specmode_safe.
ENDFORM.                               &quot; ZURUECKHOLEN</include_source>
   </include>
   <include NAME="LSVIMF1N" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*&amp;--------------------------------------------------------------------*
*&amp;      Form  EDIT_VIEW_ENTRY                                         *
*&amp;--------------------------------------------------------------------*
*       edit entry in TOTAL/EXTRACT due to foreign request            *
*---------------------------------------------------------------------*
* ENTRY  ---&gt; entry to edit                                           *
* ACTION ---&gt; action: UPD - add/update, DEL - delete, UDL - undelete  *
*             IGN - mark entry as to ignore, MRK - mark/unmark entry  *
* SY_SUBRC -&gt; return code: 0 - all right, others: failure             *
* EXT    ---&gt; table containing selected view entries                  *
* TOT    ---&gt; table containing all view entries                       *
* HEADER ---&gt; table containing header information of current view     *
* NAMTAB ---&gt; table containing information about current viewfields   *
* SELLIST --&gt; table containing select options                         *
*---------------------------------------------------------------------*
FORM edit_view_entry TABLES ext tot
                            header  STRUCTURE vimdesc
                            namtab  STRUCTURE vimnamtab
                            sellist STRUCTURE vimsellist
                     USING value(entry) value(action).
  DATA: state_vect_name(37) TYPE c,
        rc LIKE sy-subrc, pos LIKE sy-fdpos,
        texttablename(31) TYPE c VALUE &apos;*          &apos;, mmark(1) TYPE c,
        tab_rc LIKE sy-subrc, tab_ix LIKE sy-tabix,
        dummy_tab LIKE vimexclfun OCCURS 1, name(20) TYPE c.       &quot;#EC NEEDED
  FIELD-SYMBOLS: &lt;tot_x&gt; TYPE x, &lt;ext_x&gt; TYPE x, &lt;ent_x&gt; TYPE x,
                 &lt;viewkey&gt; TYPE x, &lt;act&gt; TYPE c, &lt;xact&gt; TYPE c,
                 &lt;mrk&gt; TYPE c, &lt;xmrk&gt; TYPE c,
                 &lt;txt_act&gt; TYPE c,
                 &lt;tot_struc&gt; TYPE ANY, &lt;ent_struc&gt; TYPE ANY,
                 &lt;tot_txt&gt; TYPE x, &lt;ent_txt&gt; TYPE x, &lt;ent_txt2&gt; TYPE x,
                 &lt;tot_txt_struc&gt; TYPE ANY, &lt;txt_init&gt; TYPE ANY.

  READ TABLE header INDEX 1.
  pos = header-after_tabc.
*  MOVE HEADER-TABLEN TO POS.
  ASSIGN: tot TO &lt;tot_x&gt; CASTING, ext TO &lt;ext_x&gt; CASTING,
          entry TO &lt;ent_x&gt; CASTING,
          &lt;tot_x&gt; TO &lt;tot_struc&gt; CASTING TYPE (header-maintview),
          &lt;ent_x&gt; TO &lt;ent_struc&gt; CASTING TYPE (header-maintview).
  IF header-bastab NE space AND header-texttbexst NE space.
* tab+txttb
    ADD header-aft_txttbc TO pos.
    MOVE header-texttab TO texttablename+1.
    ASSIGN: &lt;tot_x&gt;+header-after_tabc(header-texttablen) TO &lt;tot_txt&gt;,
            &lt;ent_x&gt;+header-after_tabc(header-texttablen) TO &lt;ent_txt&gt;,
            &lt;tot_txt&gt; TO &lt;tot_txt_struc&gt; CASTING TYPE (header-texttab),
            (texttablename) TO &lt;txt_init&gt;.
*    ASSIGN: TOT+HEADER-TABLEN(HEADER-TEXTTABLEN) TO &lt;TOT_TXT&gt;,
*            ENTRY+HEADER-TABLEN(HEADER-TEXTTABLEN) TO &lt;ENT_TXT&gt;,
*            (TEXTTABLENAME) TO &lt;TXT_INIT&gt;.
  ENDIF.
  ASSIGN: &lt;ent_x&gt;(header-keylen) TO &lt;viewkey&gt;,
          &lt;tot_x&gt;+pos(cl_abap_char_utilities=&gt;charsize)
           TO &lt;act&gt; CASTING,
          &lt;ext_x&gt;+pos(cl_abap_char_utilities=&gt;charsize)
           TO &lt;xact&gt; CASTING.
  ADD cl_abap_char_utilities=&gt;charsize TO pos.
  ASSIGN: &lt;tot_x&gt;+pos(cl_abap_char_utilities=&gt;charsize)
           TO &lt;mrk&gt; CASTING,
          &lt;ext_x&gt;+pos(cl_abap_char_utilities=&gt;charsize)
           TO &lt;xmrk&gt; CASTING.
  IF header-bastab NE space AND header-texttbexst NE space.&quot;tab+txttb
    ADD cl_abap_char_utilities=&gt;charsize TO pos.
    ASSIGN &lt;tot_x&gt;+pos(cl_abap_char_utilities=&gt;charsize)
     TO &lt;txt_act&gt; CASTING.
  ENDIF.
*  ASSIGN: ENTRY(HEADER-KEYLEN) TO &lt;VIEWKEY&gt;,
*          TOT+POS(1) TO &lt;ACT&gt;.
*  ADD 1 TO POS.
*  ASSIGN TOT+POS(1) TO &lt;MRK&gt;.
*  IF HEADER-BASTAB NE SPACE AND HEADER-TEXTTBEXST NE SPACE.&quot;tab+txttb
*    ADD 1 TO POS.
*    ASSIGN TOT+POS(1) TO &lt;TXT_ACT&gt;.
*    SUBTRACT 1 FROM POS.
*  ENDIF.
  IF header-viewname NE last_ext_modif_view.
    MOVE state_vect_prefix TO state_vect_name.
    WRITE header-maintview TO state_vect_name+state_vect_prefix_length.
    ASSIGN (state_vect_name) TO &lt;state&gt;.
    MOVE header-viewname TO last_ext_modif_view.
  ENDIF.
  READ TABLE tot WITH KEY &lt;viewkey&gt; BINARY SEARCH.          &quot;#EC WARNOK
  tab_rc = sy-subrc. tab_ix = sy-tabix.
  IF sy-subrc EQ 0.                    &quot; entry found in TOT
    CASE action.
      WHEN &apos;DEL&apos;.
        CASE &lt;act&gt;.
          WHEN neuer_eintrag.
            &lt;act&gt; = neuer_geloescht.
          WHEN original.
            &lt;act&gt; = geloescht.
          WHEN aendern.
            &lt;act&gt; = update_geloescht.
        ENDCASE.
        IF header-bastab NE space AND header-texttbexst NE space.
          CASE &lt;txt_act&gt;.
            WHEN neuer_eintrag.
              &lt;txt_act&gt;            = neuer_geloescht.
            WHEN original.
              IF &lt;tot_txt_struc&gt; NE &lt;txt_init&gt;.
                &lt;txt_act&gt;             = geloescht.
              ENDIF.
            WHEN aendern.
              &lt;txt_act&gt;             = update_geloescht.
          ENDCASE.
        ENDIF.
        mmark = &lt;mrk&gt;.
        IF &lt;mrk&gt; EQ markiert.
          &lt;mrk&gt; = nicht_markiert. SUBTRACT 1 FROM &lt;state&gt;-mk_to.
        ENDIF.
        MODIFY tot INDEX sy-tabix.
        READ TABLE ext WITH KEY &lt;viewkey&gt;.                  &quot;#EC WARNOK
        IF sy-subrc EQ 0.
          IF mmark EQ markiert.
            SUBTRACT 1 FROM &lt;state&gt;-mk_xt.
          ENDIF.
          DELETE ext INDEX sy-tabix.
          SUBTRACT 1 FROM &lt;state&gt;-maxlines.
        ENDIF.
      WHEN &apos;UPD&apos;.
        IF header-bastab NE space AND header-texttbexst NE space.
          IF &lt;tot_txt&gt; NE &lt;ent_txt&gt;.
            IF &lt;tot_txt_struc&gt; EQ &lt;txt_init&gt;.
              &lt;txt_act&gt; = neuer_eintrag.
            ELSE.
              IF &lt;txt_act&gt; EQ original.
                &lt;txt_act&gt; = aendern.
              ENDIF.
            ENDIF.
            MOVE &lt;ent_txt&gt; TO &lt;tot_txt&gt;.
          ENDIF.
        ENDIF.
        MOVE &lt;ent_struc&gt; TO &lt;tot_struc&gt;.
        IF &lt;act&gt; EQ original.
          &lt;act&gt; = aendern.
        ENDIF.
        MODIFY tot INDEX sy-tabix.
        READ TABLE ext WITH KEY &lt;viewkey&gt;.                  &quot;#EC WARNOK
        IF sy-subrc EQ 0.
          MOVE tot TO ext.
          MODIFY ext INDEX sy-tabix.
        ENDIF.
      WHEN &apos;UDL&apos;.
        CASE &lt;act&gt;.
          WHEN neuer_geloescht.
            &lt;act&gt; = neuer_eintrag.
          WHEN geloescht.
            &lt;act&gt; = original.
          WHEN update_geloescht.
            &lt;act&gt; = aendern.
          WHEN OTHERS.
            rc = 8.
        ENDCASE.
        IF rc EQ 0.
          IF header-bastab NE space AND header-texttbexst NE space.
            CASE &lt;txt_act&gt;.
              WHEN neuer_geloescht.
                &lt;txt_act&gt;         = neuer_eintrag.
              WHEN geloescht.
                &lt;txt_act&gt;         = original.
              WHEN update_geloescht.
                &lt;txt_act&gt;         = aendern.
            ENDCASE.
          ENDIF.
          MODIFY tot INDEX sy-tabix.
          READ TABLE ext WITH KEY &lt;viewkey&gt;.                &quot;#EC WARNOK
          IF sy-subrc EQ 0.
            IF &lt;state&gt;-selected EQ geloescht.
              DELETE ext INDEX sy-tabix.
            ELSE.
              &lt;xmrk&gt; = &lt;mrk&gt;.
              &lt;xact&gt; = &lt;act&gt;.
              MODIFY ext INDEX sy-tabix.
            ENDIF.
          ENDIF.
        ENDIF.
      WHEN &apos;IGN&apos;.
        IF &lt;mrk&gt; EQ markiert.
          MOVE uebergehen TO &lt;mrk&gt;.
          MODIFY tot INDEX sy-tabix.
          READ TABLE ext WITH KEY &lt;viewkey&gt;.                &quot;#EC WARNOK
          IF sy-subrc EQ 0.
            &lt;xmrk&gt; = &lt;mrk&gt;.
            MODIFY ext INDEX sy-tabix.
          ENDIF.
        ENDIF.
        rc = 1.
      WHEN &apos;MRK&apos;.
        IF &lt;mrk&gt; EQ markiert.
          MOVE nicht_markiert TO &lt;mrk&gt;.
        ELSE.
          MOVE markiert TO &lt;mrk&gt;.
        ENDIF.
        MODIFY tot INDEX sy-tabix.
        IF &lt;mrk&gt; EQ markiert.
          ADD 1 TO &lt;state&gt;-mk_to.
        ELSE.
          SUBTRACT 1 FROM &lt;state&gt;-mk_to.
        ENDIF.
        READ TABLE ext WITH KEY &lt;viewkey&gt;.                  &quot;#EC WARNOK
        IF sy-subrc EQ 0.
          &lt;xmrk&gt; = &lt;mrk&gt;.
          MODIFY ext INDEX sy-tabix.
          IF &lt;mrk&gt; EQ markiert.
            ADD 1 TO &lt;state&gt;-mk_xt.
          ELSE.
            SUBTRACT 1 FROM &lt;state&gt;-mk_xt.
          ENDIF.
        ENDIF.
        rc = 1.
    ENDCASE.
  ELSE.                                &quot;entry NOT found in TOT
    CLEAR sy-subrc.
    IF action NE &apos;UPD&apos;.
      rc = 8.
    ELSE.
      IF header-selection NE space.
        IF header-bastab &lt;&gt; space AND header-texttbexst &lt;&gt; space.
          ASSIGN &lt;ent_txt&gt; TO &lt;ent_txt2&gt;.
        ELSE.
          ASSIGN &lt;ent_x&gt; TO &lt;ent_txt2&gt;.
        ENDIF.
        CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
          EXPORTING
            tabname                   = header-maintview
            entry                     = entry
            entry_text                = &lt;ent_txt2&gt;
            ddic                      = &apos;J&apos;
            key                       = &apos;J&apos;
            ignore_blank_subsetfields = &apos;N&apos;
          TABLES
            x_namtab                  = namtab
            x_header                  = header
            sellist                   = sellist
          EXCEPTIONS
            entry_not_fits            = 8.
      ENDIF.
      IF sy-subrc EQ 0.
        MOVE &lt;ent_struc&gt; TO &lt;tot_struc&gt;.
        &lt;act&gt; = neuer_eintrag.
        &lt;mrk&gt; = nicht_markiert.
        IF header-bastab NE space AND header-texttbexst NE space.
          &lt;tot_txt&gt; = &lt;ent_txt&gt;.
          IF &lt;tot_txt_struc&gt; NE &lt;txt_init&gt;.
            &lt;txt_act&gt; = neuer_eintrag.
          ELSE.
            &lt;txt_act&gt; = original.
          ENDIF.
        ENDIF.
        CASE tab_rc.
          WHEN 4.
            INSERT tot INDEX tab_ix.
          WHEN 8.
            APPEND tot.
        ENDCASE.
      ELSE.
        rc = sy-subrc.
      ENDIF.
    ENDIF.
  ENDIF.
  IF rc EQ 0.
    MOVE &apos;X&apos; TO &lt;state&gt;-upd_flag.
  ENDIF.
  sy-subrc = ( rc DIV 8 ) * 8.
ENDFORM.                               &quot; EDIT_VIEW_ENTRY</include_source>
   </include>
   <include NAME="LSVIMF1O" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_FILL_WHERETAB                                        *
*---------------------------------------------------------------------*
* fill internal table for dynamic select                              *
*---------------------------------------------------------------------*
FORM VIM_FILL_WHERETAB.
  CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
       EXPORTING
            TABLENAME               = X_HEADER-ROOTTAB
       TABLES
            SELLIST                 = DBA_SELLIST
            WHERETAB                = VIM_WHERETAB
            X_NAMTAB                = X_NAMTAB
    EXCEPTIONS                                              &quot;#EC FB_RC
            NO_CONDITIONS_FOR_TABLE = 01.
ENDFORM.                               &quot;vim_fill_wheretab.</include_source>
   </include>
   <include NAME="LSVIMF1P" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM PREPARE_READ_REQUEST                                     *
*---------------------------------------------------------------------*
*       prepare global data for read request                          *
*---------------------------------------------------------------------*
FORM prepare_read_request.

  DATA: action TYPE activ_auth, oc_to_be_checked TYPE xfeld,
        sellines TYPE i, viewtype.                          &quot;#EC TYPES_MISS

  PERFORM init_state_vector.
  PERFORM vim_reset_texttab USING view_name.           &quot;SW Texttransl
  IF &lt;status&gt;-st_action NE anzeigen AND                 &quot;HCG HW680584
    vim_import_profile = space.     &quot;No actlinks needed in activation
* If table completely locked by cust distribution -&gt; no bc-locks needed
    IF x_header-bastab EQ space.
      viewtype = &apos;V&apos;.
    ELSE.
      viewtype = &apos;S&apos;.
    ENDIF.
    CALL FUNCTION &apos;SCTM_CHECK_VIEW_EDIT&apos;
             EXPORTING
               viewname        = view_name
               viewtype        = viewtype
               bcset           = vim_bcset_id &quot;if NE space -&gt; BC-set act.
             IMPORTING
               edit_flag       = vim_sync_edit_lock
               kespec_flag     = vim_sync_keyspec_check
               sourcesys       = vim_sctm_sourcesys
             EXCEPTIONS                                     &quot;#EC FB_RC
               no_sync_present
               old_sync_system
               rfc_failure.
    IF vim_sync_edit_lock NE space AND      &quot;Table locked completely
       vim_sync_keyspec_check EQ space.
    ELSE.
      PERFORM vim_bc_logs_get USING view_name x_header x_namtab[]
                            CHANGING vim_bc_entry_list.
      vim_actlinks = x_header-viewname. &quot;For which actlinks are valid
    ENDIF.
  ENDIF.
  IF vim_adjust_middle_level_mode EQ subset. &quot;ignore subsets
    vim_adj_header = x_header[].
    CLEAR x_header-subsetflag. MODIFY x_header INDEX 1.
    vim_adj_namtab = x_namtab[].
    LOOP AT x_namtab WHERE readonly EQ subset AND keyflag NE space.
      CLEAR x_namtab-readonly. MODIFY x_namtab.
    ENDLOOP.
    vim_adj_dbasellist = dba_sellist[].
    LOOP AT dba_sellist WHERE ddic CO vim_subset_marks.
      IF dba_sellist-value IS INITIAL AND dba_sellist-initial EQ space.
        DELETE dba_sellist. &quot;unvollständige Subsetbedingungen löschen
      ELSE.
        TRANSLATE dba_sellist-ddic USING &apos;S BX&apos;. &quot;&apos;S A BXMX&apos;.
        MODIFY dba_sellist.
      ENDIF.
    ENDLOOP.
    DESCRIBE TABLE dba_sellist.
    IF sy-tfill GT 0.
      READ TABLE dba_sellist INDEX sy-tfill.
      CLEAR dba_sellist-and_or.
      MODIFY dba_sellist INDEX sy-tabix.
    ENDIF.
  ENDIF.
* remove old selections from authorisation
*  if not vim_dba_sel_kept is initial and vim_called_by_cluster = space.
*    refresh dba_sellist[].                                 &quot;UF210200b
*    append lines of vim_dba_sel_kept to dba_sellist.
*  endif.
*  DELETE dba_sellist WHERE ddic = &apos;M&apos;.
  IF vim_called_by_cluster = space.
    DELETE dba_sellist WHERE from_auth &lt;&gt; space
     AND ddic &lt;&gt; &apos;S&apos; and ddic &lt;&gt; &apos;B&apos;.                       &quot;UF210200e
    DESCRIBE TABLE dba_sellist LINES sellines.
    IF sellines GT 0.
      READ TABLE dba_sellist INDEX sellines.
      CLEAR dba_sellist-and_or.
      MODIFY dba_sellist INDEX sy-tabix.
    ENDIF.
  ENDIF.                                                     &quot;UF210200
  IF NOT vim_oc_inst IS INITIAL.
* insert selection from authorisation into sellist
    IF &lt;status&gt;-st_action = anzeigen.
      action = svorg_read.
    ELSE.
      action = svorg_maint.
    ENDIF.
    CALL METHOD vim_oc_inst-&gt;combine_vimsel_with_auth
      EXPORTING
        action  = action
      CHANGING
        sellist = dba_sellist[].
    CALL METHOD vim_oc_inst-&gt;get_to_be_checked
      IMPORTING
        to_be_checked = oc_to_be_checked.
    IF oc_to_be_checked &lt;&gt; space or x_header-bastab &lt;&gt; space.
* check TOTAL vs. authorisation after reading
      PERFORM vim_maint_selflag USING    &apos;S&apos;
                                CHANGING x_header-selection.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;prepare_read_request</include_source>
   </include>
   <include NAME="LSVIMF1Q" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM GET_KEYTAB                                               *
*---------------------------------------------------------------------*
*       read table e071k                                              *
*---------------------------------------------------------------------*
FORM GET_KEYTAB.
  LOCAL: E071.
  LOOP AT VIM_CORR_OBJTAB INTO E071.
    CALL FUNCTION &apos;TRINT_READ_COMM_KEYS&apos;
         EXPORTING
              WI_APPENDING = &apos;X&apos;
              WI_E071      = E071
              WI_TRKORR    = &lt;STATUS&gt;-CORR_NBR
         TABLES
              WT_E071K     = CORR_KEYTAB.
  ENDLOOP.
  CLEAR: &lt;STATUS&gt;-KEYTBMODFD, GET_CORR_KEYTAB, &lt;STATUS&gt;-KEYTBINVLD.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF1R" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM TRANSPORTIEREN                                           *
*---------------------------------------------------------------------*
*       send popup to confirm: saving etc.                            *
*---------------------------------------------------------------------*
FORM TRANSPORTIEREN.
  CALL FUNCTION &apos;POPUP_TO_CONFIRM_WITH_MESSAGE&apos;
       EXPORTING
            TITEL         = SVIM_TEXT_020  &quot;Einträge transportieren
            DIAGNOSETEXT1 = SVIM_TEXT_018  &quot;Daten wurden verändert.
            DIAGNOSETEXT2 =
               SVIM_TEXT_021           &quot;Wenn die Änderungen transport
            DIAGNOSETEXT3 =
               SVIM_TEXT_022           &quot;werden sollen, müssen sie ers
            TEXTLINE1     = SVIM_TEXT_023  &quot;gesichert werden.
            TEXTLINE2     = SVIM_TEXT_019  &quot;Änderungen vorher sichern ?
       IMPORTING
            ANSWER        = ANSWER.
  CASE ANSWER.
    WHEN &apos;J&apos;.
      SY-SUBRC = 0.
    WHEN &apos;N&apos;.
      CLEAR &lt;STATUS&gt;-UPD_FLAG.
      SY-SUBRC = 8.
    WHEN &apos;A&apos;.
      SY-SUBRC = 12.
  ENDCASE.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF1S" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CORR_UPD.                                                *
*---------------------------------------------------------------------*
*       Behandlung des FCODES &apos;SAVE&apos; im Transportmodus                *
*       logging of changes                                            *
*---------------------------------------------------------------------*
FORM corr_upd.
  DATA: ko200 LIKE ko200,
        cu_e071k_tab LIKE e071k OCCURS 100,
        cu_e071_tab LIKE e071 OCCURS 10,
        cu_trpar LIKE trpar_int OCCURS 1,
        cu_trmess LIKE trmess_int OCCURS 1,
        cu_tadir LIKE tadir,
        cu_e071_htb LIKE e071 OCCURS 10,
        cu_dderr LIKE dderr,                                             &quot;#EC NEEDED
        cu_corr_keytab_safe LIKE corr_keytab OCCURS 50,
        cu_corr_keyhtb LIKE corr_keytab OCCURS 50,
        lockable_objects_exist(1) TYPE c, e071_safe LIKE e071,
        cu_ko200_tab LIKE ko200 OCCURS 10,
        cu_last_corr LIKE e071-trkorr,
        w_cu_ko200 LIKE ko200,
        cu_ko200_sec LIKE ko200 OCCURS 10,
        corr_for_insert LIKE e071-trkorr, rc LIKE sy-subrc,
        cu_new_locks LIKE strlocktab OCCURS 10,                        &quot;#EC NEEDED
        cu_begix TYPE i,
        cu_hobjfunc(1) TYPE c, cu_tdevc LIKE tdevc,
        cu_order_type LIKE e070-trfunction, cu_obj_not_chkd(1) TYPE c,
        cu_task_type LIKE e070-trfunction, cu_appendable(1) TYPE c,
        cu_request TYPE trwbo_request, cu_category LIKE vim_syst,
        cu_corr_objtab LIKE LINE OF vim_corr_objtab OCCURS 0,
        cu_last_cat LIKE vim_syst, cu_h_flag(1) TYPE c,
        cu_h_e071 LIKE e071, cuiorder LIKE e071-trkorr,
        cuitask LIKE e071-trkorr.

  DATA: lt_edt_objects       TYPE tredt_objects,
        ls_edt_object        TYPE LINE OF tredt_objects.
  DATA: corr_keyhtb_wa LIKE LINE OF cu_corr_keyhtb.
  FIELD-SYMBOLS: &lt;ls_e071&gt;   TYPE e071.

  FIELD-SYMBOLS: &lt;vim_corr_objtab&gt; LIKE vim_corr_objtab,
                 &lt;e071&gt; LIKE e071.

  CHECK maint_mode EQ transportieren OR vim_client_state EQ vim_log.
  CHECK x_header-flag NE vim_transport_denied.
  CHECK vim_actopts-transp_off NE bc_transport_denied.
  cu_h_flag = x_header-flag.
  IF vim_corr_obj_viewname NE x_header-viewname.
    REFRESH vim_corr_objtab.
  ELSE.
    cu_corr_objtab = vim_corr_objtab[].
  ENDIF.
  e071_safe = e071.
  CLEAR e071.
  LOOP AT corr_keytab WHERE mastername EQ x_header-viewname
                        AND ( mastertype EQ vim_unlockable_object
                              OR mastertype EQ vim_lockable_object ).
    MOVE: corr_keytab-trkorr  TO e071-trkorr,    &quot;fill object tab
          corr_keytab-pgmid   TO e071-pgmid,
          corr_keytab-object  TO e071-object,
*         CORR_KEYTAB-OBJNAME TO E071-OBJ_NAME,
          corr_keytab-objfunc TO e071-objfunc,
          corr_keytab-activity TO e071-activity. &quot;UF738595/2001
    IF corr_keytab-objname EQ vim_long_objname.
      e071-obj_name = corr_keytab-tabkey.
    ELSE.
      e071-obj_name = corr_keytab-objname.
    ENDIF.
    APPEND e071 TO cu_e071_tab.
    READ TABLE vim_corr_objtab WITH KEY pgmid = e071-pgmid
                                        object = e071-object
                                        obj_name = e071-obj_name
                               TRANSPORTING NO FIELDS.
    IF sy-subrc NE 0.                  &quot;entry not found...
*      vim_corr_objtab = e071.
      MOVE-CORRESPONDING e071 TO vim_corr_objtab.     &quot;UNICODE
      IF corr_keytab-mastertype EQ vim_unlockable_object.
*       APPEND E071 TO VIM_ULO_TRSP_OBJS.
        vim_corr_objtab-lockable = space.
      ELSE.
*       APPEND E071 TO VIM_LCK_TRSP_OBJS.
        vim_corr_objtab-lockable = lockable_objects_exist = &apos;X&apos;.
      ENDIF.
      APPEND vim_corr_objtab.
      IF corr_keytab-flag EQ &apos;V&apos;.
        IF vim_corr_obj_viewname NE x_header-viewname.
          APPEND vim_corr_objtab TO cu_corr_objtab.
        ENDIF.
      ELSE.
        cu_obj_not_chkd = &apos;X&apos;.
      ENDIF.
    ELSEIF corr_keytab-mastertype EQ vim_lockable_object.
      lockable_objects_exist = &apos;X&apos;.
    ENDIF.
  ENDLOOP.
  LOOP AT cu_e071_tab INTO e071.
    LOOP AT corr_keytab WHERE mastertype EQ e071-object
                          AND mastername EQ e071-obj_name
                          AND pgmid EQ vim_deleted_key.
      corr_keytab-pgmid = transporter. &quot;collect all keys to
      APPEND corr_keytab TO cu_e071k_tab. &quot;delete for all objects
      DELETE corr_keytab.
    ENDLOOP.
  ENDLOOP.
  vim_corr_obj_viewname = x_header-viewname.
* save keytab entries related to objects not in e071 tab
  LOOP AT corr_keytab.
    IF x_header-flag NE space AND x_header-frm_e071 EQ space AND
       ( x_header-frm_e071ka NE space OR x_header-frm_e071ks NE space ).
      IF corr_keytab-objname EQ vim_long_objname.
        READ TABLE cu_e071_tab WITH KEY
         object = corr_keytab-object
         obj_name = corr_keytab-tabkey
         TRANSPORTING NO FIELDS.
      ELSE.
        READ TABLE cu_e071_tab WITH KEY
         object = corr_keytab-object
         obj_name = corr_keytab-objname
         TRANSPORTING NO FIELDS.
      ENDIF.
      IF sy-subrc EQ 0.                &quot;delete corr_keytab anyway
        DELETE corr_keytab.
      ENDIF.
    ELSE.
      READ TABLE cu_e071_tab WITH KEY
       object = corr_keytab-mastertype
       obj_name = corr_keytab-mastername
       TRANSPORTING NO FIELDS.
    ENDIF.
    CHECK sy-subrc NE 0.
    APPEND corr_keytab TO cu_corr_keytab_safe.
    DELETE corr_keytab.
  ENDLOOP.
  IF maint_mode EQ aendern AND lockable_objects_exist EQ space AND
     cu_obj_not_chkd NE space.
* may be objects are not yet checked
    LOOP AT cu_e071_tab ASSIGNING &lt;e071&gt;.        &quot;UNICODE
      MOVE-CORRESPONDING &lt;e071&gt; TO w_cu_ko200.   &quot;UNICODE
      APPEND w_cu_ko200 TO cu_ko200_tab.         &quot;UNICODE
*    cu_ko200_tab = cu_e071_tab.
    ENDLOOP.                                     &quot;UNICODE

    CALL FUNCTION &apos;VIM_TR_OBJECTS_CHECK&apos;
*   exporting
*     IV_NO_SHOW_OPTION              = &apos;X&apos;
     IMPORTING
       WE_ORDER                      = cuiorder
       WE_TASK                       = cuitask
       WE_OBJECTS_APPENDABLE         = cu_appendable
     TABLES
       wt_ko200                      = cu_ko200_tab
       WT_E071K                      = corr_keytab
*       TT_TADIR                      =
     EXCEPTIONS
       CANCEL_EDIT_OTHER_ERROR       = 1
       SHOW_ONLY_OTHER_ERROR         = 2
       OTHERS                        = 3
              .
*    IF sy-subrc &lt;&gt; 0.
** Implement suitable error handling here
*    ENDIF.
*
*    CALL FUNCTION &apos;TR_OBJECTS_CHECK&apos;
**       exporting
**            IV_NO_SHOW_OPTION              = &apos;X&apos;
*       IMPORTING
*            we_order                       = cuiorder
*            we_task                        = cuitask
*            we_objects_appendable          = cu_appendable
*         TABLES
*              wt_ko200                     = cu_ko200_tab
*              wt_e071k                     = corr_keytab
*       EXCEPTIONS
*       cancel_edit_other_error       = 1
*       show_only_other_error         = 2
*       OTHERS                        = 3.
    IF sy-subrc NE 0 OR cu_appendable EQ space.
      rc = sy-subrc.
      LOOP AT cu_corr_keytab_safe INTO corr_keytab.
        APPEND corr_keytab.
      ENDLOOP.
      e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
      IF rc NE 0.
        MESSAGE ID     sy-msgid
                TYPE   &apos;I&apos;
                NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
        RAISE saving_correction_failed.
      ELSE.
        sy-subrc = rc.
        EXIT.
      ENDIF.
    ELSEIF cuiorder NE space OR cuitask NE space.
      &lt;status&gt;-order_nbr = cuiorder.
      &lt;status&gt;-corr_nbr = cuitask.
    ENDIF.
    REFRESH cu_ko200_tab.
  ENDIF. &quot;may be objects are not yet checked
  IF maint_mode EQ aendern AND lockable_objects_exist NE space OR
     maint_mode EQ transportieren AND cu_obj_not_chkd NE space.
    IF cu_obj_not_chkd NE space.
* first check previously unchecked lockable objects
      CLEAR vim_last_source_system.
      LOOP AT vim_corr_objtab WHERE lockable NE space.
        READ TABLE cu_corr_objtab
                         WITH KEY pgmid  = vim_corr_objtab-pgmid
                                 object  = vim_corr_objtab-object
                                 obj_name = vim_corr_objtab-obj_name
                         TRANSPORTING NO FIELDS.
        CHECK sy-subrc NE 0.
        e071 = vim_corr_objtab.
        PERFORM check_lockable_object USING e071 rc.
        IF rc NE 0 OR x_header-flag EQ vim_transport_denied.
          x_header-flag = cu_h_flag. MODIFY x_header INDEX 1.
          MESSAGE i162(sv) WITH vim_corr_objtab-pgmid
                                vim_corr_objtab-object
                                vim_corr_objtab-obj_name.
          IF maint_mode EQ aendern.
            rc = 9. EXIT.
          ELSE.
            DELETE vim_corr_objtab.
          ENDIF.
        ENDIF.
      ENDLOOP.
      DESCRIBE TABLE vim_corr_objtab.
      IF maint_mode EQ aendern AND rc NE 0 OR sy-tfill EQ 0.
* restore saved keytab entries and corr_objtab
        LOOP AT cu_corr_keytab_safe INTO corr_keytab.
          APPEND corr_keytab.
        ENDLOOP.
        e071 = e071_safe.
        RAISE saving_correction_failed.
      ENDIF.
    ENDIF.                             &quot;cu_obj_not_chckd ne space
    IF &lt;status&gt;-corr_nbr EQ space.
      LOOP AT vim_corr_objtab INTO e071.
        CALL FUNCTION &apos;TR_CHECK_TYPE&apos;
          EXPORTING
            wi_e071     = e071
          IMPORTING
            we_tadir    = cu_tadir
            we_category = cu_category.
       CHECK cu_category EQ vim_syst OR cu_category EQ vim_cust_syst OR
                     cu_category EQ vim_appl.
        cu_last_cat = vim_syst. cu_h_e071 = e071.
      ENDLOOP.
      IF cu_last_cat EQ space.
        cu_category = vim_cust.
      ELSE.
        cu_category = cu_last_cat. e071 = cu_h_e071.
      ENDIF.
      CALL FUNCTION &apos;TRINT_GET_REQUEST_TYPE&apos;
* UF041099 inserted instead of TRINT_CHECK_ORDER_TYPE
           EXPORTING
                iv_pgmid                   = e071-pgmid
                iv_object                  = e071-object
                iv_obj_name                = e071-obj_name
                iv_category                = cu_category
                is_tadir                   = cu_tadir
                is_tdevc                   = cu_tdevc
*                IV_USE_MEMORY              = &apos;X&apos;
           IMPORTING
                ev_request_type            = cu_order_type
                ev_task_type               = cu_task_type
*                EV_TARGET                  =
           EXCEPTIONS
                internal_error             = 1
                no_request_needed          = 2
                cts_initialization_failure = 3
                OTHERS                     = 4.
      CASE sy-subrc.
        WHEN 0.
        WHEN 2.
          cu_order_type = &apos;K&apos;.
          cu_task_type = &apos;S&apos;.
        WHEN OTHERS.
          LOOP AT cu_corr_keytab_safe INTO corr_keytab.
            APPEND corr_keytab.
          ENDLOOP.
          e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
          MESSAGE ID     sy-msgid
                  TYPE   &apos;I&apos;
                  NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
          RAISE saving_correction_failed.
      ENDCASE.
      DO.
        CALL FUNCTION &apos;TRINT_ORDER_CHOICE&apos;
          EXPORTING
            wi_order_type          = cu_order_type
            wi_task_type           = cu_task_type
            wi_category            = cu_category
            wi_cli_dep             = space
          IMPORTING
            we_order               = &lt;status&gt;-order_nbr
            we_task                = &lt;status&gt;-corr_nbr
          TABLES
            wt_e071                = cu_e071_tab
            wt_e071k               = corr_keytab
          EXCEPTIONS
            no_correction_selected = 1
            display_mode           = 2
            object_append_error    = 3
            recursive_call         = 4
            OTHERS                 = 5.
        IF sy-subrc NE 0.
* restore saved keytab entries and corr_objtab
          LOOP AT cu_corr_keytab_safe INTO corr_keytab.
            APPEND corr_keytab.
          ENDLOOP.
          e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
          IF sy-subrc NE 1.
            MESSAGE ID     sy-msgid
                    TYPE   &apos;I&apos;
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
          ENDIF.
          RAISE saving_correction_failed.
        ENDIF.                         &quot;sy-subrc ne 0
        IF maint_mode EQ transportieren.
* enqueue corr
          CALL FUNCTION &apos;ENQUEUE_E_TRKORR&apos;
               EXPORTING
                    trkorr = &lt;status&gt;-corr_nbr
*               X_TRKORR = E02
               EXCEPTIONS
                    foreign_lock = 01
                    system_failure = 02.
          CASE sy-subrc.
            WHEN 0.
            WHEN 1.
          MESSAGE s092(sv) WITH &lt;status&gt;-corr_nbr. &quot;Korr. wirdger.bearb.
              CONTINUE.
            WHEN 2.
              MESSAGE a095(sv) WITH &lt;status&gt;-corr_nbr. &quot;Systemfehler
              CONTINUE.
          ENDCASE.
          &lt;status&gt;-corr_enqud = &apos;X&apos;.
          EXIT.
        ELSE.                          &quot;change mode
          EXIT.
        ENDIF.                         &quot;maint_mode eq transportieren
      ENDDO.
    ENDIF.                             &quot;&lt;status&gt;-corr_nbr eq space.
* store corr number into tables
    LOOP AT cu_e071_tab INTO e071 WHERE trkorr EQ space.
      e071-trkorr = &lt;status&gt;-corr_nbr.
      MODIFY cu_e071_tab FROM e071.
      LOOP AT vim_corr_objtab WHERE pgmid = e071-pgmid
                                AND object = e071-object
                                AND obj_name = e071-obj_name.
        vim_corr_objtab-trkorr = &lt;status&gt;-corr_nbr.
        MODIFY vim_corr_objtab.
        EXIT.
      ENDLOOP.
      sy-fdpos = strlen( e071-obj_name ).
      IF sy-fdpos GT vim_71k_name_length.
        READ TABLE corr_keytab WITH KEY pgmid = e071-pgmid
                                        object = e071-object
                                        objname = vim_long_objname
                                        tabkey  = e071-obj_name.
      ELSE.
        READ TABLE corr_keytab WITH KEY pgmid = e071-pgmid
                                        object = e071-object
                                        objname = e071-obj_name.&quot;#EC WARNOK
      ENDIF.
      IF sy-subrc EQ 0.
        corr_keytab-trkorr = &lt;status&gt;-corr_nbr.
        MODIFY corr_keytab INDEX sy-tabix.
      ENDIF.
    ENDLOOP.
  ENDIF.
  IF maint_mode EQ transportieren OR lockable_objects_exist NE space.
    SORT cu_e071_tab BY trkorr.
    LOOP AT cu_e071_tab INTO e071 WHERE objfunc NE &apos;D&apos;.
      cu_begix = sy-tabix + 1.
      EXIT.
    ENDLOOP.
    IF sy-subrc EQ 0.
      APPEND e071 TO cu_e071_htb.
      LOOP AT corr_keytab WHERE mastertype EQ e071-object
                            AND mastername EQ e071-obj_name.
        APPEND corr_keytab TO cu_corr_keyhtb.
      ENDLOOP.
      cu_last_corr = e071-trkorr.
      LOOP AT cu_e071_tab INTO e071 FROM cu_begix WHERE objfunc NE &apos;D&apos;.
        IF e071-trkorr NE cu_last_corr.
*___________________________________________________________________
          LOOP AT cu_e071_htb ASSIGNING &lt;ls_e071&gt;.
            MOVE-CORRESPONDING &lt;ls_e071&gt; TO ls_edt_object.
            APPEND ls_edt_object TO lt_edt_objects.
          ENDLOOP.
          CALL FUNCTION &apos;TR_EC_CUST_ORIG_LANG&apos;
            EXPORTING
              it_objects   = lt_edt_objects
              iv_checkmode = &apos; &apos;
              iv_dialog    = &apos;X&apos;
            CHANGING
              ct_keys      = cu_corr_keyhtb
            EXCEPTIONS
              cancel       = 1
              display_only = 2
              OTHERS       = 3.
          IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
          ENDIF.
*--------------------------------------------------------------------
          CALL FUNCTION &apos;TRINT_APPEND_TO_COMM_ARRAYS&apos;
            EXPORTING
              wi_trkorr     = cu_last_corr
            TABLES
              wt_e071       = cu_e071_htb
              wt_e071k      = cu_corr_keyhtb
              wt_trmess_int = cu_trmess
              wt_trpar_int  = cu_trpar
            EXCEPTIONS
              OTHERS        = 08.
          IF sy-subrc NE 0.
* restore saved keytab entries and corr_objtab
            LOOP AT cu_corr_keytab_safe INTO corr_keytab.
              APPEND corr_keytab.
            ENDLOOP.
            e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
            MESSAGE ID     sy-msgid
                    TYPE   &apos;I&apos;
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
            RAISE saving_correction_failed.
          ENDIF.
          REFRESH: cu_e071_htb, cu_corr_keyhtb.
          cu_last_corr = e071-trkorr.
        ENDIF.
        APPEND e071 TO cu_e071_htb.
        LOOP AT corr_keytab WHERE mastertype EQ e071-object
                              AND mastername EQ e071-obj_name.
          APPEND corr_keytab TO cu_corr_keyhtb.
        ENDLOOP.
      ENDLOOP.
    ENDIF.                             &quot;sy-subrc of loop at e071_tab
    DESCRIBE TABLE cu_e071_htb.
    IF sy-tfill NE 0.
*      CALL FUNCTION &apos;TR_APPEND_TO_COMM_OBJS_KEYS&apos;
*        EXPORTING
**         WI_SIMULATION                        = &apos; &apos;
**         WI_SUPPRESS_KEY_CHECK                = &apos; &apos;
*          wi_trkorr                            = e071-trkorr
*        tables
*          wt_e071                              = cu_e071_htb
*          wt_e071k                             = cu_corr_keyhtb
*       EXCEPTIONS
*         KEY_CHAR_IN_NON_CHAR_FIELD           = 1
*         KEY_CHECK_KEYSYNTAX_ERROR            = 2
*         KEY_INTTAB_TABLE                     = 3
*         KEY_LONGER_FIELD_BUT_NO_GENERC       = 4
*         KEY_MISSING_KEY_MASTER_FIELDS        = 5
*         KEY_MISSING_KEY_TABLEKEY             = 6
*         KEY_NON_CHAR_BUT_NO_GENERIC          = 7
*         KEY_NO_KEY_FIELDS                    = 8
*         KEY_STRING_LONGER_CHAR_KEY           = 9
*         KEY_TABLE_HAS_NO_FIELDS              = 10
*         KEY_TABLE_NOT_ACTIV                  = 11
*         KEY_UNALLOWED_KEY_FUNCTION           = 12
*         KEY_UNALLOWED_KEY_OBJECT             = 13
*         KEY_UNALLOWED_KEY_OBJNAME            = 14
*         KEY_UNALLOWED_KEY_PGMID              = 15
*         KEY_WITHOUT_HEADER                   = 16
*         OB_CHECK_OBJ_ERROR                   = 17
*         OB_DEVCLASS_NO_EXIST                 = 18
*         OB_EMPTY_KEY                         = 19
*         OB_GENERIC_OBJECTNAME                = 20
*         OB_ILL_DELIVERY_TRANSPORT            = 21
*         OB_ILL_LOCK                          = 22
*         OB_ILL_PARTS_TRANSPORT               = 23
*         OB_ILL_SOURCE_SYSTEM                 = 24
*         OB_ILL_SYSTEM_OBJECT                 = 25
*         OB_ILL_TARGET                        = 26
*         OB_INTTAB_TABLE                      = 27
*         OB_LOCAL_OBJECT                      = 28
*         OB_LOCKED_BY_OTHER                   = 29
*         OB_MODIF_ONLY_IN_MODIF_ORDER         = 30
*         OB_NAME_TOO_LONG                     = 31
*         OB_NO_APPEND_OF_CORR_ENTRY           = 32
*         OB_NO_APPEND_OF_C_MEMBER             = 33
*         OB_NO_CONSOLIDATION_TRANSPORT        = 34
*         OB_NO_ORIGINAL                       = 35
*         OB_NO_SHARED_REPAIRS                 = 36
*         OB_NO_SYSTEMNAME                     = 37
*         OB_NO_SYSTEMTYPE                     = 38
*         OB_NO_TADIR                          = 39
*         OB_NO_TADIR_NOT_LOCKABLE             = 40
*         OB_PRIVAT_OBJECT                     = 41
*         OB_REPAIR_ONLY_IN_REPAIR_ORDER       = 42
*         OB_RESERVED_NAME                     = 43
*         OB_SYNTAX_ERROR                      = 44
*         OB_TABLE_HAS_NO_FIELDS               = 45
*         OB_TABLE_NOT_ACTIV                   = 46
*         TR_ENQUEUE_FAILED                    = 47
*         TR_ERRORS_IN_ERROR_TABLE             = 48
*         TR_ILL_KORRNUM                       = 49
*         TR_LOCKMOD_FAILED                    = 50
*         TR_LOCK_ENQUEUE_FAILED               = 51
*         TR_NOT_OWNER                         = 52
*         TR_NO_SYSTEMNAME                     = 53
*         TR_NO_SYSTEMTYPE                     = 54
*         TR_ORDER_NOT_EXIST                   = 55
*         TR_ORDER_RELEASED                    = 56
*         TR_ORDER_UPDATE_ERROR                = 57
*         TR_WRONG_ORDER_TYPE                  = 58
*         OB_INVALID_TARGET_SYSTEM             = 59
*         TR_NO_AUTHORIZATION                  = 60
*         OB_WRONG_TABLETYP                    = 61
*         OB_WRONG_CATEGORY                    = 62
*         OB_SYSTEM_ERROR                      = 63
*         OB_UNLOCAL_OBJEKT_IN_LOCAL_ORD       = 64
*         TR_WRONG_CLIENT                      = 65
*         OB_WRONG_CLIENT                      = 66
*         KEY_WRONG_CLIENT                     = 67
*         OTHERS                               = 68
*                .
*___________________________________________________________________
      LOOP AT cu_e071_htb ASSIGNING &lt;ls_e071&gt;.
        MOVE-CORRESPONDING &lt;ls_e071&gt; TO ls_edt_object.
        APPEND ls_edt_object TO lt_edt_objects.
      ENDLOOP.
      CALL FUNCTION &apos;TR_EC_CUST_ORIG_LANG&apos;
        EXPORTING
          it_objects   = lt_edt_objects
          iv_checkmode = &apos; &apos;
          iv_dialog    = &apos;X&apos;
        CHANGING
          ct_keys      = cu_corr_keyhtb
        EXCEPTIONS
          cancel       = 1
          display_only = 2
          OTHERS       = 3.
      IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ENDIF.
*--------------------------------------------------------------------
      IF e071-trkorr EQ space.                        &quot;HCG HW 707466
        READ TABLE cu_corr_keyhtb into corr_keyhtb_wa INDEX 1.
        e071-trkorr = corr_keyhtb_wa-trkorr.
      ENDIF.
      CALL FUNCTION &apos;TRINT_APPEND_TO_COMM_ARRAYS&apos;
           EXPORTING
                wi_trkorr     = e071-trkorr
           TABLES
                wt_e071       = cu_e071_htb
                wt_e071k      = cu_corr_keyhtb
                wt_trmess_int = cu_trmess
                wt_trpar_int  = cu_trpar
*           EXCEPTIONS
*                OTHERS        = 08.
       EXCEPTIONS
         key_check_keysyntax_error          = 1
         ob_check_obj_error                 = 2
         tr_lockmod_failed                  = 3
         tr_lock_enqueue_failed             = 4
         tr_wrong_order_type                = 5
         tr_order_update_error              = 6
         file_access_error                  = 7
         ob_no_systemname                   = 8
         OTHERS                             = 9.
      IF sy-subrc NE 0.
* restore saved keytab entries and corr_objtab
        LOOP AT cu_corr_keytab_safe INTO corr_keytab.
          APPEND corr_keytab.
        ENDLOOP.
        e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
        MESSAGE ID     sy-msgid
                TYPE   &apos;I&apos;
                NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
        RAISE saving_correction_failed.
      ENDIF.
    ENDIF.
    IF maint_mode EQ transportieren.
* process deletion
      LOOP AT cu_e071_tab INTO e071 WHERE objfunc NE space.
        IF e071-objfunc EQ &apos;K&apos;.
          CALL FUNCTION &apos;TRINT_DELETE_COMM_KEYS&apos;
            EXPORTING
              wi_e071                = e071
              wi_trkorr              = &lt;status&gt;-corr_nbr
            TABLES
              wt_e071k               = cu_e071k_tab
            EXCEPTIONS
              e070_update_error      = 01
              keys_protected         = 02
              order_already_released = 03
              unallowed_ordertyp     = 04
              user_not_owner         = 05
              wrong_client           = 06.
          IF sy-subrc NE 0.
* restore saved keytab entries and corr_objtab
            LOOP AT cu_corr_keytab_safe INTO corr_keytab.
              APPEND corr_keytab.
            ENDLOOP.
            e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
*         MESSAGE S097(SV) WITH &lt;STATUS&gt;-CORR_NBR.
            MESSAGE ID     sy-msgid
                    TYPE   &apos;I&apos;
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
            RAISE saving_correction_failed.
          ELSE.
* check if object is to be deleted and delete it if necessary
            LOOP AT corr_keytab WHERE mastertype EQ e071-object
                                  AND mastername EQ e071-obj_name.
              EXIT.
            ENDLOOP.
          ENDIF.                       &quot;sy-subrc of function call
        ELSEIF e071-objfunc EQ &apos;D&apos;.
          sy-subrc = 8.
        ELSE.
          CLEAR sy-subrc.
        ENDIF.                         &quot;e071-objfunc
        IF sy-subrc NE 0.
* delete object
          cu_hobjfunc = e071-objfunc.
          cu_request-objects = cu_e071_tab.
          cu_request-objects_filled = &apos;X&apos;.
          CALL FUNCTION &apos;TRINT_DELETE_COMM_OBJECT_KEYS&apos;
               EXPORTING
                    is_e071_delete              = e071
                    iv_dialog_flag              = &apos; &apos;
*                IMPORTING
*                     ET_NEW_LOCKS                =
               CHANGING
                    cs_request                  = cu_request
               EXCEPTIONS
                    OTHERS = 8.

          IF sy-subrc NE 0.
* restore saved keytab entries and corr_objtab
            LOOP AT cu_corr_keytab_safe INTO corr_keytab.
              APPEND corr_keytab.
            ENDLOOP.
            e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
            MESSAGE ID     sy-msgid
                    TYPE   &apos;I&apos;
                    NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
            RAISE saving_correction_failed.
          ENDIF. &quot;sy-subrc of function call corr_delete_entry.
          IF sy-subrc EQ 0 AND &quot;del. was successful or entry didn&apos;t ex.
             cu_hobjfunc EQ &apos;D&apos;.       &quot;and no table entry
            DELETE cu_corr_keytab_safe
              WHERE pgmid EQ e071-pgmid AND object EQ e071-object
                AND ( objname EQ e071-obj_name OR
                      objname EQ vim_long_objname AND
                      tabkey EQ e071-obj_name )
                AND objfunc EQ e071-objfunc.
          ENDIF.
        ENDIF.                         &quot;sy-subrc for deletion
      ENDLOOP.
      CLEAR: &lt;status&gt;-keytbmodfd, &lt;status&gt;-upd_flag.
      MESSAGE s096(sv) WITH &lt;status&gt;-corr_nbr.
    ENDIF.                             &quot;maint_mode eq transportieren.
* call synchronizer also for transp mode &quot;HCG int. message 1832131/2003
    cu_ko200_sec = cu_ko200_tab.
    ASSIGN vim_corr_objtab TO &lt;vim_corr_objtab&gt;.
    LOOP AT vim_corr_objtab.            &quot;Fill cu_ko200_tab for sync-call
      MOVE-CORRESPONDING &lt;vim_corr_objtab&gt; TO w_cu_ko200. &quot;UNICODE
      APPEND w_cu_ko200 TO cu_ko200_tab.                  &quot;UNICODE
    ENDLOOP.
    PERFORM vim_synchronizer_call
                             USING
                                  cu_ko200_tab[]
                                  corr_keytab[]
                                  space.
    cu_ko200_tab = cu_ko200_sec.              &quot;Reset cu_ko200_tab again
  ELSE.
* change mode and no lockable objects
    ASSIGN vim_corr_objtab TO &lt;vim_corr_objtab&gt;.
    LOOP AT vim_corr_objtab.
      MOVE-CORRESPONDING &lt;vim_corr_objtab&gt; TO w_cu_ko200. &quot;UNICODE
      APPEND w_cu_ko200 TO cu_ko200_tab.                  &quot;UNICODE
    ENDLOOP.
    IF &lt;status&gt;-order_nbr NE space.
      corr_for_insert = &lt;status&gt;-order_nbr.
    ELSE.
      corr_for_insert = &lt;status&gt;-corr_nbr.
    ENDIF.

*    CALL FUNCTION &apos;TR_OBJECTS_INSERT&apos;
*         EXPORTING
**             WI_ORDER                       = &lt;STATUS&gt;-ORDER_NBR
*              wi_order                       = corr_for_insert
*         IMPORTING
*              we_order                       = &lt;status&gt;-order_nbr
*              we_task                        = &lt;status&gt;-corr_nbr
*         TABLES
*              wt_ko200                       = cu_ko200_tab
*              wt_e071k                       = corr_keytab
*         EXCEPTIONS
*              cancel_edit_other_error        = 4
*              show_only_other_error          = 6
*              OTHERS                         = 8.

    CALL FUNCTION &apos;VIM_TR_OBJECTS_INSERT&apos;
     EXPORTING
       WI_ORDER                      = corr_for_insert
     IMPORTING
       WE_ORDER                      = &lt;status&gt;-order_nbr
       WE_TASK                       = &lt;status&gt;-corr_nbr
      TABLES
        wt_ko200                      = cu_ko200_tab
        WT_E071K                      = corr_keytab
*       TT_TADIR                      =
     EXCEPTIONS
       CANCEL_EDIT_OTHER_ERROR       = 4
       SHOW_ONLY_OTHER_ERROR         = 6
       OTHERS                        = 8
              .
*    IF sy-subrc &lt;&gt; 0.
** Implement suitable error handling here
*    ENDIF.
*
    IF sy-subrc NE 0.
      rc = sy-subrc.
* restore saved keytab entries and corr_objtab
      LOOP AT cu_corr_keytab_safe INTO corr_keytab.
        APPEND corr_keytab.
      ENDLOOP.
      e071 = e071_safe. vim_corr_objtab[] = cu_corr_objtab.
      IF rc GT 4.
*       MESSAGE I097(SV) WITH &lt;STATUS&gt;-CORR_NBR.
        MESSAGE ID     sy-msgid
                TYPE   &apos;I&apos;
                NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
      ENDIF.
      RAISE saving_correction_failed.
    ENDIF.
    PERFORM vim_synchronizer_call
                             USING
                                  cu_ko200_tab[]
                                  corr_keytab[]
                                  space.
  ENDIF. &quot;maint_mode eq transportieren or lockable_objects_exist ne spac
* delete saved keytab entries - but not in transport mode
  IF maint_mode EQ aendern.
    IF x_header-flag NE space AND x_header-frm_e071 EQ space AND
       ( x_header-frm_e071ks NE space OR x_header-frm_e071ka NE space ).
      REFRESH corr_keytab.
    ELSE.
      DELETE corr_keytab WHERE mastertype NE vim_unlockable_object
                           AND mastertype NE vim_lockable_object.
    ENDIF.
  ENDIF.
* restore saved keytab entries and set used task number
  LOOP AT cu_corr_keytab_safe INTO corr_keytab.
    IF corr_keytab-mastername EQ x_header-viewname AND
       ( corr_keytab-mastertype EQ vim_unlockable_object OR
         corr_keytab-mastertype EQ vim_lockable_object ).
      corr_keytab-trkorr = &lt;status&gt;-corr_nbr.
    ENDIF.
    APPEND corr_keytab.
  ENDLOOP.
  SUBTRACT sy-subrc FROM sy-subrc.
  e071 = e071_safe.
  LOOP AT vim_corr_objtab.
    READ TABLE cu_corr_objtab WITH KEY pgmid = vim_corr_objtab-pgmid
                                       object = vim_corr_objtab-object
                                     obj_name = vim_corr_objtab-obj_name
                              TRANSPORTING NO FIELDS.
    CHECK sy-subrc NE 0.               &quot;delete added entries
    DELETE vim_corr_objtab.
  ENDLOOP.
  e071-trkorr = &lt;status&gt;-corr_nbr.
  last_corr_number = &lt;status&gt;-l_corr_nbr = &lt;status&gt;-corr_nbr.
  CLEAR &lt;status&gt;-keytbmodfd.
  FREE: cu_e071k_tab, cu_trmess, cu_trpar, cu_e071_tab,
        cu_corr_keytab_safe, cu_ko200_tab, cu_e071_htb, cu_new_locks.
ENDFORM.                    &quot;corr_upd</include_source>
   </include>
   <include NAME="LSVIMF1T" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM UPDATE_CORR_KEYTAB
*---------------------------------------------------------------------*
*       update CORR_KEYTAB
*---------------------------------------------------------------------*
* UET_ACTION ---&gt; action: A - add to, D - delete from CORR_KEYTAB     *
*                         P - check if entry exists in CORR_KEYTAB    *
*                         W - do nothing
* CORR_KEYTAB (global) ---&gt; header of CORR_KEYTAB with current entry  *
*---------------------------------------------------------------------*
FORM update_corr_keytab USING value(uet_action) uet_rc.
  DATA: e071k_safe LIKE e071k,
        asteriskpos TYPE i.
  MOVE: 1 TO uet_rc,
        corr_keytab TO e071k_safe.
* modify tabkey if only generic transport allowed
  IF vim_exit_11_12_active EQ space.
    IF e071k_safe-objname EQ x_header-texttab.
      IF x_header-genertxtrp NE space.
        asteriskpos
         = x_header-trtxgkpos / cl_abap_char_utilities=&gt;charsize.
        CHECK e071k_safe-tabkey NE space.
        e071k_safe-tabkey+asteriskpos = &apos;*&apos;.
      ENDIF.
    ELSE.
      asteriskpos
       = x_header-trgkeypos / cl_abap_char_utilities=&gt;charsize.
      IF x_header-generictrp NE space.
        e071k_safe-tabkey+asteriskpos = &apos;*&apos;.
      ENDIF.
    ENDIF.
  ELSE. &quot;exits active - clear VIEWNAME for non-ddic-viewtables.
    CLEAR e071k_safe-viewname.
  ENDIF.
  CASE uet_action.
    WHEN hinzufuegen.
      IF e071k_safe-object EQ transp_object.     &quot;table keys
        LOOP AT corr_keytab WHERE objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername.
          IF corr_keytab-pgmid EQ vim_deleted_key.
            MOVE e071k_safe TO corr_keytab.
            MODIFY corr_keytab.
            CLEAR uet_rc.
          ENDIF.
          EXIT.
        ENDLOOP.
      ELSE.                            &quot;other objects
        LOOP AT corr_keytab WHERE pgmid      EQ e071k_safe-pgmid
                              AND object     EQ e071k_safe-object
                              AND objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername.
          IF corr_keytab-objfunc EQ &apos;D&apos;.
            MOVE e071k_safe TO corr_keytab.
            MODIFY corr_keytab.
            CLEAR uet_rc.
          ENDIF.
          EXIT.
        ENDLOOP.
      ENDIF.
      IF sy-subrc NE 0.
        MOVE e071k_safe TO corr_keytab.
        APPEND corr_keytab.
        CLEAR uet_rc.
      ENDIF.
    WHEN geloescht.
      IF e071k_safe-object EQ transp_object.     &quot;table keys
        LOOP AT corr_keytab WHERE objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername
                              AND pgmid      NE vim_deleted_key.
          corr_keytab-pgmid = vim_deleted_key.
          MODIFY corr_keytab.
          CLEAR uet_rc.
          EXIT.
        ENDLOOP.
      ELSE.                            &quot;other objects
        IF e071k_safe-mastername EQ space. &quot;avoid error in exit rout.
          e071k_safe-mastername = master_name.
        ENDIF.
        LOOP AT corr_keytab WHERE pgmid      EQ e071k_safe-pgmid
                              AND object     EQ e071k_safe-object
                              AND objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername.
*                             AND OBJFUNC    NE &apos;D&apos;.
          IF corr_keytab-objfunc NE &apos;D&apos;.
            corr_keytab-objfunc = &apos;D&apos;.
            MODIFY corr_keytab.
            CLEAR uet_rc.
          ENDIF.
          EXIT.
        ENDLOOP.
* &lt;&lt; Übergangslösung, da objekte zum Tabkey noch nicht eingelesen werden
        IF sy-subrc NE 0.
          MOVE e071k_safe TO corr_keytab.
          corr_keytab-objfunc = &apos;D&apos;.
          APPEND corr_keytab.
          CLEAR uet_rc.
        ENDIF.
* &gt;&gt; Übergangslösung, da objekte zum Tabkey noch nicht eingelesen werden
      ENDIF.
    WHEN pruefen.
      IF e071k_safe-object EQ transp_object.     &quot;table keys
        LOOP AT corr_keytab WHERE objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername
                              AND pgmid      NE vim_deleted_key.
          CLEAR uet_rc.
          EXIT.
        ENDLOOP.
      ELSE.                            &quot;other objects
        LOOP AT corr_keytab WHERE pgmid      EQ e071k_safe-pgmid
                              AND object     EQ e071k_safe-object
                              AND objname    EQ e071k_safe-objname
                              AND tabkey     EQ e071k_safe-tabkey
                              AND mastername EQ e071k_safe-mastername
                              AND objfunc    NE &apos;D&apos;.
          CLEAR uet_rc.
          EXIT.
        ENDLOOP.
      ENDIF.
    WHEN vim_writing_bc_imp_log.
      APPEND corr_keytab.
  ENDCASE.
  IF uet_rc EQ 0 AND uet_action NE pruefen.
    MOVE &apos;X&apos; TO &lt;status&gt;-keytbmodfd.
  ENDIF.
ENDFORM.                    &quot;UPDATE_CORR_KEYTAB</include_source>
   </include>
   <include NAME="LSVIMF1U" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_ADDRESS_KEYTAB_ENTRIES_INTERN
*---------------------------------------------------------------------*
* create address related keytab entries (intern)
*---------------------------------------------------------------------*
FORM vim_addr_keytab_entries_intern
                          USING value(vakei_tabname) TYPE tabname
                                value(vakei_table)
                                value(vakei_keylen) TYPE i
                                value(vakei_action) TYPE sychar01
                                vakei_rc type sy-subrc.
  corr_keytab =  e071k.
  corr_keytab-objname = vakei_tabname.
  MOVE vakei_table TO corr_keytab-tabkey(vakei_keylen).
  vim_exit_11_12_active = &apos;X&apos;.
  PERFORM update_corr_keytab USING vakei_action vakei_rc.
  CLEAR vim_exit_11_12_active.
ENDFORM. &quot;vim_address_keytab_entries_intern</include_source>
   </include>
   <include NAME="LSVIMF1V" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_ADDRESS_KEYTAB_ENTRIES
*---------------------------------------------------------------------*
* create address related keytab entries
*---------------------------------------------------------------------*
FORM vim_address_keytab_entries USING value(vake_action) TYPE c
                                      vake_rc TYPE i.
  STATICS: sadr2_keylen type syfleng.
  DATA: rc1 LIKE sy-subrc, x030l_wa type x030l.

  if sadr2_keylen is initial.
    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname           = &apos;SADR2&apos;
      IMPORTING
        X030L_WA          = x030l_wa
      EXCEPTIONS
        OTHERS            = 2.
    IF sy-subrc = 0.
      sadr2_keylen = x030l_wa-keylen / cl_abap_char_utilities=&gt;charsize.
    else.
      RAISE nametab_get_failed.
    ENDIF.
  endif.
  SELECT SINGLE * FROM sadr WHERE adrnr EQ &lt;address_number&gt;.&quot;#EC WARNOK
  IF sy-subrc NE 0.
* Übergangslösung Adressumstellung 30F Anfang
    CALL FUNCTION &apos;ADDR_CONVERT_ADRC_TO_SADR&apos;
      CHANGING
        address_number = &lt;address_number&gt;.
    IF &lt;address_number&gt; NE space.
      SELECT SINGLE * FROM sadr WHERE adrnr EQ &lt;address_number&gt;.&quot;#EC WARNOK
    ELSE.
      EXIT.
    ENDIF.
  ENDIF.
* Übergangslösung Adressumstellung 30F Ende
  vake_rc = 8.
  PERFORM vim_addr_keytab_entries_intern USING &apos;SADR&apos; sadr
                                               sadr_keylen
                                               vake_action rc1.
  IF rc1 EQ 0.
    CLEAR vake_rc.
  ELSE.
    IF vake_action EQ pruefen.
      EXIT.
    ENDIF.
  ENDIF.
  SELECT COUNT(*) FROM sadr2 WHERE adrnr EQ sadr-adrnr.
  CLEAR sadr2.
  MOVE: sadr-mandt TO sadr2-mandt,
        sadr-adrnr TO sadr2-adrnr,
        &apos;*&apos; TO sadr2-stdfl.
  IF sy-dbcnt GT 0.                    &quot;only if entries exist
    PERFORM vim_addr_keytab_entries_intern USING &apos;SADR2&apos; sadr2
                                                 sadr2_keylen
                                                 vake_action rc1.
    IF rc1 EQ 0.
      CLEAR vake_rc.
    ELSE.
      IF vake_action EQ pruefen.
        vake_rc = 8. EXIT.
      ENDIF.
    ENDIF.
  ENDIF.
  SELECT COUNT(*) FROM sadr3 WHERE adrnr EQ sadr-adrnr.
  IF sy-dbcnt GT 0.                    &quot;only if entries exist
    sadr3 = sadr2.
    PERFORM vim_addr_keytab_entries_intern USING &apos;SADR3&apos; sadr3
                                                 sadr2_keylen
                                                 vake_action rc1.
    IF rc1 EQ 0.
      CLEAR vake_rc.
    ELSE.
      IF vake_action EQ pruefen.
        vake_rc = 8. EXIT.
      ENDIF.
    ENDIF.
  ENDIF.
  SELECT COUNT(*) FROM sadr4 WHERE adrnr EQ sadr-adrnr.
  IF sy-dbcnt GT 0.                    &quot;only if entries exist
    sadr4 = sadr2.
    PERFORM vim_addr_keytab_entries_intern USING &apos;SADR4&apos; sadr4
                                                 sadr2_keylen
                                                 vake_action rc1.
    IF rc1 EQ 0.
      CLEAR vake_rc.
    ELSE.
      IF vake_action EQ pruefen.
        vake_rc = 8. EXIT.
      ENDIF.
    ENDIF.
  ENDIF.
  SELECT COUNT(*) FROM sadr5 WHERE adrnr EQ sadr-adrnr.
  IF sy-dbcnt GT 0.                    &quot;only if entries exist
    sadr5 = sadr2.
    PERFORM vim_addr_keytab_entries_intern USING &apos;SADR5&apos; sadr5
                                                  sadr2_keylen
                                                  vake_action rc1.
    IF rc1 EQ 0.
      CLEAR vake_rc.
    ELSE.
      IF vake_action EQ pruefen.
        vake_rc = 8.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;vim_address_keytab_entries</include_source>
   </include>
   <include NAME="LSVIMF1W" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM UPDATE_CORR                                              *
*---------------------------------------------------------------------*
*       update correction command file                                *
* UF230499: no changing of X_HEADER-KEYLEN if key is to long for
*           transport. Move appropriate key length to KEYLEN instead.
* UF170200: same for translated text fields
*---------------------------------------------------------------------*
* CORR_ACTION -&gt;(glob) action: D - delete from, A - add to command file
*---------------------------------------------------------------------*
FORM update_corr.
  LOCAL: x_header.
  DATA: rc LIKE sy-subrc, fails TYPE i, flag TYPE c, rc1 LIKE sy-subrc,
        uc_addr_71ktab LIKE e071k OCCURS 0,
        addr_e071k LIKE e071k,                               &quot;#EC NEEDED
        object_key TYPE ad_objkey, keylen TYPE syfleng,
        txtkeylen TYPE syfleng,
        sys_type(10) TYPE c,
        texttab_wa TYPE REF TO data,                       &quot;#EC NEEDED
        max_trsp_keylength_in_byte type i.
  FIELD-SYMBOLS: &lt;adr_obj_key&gt; TYPE x,
                 &lt;texttab_wa&gt; TYPE ANY,                     &quot;#EC NEEDED
                 &lt;texttab_wax&gt; TYPE x,                      &quot;#EC NEEDED
                 &lt;lang&gt; TYPE ANY.                           &quot;#EC NEEDED

  CHECK maint_mode EQ aendern OR maint_mode EQ transportieren.
  CHECK x_header-flag NE vim_transport_denied.
  CHECK vim_actopts-transp_off NE bc_transport_denied.
  max_trsp_keylength_in_byte = vim_max_trsp_keylength
   * cl_abap_char_utilities=&gt;charsize.
  CALL &apos;C_SAPGPARAM&apos; ID &apos;NAME&apos;  FIELD &apos;transport/systemtype&apos;      &quot;#EC CI_CCALL
                     ID &apos;VALUE&apos; FIELD sys_type.
  IF x_header-keylen GT max_trsp_keylength_in_byte.
    keylen = x_header-maxtrkeyln.                           &quot;UF230499
  ELSE.                                                     &quot;UF230499
    keylen = x_header-keylen.                               &quot;UF230499
  ENDIF.
  IF x_header-textkeylen GT max_trsp_keylength_in_byte.
    txtkeylen = x_header-maxtrtxkln.                        &quot;UF230499
  ELSE.                                                     &quot;UF230499
    txtkeylen = x_header-textkeylen.                        &quot;UF230499
  ENDIF.
  IF x_header-adrnbrflag EQ &apos;N&apos;.
    ASSIGN object_key TO &lt;adr_obj_key&gt; CASTING.
    LOOP AT vim_addr_e071k_tab INTO addr_e071k.
      e071k-trkorr = &lt;status&gt;-corr_nbr.
    ENDLOOP.
  ENDIF.
  IF status-action EQ transportieren.
* force marked entries
************************************************************************
    CHECK vim_client_state NE vim_local_clnt.
    IF status-mode EQ list_bild.
* overview_screen
      IF ( x_header-frm_e071ks NE space OR x_header-flag EQ space ) AND
         vim_called_by_cluster NE space.
        PERFORM vim_store_state_info.
        CALL FUNCTION &apos;VIEWCLUSTER_TRANS_DEPENDENT&apos;
          EXPORTING
            view_name   = x_header-viewname
            action      = corr_action
            status_mode = status-mode
            workarea    = extract
            no_dialog   = vim_external_mode
            corr_number = &lt;status&gt;-corr_nbr.
      ENDIF.
      CLEAR counter.
      LOOP AT extract.
        CHECK &lt;xmark&gt; EQ markiert.
        PERFORM move_extract_to_view_wa.
        IF x_header-flag EQ space.     &quot;standard logging required
          IF x_header-bastab EQ space. &quot;view
            PERFORM (corr_formname) IN PROGRAM (sy-repid)
                                                   USING corr_action rc.
          ELSE.                        &quot;base table
            corr_keytab =  e071k.
            corr_keytab-objname = x_header-maintview.
            MOVE &lt;vim_xextract_key&gt; TO &lt;vim_corr_keyx&gt;(keylen).
            PERFORM update_corr_keytab USING corr_action rc.
            IF x_header-texttbexst NE space AND  &quot;base table with
            &lt;vim_xextract_text&gt; NE &lt;text_initial_x&gt;.     &quot;text table
* only texttable&apos;s original language shall be transported internally
              corr_keytab =  e071k.
              corr_keytab-objname = x_header-texttab.
              MOVE &lt;vim_xextract_text&gt; TO &lt;vim_corr_keyx&gt;(txtkeylen).
              PERFORM update_corr_keytab USING corr_action rc1.
              IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
            ENDIF.
          ENDIF.
          IF x_header-texttbexst &lt;&gt; space AND        &quot;SW Texttransl ..
             vim_texttab_is_ro EQ space.
            PERFORM vim_text_keytab_entry
                    USING &lt;vim_xextract_key&gt; corr_action rc1.
            IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
          ENDIF.                       &quot;.. Texttransl
          IF x_header-adrnbrflag EQ &apos;O&apos; AND &lt;address_number&gt; NE space.
            PERFORM vim_address_keytab_entries USING corr_action rc1.
            IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
          ELSEIF x_header-adrnbrflag EQ &apos;N&apos; AND
                 &lt;address_number&gt; NE space.
            APPEND LINES OF vim_addr_e071k_tab TO uc_addr_71ktab.
*            object_key = &lt;vim_total_key&gt;.
            &lt;adr_obj_key&gt;(keylen) = &lt;vim_xextract_key&gt;. &quot;UF474925/2000
            CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
              EXPORTING
                addrnumber = &lt;address_number&gt;
                table_name = vim_addr_basetable
                field_name = vim_addr_bastab_field
                objkey     = object_key
              TABLES
                e071k_tab  = uc_addr_71ktab.
            vim_exit_11_12_active = &apos;X&apos;.
            LOOP AT uc_addr_71ktab INTO corr_keytab WHERE
             mastername = vim_addr_e071k_master_46 OR    &quot;UF688403/2000
             mastername = vim_addr_e071k_master.
* Rel &lt; 4.6A: ignore old type address entries inserted only for downward
*             compatibility
              PERFORM update_corr_keytab USING corr_action rc1.
              IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
            ENDLOOP.
            REFRESH uc_addr_71ktab.
            CLEAR vim_exit_11_12_active.
          ENDIF.
        ENDIF.                         &quot;standard logging required
        IF x_header-frm_e071ks NE space.
          vim_exit_11_12_active = &apos;X&apos;.
          PERFORM (x_header-frm_e071ks) IN PROGRAM (sy-repid).
          IF sy-subrc EQ 0. MOVE sy-subrc TO rc. ENDIF.
          CLEAR vim_exit_11_12_active.
        ELSE.
          IF x_header-frm_e071 NE space AND
             x_header-frm_e071ka EQ space.
            &lt;status&gt;-keytbmodfd = &apos;X&apos;.
          ENDIF.
          IF x_header-flag NE space.
            EXIT.
          ENDIF.
        ENDIF.
        IF rc NE 0.
          ADD 1 TO fails.
          IF replace_mode NE space.
            READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
            &lt;mark&gt; = &lt;xmark&gt; = nicht_markiert.
            MODIFY total INDEX sy-tabix.
            MODIFY extract.
            SUBTRACT: 1 FROM mark_total, 1 FROM mark_extract.
            ok_code = &apos;IGN &apos;.
          ENDIF.
        ELSE.
          READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
          &lt;mark&gt; = &lt;xmark&gt; = nicht_markiert.
*          IF rc EQ 0.                          &quot;??? UF222098
          CASE corr_action.
            WHEN hinzufuegen.
              MOVE transportieren TO &lt;action&gt;.
            WHEN geloescht.
              CLEAR &lt;action&gt;.
          ENDCASE.
          &lt;xact&gt; = &lt;action&gt;.
*          ENDIF.
          MODIFY total INDEX sy-tabix.
          MODIFY extract.
          SUBTRACT: 1 FROM mark_total, 1 FROM mark_extract.
        ENDIF.
        ADD 1 TO counter.
      ENDLOOP.
      IF counter GT fails.
        IF fails GT 0.
          MOVE 4 TO rc.
        ELSE.
          CLEAR rc.
        ENDIF.
      ELSE.
        MOVE 8 TO rc.
      ENDIF.
      IF replace_mode EQ space.
        IF corr_action EQ hinzufuegen.
          IF counter EQ 1.
            IF rc EQ 0.
          MESSAGE s098(sv) WITH &lt;status&gt;-corr_nbr. &quot;Eintr. in K. aufgen.
            ELSE.
          MESSAGE s107(sv) WITH &lt;status&gt;-corr_nbr. &quot;Eintr. schon enthal.
            ENDIF.
          ELSE.
            SUBTRACT fails FROM counter.
            CASE rc.
              WHEN 0.
                MESSAGE s105(sv) WITH counter
                                &lt;status&gt;-corr_nbr. &quot;Eintr. in K. aufgen.
              WHEN 4.
                MESSAGE s109(sv) WITH counter fails
                                  &lt;status&gt;-corr_nbr. &quot;Eintr. schon enth.
              WHEN 8.
                MESSAGE s108(sv) WITH fails
                                  &lt;status&gt;-corr_nbr. &quot;Eintr. schon enth.
            ENDCASE.
          ENDIF.
        ELSE.
          IF counter EQ 1.
            IF rc EQ 0.
          MESSAGE s099(sv) WITH &lt;status&gt;-corr_nbr. &quot;Eintr.aus K. gelösch
            ELSE.
          MESSAGE s110(sv) WITH &lt;status&gt;-corr_nbr. &quot;Eintr. schon enthal.
            ENDIF.
          ELSE.
            SUBTRACT fails FROM counter.
            CASE rc.
              WHEN 0.
                MESSAGE s106(sv) WITH counter
                               &lt;status&gt;-corr_nbr. &quot;Eintr. aus K. gelösch
              WHEN 4.
                MESSAGE s111(sv) WITH counter fails
                                  &lt;status&gt;-corr_nbr. &quot;Eintr. nicht enth.
              WHEN 8.
                MESSAGE s112(sv) WITH fails
                                  &lt;status&gt;-corr_nbr. &quot;Eintr. nicht enth.
            ENDCASE.
          ENDIF.
        ENDIF.
      ENDIF.                           &quot;replace_mode eq space
    ELSE.
* detail screen
      IF x_header-flag EQ space.
* standard logging required
        IF x_header-bastab EQ space.
* view
          PERFORM (corr_formname) IN PROGRAM (sy-repid)
                                                   USING corr_action rc.
        ELSE.
* base table
          corr_keytab =  e071k.
          corr_keytab-objname = x_header-maintview.
*          MOVE &lt;table1&gt; TO corr_keytab-tabkey(x_header-keylen).
          MOVE &lt;table1_x&gt; TO &lt;vim_corr_keyx&gt;(keylen).
          PERFORM update_corr_keytab USING corr_action rc.
          IF x_header-texttbexst NE space
           AND &lt;table1_text&gt; NE &lt;text_initial&gt;.
* base table with text table
            corr_keytab =  e071k.
            corr_keytab-objname = x_header-texttab.
            MOVE &lt;table1_xtext&gt; TO &lt;vim_corr_keyx&gt;(txtkeylen).
            PERFORM update_corr_keytab USING corr_action rc1.
            IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
          ENDIF.
        ENDIF.
        IF x_header-texttbexst &lt;&gt; space AND        &quot;SW Texttransl ..
           vim_texttab_is_ro EQ space.
          PERFORM vim_text_keytab_entry
                  USING &lt;table1_x&gt; corr_action rc1.
          IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
        ENDIF.                         &quot;.. Texttransl
        IF x_header-adrnbrflag EQ &apos;O&apos; AND &lt;address_number&gt; NE space.
          PERFORM vim_address_keytab_entries USING corr_action rc1.
          IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
        ELSEIF x_header-adrnbrflag EQ &apos;N&apos; AND
               &lt;address_number&gt; NE space.
* transport addresses
          APPEND LINES OF vim_addr_e071k_tab TO uc_addr_71ktab.
*          object_key = &lt;vim_extract_key&gt;.
          &lt;adr_obj_key&gt;(keylen) = &lt;vim_xextract_key&gt;.
          CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
            EXPORTING
              addrnumber = &lt;address_number&gt;
              table_name = vim_addr_basetable
              field_name = vim_addr_bastab_field
              objkey     = object_key
            TABLES
              e071k_tab  = uc_addr_71ktab.
          vim_exit_11_12_active = &apos;X&apos;.
          LOOP AT uc_addr_71ktab INTO corr_keytab WHERE
           mastername = vim_addr_e071k_master_46 OR    &quot;UF688403/2000
           mastername = vim_addr_e071k_master.
* Rel &lt; 4.6A: ignore old type address entries inserted only for downward
*             compatibility
            PERFORM update_corr_keytab USING corr_action rc1.
            IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
          ENDLOOP.
          REFRESH uc_addr_71ktab.
          CLEAR vim_exit_11_12_active.
        ENDIF.
      ENDIF.                           &quot;standard logging required
      IF x_header-frm_e071ks NE space.
        vim_exit_11_12_active = &apos;X&apos;.
        PERFORM (x_header-frm_e071ks) IN PROGRAM (sy-repid).
        IF sy-subrc EQ 0. MOVE sy-subrc TO rc. ENDIF.
        CLEAR vim_exit_11_12_active.
      ELSE.
        IF x_header-frm_e071 NE space AND
           x_header-frm_e071ka EQ space.
          IF x_header-flag NE space.
            &lt;status&gt;-keytbmodfd = &apos;E&apos;.
          ELSE.
            &lt;status&gt;-keytbmodfd = &apos;X&apos;.
          ENDIF.
        ENDIF.
      ENDIF.
      IF &lt;status&gt;-keytbmodfd NE &apos;E&apos;.
        IF vim_called_by_cluster NE space.
          PERFORM vim_store_state_info.
          CALL FUNCTION &apos;VIEWCLUSTER_TRANS_DEPENDENT&apos;
            EXPORTING
              view_name   = x_header-viewname
              action      = corr_action
              status_mode = status-mode
              workarea    = extract
              no_dialog   = vim_external_mode
              corr_number = &lt;status&gt;-corr_nbr.
        ENDIF.
      ELSE.
        &lt;status&gt;-keytbmodfd = &apos;X&apos;.
      ENDIF.
      READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
      IF rc EQ 0.
        CASE corr_action.
          WHEN hinzufuegen.
            MOVE transportieren TO &lt;action&gt;.
          WHEN geloescht.
            CLEAR &lt;action&gt;.
        ENDCASE.
        &lt;xact&gt; = &lt;action&gt;.
        MOVE &apos;X&apos; TO flag.
      ELSE.
        IF replace_mode NE space.
          ok_code = &apos;IGN &apos;.
        ENDIF.
      ENDIF.
      IF &lt;xmark&gt; EQ markiert.
        &lt;mark&gt; = &lt;xmark&gt; = nicht_markiert.
        SUBTRACT: 1 FROM mark_total, 1 FROM mark_extract.
        MOVE &apos;X&apos; TO flag.
      ENDIF.
      IF flag NE space.
        MODIFY total INDEX sy-tabix.
        MODIFY extract INDEX nextline.
      ENDIF.
      IF replace_mode EQ space.
        IF corr_action EQ hinzufuegen.
          IF rc EQ 0.
            MESSAGE s098(sv) WITH &lt;status&gt;-corr_nbr.&quot;Eintr. in K. aufg.
          ELSE.
            MESSAGE s107(sv) WITH &lt;status&gt;-corr_nbr.&quot;Eintr. schon enthl.
          ENDIF.
        ELSE.
          IF rc EQ 0.
            MESSAGE s099(sv) WITH &lt;status&gt;-corr_nbr.&quot;Eintr.aus K. gelösc
          ELSE.
            MESSAGE s110(sv) WITH &lt;status&gt;-corr_nbr.&quot;Eintr. schon enthl.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
  ELSE.
* logging of changed entries
***********************************************************************
    CHECK vim_client_state EQ vim_log.
    corr_action = hinzufuegen.
*   REFRESH CORR_KEYTAB. &quot;only delete all keys for current object
    LOOP AT vim_corr_objtab WHERE objfunc NE space.
      LOOP AT corr_keytab WHERE mastertype EQ vim_corr_objtab-object
                            AND mastername EQ vim_corr_objtab-obj_name.
        DELETE corr_keytab.
      ENDLOOP.
    ENDLOOP.
    LOOP AT total.
      IF x_header-flag EQ space.       &quot;standard logging required
        IF x_header-bastab EQ space.   &quot;view
          CHECK &lt;action&gt; NE original AND &lt;action&gt; NE neuer_geloescht.
          MOVE &lt;vim_total_struc&gt; TO &lt;table1&gt;.
          PERFORM (corr_formname) IN PROGRAM (sy-repid)
                                                  USING corr_action rc.
        ELSE.                          &quot;base table
          IF x_header-texttbexst EQ space.
            CHECK &lt;action&gt; NE original AND &lt;action&gt; NE neuer_geloescht.
          ELSE.
          CHECK &lt;action&gt; NE original AND &lt;action&gt; NE neuer_geloescht OR
                                         &lt;action_text&gt; NE original AND
                                       &lt;action_text&gt; NE neuer_geloescht.
          ENDIF.
          MOVE &lt;vim_total_struc&gt; TO &lt;table1&gt;.
          corr_keytab =  e071k.
          corr_keytab-objname = x_header-maintview.
          MOVE &lt;vim_xtotal_key&gt; TO &lt;vim_corr_keyx&gt;(keylen).
          PERFORM update_corr_keytab USING corr_action rc.
          IF x_header-texttbexst NE space AND       &quot;base table with
             &lt;vim_xtotal_text&gt; NE &lt;text_initial_x&gt;. &quot;text table
            corr_keytab =  e071k.
            corr_keytab-objname = x_header-texttab.
            MOVE &lt;vim_xtotal_text&gt; TO &lt;vim_corr_keyx&gt;(txtkeylen).
            PERFORM update_corr_keytab USING corr_action rc1.
          ENDIF.
        ENDIF.                         &quot;base table or view
        IF x_header-adrnbrflag EQ &apos;O&apos; AND &lt;address_number&gt; NE space.
          PERFORM vim_address_keytab_entries USING corr_action rc1.
        ELSEIF x_header-adrnbrflag EQ &apos;N&apos; AND &lt;address_number&gt; NE space.
          READ TABLE vim_addresses_to_save
                        WITH KEY viewname = x_header-viewname
                                 addrnumber = &lt;address_number&gt;
                        BINARY SEARCH TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.            &quot;only existing addresses possible
            APPEND LINES OF vim_addr_e071k_tab TO uc_addr_71ktab.
*            object_key = &lt;vim_extract_key&gt;.
            &lt;adr_obj_key&gt;(keylen) = &lt;vim_xtotal_key&gt;. &quot;UF686454/2000
            CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
              EXPORTING
                addrnumber = &lt;address_number&gt;
                table_name = vim_addr_basetable
                field_name = vim_addr_bastab_field
                objkey     = object_key
              TABLES
                e071k_tab  = uc_addr_71ktab.
            vim_exit_11_12_active = &apos;X&apos;.
            LOOP AT uc_addr_71ktab INTO corr_keytab WHERE
             mastername = vim_addr_e071k_master_46 OR    &quot;UF688403/2000
             mastername = vim_addr_e071k_master.
* Rel &lt; 4.6A: ignore old type address entries inserted only for downward
*             compatibility
              PERFORM update_corr_keytab USING corr_action rc1.
              IF rc1 EQ 0. MOVE rc1 TO rc. ENDIF.
            ENDLOOP.
            REFRESH uc_addr_71ktab.
            CLEAR vim_exit_11_12_active.
          ENDIF.
        ENDIF.
      ENDIF.                           &quot;standard logging required
      IF x_header-frm_e071ks NE space.
        vim_exit_11_12_active = &apos;X&apos;.
        PERFORM (x_header-frm_e071ks) IN PROGRAM (sy-repid).
        CLEAR vim_exit_11_12_active.
      ELSE.
        IF x_header-flag NE space.
          EXIT.
        ENDIF.
      ENDIF.
    ENDLOOP.
    IF x_header-flag EQ space AND      &quot;standard logging required
       x_header-texttbexst &lt;&gt; space.   &quot;SW Texttransl ..
      PERFORM vim_text_keytab_entries USING corr_action rc1
                                            keylen          &quot;UF170200
                                            txtkeylen.      &quot;UF170200
    ENDIF.                             &quot;.. Texttransl
  ENDIF.                               &quot;maint_mode transport or update
  IF x_header-frm_e071ka NE space.
    vim_exit_11_12_active = &apos;X&apos;.
    PERFORM (x_header-frm_e071ka) IN PROGRAM (sy-repid).
    CLEAR vim_exit_11_12_active.
    IF status-action EQ transportieren AND x_header-flag NE space AND
       x_header-frm_e071 NE space AND x_header-frm_e071ks EQ space AND
       vim_called_by_cluster NE space.
      PERFORM vim_store_state_info.
      CALL FUNCTION &apos;VIEWCLUSTER_TRANS_DEPENDENT&apos;
        EXPORTING
          view_name   = x_header-viewname
          action      = corr_action
          status_mode = status-mode
          workarea    = extract
          no_dialog   = vim_external_mode
          corr_number = &lt;status&gt;-corr_nbr.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;update_corr</include_source>
   </include>
   <include NAME="LSVIMF1X" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM PREPARE_CORR                                             *
*---------------------------------------------------------------------*
*       prepare command file tables (E070, E071)                      *
*---------------------------------------------------------------------*
FORM prepare_corr.
  DATA: x030l_sadr type x030l,
        pc_objtype LIKE objs-objecttype,
        pc_maint_mode(1) TYPE c.

  CHECK x_header-flag NE vim_transport_denied.
  CHECK vim_actopts-transp_off NE bc_transport_denied.
  CHECK maint_mode EQ transportieren OR&quot;transport mode or change mode
        vim_client_state EQ vim_log.   &quot;and logging required
  IF &lt;status&gt;-tr_alrchkd EQ &apos;x&apos;.
* send warning if generic transport is required &quot;HCG and no BCset import
    IF x_header-generictrp NE space and vim_import_profile EQ space.
      MESSAGE i141(sv) WITH vim_max_trsp_keylength
                            vim_max_trsp_identical_key
                            x_header-maxtrkeyln.
    ELSEIF x_header-genertxtrp NE space and vim_import_profile EQ space.
      MESSAGE i141(sv) WITH vim_max_trsp_keylength
                            vim_max_trsp_identical_key
                            x_header-maxtrtxkln.
    ENDIF.
    DESCRIBE TABLE vim_corr_objtab.
    IF sy-tfill GT 0.                  &quot;save objects in corr_keytab
      CLEAR corr_keytab.
      MOVE x_header-viewname TO corr_keytab-mastername.
      LOOP AT vim_corr_objtab.
        IF vim_corr_objtab-lockable EQ space.
          corr_keytab-mastertype = vim_unlockable_object.
        ELSE.
          corr_keytab-mastertype = vim_lockable_object.
        ENDIF.
        MOVE: vim_corr_objtab-pgmid    TO corr_keytab-pgmid,
              vim_corr_objtab-object   TO corr_keytab-object,
*             VIM_CORR_OBJTAB-OBJ_NAME TO CORR_KEYTAB-OBJNAME,
              vim_corr_objtab-objfunc  TO corr_keytab-objfunc,
        vim_corr_objtab-activity TO corr_keytab-activity. &quot;UF738595/2001
        sy-fdpos = strlen( vim_corr_objtab-obj_name ).
        IF sy-fdpos GT vim_71k_name_length.
          corr_keytab-objname = vim_long_objname.
          corr_keytab-tabkey  = vim_corr_objtab-obj_name.
        ELSE.
          corr_keytab-objname = vim_corr_objtab-obj_name.
        ENDIF.
        READ TABLE corr_keytab
                   WITH KEY pgmid      = corr_keytab-pgmid
                            object     = corr_keytab-object
                            objname    = corr_keytab-objname
                            objfunc    = corr_keytab-objfunc
                            mastertype = corr_keytab-mastertype
                            mastername = corr_keytab-mastername
                            tabkey     = corr_keytab-tabkey     &quot;Note 1467152  PATIDARP
                   TRANSPORTING NO FIELDS.
        CHECK sy-subrc NE 0.
        IF vim_corr_objtab-trkorr EQ space.
          MOVE: &lt;status&gt;-corr_nbr    TO corr_keytab-trkorr,
                &lt;status&gt;-corr_nbr    TO vim_corr_objtab-trkorr.
          MODIFY vim_corr_objtab.
        ELSE.
          corr_keytab-trkorr = vim_corr_objtab-trkorr.
        ENDIF.
        corr_keytab-flag = &apos;V&apos;.
        APPEND corr_keytab.
      ENDLOOP.
    ENDIF.                             &quot;sy-tfill
  ENDIF.                               &quot;&lt;status&gt;-tr_alrchkd eq &apos;x&apos;.
  IF maint_mode EQ transportieren.
    MOVE &apos;X&apos; TO get_corr_keytab.
    IF &lt;status&gt;-keytbinvld EQ space.
      LOOP AT vim_corr_objtab WHERE lockable EQ space.
        LOOP AT corr_keytab WHERE mastertype EQ vim_corr_objtab-object
                             AND mastername EQ vim_corr_objtab-obj_name.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          CLEAR get_corr_keytab.
        ENDIF.
      ENDLOOP.
    ELSE.
      LOOP AT vim_corr_objtab WHERE lockable EQ space.
        LOOP AT corr_keytab WHERE mastertype EQ vim_corr_objtab-object
                             AND mastername EQ vim_corr_objtab-obj_name.
          DELETE corr_keytab.
        ENDLOOP.
      ENDLOOP.
    ENDIF.
  ENDIF.
  MOVE &lt;status&gt;-corr_nbr TO &lt;status&gt;-l_corr_nbr.
  &lt;status&gt;-tr_alrchkd = &apos;X&apos;.
  IF ( status-action EQ transportieren OR
       vim_client_state EQ vim_log ) AND
     x_header-adrnbrflag EQ &apos;O&apos; AND sadr_namtab_read EQ space.
    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname           = &apos;SADR&apos;
      IMPORTING
        X030L_WA          = x030l_sadr
      EXCEPTIONS
        OTHERS            = 2.
    IF sy-subrc EQ 0.
      MOVE &apos;X&apos; TO sadr_namtab_read.
      sadr_keylen = x030l_sadr-keylen
                     / cl_abap_char_utilities=&gt;charsize.
* Übrgangslösung Adreßtabellen SADR2...SADR5 zu 3.0A Anfang
      IF x_header-bastab EQ space.
        pc_objtype = &apos;V&apos;.
      ELSE.
        pc_objtype = &apos;S&apos;.
      ENDIF.
      CALL FUNCTION &apos;VIEW_CHECK_OBJ_LIST_FOR_ADDR&apos;
        EXPORTING
          objectname                     = x_header-viewname
          objecttype                     = pc_objtype
        EXCEPTIONS
          not_all_address_tables_in_list = 01.
      IF sy-subrc NE 0. &quot;regenerating of object list required
        pc_maint_mode = x_header-bastab.
        TRANSLATE pc_maint_mode USING &apos; VXS&apos;.
        CALL FUNCTION &apos;OBJ_GENERATE&apos;
          EXPORTING
            iv_objectname    = x_header-viewname
            iv_objecttype    = pc_maint_mode
            iv_maint_mode    = aendern
            iv_no_correction = &apos;X&apos;
          EXCEPTIONS                                        &quot;#EC FB_RC
            OTHERS           = 5.
      ENDIF.
* Übrgangslösung Adreßtabellen SADR2...SADR5 zu 3.0A Ende
    ELSE.
      RAISE nametab_get_failed.                             &quot;#EC FB_RAIS_EX
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;PREPARE_CORR</include_source>
   </include>
   <include NAME="LSVIMF1Y" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_TRANSP_OBJS_FOR_MAINT                              *
*---------------------------------------------------------------------*
*  check transport objects for logging during maintenance             *
*---------------------------------------------------------------------*
FORM check_transp_objs_for_maint USING ctofm_return TYPE i.
  DATA: obj_appendable(1) TYPE c, rc LIKE sy-subrc, e071_safe LIKE e071,
      last_order LIKE e071-trkorr, ctofm_ko200_tab LIKE ko200 OCCURS 10,
        ctofm_keytab_safe LIKE corr_keytab OCCURS 50,
        last_corr LIKE e071-trkorr.

  CLEAR ctofm_return.
  CHECK maint_mode EQ aendern.
* Insert IMG-activity
  PERFORM vim_get_img_activity CHANGING e071-activity.  &quot;UF738595/2001
  IF vim_corr_obj_viewname NE x_header-viewname.
    CLEAR e071-trkorr.
    PERFORM get_transp_info.
    CHECK x_header-flag NE vim_transport_denied.
    CHECK vim_actopts-transp_off NE bc_transport_denied.
    IF maint_mode EQ anzeigen. ctofm_return = 4. EXIT. ENDIF.
  ELSE. &quot; csn ext.382209 2002 XB
    IF NOT objh IS INITIAL.
      IF x_header-importable IS INITIAL.
        x_header-importable = objh-importable.
      ENDIF.
    ENDIF.
  ENDIF.
  CHECK vim_client_state EQ vim_log.
  IF &lt;status&gt;-corr_nbr NE &lt;status&gt;-l_corr_nbr.
    CLEAR: &lt;status&gt;-tr_alrchkd, &lt;status&gt;-corr_enqud.
  ENDIF.
  IF &lt;status&gt;-tr_alrchkd NE space.
    vim_corr_obj_viewname = x_header-viewname.
    EXIT.
  ENDIF.
* first get corr nbr for lockable transport objects
  e071_safe = e071.
  CLEAR vim_last_source_system.
  LOOP AT vim_corr_objtab WHERE lockable NE space.
    e071 = vim_corr_objtab.
    PERFORM check_lockable_object USING e071 ctofm_return.
    IF ctofm_return NE 0 OR x_header-flag EQ vim_transport_denied.
      EXIT.
    ENDIF.
  ENDLOOP.
  IF ctofm_return NE 0 OR x_header-flag EQ vim_transport_denied.
    e071 = e071_safe. EXIT.
  ENDIF.
  vim_corr_obj_viewname = x_header-viewname.
* second: check unlockable objects
* REFRESH VIM_ULO_TRSP_OBJS.
  LOOP AT vim_corr_objtab WHERE lockable EQ space.
    e071 = vim_corr_objtab.
*   APPEND E071 TO VIM_ULO_TRSP_OBJS.
    APPEND e071 TO ctofm_ko200_tab.
  ENDLOOP.
  IF sy-subrc EQ 0.                    &quot;only if unlockable objects exist
* CTOFM_KO200_TAB = VIM_ULO_TRSP_OBJS.
    LOOP AT corr_keytab.                &quot;save keys of other objects
      LOOP AT vim_corr_objtab WHERE lockable EQ space
                                AND object   EQ corr_keytab-mastertype
                                AND obj_name EQ corr_keytab-mastername.
        EXIT.
      ENDLOOP.
      CHECK sy-subrc NE 0.
      APPEND corr_keytab TO ctofm_keytab_safe.
      DELETE corr_keytab.
    ENDLOOP.
    last_order = &lt;status&gt;-order_nbr.
    last_corr = &lt;status&gt;-corr_nbr.
    CALL FUNCTION &apos;VIM_TR_OBJECTS_CHECK&apos;
     IMPORTING
       WE_ORDER                      = &lt;status&gt;-order_nbr
       WE_TASK                       = &lt;status&gt;-corr_nbr
       WE_OBJECTS_APPENDABLE         = obj_appendable
     TABLES
       WT_KO200                      = ctofm_ko200_tab
       WT_E071K                      = corr_keytab
*       TT_TADIR                      =
     EXCEPTIONS
       CANCEL_EDIT_OTHER_ERROR       = 1
       SHOW_ONLY_OTHER_ERROR         = 2
       OTHERS                        = 3
              .
*    IF SY-SUBRC &lt;&gt; 0.
** Implement suitable error handling here
*    ENDIF.

*    CALL FUNCTION &apos;TR_OBJECTS_CHECK&apos;
*      IMPORTING
*        we_order                = &lt;status&gt;-order_nbr
*        we_task                 = &lt;status&gt;-corr_nbr
*        we_objects_appendable   = obj_appendable
*      TABLES
*        wt_ko200                = ctofm_ko200_tab
*        wt_e071k                = corr_keytab
*      EXCEPTIONS
*        cancel_edit_other_error = 1
*        show_only_other_error   = 2
*        OTHERS                  = 3.
    IF sy-subrc NE 0.
      rc = sy-subrc.
      MESSAGE ID      sy-msgid
              TYPE    &apos;I&apos;
              NUMBER  sy-msgno
              WITH    sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      IF rc = 2.
*     MAINT_MODE = STATUS-ACTION = ANZEIGEN.
        ctofm_return = 4.
        e071 = e071_safe. EXIT.
      ELSE.                            &quot;cancel edit
*     RAISE MISSING_CORR_NUMBER.
        ctofm_return = 8. e071 = e071_safe. EXIT.
      ENDIF.
    ENDIF.
    IF &lt;status&gt;-corr_nbr NE space AND last_corr NE space.
      IF last_corr NE &lt;status&gt;-corr_nbr.
        IF &lt;status&gt;-order_nbr NE last_order.
          MESSAGE i129(sv). &quot;Zusammengehörige Objekte in verschied
*       RAISE MISSING_CORR_NUMBER.
          ctofm_return = 4. e071 = e071_safe. EXIT.
        ENDIF.
      ENDIF.
    ELSE.
      IF &lt;status&gt;-corr_nbr EQ space.
        &lt;status&gt;-corr_nbr = last_corr.
        &lt;status&gt;-order_nbr = last_order.
      ENDIF.
    ENDIF.
    LOOP AT ctofm_keytab_safe INTO corr_keytab. &quot;restore saved entries
      APPEND corr_keytab.
    ENDLOOP.
    IF obj_appendable EQ space.        &quot;no ...INSERT - call required
      vim_client_state = vim_noact.
    ENDIF.
  ENDIF.                               &quot;unlockable objects exist
  e071 = e071_safe.
  &lt;status&gt;-tr_alrchkd = &apos;x&apos;.
ENDFORM.                               &quot;check_transp_objs_for_maint
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_get_img_activity
*&amp;---------------------------------------------------------------------*
*       Gets IMG-activity the dialogue has been called from.
*       UF738595/2001
*----------------------------------------------------------------------*
*      &lt;--P_ACTIVITY  IMG-activity
*----------------------------------------------------------------------*
FORM vim_get_img_activity  CHANGING p_activity TYPE e071-activity.

  CALL FUNCTION &apos;READ_IMG_ACTIVITY_FROM_MEMORY&apos;
    IMPORTING
      img_activity = p_activity.
ENDFORM.                    &quot; get_img_activity</include_source>
   </include>
   <include NAME="LSVIMF1Z" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_LOCKABLE_OBJECT                                    *
*---------------------------------------------------------------------*
*  check lockable transport objects                                   *
*---------------------------------------------------------------------*
* &lt;---&gt; CLO_E071 ......
* &lt;---- return code: 0 - ok, 4 - display only, 8 - cancel edit        *
*---------------------------------------------------------------------*
FORM CHECK_LOCKABLE_OBJECT USING CLO_E071 STRUCTURE E071
                                 CLO_RETURN TYPE I.
  DATA: CLO_TADIR LIKE TADIR, CLO_DDERR LIKE DDERR,              &quot;#EC NEEDED
        CLO_LOCKED(1) TYPE C, CLO_LOCKABLE(1) TYPE C,
        CLO_EDITABLE(1) TYPE C, CLO_LOCK_TASK LIKE E071-TRKORR,
        CLO_LOCK_USER LIKE SY-UNAME, CLO_LOCK_ORDER LIKE E071-TRKORR,
        CLO_TRANSPORTABLE(1) TYPE C, CLO_ICORR LIKE E070-TRKORR,
        CLO_TE071 LIKE KO200 OCCURS 0, CLO_TTADIR LIKE TADIR OCCURS 0,
        CLO_TE071K LIKE E071K OCCURS 0.

  APPEND CLO_E071 TO CLO_TE071.
  CALL FUNCTION &apos;TR_EDIT_CHECK_OBJECTS_KEYS&apos;
       EXPORTING
            WI_ORDER                       = CLO_E071-TRKORR
            WI_WITH_DIALOG                 = &apos;R&apos;
*           WI_OBJ_CATEGOGY_MIX            = &apos;X&apos;
            WI_SEND_MESSAGE                = &apos; &apos;
       IMPORTING
*           WE_ORDER                       =
            WE_TASK                        = CLO_E071-TRKORR
*           WE_OBJECTS_APPENDABLE          =
*           EV_ERRNUM                      =
*           EV_OBJECT_UNLOCKED             =
       TABLES
            WT_E071                        = CLO_TE071
            WT_E071K                       = CLO_TE071K
            WT_TADIR                       = CLO_TTADIR
       EXCEPTIONS
            CANCEL_EDIT_APPEND_ERROR_KEYS  = 1
            CANCEL_EDIT_APPEND_ERROR_OBJCT = 2
            CANCEL_EDIT_APPEND_ERROR_ORDER = 3
            CANCEL_EDIT_BUT_SE01           = 4
            CANCEL_EDIT_NO_HEADER_OBJECT   = 5
            CANCEL_EDIT_NO_ORDER_SELECTED  = 6
            CANCEL_EDIT_REPAIRED_OBJECT    = 7
            CANCEL_EDIT_SYSTEM_ERROR       = 8
            CANCEL_EDIT_TADIR_MISSING      = 9
            CANCEL_EDIT_TADIR_UPDATE_ERROR = 10
            CANCEL_EDIT_UNKNOWN_DEVCLASS   = 11
            CANCEL_EDIT_UNKNOWN_OBJECTTYPE = 12
            CANCEL_EDIT_NO_CHECK_CALL      = 13
            CANCEL_EDIT_CATEGORY_MIXTURE   = 14
            CANCEL_EDIT_USER_AFTER_ERROR   = 15
            CANCEL_EDIT_CUSTOM_OBJ_AT_SAP  = 16
            CANCEL_EDIT_ACCESS_DENIED      = 17
            SHOW_ONLY_CLOSED_SYSTEM        = 18
            SHOW_ONLY_CONSOLIDATION_LEVEL  = 19
            SHOW_ONLY_DDIC_IN_CUSTOMER_SYS = 20
            SHOW_ONLY_DELIVERY_SYSTEM      = 21
            SHOW_ONLY_DIFFERENT_ORDERTYPES = 22
            SHOW_ONLY_DIFFERENT_TASKTYPES  = 23
            SHOW_ONLY_ENQUEUE_FAILED       = 24
            SHOW_ONLY_GENERATED_OBJECT     = 25
            SHOW_ONLY_ILL_LOCK             = 26
            SHOW_ONLY_LOCK_ENQUEUE_FAILED  = 27
            SHOW_ONLY_MIXED_ORDERS         = 28
            SHOW_ONLY_MIX_LOCAL_TRANSP_OBJ = 29
            SHOW_ONLY_NO_SHARED_REPAIR     = 30
            SHOW_ONLY_OBJECT_LOCKED        = 31
            SHOW_ONLY_REPAIRED_OBJECT      = 32
            SHOW_ONLY_SHOW_CLIENT          = 33
            SHOW_ONLY_TADIR_MISSING        = 34
            SHOW_ONLY_UNKNOWN_DEVCLASS     = 35
            SHOW_ONLY_CLOSED_CLIENT        = 36
            SHOW_ONLY_CLOSED_ALE_OBJECT    = 37
            SHOW_ONLY_UNALLOWED_SUPERUSER  = 38
            SHOW_ONLY_NO_REPAIR_SYSTEM     = 39
            SHOW_ONLY_NO_LICENSE           = 40
            SHOW_ONLY_CENTRAL_BASIS        = 41
            SHOW_ONLY_USER_AFTER_ERROR     = 42
            SHOW_ONLY_OBJECT_NOT_PATCHABLE = 43.
  IF SY-SUBRC NE 0.
    MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO
            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    IF SY-SUBRC LE 17.
      CLO_RETURN = 8. EXIT.
    ELSE.
      CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
    ENDIF.
  ELSE.
    READ TABLE CLO_TE071 INTO CLO_E071 INDEX 1.
    READ TABLE CLO_TTADIR INTO CLO_TADIR INDEX 1.
    IF CLO_TADIR-DEVCLASS IS INITIAL.
      CALL FUNCTION &apos;TR_EDIT_CHECK_OBJECTS_KEYS&apos;
           EXPORTING
                WI_ORDER                       = CLO_E071-TRKORR
                WI_WITH_DIALOG                 = &apos;X&apos;
*           WI_OBJ_CATEGOGY_MIX            = &apos;X&apos;
                WI_SEND_MESSAGE                = &apos; &apos;
           IMPORTING
*           WE_ORDER                       =
                WE_TASK                        = CLO_E071-TRKORR
*           WE_OBJECTS_APPENDABLE          =
*           EV_ERRNUM                      =
*           EV_OBJECT_UNLOCKED             =
           TABLES
                WT_E071                        = CLO_TE071
                WT_E071K                       = CLO_TE071K
                WT_TADIR                       = CLO_TTADIR
           EXCEPTIONS
                CANCEL_EDIT_APPEND_ERROR_KEYS  = 1
                CANCEL_EDIT_APPEND_ERROR_OBJCT = 2
                CANCEL_EDIT_APPEND_ERROR_ORDER = 3
                CANCEL_EDIT_BUT_SE01           = 4
                CANCEL_EDIT_NO_HEADER_OBJECT   = 5
                CANCEL_EDIT_NO_ORDER_SELECTED  = 6
                CANCEL_EDIT_REPAIRED_OBJECT    = 7
                CANCEL_EDIT_SYSTEM_ERROR       = 8
                CANCEL_EDIT_TADIR_MISSING      = 9
                CANCEL_EDIT_TADIR_UPDATE_ERROR = 10
                CANCEL_EDIT_UNKNOWN_DEVCLASS   = 11
                CANCEL_EDIT_UNKNOWN_OBJECTTYPE = 12
                CANCEL_EDIT_NO_CHECK_CALL      = 13
                CANCEL_EDIT_CATEGORY_MIXTURE   = 14
                CANCEL_EDIT_USER_AFTER_ERROR   = 15
                CANCEL_EDIT_CUSTOM_OBJ_AT_SAP  = 16
                CANCEL_EDIT_ACCESS_DENIED      = 17
                SHOW_ONLY_CLOSED_SYSTEM        = 18
                SHOW_ONLY_CONSOLIDATION_LEVEL  = 19
                SHOW_ONLY_DDIC_IN_CUSTOMER_SYS = 20
                SHOW_ONLY_DELIVERY_SYSTEM      = 21
                SHOW_ONLY_DIFFERENT_ORDERTYPES = 22
                SHOW_ONLY_DIFFERENT_TASKTYPES  = 23
                SHOW_ONLY_ENQUEUE_FAILED       = 24
                SHOW_ONLY_GENERATED_OBJECT     = 25
                SHOW_ONLY_ILL_LOCK             = 26
                SHOW_ONLY_LOCK_ENQUEUE_FAILED  = 27
                SHOW_ONLY_MIXED_ORDERS         = 28
                SHOW_ONLY_MIX_LOCAL_TRANSP_OBJ = 29
                SHOW_ONLY_NO_SHARED_REPAIR     = 30
                SHOW_ONLY_OBJECT_LOCKED        = 31
                SHOW_ONLY_REPAIRED_OBJECT      = 32
                SHOW_ONLY_SHOW_CLIENT          = 33
                SHOW_ONLY_TADIR_MISSING        = 34
                SHOW_ONLY_UNKNOWN_DEVCLASS     = 35
                SHOW_ONLY_CLOSED_CLIENT        = 36
                SHOW_ONLY_CLOSED_ALE_OBJECT    = 37
                SHOW_ONLY_UNALLOWED_SUPERUSER  = 38
                SHOW_ONLY_NO_REPAIR_SYSTEM     = 39
                SHOW_ONLY_NO_LICENSE           = 40
                SHOW_ONLY_CENTRAL_BASIS        = 41
                SHOW_ONLY_USER_AFTER_ERROR     = 42
                SHOW_ONLY_OBJECT_NOT_PATCHABLE = 43.
      IF SY-SUBRC NE 0.
        MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO
                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
        IF SY-SUBRC LE 17.
          CLO_RETURN = 8. EXIT.
        ELSE.
          CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
        ENDIF.
      ELSE.
        READ TABLE CLO_TE071 INTO CLO_E071 INDEX 1.
        READ TABLE CLO_TTADIR INTO CLO_TADIR INDEX 1.
      ENDIF.
    ENDIF.
  ENDIF.
* PERFORM MCOMMEDITCHECK(RDDINSYS)
*                        CHANGING CLO_E071 CLO_TADIR CLO_DDERR.
* IF CLO_DDERR-SEVERITY EQ &apos;F&apos;.
*   IF CLO_DDERR-ERRNUM EQ &apos;16&apos;.       &quot;repair requested
*     PERFORM FCOMMEDITCHECK(RDDINSYS)
*                            CHANGING CLO_E071 CLO_TADIR CLO_DDERR.
*     IF CLO_DDERR-SEVERITY EQ &apos;F&apos;.
*       CASE CLO_DDERR-ERRNUM.
*         WHEN 4.                      &quot;display
**          MAINT_MODE = STATUS-ACTION = ANZEIGEN.
**          EXIT.
*           CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR.
*           EXIT.
*         WHEN 12.                     &quot;cancel edit
**          RAISE MISSING_CORR_NUMBER.
*           CLO_RETURN = 8. EXIT.
*       ENDCASE.
*     ENDIF.
*   ELSEIF CLO_DDERR-ERRNUM EQ &apos;17&apos; OR &quot;no TADIR or
*          CLO_DDERR-ERRNUM EQ &apos;18&apos;.   &quot;missing devclass
*     IF CLO_DDERR-ERRNUM EQ &apos;17&apos;.
*       MESSAGE S133(SV). &quot;Bitte Transporteigenschaften eingeben
*     ELSE.
*       MESSAGE S486(TK) WITH CLO_TADIR-DEVCLASS.
*     ENDIF.
*     CLO_TADIR-PGMID    = CLO_E071-PGMID.
*     CLO_TADIR-OBJECT   = CLO_E071-OBJECT.
*     CLO_TADIR-OBJ_NAME = CLO_E071-OBJ_NAME.
*     CALL FUNCTION &apos;TADIR_PFLEGE&apos;
*          EXPORTING
*               ADIR      = CLO_TADIR
*               E71TEMP   = CLO_E071
*               START_ROW = 2
*          IMPORTING
*               NEWADIR   = CLO_TADIR
*               PDDERR    = CLO_DDERR
*          EXCEPTIONS
*               ILL_TYPE  = 01.
*     IF SY-SUBRC NE 0.
*       MESSAGE I095(SV) WITH E071-TRKORR. &quot;Systemfehler
**      RAISE MISSING_CORR_NUMBER.
*       CLO_RETURN = 8. EXIT.
*     ENDIF.
*     IF CLO_DDERR-SEVERITY EQ &apos;F&apos;.
*       CASE CLO_DDERR-ERRNUM.
*         WHEN 4.                      &quot;display
**          MAINT_MODE = STATUS-ACTION = ANZEIGEN.
**          EXIT.
*           CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR.
*           EXIT.
*         WHEN 12.                     &quot;cancel edit
**          RAISE MISSING_CORR_NUMBER.
*           CLO_RETURN = 8. EXIT.
*       ENDCASE.
*     ELSE.
*       CALL FUNCTION &apos;TRINT_CHANGE_TADIR_MASTERLANG&apos;
*            EXPORTING
*                 WI_TADIR_PGMID               = CLO_TADIR-PGMID
*                 WI_TADIR_OBJECT              = CLO_TADIR-OBJECT
*                 WI_TADIR_OBJ_NAME            = CLO_TADIR-OBJ_NAME
*                 WI_TADIR_MASTERLANG          = SY-LANGU
*            EXCEPTIONS
*                 MASTERLANG_NOT_ALLOWED       = 1.
*       IF SY-SUBRC NE 0. &quot;language not allowed
*         MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO
*           WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
*       ENDIF.
*     ENDIF.
*   ELSE.  &quot;other problems in MCOMM....
*     MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO
*             WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
**    MESSAGE I733(TK).
*     IF CLO_DDERR-ERRNUM EQ &apos;4&apos;.   &quot;display
*       CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR.
*       EXIT.
*     ELSE.                         &quot;cancel
*       CLO_RETURN = 8. EXIT.
*     ENDIF.
**    MESSAGE I095(SV) WITH E071-TRKORR. &quot;Systemfehler
**    RAISE MISSING_CORR_NUMBER.
*   ENDIF.                             &quot; clo_dderr-errnum in ( 17, 18 )
* ENDIF.                               &quot;clo_dderr-severity eq &apos;F&apos;
* first check if devclass is ok
* SELECT SINGLE * FROM TADIR INTO CLO_TADIR &quot;already done in MCOMMEDITCH
*                            WHERE PGMID    = CLO_E071-PGMID
*                              AND OBJECT   = CLO_E071-OBJECT
*                              AND OBJ_NAME = CLO_E071-OBJ_NAME.
* IF TADIR-DEVCLASS(1) EQ &apos;$&apos;. &quot;local object -&gt; no transport
  IF CLO_TADIR IS INITIAL.             &quot;may be no lockable object?
    CALL FUNCTION &apos;TR_CHECK_OBJECT_LOCK&apos;
         EXPORTING
              WI_OBJECT                  = CLO_E071-OBJECT
              WI_OBJNAME                 = CLO_E071-OBJ_NAME
              WI_PGMID                   = CLO_E071-PGMID
         IMPORTING
              WE_LOCKABLE_OBJECT         = CLO_LOCKABLE
              WE_LOCKED                  = CLO_LOCKED
              WE_LOCK_TASK               = CLO_LOCK_TASK
              WE_LOCK_TASK_USER          = CLO_LOCK_USER
              WE_LOCK_ORDER              = CLO_LOCK_ORDER
              WE_OBJECT_EDITABLE         = CLO_EDITABLE
* 4.0 Namesp. WE_POSSIBLE_USER_EDIT_TASK = CLO_TADIR-KORRNUM
              WE_POSSIBLE_USER_EDIT_TASK = CLO_ICORR
         EXCEPTIONS
              EMPTY_KEY                  = 01
              NO_SYSTEMNAME              = 02
              NO_SYSTEMTYPE              = 03
              UNALLOWED_LOCK_ORDER       = 04.
    IF SY-SUBRC NE 0.
      MESSAGE I095(SV) WITH E071-TRKORR. &quot;Systemfehler
*     RAISE MISSING_CORR_NUMBER.
      CLO_RETURN = 8. EXIT.
    ENDIF.
    IF CLO_LOCKABLE EQ SPACE.          &quot;yes no lockable object
      VIM_CORR_OBJTAB-LOCKABLE = SPACE.
      MODIFY VIM_CORR_OBJTAB.
      EXIT.
    ELSE.                              &quot;inconsistent object.
      MESSAGE I095(SV) WITH E071-TRKORR. &quot;Systemfehler
      CLO_RETURN = 8. EXIT.
    ENDIF.
  ENDIF.                               &quot;clo_tadir is initial
  CALL FUNCTION &apos;VIEW_GET_DEVCLASS_STATE&apos;
       EXPORTING
            DEV_CLASS          = CLO_TADIR-DEVCLASS
       IMPORTING
            TRANSPORT_POSSIBLE = CLO_TRANSPORTABLE
    EXCEPTIONS                                              &quot;#EC FB_RC
            NOT_FOUND          = 01.
  IF CLO_TRANSPORTABLE EQ SPACE.       &quot;local object -&gt; no transport
    X_HEADER-FLAG = VIM_TRANSPORT_DENIED.
    MODIFY X_HEADER INDEX 1.
  ELSE.
* second check if all objects have valid source systems
    IF VIM_LAST_SOURCE_SYSTEM EQ SPACE.
      VIM_LAST_SOURCE_SYSTEM = CLO_TADIR-SRCSYSTEM.
    ELSE.
      IF CLO_TADIR-SRCSYSTEM EQ SY-SYSID.    &quot;if one object has sy-sysid
        IF VIM_LAST_SOURCE_SYSTEM NE SY-SYSID.&quot;all objs must have sy-sys
          MESSAGE I134(SV). &quot;Inkonsistenz in Objektdefinition, nur Anzei
*       MAINT_MODE = STATUS-ACTION = ANZEIGEN.
*       EXIT.
          CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
        ENDIF.
      ELSE. &quot;if one object has another source system, all objects must
        IF VIM_LAST_SOURCE_SYSTEM EQ SY-SYSID. &quot;another source system
          MESSAGE I134(SV). &quot;Inkonsistenz in Objektdefinition, nur Anzei
*       MAINT_MODE = STATUS-ACTION = ANZEIGEN.
*       EXIT.
          CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
        ENDIF.
      ENDIF.
    ENDIF.
    CALL FUNCTION &apos;TR_CHECK_OBJECT_LOCK&apos;
         EXPORTING
              WI_OBJECT                  = CLO_E071-OBJECT
              WI_OBJNAME                 = CLO_E071-OBJ_NAME
              WI_PGMID                   = CLO_E071-PGMID
         IMPORTING
              WE_LOCKABLE_OBJECT         = CLO_LOCKABLE
              WE_LOCKED                  = CLO_LOCKED
              WE_LOCK_TASK               = CLO_LOCK_TASK
              WE_LOCK_TASK_USER          = CLO_LOCK_USER
              WE_LOCK_ORDER              = CLO_LOCK_ORDER
              WE_OBJECT_EDITABLE         = CLO_EDITABLE
* 4.0 Namesp. WE_POSSIBLE_USER_EDIT_TASK = CLO_TADIR-KORRNUM
              WE_POSSIBLE_USER_EDIT_TASK = CLO_ICORR
         EXCEPTIONS
              EMPTY_KEY                  = 01
              NO_SYSTEMNAME              = 02
              NO_SYSTEMTYPE              = 03
              UNALLOWED_LOCK_ORDER       = 04.
    IF SY-SUBRC NE 0.
      MESSAGE I095(SV) WITH E071-TRKORR. &quot;Systemfehler
*     RAISE MISSING_CORR_NUMBER.
      CLO_RETURN = 8. EXIT.
    ENDIF.
    IF CLO_LOCKABLE EQ SPACE.
      VIM_CORR_OBJTAB-LOCKABLE = SPACE.
      MODIFY VIM_CORR_OBJTAB.
      EXIT.
    ENDIF.
    IF CLO_LOCKED NE SPACE.
      IF CLO_EDITABLE EQ SPACE.
        MESSAGE I132(SV) WITH CLO_LOCK_TASK CLO_LOCK_USER.
*       MAINT_MODE = STATUS-ACTION = ANZEIGEN.
*       EXIT.
        CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
      ELSE.
*       CLO_E071-TRKORR = CLO_TADIR-KORRNUM.   &quot;4.0 Namespace
        CLO_E071-TRKORR = CLO_ICORR.   &quot;4.0 Namespace
      ENDIF.
    ENDIF.                             &quot;clo_locked
  ENDIF.                               &quot;devclass
  IF &lt;STATUS&gt;-CORR_NBR NE SPACE AND CLO_E071-TRKORR NE SPACE.
    IF CLO_E071-TRKORR NE &lt;STATUS&gt;-CORR_NBR.
      IF &lt;STATUS&gt;-ORDER_NBR NE CLO_LOCK_ORDER.
        MESSAGE I129(SV). &quot;Zusammengehörige Objekte in verschied
*       RAISE MISSING_CORR_NUMBER.
        CLO_RETURN = 4. &lt;STATUS&gt;-CORR_NBR = VIM_LOCKED_IN_CORR. EXIT.
      ENDIF.
      VIM_CORR_OBJTAB-TRKORR = CLO_E071-TRKORR.
      MODIFY VIM_CORR_OBJTAB.
    ENDIF.
  ELSE.
    IF &lt;STATUS&gt;-CORR_NBR EQ SPACE.
      &lt;STATUS&gt;-CORR_NBR = CLO_E071-TRKORR.
      &lt;STATUS&gt;-ORDER_NBR = CLO_LOCK_ORDER.
    ENDIF.
  ENDIF.
  TRANSLATE &lt;STATUS&gt;-TR_ALRCHKD USING &apos; x&apos;.
  CLEAR CLO_RETURN.
ENDFORM.                               &quot;check_lockable_object</include_source>
   </include>
   <include NAME="LSVIMF20" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM REQUEST_CORR_NUMBER                                      *
*---------------------------------------------------------------------*
*       request correction number                                     *
*---------------------------------------------------------------------*
FORM request_corr_number.
  DATA: rc LIKE sy-subrc, e071_safe LIKE e071.

  CHECK maint_mode EQ transportieren.  &quot;manual transport mode
  IF &lt;status&gt;-l_corr_nbr NE space.
    IF &lt;status&gt;-corr_nbr NE &lt;status&gt;-l_corr_nbr.
      CLEAR: &lt;status&gt;-tr_alrchkd, &lt;status&gt;-corr_enqud.
    ELSE.
      IF vim_external_mode EQ space.
        TRANSLATE &lt;status&gt;-tr_alrchkd USING &apos;Xx&apos;.
      ENDIF.
    ENDIF.
  ENDIF.
  PERFORM vim_get_img_activity CHANGING e071-activity.  &quot;UF738595/2001
  IF vim_corr_obj_viewname NE x_header-viewname.
    CLEAR e071-trkorr.
    PERFORM get_transp_info.
    CHECK x_header-flag NE vim_transport_denied.
    CHECK vim_actopts-transp_off NE bc_transport_denied.
  ENDIF.
  IF &lt;status&gt;-tr_alrchkd EQ space.
* first get corr nbr for lockable transport objects
    e071_safe = e071.
    CLEAR vim_last_source_system.
    LOOP AT vim_corr_objtab WHERE lockable NE space.
      e071 = vim_corr_objtab.
      PERFORM check_lockable_object USING e071 rc.
      CASE rc.
        WHEN 4. maint_mode = anzeigen.
        WHEN 8. RAISE missing_corr_number.
      ENDCASE.
      IF maint_mode EQ anzeigen OR
         x_header-flag EQ vim_transport_denied OR
         vim_actopts-transp_off EQ bc_transport_denied.
        EXIT.
      ENDIF.
    ENDLOOP.
    e071 = e071_safe.
  ENDIF.                               &quot;&lt;status&gt;-tr_alrchkd eq space
  CHECK maint_mode NE anzeigen AND
        x_header-flag NE vim_transport_denied AND
        vim_actopts-transp_off NE bc_transport_denied.
  vim_corr_obj_viewname = x_header-viewname.
  IF &lt;status&gt;-corr_nbr NE space AND    &quot;task specified and...
     corr_nbr EQ space AND          &quot;...task not setted by caller and...
     &lt;status&gt;-corr_enqud EQ space.     &quot;...corr not yet enqueued
    CALL FUNCTION &apos;ENQUEUE_E_TRKORR&apos;
         EXPORTING
              trkorr = &lt;status&gt;-corr_nbr
*               X_TRKORR = E02
         EXCEPTIONS
              foreign_lock = 01
              system_failure = 02.
    CASE sy-subrc.
      WHEN 1.
        MESSAGE s092(sv) WITH &lt;status&gt;-corr_nbr. &quot;Korr. wird ger.bearb.
      WHEN 2.
        MESSAGE a095(sv) WITH &lt;status&gt;-corr_nbr. &quot;Systemfehler
    ENDCASE.
    &lt;status&gt;-corr_enqud = &apos;X&apos;.
  ENDIF.
* if no lockable objects exist get corr nbr for other objects...
* but only if objects exist....
  DESCRIBE TABLE vim_corr_objtab.
  IF &lt;status&gt;-corr_nbr EQ space AND sy-tfill GT 0.
    DO.
      CALL FUNCTION &apos;TR_ORDER_CHOICE_CORRECTION&apos;
           EXPORTING
                iv_category            = objh-objcateg
                iv_cli_dep             = objh-clidep
           IMPORTING
                ev_order               = &lt;status&gt;-order_nbr
                ev_task                = &lt;status&gt;-corr_nbr
           EXCEPTIONS
                invalid_category       = 01
                no_correction_selected = 02.
      CASE sy-subrc.
        WHEN 1.
          IF objh-objcateg NE vim_syst AND objh-objcateg NE vim_cust.
            CASE objh-objcateg.
              WHEN vim_cust_syst. objh-objcateg = vim_syst.
              WHEN vim_appl.      objh-objcateg = vim_syst.
              WHEN OTHERS.
                MESSAGE ID     sy-msgid
                        TYPE   &apos;I&apos;
                        NUMBER sy-msgno
                        WITH sy-msgv1 sy-msgv2  sy-msgv3 sy-msgv4.
                RAISE missing_corr_number.
            ENDCASE.
            CONTINUE.
          ENDIF.
        WHEN 2.
          CLEAR vim_corr_obj_viewname.
          RAISE missing_corr_number.
      ENDCASE.
      CALL FUNCTION &apos;ENQUEUE_E_TRKORR&apos;
           EXPORTING
                trkorr = &lt;status&gt;-corr_nbr
*               X_TRKORR = E02
           EXCEPTIONS
                foreign_lock = 01
                system_failure = 02.
      CASE sy-subrc.
*       WHEN 0.
        WHEN 1.
          MESSAGE s092(sv) WITH &lt;status&gt;-corr_nbr. &quot;Korr. wirdger.bearb.
          CONTINUE.
        WHEN 2.
          MESSAGE a095(sv) WITH &lt;status&gt;-corr_nbr. &quot;Systemfehler
          CONTINUE.
      ENDCASE.
      IF ( last_corr_number NE space AND
           &lt;status&gt;-corr_nbr NE last_corr_number ) OR
         &lt;status&gt;-tr_alrchkd EQ space.
        LOOP AT corr_keytab.             &quot;UF 514599/1999beg
          READ TABLE vim_corr_objtab
           WITH KEY pgmid    = corr_keytab-pgmid
           object   = corr_keytab-object obj_name = corr_keytab-objname.
          CHECK sy-subrc = 0 AND vim_corr_objtab-lockable = space.
* new corrnumber for unlockable objects only
          CLEAR vim_corr_objtab-trkorr.
* will be filled again in form PREPARE_CORR
          MODIFY vim_corr_objtab INDEX sy-tabix.
        ENDLOOP.                       &quot;UF 514599/1999end
        REFRESH corr_keytab.
        MOVE &lt;status&gt;-corr_nbr TO last_corr_number.
      ELSEIF last_corr_number EQ space.
        LOOP AT corr_keytab WHERE
                                ( mastertype EQ vim_unlockable_object OR
                                  mastertype EQ vim_lockable_object ).
*                           AND TRKORR EQ SPACE.
* SW: bei TRSP -&gt; neue Korrnummer, alte blieb aber in CORR_KEYTAB-TRKORR
          IF  corr_keytab-trkorr EQ space.
            corr_keytab-trkorr = &lt;status&gt;-corr_nbr.
            MODIFY corr_keytab.
          ELSE.                        &quot;SW ..
            READ TABLE vim_corr_objtab
                    WITH KEY pgmid    = corr_keytab-pgmid
                             object   = corr_keytab-object
                             obj_name = corr_keytab-objname.
            IF sy-subrc = 0.
              corr_keytab-trkorr = &lt;status&gt;-corr_nbr.
              MODIFY corr_keytab.
            ENDIF.
          ENDIF.                       &quot;.. SW
        ENDLOOP.
      ENDIF.
      EXIT.
    ENDDO.
    &lt;status&gt;-corr_enqud = &apos;X&apos;.
  ENDIF.                               &quot;&lt;status&gt;-corr_nbr eq space
  MOVE: &lt;status&gt;-corr_nbr TO e071k-trkorr,
        &lt;status&gt;-corr_nbr TO e071-trkorr,
        &lt;status&gt;-corr_nbr TO e070-trkorr.
  TRANSLATE &lt;status&gt;-tr_alrchkd USING &apos; x&apos;.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF21" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM GET_TRANSP_INFO                                          *
*---------------------------------------------------------------------*
* get client state and transport objects                              *
*---------------------------------------------------------------------*
FORM get_transp_info.
  LOCAL: e071.
  DATA: obj_type LIKE objh-objecttype, last_category LIKE objh-objcateg,
        last_clidep LIKE objh-clidep VALUE &apos;X&apos;, gti_e071 LIKE e071,
        last_protect LIKE objh-protect, gti_cliindep_state(1) TYPE c,  &quot;#EC NEEDED
        gti_x030l LIKE x030l,
        gti_tabname TYPE tabname,
        gti_client_role LIKE t000-cccategory,
        gti_flag_safe(1) TYPE c,
        cursetting TYPE cursetting, addr_e071k LIKE e071k,
        importable TYPE objimp value &apos;4&apos;,
        tr_result LIKE trpari-s_checked,
        addr_e071k2 LIKE e071k.

* check if logging of changes is necessary
  gti_flag_safe = x_header-flag.
  IF x_header-customauth CO no_transport_classes.&quot;transport impossible
    x_header-flag = vim_transport_denied. &quot;no standard logging
    CLEAR: x_header-frm_e071,          &quot;no individual transport
           x_header-frm_e071ks,
           x_header-frm_e071ka.
    IF maint_mode EQ aendern.
      MOVE &apos;TRSP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ELSEIF maint_mode EQ transportieren.
      MESSAGE i128(sv) WITH &quot;Auslieferungsklasse &amp;, kein Transport mög
              x_header-customauth.
      RAISE missing_corr_number.
    ENDIF.
    MOVE &apos;ORDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    sy-subrc = 9.
  ELSEIF x_header-customauth CO no_transport_log_classes.
    IF x_header-frm_e071 EQ space AND x_header-frm_e071ks EQ space AND
       x_header-frm_e071ka EQ space.   &quot;no individual transport routines
      x_header-flag = vim_transport_denied. &quot;no transport
      IF maint_mode EQ aendern.
        MOVE &apos;TRSP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      ELSEIF maint_mode EQ transportieren.
        MESSAGE i128(sv) WITH &quot;Auslieferungsklasse &amp;, kein Transport mög
                x_header-customauth.
        RAISE missing_corr_number.
      ENDIF.
      MOVE &apos;ORDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ELSE.
      x_header-flag = &apos;X&apos;.             &quot;no standard logging
    ENDIF.
    sy-subrc = 9.
  ENDIF.
  IF sy-subrc EQ 9.
    MODIFY x_header INDEX 1.
  ENDIF.
*&lt;&lt;&lt; Übergangslösung Transportstatus des Mandanten Anfang
* check if client allows transport
  CALL FUNCTION &apos;VIEW_GET_CLIENT_STATE&apos;
    IMPORTING
      transp_state   = vim_client_state
      cliindep_state = gti_cliindep_state
      client_state   = gti_client_role.
  IF x_header-clidep NE space AND      &quot;clientdependent and
     x_header-customauth CN sap_only_classes. &quot;not delclass `S`
    CASE vim_client_state.
      WHEN vim_local_clnt. &quot;client is local -&gt; transport denied
        IF maint_mode EQ aendern OR maint_mode EQ anzeigen.
          excl_cua_funct-function = &apos;TRSP&apos;. COLLECT excl_cua_funct.
          excl_cua_funct-function = &apos;ORDR&apos;. COLLECT excl_cua_funct.
          x_header-flag = vim_transport_denied.
        ELSE.
          MESSAGE i130(sv) WITH &quot;Mandant ist lokal, keine Transporte m
                  sy-mandt.
          RAISE missing_corr_number.
        ENDIF.
      WHEN vim_locked. &quot;client is locked -&gt; no changes but transport
*       IF MAINT_MODE EQ AENDERN.  &quot;only for CUST/CUSY objects!!!!!!
*         MESSAGE I430(TK) WITH SY-MANDT.&quot;Mandant &amp;1 &apos;nicht änderbar&apos;
*         MAINT_MODE = STATUS-ACTION = ANZEIGEN.
*         EXIT.
*       ENDIF.
    ENDCASE.
  ELSE. &quot;clientindependent or deliveryclass &apos;S&apos;
    vim_client_state = vim_log.        &quot;such objects always log
  ENDIF.                               &quot;xheader-clidep ne space.
*&lt;&lt;&lt; Übergangslösung Transportstatus des Mandanten Ende
* if transport allowed -&gt; get transport objects
  REFRESH vim_corr_objtab.
  gti_e071 = e071.
  IF x_header-frm_e071 NE space.       &quot;individual transport objects
    PERFORM (x_header-frm_e071) IN PROGRAM (sy-repid).
  ENDIF.
  IF gti_flag_safe EQ space.                                &quot;240997
* automatic recording of changes switched on in SE54
    APPEND gti_e071 TO vim_corr_objtab.
    IF x_header-adrnbrflag EQ &apos;N&apos;.     &quot;new version of addresses used
* addresses
      REFRESH: vim_addr_e071k_tab, vim_addr_e071_tab.
      CALL FUNCTION &apos;ADDR_TRANSPORT_TDAT_ENTRIES&apos;
        TABLES
          e071k_tab = vim_addr_e071k_tab.
      addr_e071k2 = e071k.
      LOOP AT vim_addr_e071k_tab INTO addr_e071k.
        gti_e071-object = addr_e071k2-mastertype
         = addr_e071k-mastertype.
        gti_e071-obj_name = addr_e071k2-mastername
         = addr_e071k-mastername.
        APPEND gti_e071 TO vim_addr_e071_tab.
        APPEND gti_e071 TO vim_corr_objtab.
        MODIFY vim_addr_e071k_tab FROM addr_e071k2.
      ENDLOOP.
    ENDIF.
  ELSEIF x_header-frm_e071 EQ space AND    &quot;no individual transport
         x_header-frm_e071ks EQ space AND  &quot;routines and no standard
         x_header-frm_e071ka EQ space.
* no events concerning change recording are used
    APPEND gti_e071 TO vim_corr_objtab.    &quot;but check cliiendep settings
    x_header-flag = vim_transport_denied. MODIFY x_header INDEX 1.
    IF maint_mode EQ aendern.
      MOVE &apos;TRSP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ENDIF.
    MOVE &apos;ORDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    gti_flag_safe = &apos;@&apos;.
  ENDIF.
* get object category and client dependency for transport objects
  LOOP AT vim_corr_objtab.
    CASE vim_corr_objtab-object.
      WHEN vim_view_type.              &quot;-&gt; view
        obj_type = vim_view.
      WHEN transp_object.              &quot;-&gt; tables
        obj_type = vim_tabl.
      WHEN vim_tran_type.              &quot;-&gt; individual transaction
        obj_type = vim_tran.
      WHEN vim_clus_type.           &quot;-&gt; cluster of views/tables/clusters
        obj_type = vim_clst.
      WHEN OTHERS.                     &quot;-&gt; may be: TLOGO object ?
        obj_type = vim_logo.
    ENDCASE.
    IF obj_type NE vim_logo.
      SELECT SINGLE * FROM objh
                      WHERE objectname EQ vim_corr_objtab-obj_name
                        AND objecttype EQ obj_type. &quot;#EC CI_GENBUFF
    ELSE. &quot;TLOGO -&gt; use obj type as obj name
      SELECT SINGLE * FROM objh
                      WHERE objectname EQ vim_corr_objtab-object
                        AND objecttype EQ obj_type. &quot;#EC CI_GENBUFF
    ENDIF.
    IF sy-subrc NE 0.
      IF obj_type NE vim_logo. &quot;set defaults for table transp. obj.
        IF x_header-viewname EQ vim_corr_objtab-obj_name AND
           ( x_header-bastab EQ space AND
             vim_corr_objtab-object EQ vim_view_type OR
             x_header-bastab NE space AND
             vim_corr_objtab-object EQ transp_object ) OR
           vim_called_by_cluster NE space AND
           vim_calling_cluster EQ vim_corr_objtab-obj_name AND
           vim_corr_objtab-object EQ vim_clus_type.
          IF x_header-clidep EQ space. &quot;clientindependent
            IF x_header-customauth CO customizing_delivery_classes.
              objh-objcateg = vim_cust_syst.
            ELSEIF x_header-customauth CO sap_only_classes.
              objh-objcateg = vim_syst.
            ELSEIF x_header-customauth CO application_delivery_classes.
              objh-objcateg = vim_appl.
            ELSE.
              objh-objcateg = vim_syst.
            ENDIF.
          ELSE.                        &quot;clientdependent
            IF x_header-customauth CO customizing_delivery_classes.
              objh-objcateg = vim_cust.
            ELSEIF x_header-customauth CO sap_only_classes.
              objh-objcateg = vim_cust_syst.
            ELSEIF x_header-customauth CO application_delivery_classes.
              objh-objcateg = vim_appl.
            ELSE.
              objh-objcateg = vim_syst.
            ENDIF.
          ENDIF.
          objh-clidep   = x_header-clidep.
        ELSE.           &quot;unknown object -&gt; check if clientdep. table
          IF vim_corr_objtab-object EQ transp_object. &quot;table
            gti_tabname = vim_corr_objtab-obj_name.
            CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
              EXPORTING
                tabname   = gti_tabname
              IMPORTING
                x030l_wa  = gti_x030l
              EXCEPTIONS
                not_found = 1
                OTHERS    = 2.
            IF sy-subrc EQ 0 AND gti_x030l-flagbyte O vim_clidep.
              objh-objcateg = vim_cust.&quot;clientdependent table
              objh-clidep   = &apos;X&apos;.
            ELSE.                      &quot;no nametab or clientindependent
              objh-objcateg = vim_syst.
              objh-clidep   = space.
            ENDIF.
          ELSE.                        &quot;unknown object -&gt; syst
            objh-objcateg = vim_syst.
            objh-clidep   = space.
          ENDIF.
        ENDIF.
      ELSE. &quot;vim_logo                  &quot;no objh-object -&gt; syst
        objh-objcateg = vim_syst.
        objh-clidep   = space.
* note lockable transport object
        vim_corr_objtab-lockable = &apos;X&apos;.
        MODIFY vim_corr_objtab.
      ENDIF.                           &quot;obj_type ne vim_logo
    ELSE.
* entry in OBJH found -&gt; check current setting, importability,
* protect-flag
      IF objh-cursetting &lt;&gt; space.           &quot;UF615995/2000b
        cursetting = objh-cursetting.
      ENDIF.                                 &quot;UF615995/2000e
      IF objh-importable &lt;&gt; space
       AND objh-importable &lt; importable.     &quot;#EC PORTABLE
* &quot;most unimportable&quot; object sets standard
        importable = objh-importable.
      ENDIF.
      IF objh-protect NE space.
        IF objh-objectname EQ x_header-viewname AND &quot;current VIM object
           ( x_header-bastab EQ space AND objh-objecttype EQ vim_view OR
             x_header-bastab NE space AND objh-objecttype EQ vim_tabl ).
          IF x_header-frm_e071 EQ space AND
             x_header-frm_e071ks EQ space AND
             x_header-frm_e071ka EQ space. &quot;no individ. transp. routines
            x_header-flag = vim_transport_denied. &quot;no transport
            MOVE &apos;TRSP&apos; TO excl_cua_funct-function.
            COLLECT excl_cua_funct.
            MOVE &apos;ORDR&apos; TO excl_cua_funct-function.
            COLLECT excl_cua_funct.
*           EXIT.                                         &quot;240997
          ELSE.
            x_header-flag = &apos;X&apos;.       &quot;no standard logging
            DELETE vim_corr_objtab.
          ENDIF.
          MODIFY x_header INDEX 1.
        ENDIF. &quot;curr. VIM obj./ignore added individual transport objects
      ENDIF.                           &quot;protect ne space
*     IF OBJH-OBJECTTYPE EQ VIM_LOGO.
* note object as lockable transport object until TR_OBJECTS_* force
* TLOGO-objects too  &quot;changed in 4.0
      IF objh-checkid EQ &apos;L&apos;.          &quot;note lockable object!
        vim_corr_objtab-lockable = &apos;X&apos;.
        MODIFY vim_corr_objtab.
      ENDIF.
    ENDIF.                             &quot;sy-subrc ne 0.
    IF ( objh-objcateg EQ vim_syst OR
         objh-objcateg EQ vim_cust_syst ) AND
       last_category NE vim_syst.
      last_category = objh-objcateg.
    ENDIF.
    IF objh-clidep EQ space.
      last_clidep = objh-clidep.
    ENDIF.
  ENDLOOP.
* IF SY-SUBRC NE 0.  &quot;may be user exits.....
  IF sy-subrc NE 0.
    IF ( x_header-frm_e071 NE space OR
       x_header-frm_e071ks EQ space AND x_header-frm_e071ka EQ space ).
      x_header-flag = vim_transport_denied. MODIFY x_header INDEX 1.
      IF maint_mode EQ aendern.
        MOVE &apos;TRSP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      ENDIF.
      MOVE &apos;ORDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ENDIF.
    EXIT. &quot;if no object could be determined exit this routine
  ELSEIF gti_flag_safe EQ &apos;@&apos;.         &quot;temporaryly appended
    REFRESH vim_corr_objtab.
  ENDIF.
* CHECK X_HEADER-FLAG NE VIM_TRANSPORT_DENIED.             &quot;240997
  IF objh-objcateg NE vim_syst AND
     ( last_category EQ vim_syst OR
       last_category EQ vim_cust_syst ).
    objh-objcateg = last_category.
  ENDIF.
  objh-clidep = last_clidep.
* no logging for settings in productive clients
  IF cursetting NE space.
    x_header-cursetting = x_header-flag.
    TRANSLATE x_header-cursetting USING &apos; XXY&apos;.
    MODIFY x_header INDEX 1.
  ENDIF.
* put importable-flag into x_header.
  IF importable &lt;&gt; 4.
    x_header-importable = importable.
    MODIFY x_header INDEX 1.
  ENDIF.
  IF maint_mode EQ aendern AND objh-clidep NE space AND
     cursetting NE space AND gti_client_role EQ &apos;P&apos;.
    x_header-flag = vim_transport_denied. MODIFY x_header INDEX 1.
    MOVE &apos;ORDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    EXIT.                                                   &quot;240997
  ENDIF.
* CHECK X_HEADER-FLAG NE VIM_TRANSPORT_DENIED.          &quot;240997
  IF x_header-flag NE vim_transport_denied AND
     vim_actopts-transp_off NE bc_transport_denied AND
     vim_client_state EQ vim_locked AND
     ( objh-objcateg EQ vim_cust OR objh-objcateg EQ vim_cust_syst ) AND
     maint_mode EQ aendern.            &quot;only for CUST/CUSY objects!!!!!!
    MESSAGE i430(tk) WITH sy-mandt.    &quot;Mandant &amp;1 &apos;nicht änderbar&apos;
    maint_mode = status-action = anzeigen.
    ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
    vim_enqueue_range = x_header-subsetflag.
    PERFORM enqueue
                USING
                    &apos;D&apos;
                    space.
    EXIT.
  ENDIF.
  CASE gti_cliindep_state.
    WHEN vim_noact.
    WHEN vim_nocliindep_cust.
      IF maint_mode EQ aendern AND objh-objcateg = vim_cust_syst.
        CHECK x_header-flag NE vim_transport_denied.
        CHECK vim_actopts-transp_off NE bc_transport_denied.
        MESSAGE i731(tk).              &quot; WITH SY-MANDT.
        maint_mode = status-action = anzeigen.
        ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
        vim_enqueue_range = x_header-subsetflag.
        PERFORM enqueue
                    USING
                        &apos;D&apos;
                        space.
        vim_client_state = vim_noact. EXIT.
      ENDIF.
    WHEN vim_noreposiandcust.
      IF maint_mode EQ aendern AND
       ( objh-objcateg = vim_syst OR objh-objcateg = vim_cust_syst ).
        CHECK x_header-flag NE vim_transport_denied.
        CHECK vim_actopts-transp_off NE bc_transport_denied.
        MESSAGE i730(tk).              &quot; WITH SY-MANDT.
        maint_mode = status-action = anzeigen.
        ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
        vim_enqueue_range = x_header-subsetflag.
        PERFORM enqueue
                    USING
                        &apos;D&apos;
                        space.
        vim_client_state = vim_noact. EXIT.
      ENDIF.
    WHEN vim_noreposichanges.
      LOOP AT vim_corr_objtab INTO e071.
        CALL FUNCTION &apos;TR_CHECK_TYPE&apos;
          EXPORTING
            wi_e071   = e071
          IMPORTING
            pe_result = tr_result.
*  PE_RESULT        syntax  transport  TADIR     TLOCK
*           SPACE     -         -        -         -
*             S       X         -        -         -
*             R       X         X        -         -
*             T       X         X        X         -  (only for sapsccs)
*             L       X         X        X         X
*             P     system object or illegal name selection
*                   (T100, SAPL...., ... )
* no repository object and not lockable?
        IF &apos;TLP&apos; CS tr_result.
          MESSAGE i729(tk).              &quot;WITH SY-MANDT.
          IF x_header-flag NE vim_transport_denied AND
             vim_actopts-transp_off NE bc_transport_denied.
            maint_mode = status-action = anzeigen.
            ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
            vim_enqueue_range = x_header-subsetflag.
            PERFORM enqueue
                        USING
                            &apos;D&apos;
                            space.
            vim_client_state = vim_noact.
          ENDIF.
          EXIT.
        ENDIF.
      ENDLOOP.
  ENDCASE.
ENDFORM.                               &quot;get_transp_info</include_source>
   </include>
   <include NAME="LSVIMF22" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM ORDER_ADMINISTRATION                                     *
*---------------------------------------------------------------------*
* get client state and transport objects                              *
*---------------------------------------------------------------------*
FORM ORDER_ADMINISTRATION.
  DATA: RC LIKE SY-SUBRC.
  IF STATUS-ACTION EQ ANZEIGEN AND
     VIM_CORR_OBJ_VIEWNAME NE X_HEADER-VIEWNAME.
    CLEAR E071-TRKORR.
    PERFORM GET_TRANSP_INFO.
    VIM_CORR_OBJ_VIEWNAME = X_HEADER-VIEWNAME.
  ENDIF.
  IF X_HEADER-FLAG EQ VIM_TRANSPORT_DENIED.
    MESSAGE S001(SV). EXIT.
  ENDIF.
  IF vim_actopts-transp_off EQ bc_transport_denied.
    EXIT. &quot;HCG No message in BC_Set activation mode
  ENDIF.
  DO.
    CALL FUNCTION &apos;TR_TASK_OVERVIEW&apos;
         EXPORTING
              IV_USERNAME      = SY-UNAME
              IV_CATEGORY      = OBJH-OBJCATEG
              IV_CLIENT        = SY-MANDT
         EXCEPTIONS
              INVALID_CATEGORY = 01
              OTHERS           = 02.
    RC = SY-SUBRC.
    IF SY-SUBRC EQ 1 AND
       OBJH-OBJCATEG EQ VIM_CUST_SYST OR OBJH-OBJCATEG EQ VIM_APPL.
      OBJH-OBJCATEG = VIM_SYST.
      CONTINUE.
    ENDIF.
    EXIT.
  ENDDO.
  IF RC NE 0.
    MESSAGE ID      SY-MSGID
            TYPE    &apos;I&apos;
            NUMBER  SY-MSGNO
            WITH    SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.
  CLEAR FUNCTION.
ENDFORM.                               &quot;order_administration</include_source>
   </include>
   <include NAME="LSVIMF23" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM ORIGINAL_HOLEN                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM original_holen.
  DATA: count1 TYPE i, count2 TYPE i, count3 TYPE i, sum TYPE i,
        texttab_mod(1) TYPE c.         &quot;SW Texttransl
  IF status-action NE aendern OR status-delete EQ geloescht.
    MESSAGE i001(sv).
    EXIT.
  ENDIF.
  IF status-mode EQ list_bild.
    LOOP AT extract.
      CLEAR texttab_mod.
      CHECK &lt;xmark&gt; EQ markiert.
      ADD 1 TO count1.
      IF x_header-texttbexst &lt;&gt; space. &quot;SW Texttransl
        PERFORM vim_texttab_modif_for_key CHANGING texttab_mod.
      ENDIF.
      IF x_header-bastab NE space AND x_header-texttbexst NE space.
        CHECK &lt;xact&gt; EQ neuer_eintrag OR ( &lt;xact&gt; EQ original AND
              &lt;xact_text&gt; EQ original  AND texttab_mod EQ space ).
      ELSE.
        CHECK &lt;xact&gt; EQ neuer_eintrag OR ( &lt;xact&gt; EQ original
                                     AND texttab_mod EQ space ).
      ENDIF.
      IF &lt;xact&gt; EQ neuer_eintrag.
        ADD 1 TO count2.
      ELSE.
        ADD 1 TO count3.
      ENDIF.
    ENDLOOP.
  ELSE.
    ADD 1 TO count1.
    CASE &lt;xact&gt;.
      WHEN neuer_eintrag.
        ADD 1 TO count2.
      WHEN original.
        CLEAR texttab_mod.
        IF x_header-texttbexst &lt;&gt; space.              &quot;SW Texttransl
          PERFORM vim_texttab_modif_for_key CHANGING texttab_mod.
        ENDIF.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
*          IF sy-datar EQ space AND &lt;table1&gt; EQ &lt;extract_enti&gt; AND
          IF sy-datar EQ space AND &lt;table1&gt; EQ &lt;vim_extract_struc&gt;
           AND &lt;table1_xtext&gt; EQ &lt;vim_xextract_text&gt;
           AND texttab_mod EQ space.
            ADD 1 TO count3.
          ENDIF.
        ELSE.
*          IF sy-datar EQ space AND &lt;table1&gt; EQ &lt;table2&gt;
          IF sy-datar EQ space AND &lt;table1&gt; EQ &lt;vim_extract_struc&gt;
                               AND texttab_mod EQ space.
            ADD 1 TO count3.
          ENDIF.
        ENDIF.
    ENDCASE.
  ENDIF.
  sum = count2 + count3.
  IF count1 EQ 0.
    MESSAGE s056(sv).
  ELSEIF count1 EQ count2.
    IF count1 EQ 1.
      MESSAGE s057(sv).
      IF status-mode EQ detail_bild.
        CLEAR function.
      ENDIF.
    ELSE.
      MESSAGE s058(sv).
    ENDIF.
  ELSEIF count1 EQ count3.
    IF count1 EQ 1.
      MESSAGE s059(sv).
    ELSE.
      MESSAGE s060(sv).
    ENDIF.
  ELSEIF count1 EQ sum.
    MESSAGE s061(sv) WITH count3 count2.
  ELSE.
    CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
         EXPORTING
              titel     = svim_text_010
              textline1 = svim_text_009
              textline2 = svim_text_011
         IMPORTING
              answer    = answer.
    IF answer EQ &apos;J&apos;.
      IF status-mode EQ list_bild.
        function = &apos;ORGL&apos;.
      ELSE.
        IF &lt;xact&gt; NE original OR texttab_mod NE space.
          function = &apos;ORGD&apos;.
        ELSE.
          answer = &apos;N&apos;.
        ENDIF.
      ENDIF.
      IF answer = &apos;J&apos;.
*       SET SCREEN 0. LEAVE SCREEN.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    ELSE.
      CLEAR function.
    ENDIF.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF24" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM ADDRESS_MAINTAIN                                         *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM address_maintain.
  DATA: mode, return TYPE i, kz, answer, am_save(1) TYPE c, &quot;#EC TYPES_MISS
        am_pos LIKE sy-fdpos, am_length LIKE sy-fdpos,
        func_name TYPE rs38l_fnam.
  DATA: am_handletab LIKE addr1_dia OCCURS 1 WITH HEADER LINE,
        am_sel LIKE addr1_sel, am_address LIKE addr1_val,
        am_ucomm LIKE sy-ucomm, am_title LIKE sy-title.
  DATA: keytab TYPE TABLE OF vimty_textfield,
        keytab_wa TYPE vimty_textfield,
        am_key TYPE vimty_max_textline.
  DATA: am_index TYPE sy-tabix.           &quot;Note 1459423    PATIDARP
  FIELD-SYMBOLS: &lt;am_title&gt; TYPE c, &lt;am_key&gt; TYPE c,
                 &lt;am_handle_x&gt; TYPE x,
                 &lt;namtab&gt; TYPE vimnamtab,                   &quot;#EC NEEDED
                 &lt;keyfld&gt; TYPE ANY.                         &quot;#EC NEEDED

  IF x_header-adrnbrflag EQ space.
    MESSAGE e001(sv).
    EXIT.
  ENDIF.
  IF status-action NE anzeigen AND status-action NE transportieren AND
     adrnbr_roflag EQ space.
    MOVE svim_text_012 TO am_title.    &quot;Adresse bearbeiten
  ELSE.
    MOVE svim_text_017 TO am_title.    &quot;Adresse anzeigen
  ENDIF.
  am_pos = strlen( am_title ).
  am_length = 70 - am_pos.
  ASSIGN am_title+am_pos(am_length) TO &lt;am_title&gt;.
  MOVE &apos;:&apos; TO &lt;am_title&gt;.
  ADD 2 TO am_pos.
  SUBTRACT 2 FROM am_length.
  ASSIGN am_title+am_pos(am_length) TO &lt;am_title&gt;.
  CLEAR am_pos.
  PERFORM vim_external_repr_for_key TABLES keytab
                                    USING &lt;f1_x&gt;.
  LOOP AT keytab INTO keytab_wa.
    CONCATENATE am_key keytab_wa-text INTO am_key SEPARATED BY space.
    am_pos = am_pos + keytab_wa-outplen + 1.
    IF am_pos &gt; am_length. EXIT. ENDIF.
  ENDLOOP.
  IF sy-subrc = 0.
    ASSIGN am_key(am_pos) TO &lt;am_key&gt;.
*  IF x_header-clidep NE space.
*    am_length = x_header-keylen - client_length.
*    ASSIGN &lt;f1&gt;+client_length(am_length) TO &lt;am_key&gt;.
*  ELSE.
*    ASSIGN &lt;f1&gt; TO &lt;am_key&gt;.
*  ENDIF.
    MOVE &lt;am_key&gt; TO &lt;am_title&gt;.
  ENDIF.
  ASSIGN am_handletab-handle TO &lt;am_handle_x&gt; CASTING.
  IF x_header-adrnbrflag EQ &apos;O&apos;.       &quot;use old technique
* Übergangslösung Adressumstellung 3.0F Anfang
    IF &lt;address_number&gt; NE space.
      SELECT adrnr FROM sadr INTO sadr-adrnr
                             WHERE adrnr EQ &lt;address_number&gt;.
        EXIT.
      ENDSELECT.
      IF sy-subrc NE 0.
        CALL FUNCTION &apos;ADDR_CONVERT_ADRC_TO_SADR&apos;
          CHANGING
            address_number = &lt;address_number&gt;.
*     IF &lt;ADDRESS_NUMBER&gt; NE SPACE AND &quot;new address number -&gt; update
*        STATUS-ACTION NE ANZEIGEN AND STATUS-ACTION NE TRANSPORTIEREN.
*       &lt;STATUS&gt;-UPD_FLAG = &apos;X&apos;.
*     ENDIF.  &quot;not necessary, adrnbr will never be changed
      ENDIF.
    ENDIF.
* Übergangslösung Adressumstellung 3.0F Ende
    MOVE &lt;address_number&gt; TO sadr-adrnr.
    kz = space.
   IF status-action NE anzeigen AND status-action NE transportieren AND
             adrnbr_roflag EQ space.
      IF &lt;address_number&gt; EQ space.
        mode = &apos;A&apos;.
      ELSE.
        mode = &apos;M&apos;.
      ENDIF.
      IF status-action EQ kopieren.
        IF &lt;address_number&gt; NE space.
          SELECT * FROM sadr WHERE adrnr EQ &lt;address_number&gt;.
            kz = &apos;X&apos;.
            EXIT.
          ENDSELECT.
        ELSE.
          CLEAR sadr.
        ENDIF.
        CLEAR &lt;address_number&gt;.
        mode = &apos;A&apos;.
      ENDIF.
    ELSE.
      mode = &apos;D&apos;.
    ENDIF.
    func_name = &apos;ADDRESS_MAINTAIN&apos;. &quot;struggling against extended check
    DO.
      CALL FUNCTION func_name
        EXPORTING
          adrswa_in         = sadr
          processing_status = mode
          kennzeichen       = kz
          save_intern       = &apos;X&apos;
          title             = am_title
        IMPORTING
          adrswa_out        = sadr
          returncode        = return
          update_flag       = am_save
        EXCEPTIONS
          not_found         = 4.
      IF sy-subrc NE 0.
        IF status-action NE anzeigen AND
           status-action NE transportieren AND
           adrnbr_roflag EQ space.
          CALL FUNCTION &apos;POPUP_TO_CONFIRM_WITH_MESSAGE&apos;     &quot;#EC FB_OLDED
            EXPORTING
              diagnosetext1 = svim_text_013   &quot;Die Adresse für das
              diagnosetext2 = &lt;am_key&gt;
              diagnosetext3 = svim_text_014 &quot;wurde nicht gefunden.
              textline1     = svim_text_015&quot;Möchten Sie eine neue er
              titel         = svim_text_016&quot;Adresse nicht vorhanden
            IMPORTING
              answer        = answer.
          IF answer EQ &apos;J&apos;.
            mode = &apos;A&apos;.
          ELSE.
            return = 4.
            EXIT.
          ENDIF.
        ELSE.
          MESSAGE i055(sv) WITH &lt;am_key&gt;.
          return = 4.
          EXIT.
        ENDIF.
      ELSE.
        EXIT.
      ENDIF.
    ENDDO.
   IF status-action NE anzeigen AND status-action NE transportieren AND
             adrnbr_roflag EQ space.
      IF return NE 4 AND sadr-adrnr NE &lt;address_number&gt; OR
         am_save NE space. &quot;transport for address changes is requested
        MOVE: &apos;X&apos; TO &lt;status&gt;-upd_flag,
               sadr-adrnr TO &lt;address_number&gt;.
      ENDIF.
    ENDIF.
    CLEAR am_ucomm.
  ELSE. &quot;4.0: use new version of address maintenance
   IF status-action NE anzeigen AND status-action NE transportieren AND
             adrnbr_roflag EQ space.
      IF status-action EQ kopieren.
        IF &lt;address_number&gt; NE space.
          IF &lt;address_number&gt; NP &apos;@NEW*&apos;.
            am_sel-addrnumber = &lt;address_number&gt;.
          ELSE.
            am_sel-addrhandle = &lt;f1_x&gt;.
          ENDIF.
          CALL FUNCTION &apos;ADDR_GET&apos;
            EXPORTING
              address_selection = am_sel
            IMPORTING
              address_value     = am_address
            EXCEPTIONS
              parameter_error   = 1
              address_not_exist = 2
              version_not_exist = 3
              internal_error    = 4.
          IF sy-subrc EQ 0.
            MOVE-CORRESPONDING am_address TO am_handletab.&quot;#EC ENHOK
          ENDIF.
        ENDIF.
        CLEAR &lt;address_number&gt;.
        am_handletab-maint_mode = &apos;CREATE&apos;.
      ELSE.
        IF &lt;address_number&gt; EQ space.
          am_handletab-maint_mode = &apos;CREATE&apos;.
        ELSE.
          am_handletab-maint_mode = &apos;CHANGE&apos;.
        ENDIF.
      ENDIF.                           &quot;status-action eq kopieren.
    ELSE.
      IF &lt;address_number&gt; IS INITIAL.  &quot;no address assigned
        MESSAGE i055(sv) WITH &lt;am_key&gt;.
        EXIT.
      ENDIF.
      am_handletab-maint_mode = &apos;DISPLAY&apos;.
    ENDIF.
    IF am_handletab-maint_mode EQ &apos;CREATE&apos; OR
       &lt;address_number&gt; CP &apos;@NEW*&apos;.
      &lt;am_handle_x&gt;(x_header-keylen) = &lt;f1_x&gt;.
*      am_handletab-handle = &lt;f1&gt;.
    ELSE.
      CLEAR am_handletab-handle.
    ENDIF.
    IF &lt;address_number&gt; NP &apos;@NEW*&apos;.
      am_handletab-addrnumber = &lt;address_number&gt;.
    ELSE.
      CLEAR am_handletab-addrnumber.
    ENDIF.
    am_handletab-addr_group = vim_addr_group.
    APPEND am_handletab.
* individual preparation of address dialog requested?.....
    CLEAR: vim_addr_field_selection,
           vim_addr_keywords,
           vim_addr_chng_deflt_comm_types,
           vim_addr_frame_text,
           vim_addr_excluded_functions.
    REFRESH vim_addr_excluded_functions.
    vim_addr_titlebar = am_title.
    CLEAR vim_skip_adr_maint.                               &quot;UF120400
    IF x_header-frm_bf_adr NE space.   &quot;...yes
      PERFORM (x_header-frm_bf_adr) IN PROGRAM.
    ENDIF.
    CHECK vim_skip_adr_maint IS INITIAL.                    &quot;UF120400
    CALL FUNCTION &apos;ADDR_DIALOG_PREPARE&apos;
         EXPORTING
              field_selection           = vim_addr_field_selection
              keywords                  = vim_addr_keywords
*             TITLEBAR                  = AM_TITLE
              titlebar                  = vim_addr_titlebar
              change_default_comm_types = vim_addr_chng_deflt_comm_types
              frame_text                = vim_addr_frame_text
         TABLES
              excluded_functions        = vim_addr_excluded_functions
*             ERROR_TABLE               =
         EXCEPTIONS                                         &quot;#EC FB_RC
              internal_error            = 1
              OTHERS                    = 2.
    IF am_handletab-maint_mode EQ &apos;CHANGE&apos; AND
       am_handletab-addrnumber NE space.
      READ TABLE vim_locked_addresses FROM am_handletab-addrnumber
                                      TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.                &quot;not yet locked
        CALL FUNCTION &apos;ADDR_ENQUEUE&apos;
             EXPORTING
                  address_number    = am_handletab-addrnumber
*               MODE_ADRC         = &apos;E&apos;
*               _SCOPE            = &apos;2&apos;
*               _WAIT             = &apos; &apos;
*               _COLLECT          = &apos; &apos;
             EXCEPTIONS
                  address_not_exist = 1
                  foreign_lock      = 2
                  system_failure    = 3
                  internal_error    = 4.
        CASE sy-subrc.
          WHEN 0.
            INSERT am_handletab-addrnumber INTO TABLE
                                           vim_locked_addresses.
          WHEN 1.
            IF status-action NE anzeigen AND
               status-action NE transportieren AND
               adrnbr_roflag EQ space.
              CALL FUNCTION &apos;POPUP_TO_CONFIRM_WITH_MESSAGE&apos;
                EXPORTING
                  diagnosetext1 = svim_text_013&quot;Die Adresse für das Obj:
                  diagnosetext2 = &lt;am_key&gt;
                  diagnosetext3 = svim_text_014&quot;wurde nicht gefunden.
                  textline1     = svim_text_015&quot;Möchten Sie eine neue er
                  titel         = svim_text_016&quot;Adresse nicht vorhanden
                IMPORTING
                  answer        = answer.
              IF answer EQ &apos;J&apos;.
                am_handletab-maint_mode = &apos;CREATE&apos;.
                IF &lt;address_number&gt; NP &apos;@NEW*&apos;.
                  &lt;am_handle_x&gt;(x_header-keylen) = &lt;f1_x&gt;.
*                  am_handletab-handle = &lt;f1&gt;.
                  CLEAR am_handletab-addrnumber.
                ENDIF.
                MODIFY am_handletab INDEX 1.
              ELSE.
                EXIT.
              ENDIF.
            ELSE.
              MESSAGE i055(sv) WITH &lt;am_key&gt;.
              EXIT.
            ENDIF.
          WHEN 2.
            MESSAGE i049(sv) WITH sy-msgv1.
            am_handletab-maint_mode = &apos;DISPLAY&apos;.
          WHEN OTHERS.
            MESSAGE i050(sv) WITH &lt;am_key&gt;.
            am_handletab-maint_mode = &apos;DISPLAY&apos;.
        ENDCASE.
      ENDIF.                           &quot;not yet locked
    ENDIF. &quot;am_handletab-maint_mode eq &apos;CHANGE&apos; and no new address
    DO.
      CALL FUNCTION &apos;ADDR_DIALOG&apos;
           IMPORTING
                ok_code           = am_ucomm
           TABLES
                number_handle_tab = am_handletab
*             VALUES            =
           EXCEPTIONS
                address_not_exist = 1
                group_not_valid   = 2
                parameter_error   = 3
                internal_error    = 4.
      CASE sy-subrc.
        WHEN 0.
          READ TABLE am_handletab INDEX 1.
          EXIT.
        WHEN 1.
          IF status-action NE anzeigen AND
             status-action NE transportieren AND
             adrnbr_roflag EQ space.
            CALL FUNCTION &apos;POPUP_TO_CONFIRM_WITH_MESSAGE&apos;
              EXPORTING
                diagnosetext1 = svim_text_013 &quot;Die Adresse für das
                diagnosetext2 = &lt;am_key&gt;
                diagnosetext3 = svim_text_014&quot;wurde nicht gefunden.
                textline1     = svim_text_015&quot;Möchten Sie eine neue er
                titel         = svim_text_016&quot;Adresse nicht vorhanden
              IMPORTING
                answer        = answer.
            IF answer EQ &apos;J&apos;.
              READ TABLE am_handletab INDEX 1.
              am_handletab-maint_mode = &apos;CREATE&apos;.
              IF &lt;address_number&gt; NP &apos;@NEW*&apos;.
                &lt;am_handle_x&gt;(x_header-keylen) = &lt;f1_x&gt;.
*                am_handletab-handle = &lt;f1&gt;.
                CLEAR am_handletab-addrnumber.
              ENDIF.
              MODIFY am_handletab INDEX 1.
            ELSE.
              am_ucomm = &apos;CANC&apos;.
              EXIT.
            ENDIF.
          ELSE.
            MESSAGE i055(sv) WITH &lt;am_key&gt;.
            am_ucomm = &apos;CANC&apos;.
            EXIT.
          ENDIF.
        WHEN OTHERS.
          MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno WITH
                  sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          am_ucomm = &apos;CANC&apos;. EXIT.
      ENDCASE.
    ENDDO.
    IF am_handletab-maint_mode EQ &apos;CHANGE&apos; AND
       am_handletab-addrnumber NE space    AND
       ( am_ucomm EQ &apos;CANC&apos; OR am_handletab-updateflag EQ space ).
      READ TABLE vim_locked_addresses FROM am_handletab-addrnumber
                                      TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.                &quot;dequeue
       am_index = sy-tabix.                        &quot;Note 1459423 PATIDARP
        CALL FUNCTION &apos;ADDR_DEQUEUE&apos;
               EXPORTING
                 address_number    = am_handletab-addrnumber
*                MODE_ADRC         = &apos;E&apos;
*                _SCOPE            = &apos;3&apos;
*                _SYNCHRON         = &apos; &apos;
*                _COLLECT          = &apos; &apos;
               EXCEPTIONS                                   &quot;#EC FB_RC
                 address_not_exist = 1
                 internal_error    = 2.
*     Start of Note 1459423                         PATIDARP
        IF sy-subrc = 0.
          DELETE vim_locked_addresses INDEX am_index.
        ENDIF.
*    End of Note 1459423                            PATIDARP
      ENDIF.
    ENDIF.
   IF status-action NE anzeigen AND status-action NE transportieren AND
             adrnbr_roflag EQ space.
      IF am_ucomm NE &apos;CANC&apos;.
        IF am_handletab-maint_mode EQ &apos;CREATE&apos;.
          &lt;address_number&gt; = &apos;@NEW&apos;.
          &lt;address_number&gt;+4(6) = &lt;status&gt;-newadrcnt.
          ADD 1 TO &lt;status&gt;-newadrcnt.
          &lt;status&gt;-upd_flag = &apos;X&apos;.
        ENDIF.
        IF am_handletab-updateflag NE space. &quot;addr. itself is to be save
          READ TABLE vim_addresses_to_save
                              WITH KEY viewname = x_header-viewname
                                       addrnumber = &lt;address_number&gt;
                              BINARY SEARCH TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.
            vim_addresses_to_save-addrnumber = &lt;address_number&gt;.
            CLEAR vim_addresses_to_save-handle.
            &lt;vim_addr_handle_x&gt;(x_header-keylen) = &lt;f1_x&gt;.
*            vim_addresses_to_save-handle = &lt;f1&gt;.
            INSERT vim_addresses_to_save INDEX sy-tabix.
          ENDIF.
          IF vim_client_state EQ vim_log AND
             x_header-flag NE vim_transport_denied AND
             vim_actopts-transp_off NE bc_transport_denied.
            &lt;status&gt;-upd_flag = &apos;X&apos;. &quot;nec. for transport of master entry
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    CLEAR return.
  ENDIF.                               &quot;am_statetab-value eq space.
* IF STATUS-ACTION NE KOPIEREN AND STATUS-ACTION NE HINZUFUEGEN.
  IF status-action NE kopieren AND status-action NE hinzufuegen AND
     vim_single_entry_function NE &apos;INS&apos;.
    IF return NE 4 AND am_ucomm NE &apos;CANC&apos;.
      IF &lt;xmark&gt; EQ markiert.
        &lt;xmark&gt; = nicht_markiert.
        IF &lt;status&gt;-upd_flag EQ space.
          MODIFY extract INDEX exind.
          READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
          &lt;mark&gt; = nicht_markiert.
          MODIFY total INDEX sy-tabix.
        ENDIF.
        SUBTRACT: 1 FROM mark_extract,
                  1 FROM mark_total.
      ENDIF.
    ENDIF.
    CLEAR function.
  ENDIF.
ENDFORM.                    &quot;address_maintain</include_source>
   </include>
   <include NAME="LSVIMF25" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_ADDRESS_MAINTAIN                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM LISTE_ADDRESS_MAINTAIN.
  IF X_HEADER-ADRNBRFLAG EQ SPACE.
    MESSAGE E001(SV).
    EXIT.
  ENDIF.
  LOOP AT EXTRACT.
    CHECK &lt;XMARK&gt; EQ MARKIERT.
    MOVE SY-TABIX TO EXIND.
    PERFORM MOVE_EXTRACT_TO_VIEW_WA.
    PERFORM ADDRESS_MAINTAIN.
    PERFORM UPDATE_TAB.
  ENDLOOP.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF27" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM ENQUEUE                                                  *
*---------------------------------------------------------------------*
* enqueue view                                                        *
*---------------------------------------------------------------------*
* VALUE(E_ACT) --&gt; action: E -&gt; enqueue, D -&gt; dequeue                 *
* VALUE(EXIT_FORM) ---&gt; name of exit form to process after enqueue    *
*---------------------------------------------------------------------*
FORM enqueue USING value(e_act) value(exit_form).
*----------------------------------------------------------------------*
*      enqueue view
*----------------------------------------------------------------------*
  CALL FUNCTION &apos;VIEW_ENQUEUE&apos;
       EXPORTING
            view_name        = vim_view_name
            action           = e_act
            enqueue_mode     = &apos;E&apos;
            enqueue_range    = vim_enqueue_range
       TABLES
            sellist          = &lt;vim_sellist&gt;
    EXCEPTIONS                                              &quot;#EC FB_RC
            foreign_lock     = 1
            system_failure   = 2
            table_not_found  = 5
            client_reference = 7.

  DATA: rc LIKE sy-subrc.

  CASE sy-subrc.
    WHEN 1.
      MESSAGE i049(sv) WITH sy-msgv1.
      sy-subrc = 1.
    WHEN 2.
      MESSAGE a050(sv) WITH view_name.
    WHEN 3.
      MESSAGE a037(sv) WITH view_name.
    WHEN 5.
      MESSAGE a028(sv) WITH view_name.
    WHEN 7.
      MESSAGE w054(sv) WITH sy-mandt.
      sy-subrc = 7.
  ENDCASE.
  rc = sy-subrc.
  IF exit_form NE space.
    PERFORM (exit_form) IN PROGRAM (sy-repid).
  ENDIF.
  IF e_act EQ &apos;E&apos;.
    IF sy-subrc &lt;&gt; 0.
      vim_enq_s_u_rc = sy-subrc.
    ELSEIF rc &lt;&gt; 0.
      vim_enq_s_u_rc = rc.
    ELSE.
      vim_enq_s_u_rc = 0.
    ENDIF.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF28" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM X_ENQUEUE                                                *
*---------------------------------------------------------------------*
* enqueue view (external call)                                        *
*---------------------------------------------------------------------*
* XE_SELLIST       ---&gt; table of selection conditions for view/table  *
* VALUE(XE_NAME)   ---&gt; name of view/table to process                 *
* VALUE(XE_ACT)    ---&gt; action: E -&gt; enqueue, D -&gt; dequeue            *
* VALUE(EXIT_FORM) ---&gt; name of exit form to process after enqueue    *
* VALUE(XE_ENQRNG) ---&gt; flag: X -&gt; enqueue range, &apos; &apos; -&gt; full table   *
*---------------------------------------------------------------------*
FORM X_ENQUEUE TABLES XE_SELLIST STRUCTURE VIMSELLIST
               USING VALUE(XE_NAME) VALUE(XE_ACT) VALUE(EXIT_FORM)
                     VALUE(XE_ENQRNG).
  DATA: VIEWNAME_SAFE LIKE VIMDESC-VIEWNAME, ENQ_RANGE_SAFE(1) TYPE C.

  VIEWNAME_SAFE = VIM_VIEW_NAME. ENQ_RANGE_SAFE = VIM_ENQUEUE_RANGE.
  VIM_VIEW_NAME = XE_NAME. VIM_ENQUEUE_RANGE = XE_ENQRNG.
  ASSIGN XE_SELLIST-*SYS* TO &lt;VIM_SELLIST&gt;.
  PERFORM ENQUEUE USING XE_ACT EXIT_FORM.
  VIM_VIEW_NAME = VIEWNAME_SAFE. VIM_ENQUEUE_RANGE = ENQ_RANGE_SAFE.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF29" SQLX="X" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="E" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF29 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_MULTI_LANGU_TEXT_ALS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM VIM_MULTI_LANGU_TEXT_ALS .

  DATA: sel_langus TYPE ALS_T002,
        texttab_for_output TYPE vimty_multilangu_texttab,
        lb_als TYPE REF TO IF_EX_VIM_ALS_BADI,
        curr_sptxt LIKE t002t-sptxt,
        maint_mode(1) TYPE c,                            &quot;#EC NEEDED
        textmodif(1) TYPE c,                             &quot;#EC NEEDED
        f_called_by_viewmaint TYPE c,                    &quot;#EC NEEDED
        als_text TYPE vimty_max_textline,
        wa1_texttab_for_output LIKE LINE OF texttab_for_output,
        wa2_texttab_for_output LIKE LINE OF texttab_for_output,
        wa1_texttab TYPE vimty_textfield,
        wa2_texttab TYPE vimty_textfield,
        index TYPE sy-tabix.


  CALL METHOD cl_exithandler=&gt;get_instance
    EXPORTING
      null_instance_accepted        = seex_false
      exit_name                     = &apos;VIM_ALS_BADI&apos;
    CHANGING
      instance                      = lb_als
    EXCEPTIONS
      no_reference                  = 1
      no_interface_reference        = 2
      no_exit_interface             = 3
      class_not_implement_interface = 4
      single_exit_multiply_active   = 5
      cast_error                    = 6
      exit_not_existing             = 7
      data_incons_in_exit_managem   = 8
      OTHERS                        = 9.
  IF sy-subrc NE 0.
    EXIT.
  ELSE.
    IF als_active &lt;&gt; &apos;X&apos; AND als_langus_selected &lt;&gt; &apos;X&apos;.
      CALL METHOD lb_als-&gt;get_als_languages
        EXPORTING
          view_name  = x_header-viewname
        IMPORTING
          als_active = als_active
        CHANGING
          als_langus = sel_langus.
      als_langus_selected = &apos;X&apos;.
      als_sel_langus[] = sel_langus[].
    ENDIF.

    sel_langus[] = als_sel_langus[].
    CALL FUNCTION &apos;VIEW_SET_ALS_LANGUAGES&apos;
      IMPORTING
        curr_sptxt = curr_sptxt
      TABLES
        languages  = sel_langus.

    PERFORM vim_read_texttab_for_langus TABLES sel_langus USING &apos; &apos;.
    REFRESH texttab_for_output.
    PERFORM vim_fill_texttab_for_als TABLES sel_langus
                                       USING curr_sptxt
                                       CHANGING texttab_for_output.

    CLEAR als_text.
    CLEAR index.

    LOOP AT texttab_for_output INTO wa1_texttab_for_output.
      IF sy-tabix EQ 1.
        LOOP AT wa1_texttab_for_output-texttab INTO wa1_texttab.
          index = sy-tabix.
          als_text = wa1_texttab-text.
          LOOP AT texttab_for_output INTO wa2_texttab_for_output.
            IF sy-tabix EQ 1.
              wa2_texttab_for_output-ACTION = &apos;X&apos;.
              MODIFY texttab_for_output FROM wa2_texttab_for_output.
            ELSE.
              LOOP AT wa2_texttab_for_output-texttab INTO wa2_texttab.
                IF sy-tabix = index.
                  wa2_texttab-text = als_text.
                 MODIFY wa2_texttab_for_output-texttab FROM wa2_texttab.
                  MODIFY texttab_for_output FROM wa2_texttab_for_output.
                ENDIF.
              ENDLOOP.
            ENDIF.
          ENDLOOP.
        ENDLOOP.
      ENDIF.
    ENDLOOP.

    PERFORM als_update_texttab USING texttab_for_output.
    MODIFY vim_texttab_container INDEX vim_texttab_container_index.
  ENDIF.


ENDFORM.                    &quot; VIM_MULTI_LANGU_TEXT_ALS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_fill_texttab_for_als
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_SEL_LANGUS  text
*      --&gt;P_CURR_SPTXT  text
*      &lt;--P_TEXTTAB_FOR_OUTPUT  text
*----------------------------------------------------------------------*
FORM vim_fill_texttab_for_als TABLES sel_langus STRUCTURE h_t002
               USING curr_sptxt LIKE t002t-sptxt
               CHANGING texttab_for_maint TYPE vimty_multilangu_texttab.
  DATA: textmaint_record TYPE vimty_textmaint_record,
        textmaint_field TYPE vimty_textfield,
        align1 TYPE f,                                                 &quot;#EC NEEDED
        texttab_wa TYPE vim_line_ul,
        align2 TYPE f,                                                 &quot;#EC NEEDED
        tmp_wa TYPE tabl8000,
        condense(1) TYPE c,                                            &quot;#EC NEEDED
        texttab_tabix LIKE sy-tabix,
        extract_index LIKE sy-tabix,                                   &quot;#EC NEEDED
        keylen TYPE i,
        rc LIKE sy-subrc,
        keys_identical TYPE xfeld.
  DATA: primkeylen TYPE i.
  FIELD-SYMBOLS: &lt;extract_key&gt; TYPE x,
                 &lt;next_spras&gt; TYPE spras,
                 &lt;text_rec_key&gt; TYPE x, &lt;h_texttab_wa&gt; TYPE x,
                 &lt;viewkey_in_texttab&gt; TYPE x, &lt;txtfld&gt; TYPE ANY,
                 &lt;h_tmp&gt; TYPE x, &lt;tmp_struc&gt; TYPE ANY,
                 &lt;h_texttab&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY.
  FIELD-SYMBOLS: &lt;extract_primkey&gt; TYPE x.

  ASSIGN &lt;f1_x&gt; TO &lt;extract_key&gt;.
  keylen = x_header-after_keyc.
  keylen = x_header-keylen.

* In case of viewkey &gt; primtabkey -&gt; additional key fields are filled
* in &lt;extract_key&gt; but not existent in &lt;vim_texttab&gt; &quot;HCG 09/02/2005
*  primkeylen = x_header-textkeylen - cl_abap_char_utilities=&gt;charsize.
  IF x_header-bastab EQ space.                              &quot;IG 875536
    CLEAR keys_identical.
    PERFORM vim_comp_roottabkey USING x_header
                                      x_namtab[]
                             CHANGING keys_identical
                                      rc.
    IF keys_identical EQ space.
      primkeylen = keylen.
    ELSE.
      clear primkeylen.
      LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
                           bastabname = x_header-roottab.
        IF x_namtab-DATATYPE NE &apos;DATS&apos;.
          primkeylen = primkeylen + x_namtab-FLENGTH.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ELSE.
    primkeylen = x_header-keylen.
  ENDIF.                                                    &quot;IG 875536
  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(primkeylen) TO &lt;viewkey_in_texttab&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen) TO &lt;h_texttab&gt;,
          tmp_wa+keylen(x_header-texttablen)
           TO &lt;h_tmp&gt;,
          &lt;h_texttab&gt; TO &lt;texttab_struc&gt;
           CASTING TYPE (x_header-texttab),
          &lt;h_tmp&gt; TO &lt;tmp_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
           TO &lt;next_spras&gt;,
           textmaint_record-keys TO &lt;text_rec_key&gt; CASTING.

  CLEAR textmaint_record.
  &lt;text_rec_key&gt; = &lt;extract_key&gt;.
  PERFORM vim_external_repr_for_key TABLES textmaint_record-keytab
                                    USING &lt;vim_xextract_key&gt;.
  textmaint_record-spras = sy-langu.
  textmaint_record-sptxt = curr_sptxt.
  IF x_header-bastab = space.
* view
    LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
      textmaint_field-namtab_idx = sy-tabix.
      textmaint_field-outplen = x_namtab-flength.
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
       &lt;table1&gt; TO &lt;txtfld&gt;.
      textmaint_field-text = &lt;txtfld&gt;.
      APPEND textmaint_field TO textmaint_record-texttab.
    ENDLOOP.
  ELSE.
* tab + texttab
    LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
      textmaint_field-namtab_idx = sy-tabix.
      textmaint_field-outplen = x_namtab-flength.
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
       &lt;table1_text&gt; TO &lt;txtfld&gt;.
      textmaint_field-text = &lt;txtfld&gt;.
      APPEND textmaint_field TO textmaint_record-texttab.
    ENDLOOP.
  ENDIF.
  APPEND textmaint_record TO texttab_for_maint.

*   Texte in ausgewählten Sprachen
************************************************************************
  CLEAR: &lt;viewkey_in_texttab&gt;, &lt;texttab_struc&gt;.
*    CLEAR texttab_wa.
*   In case of viewkey &gt; primtabkey -&gt; additional key fields are filled
*   in &lt;extract_key&gt; but not existent in &lt;vim_texttab&gt;  &quot;HCG 09/02/2005
  ASSIGN &lt;extract_key&gt;(primkeylen) TO &lt;extract_primkey&gt;.
  READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;extract_primkey&gt;     &quot;#EC WARNOK
                             INTO texttab_wa. &quot; BINARY SEARCH.
  texttab_tabix = sy-tabix.
  LOOP AT sel_langus.
    CLEAR textmaint_record.
    &lt;text_rec_key&gt; = &lt;extract_key&gt;.
    textmaint_record-spras = sel_langus-spras.
    textmaint_record-sptxt = sel_langus-sptxt.
    textmaint_record-action = &apos;X&apos;.

    IF &lt;viewkey_in_texttab&gt; = &lt;extract_primkey&gt; AND         &quot;817790
       &lt;next_spras&gt; &lt; sel_langus-spras.                   &quot;#EC PORTABLE
      LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
        IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_primkey&gt; OR     &quot;817790
           &lt;next_spras&gt; &gt;= sel_langus-spras.              &quot;#EC PORTABLE
          texttab_tabix = sy-tabix.
          EXIT.
        ENDIF.
      ENDLOOP.
    ENDIF.   &quot; &lt;next_spras&gt; &gt;= sel_langus-spras oder ex. nicht
    IF &lt;next_spras&gt; &lt;&gt; sel_langus-spras OR
        &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_primkey&gt;.&quot;langu:text not ex
      CLEAR &lt;tmp_struc&gt;.
    ELSE.
      tmp_wa = &lt;h_texttab_wa&gt;.
    ENDIF.
    LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
      textmaint_field-namtab_idx = sy-tabix.
      textmaint_field-outplen = x_namtab-flength.
      ASSIGN COMPONENT x_namtab-bastabfld OF STRUCTURE     &quot;HCG wrong
       &lt;tmp_struc&gt; TO &lt;txtfld&gt;.   &quot;HCG for txtfldname in view differs
      textmaint_field-text = &lt;txtfld&gt;.
      APPEND textmaint_field TO textmaint_record-texttab.
    ENDLOOP.
    APPEND textmaint_record TO texttab_for_maint.
  ENDLOOP.                           &quot; SEL_LANGUS

ENDFORM.                    &quot; vim_fill_texttab_for_als
*&amp;---------------------------------------------------------------------*
*&amp;      Form  set_als_update_flag
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM set_als_update_flag .

  DATA: als_flag(1) TYPE c.
  FIELD-SYMBOLS: &lt;h1&gt;,
                 &lt;h2&gt;.
  CLEAR als_flag.
  LOOP AT x_namtab WHERE keyflag EQ space
      AND bastabname EQ x_header-texttab.
    assign component x_namtab-viewfield of structure &lt;table1&gt; to &lt;h1&gt;.
    assign component x_namtab-viewfield of structure
                     &lt;vim_extract_struc&gt; to &lt;h2&gt;.
    IF &lt;h1&gt; NE &lt;h2&gt;.
      als_flag =&apos;X&apos;.
    ENDIF.
  ENDLOOP.

  IF als_flag EQ &apos;X&apos;.
    PERFORM VIM_MULTI_LANGU_TEXT_ALS.
  ENDIF.

ENDFORM.                    &quot; set_als_update_flag
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALS_UPDATE_TEXTTAB
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM als_update_texttab
                USING texttab_for_maint TYPE vimty_multilangu_texttab.
  DATA: textmaint_record TYPE vimty_textmaint_record,
        textmaint_field TYPE vimty_textfield,
        align TYPE f,                                       &quot;#EC NEEDED
        texttab_wa TYPE vim_line_ul,
        search_key TYPE tabl8000,
        offset LIKE sy-fdpos,
        keylen LIKE sy-fdpos,
        extract_index LIKE sy-tabix,                     &quot;#EC NEEDED
        total_index   LIKE sy-tabix,                             &quot;#EC NEEDED
        texttab_tabix LIKE sy-tabix,
        new_entry(1)  TYPE c,
        keylen_char TYPE i,
        primkeylen type i,                                  &quot;817790
        rc LIKE sy-subrc,                                   &quot;875536
        keys_identical TYPE xfeld.
  FIELD-SYMBOLS:
        &lt;search_key&gt; TYPE x, &lt;rec_key&gt; TYPE x, &lt;curr_spras&gt; TYPE ANY,
        &lt;h_texttab_wa&gt; TYPE x,
        &lt;viewkey_in_texttab&gt; TYPE x, &quot;Key aus View/Tab in Texttab
        &lt;texttab_key&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY,
        &lt;h_texttab&gt; TYPE x, &lt;tot_fld&gt; TYPE ANY, &lt;ext_fld&gt; TYPE ANY,    &quot;#EC NEEDED
        &lt;texttab_action&gt; TYPE c,
        &lt;t_action&gt;, &lt;e_action&gt;,
        &lt;search_txtkey&gt; type x.                             &quot;817790

  IF x_header-delmdtflag &lt;&gt; space AND     &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.          &quot;      -&gt; zeitunabh. Texttab.
    keylen = x_header-after_keyc
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    keylen = x_header-after_keyc.
  ENDIF.
  keylen_char = keylen / cl_abap_char_utilities=&gt;charsize.
  IF x_header-bastab EQ space.                              &quot;IG 875536
    CLEAR keys_identical.
    PERFORM vim_comp_roottabkey USING x_header
                                      x_namtab[]
                             CHANGING keys_identical
                                      rc.
    IF keys_identical EQ space.
      primkeylen = keylen.
    ELSE.
      clear primkeylen.
      LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
                           bastabname = x_header-roottab.
        IF x_namtab-DATATYPE NE &apos;DATS&apos;.
          primkeylen = primkeylen + x_namtab-FLENGTH.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ELSE.
    primkeylen = x_header-keylen.
  ENDIF.                                                    &quot;IG 875536

  ASSIGN: search_key(keylen) TO &lt;search_key&gt;,
          textmaint_record-keys(keylen_char) TO &lt;rec_key&gt; CASTING,
          texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(keylen) TO &lt;viewkey_in_texttab&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-textkeylen) TO &lt;texttab_key&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen) TO &lt;h_texttab&gt;,
          &lt;h_texttab&gt; TO &lt;texttab_struc&gt;
           CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
           TO &lt;curr_spras&gt;.
  ASSIGN: search_key(primkeylen) TO &lt;search_txtkey&gt;.        &quot;817790

  offset = keylen + x_header-aft_txttbc.
  ASSIGN &lt;h_texttab_wa&gt;+offset(cl_abap_char_utilities=&gt;charsize)
   TO &lt;texttab_action&gt; CASTING.
  IF x_header-bastab = &apos;X&apos;.
* tab+texttab
    ASSIGN &lt;action_text&gt; TO &lt;t_action&gt;.
    ASSIGN &lt;xact_text&gt; TO &lt;e_action&gt;.
  ELSE.
    ASSIGN &lt;action&gt; TO &lt;t_action&gt;.
    ASSIGN &lt;xact&gt; TO &lt;e_action&gt;.
  ENDIF.

  LOOP AT texttab_for_maint INTO textmaint_record.
    IF textmaint_record-spras = sy-langu.
      &lt;search_key&gt; = &lt;rec_key&gt;.
      READ TABLE extract WITH KEY &lt;search_key&gt; BINARY SEARCH.&quot;#EC WARNOK
      extract_index = sy-tabix.
    ENDIF.
    CHECK textmaint_record-action = &apos;X&apos;.      &quot; Texte wurden modifiziert

    IF textmaint_record-spras = sy-langu.
      READ TABLE total WITH KEY &lt;search_key&gt; BINARY SEARCH. &quot;#EC WARNOK
      total_index = sy-tabix.
      IF x_header-bastab = &apos;X&apos;
       AND &lt;vim_xextract_text&gt; = &lt;text_initial_x&gt;.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                sy-langu
                                                &lt;vim_xtotal&gt;
                                          CHANGING &lt;vim_xextract_text&gt;.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                sy-langu
                                                &lt;vim_xtotal&gt;
                                          CHANGING &lt;vim_xtotal_text&gt;.

        &lt;e_action&gt; = neuer_eintrag.
        &lt;t_action&gt; = neuer_eintrag.
      ELSEIF &lt;e_action&gt; = original.
        &lt;e_action&gt; = aendern.
        &lt;t_action&gt; = aendern.
*     Else.                     &quot; neuer_eintrag / aendern =&gt; ok
      ENDIF.

    ELSE.
* different language: Update in texttable
      CLEAR: &lt;h_texttab_wa&gt;, &lt;texttab_struc&gt;.
      READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;search_txtkey&gt;      &quot;#EC WARNOK
                               INTO texttab_wa BINARY SEARCH.&quot;817790

      texttab_tabix = sy-tabix.
      IF &lt;viewkey_in_texttab&gt;(primkeylen) = &lt;search_txtkey&gt; AND&quot;817790
         &lt;curr_spras&gt; &lt; textmaint_record-spras.
        LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
        IF &lt;viewkey_in_texttab&gt;(primkeylen) &lt;&gt; &lt;search_txtkey&gt; OR&quot;817790
             &lt;curr_spras&gt; &gt;= textmaint_record-spras.
            texttab_tabix = sy-tabix.
            EXIT.
* Condition redundant - Internal Message 0001699060 - ACHACHADI
*          ELSEIF &lt;curr_spras&gt; &lt; textmaint_record-spras.                     &quot;#EC BOOL_OK
           ELSE.
            texttab_tabix = sy-tabix + 1.
          ENDIF.
        ENDLOOP.
      ENDIF.   &quot; &lt;next_spras&gt; &gt;= sel_langus-spras oder ex. nicht
      IF &lt;viewkey_in_texttab&gt;(primkeylen) &lt;&gt; &lt;search_txtkey&gt; OR &quot;817790
        &lt;curr_spras&gt; &lt;&gt; textmaint_record-spras.
        CLEAR: &lt;texttab_struc&gt;.
        new_entry = &apos;X&apos;.
        &lt;viewkey_in_texttab&gt; = &lt;search_key&gt;.
        &lt;texttab_action&gt; = neuer_eintrag.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                textmaint_record-spras
                                                &lt;viewkey_in_texttab&gt;
                                          CHANGING &lt;texttab_key&gt;.
      ELSE.
        CLEAR new_entry.
      ENDIF.
*     Text-Values übernehmen
      LOOP AT textmaint_record-texttab INTO textmaint_field.
        READ TABLE x_namtab INDEX textmaint_field-namtab_idx.
        IF x_namtab-lowercase = space.
          TRANSLATE textmaint_field-text TO UPPER CASE.
        ENDIF.
        IF x_header-bastab = &apos;X&apos;.&quot;HCG Custmessage 282684/02------------
* tab + texttab
          ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;texttab_struc&gt; TO &lt;ext_fld&gt;. &quot;XB int.40684/02
        ELSE.
* view, basis table field name.
          ASSIGN: COMPONENT x_namtab-bastabfld OF STRUCTURE
                   &lt;texttab_struc&gt; TO &lt;ext_fld&gt;. &quot;XB int.. 40684
        ENDIF.
        &lt;ext_fld&gt; = textmaint_field-text.
      ENDLOOP.
      IF &lt;texttab_action&gt; = original.
        &lt;texttab_action&gt; = aendern.
      ENDIF.
      IF new_entry = &apos;X&apos;.
        INSERT texttab_wa INTO &lt;vim_texttab&gt; INDEX texttab_tabix.
      ELSE.
        MODIFY &lt;vim_texttab&gt; FROM texttab_wa INDEX texttab_tabix.
      ENDIF.

    ENDIF.                             &quot; Sy-Langu
  ENDLOOP.                             &quot; TEXTTAB_FOR_MAINT


ENDFORM.                    &quot; ALS_UPDATE_TEXTTAB</include_source>
   </include>
   <include NAME="LSVIMF2A" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM COMPLETE_SUBSETFIELDS                                    *
*---------------------------------------------------------------------*
*  fill subset comment fields in view-wa from *view-wa (detail screen)*
*---------------------------------------------------------------------*
FORM complete_subsetfields.

  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab.

  LOOP AT x_namtab ASSIGNING &lt;namtab&gt;
   WHERE readonly EQ subset AND keyflag EQ space.
    ASSIGN: COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;initial&gt;
             TO &lt;value&gt;,
            COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;subsetfield&gt;.
*    ASSIGN &lt;INITIAL&gt;+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH)
*           TO &lt;VALUE&gt;.
*    ASSIGN &lt;TABLE1&gt;+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH)
*           TO &lt;SUBSETFIELD&gt;.
    MOVE &lt;value&gt; TO &lt;subsetfield&gt;.
  ENDLOOP.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2B" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM COMPLETE_EXPROFIELDS                                     *
*---------------------------------------------------------------------*
*  fill read only fields of referenced tables (exp ro tables)         *
*---------------------------------------------------------------------*
FORM COMPLETE_EXPROFIELDS.
  IF X_HEADER-FRM_RP_CPL NE SPACE.
    PERFORM (X_HEADER-FRM_RP_CPL) IN PROGRAM.
  ELSE.
    PERFORM (COMPL_FORMNAME) IN PROGRAM (SY-REPID) USING &lt;TABLE1&gt;
                                 IF FOUND.
  ENDIF.
  IF VIM_CALLED_BY_CLUSTER NE SPACE.
    CALL FUNCTION &apos;VIEWCLUSTER_COMPL_SUBSET_VALUE&apos;
         EXPORTING
              VIEW_NAME = X_HEADER-VIEWNAME
         CHANGING
              WORKAREA  = &lt;TABLE1&gt;.
  ENDIF.
ENDFORM.                               &quot;complete_exprofields</include_source>
   </include>
   <include NAME="LSVIMF2C" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM FILL_SUBSETFIELDS                                        *
*---------------------------------------------------------------------*
*  fill subset fields in *view-wa                                     *
*---------------------------------------------------------------------*
FORM FILL_SUBSETFIELDS.
  DATA: progname LIKE sy-repid.
  IF &lt;STATUS&gt;-SBSID_RCVD CO &apos; R&apos;.
    progname = sy-repid.
    PERFORM INIT_SUBSET_FCTFIELDS USING COMPL_FORMNAME progname.
    TRANSLATE &lt;STATUS&gt;-SBSID_RCVD USING &apos; XRS&apos;.
  ELSE.
    IF MAXLINES EQ 0 OR VIM_CALLED_BY_CLUSTER NE SPACE.
      MOVE &lt;INITIAL&gt; TO &lt;TABLE1&gt;.
    ENDIF.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2D" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM INIT_SUBSET_FCTFIELDS                                    *
*---------------------------------------------------------------------*
* init subset fields which are not keyfields                          *
*---------------------------------------------------------------------*
* FORMNAME --&gt; name of FORM to get view work area filled with current *
*              subset field values                                    *
* PROGNAME --&gt; program of FORM &apos;FORMNAME&apos;                             *
*---------------------------------------------------------------------*
FORM init_subset_fctfields USING value(formname) value(progname).

  DATA: alr_read TYPE c.

  LOOP AT x_namtab WHERE readonly EQ subset AND keyflag EQ space.
    ASSIGN component x_namtab-viewfield of structure &lt;initial&gt;
           TO &lt;subsetfield&gt;.
    ASSIGN component x_namtab-viewfield of structure &lt;table1&gt;
           TO &lt;value&gt;.
    IF alr_read EQ space.
      MOVE &lt;initial&gt; TO &lt;table1&gt;.
      IF x_header-clidep NE space.
        MOVE sy-mandt TO &lt;client&gt;.
      ENDIF.
      IF x_header-frm_rp_cpl NE space.   &quot;event AD
        PERFORM (x_header-frm_rp_cpl) IN PROGRAM (sy-repid).
      ELSEIF formname NE compl_formname OR progname NE sy-repid.
        PERFORM (formname) IN PROGRAM (progname) USING &lt;table1&gt;.
      ELSEIF maxlines EQ 0.
        PERFORM (compl_formname) IN PROGRAM (sy-repid) USING &lt;table1&gt;
                                 IF FOUND.
      ELSE.
        READ TABLE extract INDEX 1.
        MOVE &lt;vim_extract_struc&gt; TO &lt;table1&gt;.
      ENDIF.
      IF vim_called_by_cluster NE space.
        CALL FUNCTION &apos;VIEWCLUSTER_COMPL_SUBSET_VALUE&apos;
             EXPORTING
                  view_name = x_header-viewname
             CHANGING
                  workarea  = &lt;table1&gt;.
      ENDIF.
      MOVE &apos;X&apos; TO  alr_read.
    ENDIF.
    MOVE &lt;value&gt; TO &lt;subsetfield&gt;.
  ENDLOOP.
  IF sy-subrc NE 0 AND maxlines EQ 0.
    MOVE &lt;initial&gt; TO &lt;table1&gt;.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2E" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM INIT_SUBSET_KEYFIELDS                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM init_subset_keyfields.
  DATA: all_flds_blank TYPE c VALUE &apos;X&apos;, state_init TYPE c.
  FIELD-SYMBOLS: &lt;key&gt; type x.
  ASSIGN &lt;initial_x&gt;(x_header-keylen) TO &lt;key&gt;.
  clear &lt;table1_wa&gt;.
  MOVE &lt;key&gt; TO &lt;f1_wax&gt;.
  IF &lt;status&gt;-sbsid_rcvd NE space.
    CALL FUNCTION &apos;VIEW_INIT_SUBST_KEYFLDS&apos;
         EXPORTING
              visk_tabname         = x_header-maintview
              workarea_in          = &lt;initial&gt;
         IMPORTING
              workarea_out         = &lt;initial&gt;
              all_fields_blank     = all_flds_blank
              state_init_necessary = state_init
         TABLES
              sellist              = dba_sellist
              x_namtab             = x_namtab.
  ELSE.
    CALL FUNCTION &apos;VIEW_INIT_SUBST_KEYFLDS&apos;
         EXPORTING
              visk_tabname         = x_header-maintview
              workarea_in          = &lt;initial&gt;
         IMPORTING
              workarea_out         = &lt;initial&gt;
              all_fields_blank     = all_flds_blank
              state_init_necessary = state_init
         TABLES
              sellist              = dpl_sellist
              x_namtab             = x_namtab.
    IF all_flds_blank NE space.
      RAISE no_value_for_subset_ident.
    ENDIF.
    IF &lt;key&gt; NE &lt;f1_wax&gt;.
      MOVE &apos;X&apos; TO state_init.
    ELSE.  &quot;nicht-Key Subsetfelder, für die in ZP19 Keyflag gesetzt
      LOOP AT x_namtab where keyflag  &lt;&gt; SPACE  AND
                             readonly =  subset AND
                             position &gt;= x_header-keylen.
        MOVE &apos;X&apos; TO state_init. EXIT.
      ENDLOOP.
    ENDIF.
    IF state_init NE space.
      CLEAR: &lt;status&gt;-maxlines,
             &lt;status&gt;-cur_field,
             &lt;status&gt;-cur_offset.
      MOVE: 1 TO &lt;status&gt;-cur_line,
            1 TO &lt;status&gt;-firstline,
            maint_mode TO &lt;status&gt;-st_action,
            nicht_geloescht TO &lt;status&gt;-st_delete,
            list_bild TO &lt;status&gt;-st_mode.
      PERFORM set_status_nokeyselcnds.
    ELSE.
* further selection criteria?
      LOOP AT dpl_sellist TRANSPORTING NO FIELDS
                          WHERE ddic EQ space OR ( operator EQ &apos;GE&apos; OR
                                                   operator EQ &apos;GT&apos; OR
                                                   operator EQ &apos;LE&apos; OR
                                                   operator EQ &apos;LT&apos; ).
        EXIT.
      ENDLOOP.
      IF sy-subrc &lt;&gt; 0 and &lt;status&gt;-maxlines &lt;&gt; 0.
        &lt;status&gt;-selcd_rcvd = &apos;X&apos;.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2F" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM MODIFY_TABLES                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  VALUE(TAB_INDEX)                                              *
*---------------------------------------------------------------------*
FORM modify_tables USING value(tab_index).
  CLEAR &lt;status&gt;-upd_flag.
  IF &lt;xmark&gt; EQ markiert.
    SUBTRACT: 1 FROM &lt;status&gt;-mk_xt,
              1 FROM &lt;status&gt;-mk_to.
  ENDIF.
  READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
  MOVE &lt;table1&gt; TO &lt;vim_extract_struc&gt;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    MOVE: &lt;table1_xtext&gt; TO &lt;vim_xextract_text&gt;,
          original TO &lt;xact_text&gt;.
  ENDIF.
  &lt;xmark&gt; = nicht_markiert.
  &lt;xact&gt; = original.
  IF tab_index NE 0.
    MODIFY extract INDEX tab_index.
  ENDIF.
  total = extract.
  MODIFY total INDEX sy-tabix.
  IF x_header-frm_on_org NE space.
    PERFORM (x_header-frm_on_org) IN PROGRAM (sy-repid).
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2G" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_DYNAMIC_SELECT_OPTIONS                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM check_dynamic_select_options.
  DATA: total_ix TYPE i VALUE &apos;2&apos;, flag.                    &quot;#EC STR_NUM
                                                            &quot;#EC TYPES_MISS
  DATA: cdso_sellist LIKE vimsellist OCCURS 10,
        oc_to_be_checked TYPE xfeld,
        keyvalues TYPE occheckkeyflds,
        activity TYPE xuval.
  FIELD-SYMBOLS: &lt;vim_tot_txt_struc_loc&gt; TYPE ANY.

  IF x_header-delmdtflag NE space.
    PERFORM build_mainkey_tab_0.
  ENDIF.
  IF x_header-subsetflag NE space.
    MOVE &apos;R&apos; TO &lt;status&gt;-sbsid_rcvd.
    LOOP AT dba_sellist WHERE ddic CO vim_subset_marks
                          AND value EQ space
                          AND initial EQ space.
      CLEAR &lt;status&gt;-sbsid_rcvd. EXIT.
    ENDLOOP.
  ENDIF.
  READ TABLE total INDEX 1.
  IF sy-subrc NE 0.
    EXIT.
  ENDIF.
  IF NOT vim_oc_inst IS INITIAL.
* check authorisation for lines: only for conditions from authorisation
* which could not be included into dba_sellist
    CALL METHOD vim_oc_inst-&gt;get_to_be_checked
      IMPORTING
        to_be_checked = oc_to_be_checked.
    IF oc_to_be_checked &lt;&gt; space.
      IF &lt;status&gt;-st_action = anzeigen.
        activity = svorg_read.
      ELSE.
        activity = svorg_maint.
      ENDIF.
      LOOP AT total.
        CALL METHOD vim_oc_inst-&gt;build_key_value_tab
          EXPORTING
            entry     = total
          IMPORTING
            keyvalues = keyvalues.
        CALL METHOD vim_oc_inst-&gt;check_oc_authority
          EXPORTING
            activity        = activity
          CHANGING
            key_values      = keyvalues
           EXCEPTIONS
             no_auth         = 1
             key_incomplete  = 2
*          WRONG_PARAMETER = 3
             OTHERS          = 4.
        IF sy-subrc = 1.
          DELETE total.
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                  WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.
  LOOP AT dba_sellist.
    IF dba_sellist-ddic CO ddic_marks. &quot;only ddic-limits
      READ TABLE x_namtab INDEX dba_sellist-tabix.
      IF x_namtab-texttabfld NE space OR x_header-bastab EQ space AND
         x_namtab-bastabname NE x_header-roottab.
        CLEAR dba_sellist-ddic.
      ENDIF.
    ENDIF.
    APPEND dba_sellist TO cdso_sellist.
  ENDLOOP.
  READ TABLE total INDEX 1.                                 &quot;IG 951411
  IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
    ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
  ELSE.
    ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
  ENDIF.
  CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
    EXPORTING
      tabname                   = x_header-maintview
      entry                     = total
      entry_text                = &lt;vim_tot_txt_struc_loc&gt;
      ddic                      = &apos;N&apos;
      key                       = &apos;N&apos;
      ignore_blank_subsetfields = &apos;J&apos;
    TABLES
      x_namtab                  = x_namtab
      x_header                  = x_header
      sellist                   = cdso_sellist
    EXCEPTIONS
      entry_not_fits            = 1
      no_value_for_subset_ident = 2.
  CASE sy-subrc.
    WHEN 0.
      IF x_header-delmdtflag NE space.
        PERFORM build_mainkey_tab_1. flag = &apos;X&apos;.
      ENDIF.
    WHEN 1.
      DELETE total INDEX 1.
      SUBTRACT 1 FROM total_ix.
    WHEN 2.
      CLEAR &lt;status&gt;-sbsid_rcvd.
  ENDCASE.
  LOOP AT total FROM total_ix.
    CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
      EXPORTING
        tabname                   = x_header-maintview
        entry                     = total
        entry_text                = &lt;vim_tot_txt_struc_loc&gt;
        ddic                      = &apos;N&apos;
        key                       = &apos;N&apos;
        ignore_blank_subsetfields = &apos;J&apos;
      TABLES
        x_namtab                  = x_namtab
        x_header                  = x_header
        sellist                   = cdso_sellist
      EXCEPTIONS
        entry_not_fits            = 1
        no_value_for_subset_ident = 2.
    CASE sy-subrc.
      WHEN 0.
        IF x_header-delmdtflag NE space.
          PERFORM build_mainkey_tab_1. flag = &apos;X&apos;.
        ENDIF.
      WHEN 1.
        DELETE total.
      WHEN 2.
        CLEAR &lt;status&gt;-sbsid_rcvd.
    ENDCASE.
  ENDLOOP.
  IF flag NE space.
    PERFORM build_mainkey_tab_2.
  ENDIF.
ENDFORM.                    &quot;check_dynamic_select_options</include_source>
   </include>
   <include NAME="LSVIMF2H" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_MARK_AND_PROCESS                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_MARK_AND_PROCESS USING VALUE(VMAP_EXIX) TYPE I
                                VALUE(VMAP_OKCODE) LIKE OK_CODE
                                VMAP_NBR TYPE I VMAP_RC TYPE I.
  DATA: VMAP_I_RC TYPE I.
  READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH. &quot;#EC WARNOK
  &lt;MARK&gt; = MARKIERT. ADD 1 TO MARK_TOTAL.
  MODIFY TOTAL INDEX SY-TABIX.
  &lt;XACT&gt; = &lt;ACTION&gt;.
  &lt;XMARK&gt; = MARKIERT. ADD 1 TO MARK_EXTRACT.
  MODIFY EXTRACT.
  PERFORM VIM_PROCESS_VIEW_ENTRY USING VMAP_EXIX VMAP_OKCODE VMAP_I_RC.
  IF VMAP_I_RC EQ 0.
    ADD 1 TO VMAP_NBR.
  ELSE.
    VMAP_RC = VMAP_I_RC.
  ENDIF.
ENDFORM.                               &quot;vim_mark_and_process</include_source>
   </include>
   <include NAME="LSVIMF2I" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_EXTERNAL_EDIT                                        *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM vim_external_edit.
  TYPES: vee_sellist LIKE vimsellist OCCURS 10.
  DATA: ee_rc TYPE i, upd_flags(3) TYPE c, del_flags(3) TYPE c,
      h_flag(1) TYPE c, repmode_safe(1) TYPE c, specmode_safe(1) TYPE c,
        extmode_safe(1) TYPE c, vee_results LIKE vimmodres, h_ix TYPE i.
  FIELD-SYMBOLS: &lt;h_sellist&gt; TYPE vee_sellist, &lt;hf&gt; TYPE ANY.

  IF maint_mode EQ anzeigen.
    vee_results-rc_udl = vee_results-rc_ins = vee_results-rc_upd =
    vee_results-rc_del = vee_results-rc_tin = vee_results-rc_del = 8.
    vim_results_of_ext_mod = vee_results.
    EXIT.
  ENDIF.
  MOVE: aendern TO upd_flags, neuer_eintrag TO upd_flags+1,
        kopieren TO upd_flags+2,
        geloescht TO del_flags, update_geloescht TO del_flags+1,
        neuer_geloescht TO del_flags+2.
  repmode_safe = replace_mode. replace_mode = &apos;X&apos;.
  specmode_safe = vim_special_mode. vim_special_mode = vim_upgrade.
  extmode_safe = vim_external_mode. vim_external_mode = &apos;X&apos;.
  maxlines = 1.
  clear &lt;status&gt;-bcfixdelinfosent.
  LOOP AT extract.
    IF &lt;xact&gt; EQ zurueckholen.
      h_flag = status-delete. status-delete = geloescht.
      PERFORM vim_mark_and_process USING sy-tabix &apos;UNDO&apos;
                                         vee_results-nbr_of_udl
                                         vee_results-rc_udl.
      status-delete = h_flag.
      ee_rc = vee_results-rc_udl.
    ELSEIF &lt;xact&gt; CO upd_flags.
      IF &lt;xact&gt; EQ kopieren.
        h_ix = sy-tabix + 1.
        vim_extcopy_mode = &apos;X&apos;.
        &lt;xact&gt; = neuer_eintrag.
        ASSIGN &lt;vim_ck_sellist&gt; TO &lt;h_sellist&gt;.
        LOOP AT &lt;h_sellist&gt; INTO dpl_sellist
                            WHERE value EQ space AND initial EQ space.
* check if sellist is filled completely &amp; fill it if not
          READ TABLE x_namtab INDEX dpl_sellist-tabix.
          IF sy-subrc EQ 0.
            IF x_header-bastab = space.
* view
              ASSIGN COMPONENT x_namtab-viewfield
               OF STRUCTURE &lt;vim_total_struc&gt; TO &lt;hf&gt;.
            ELSE.
              IF x_namtab-texttabfld NE space.
* Type S: text field
                ASSIGN COMPONENT x_namtab-viewfield
                 OF STRUCTURE &lt;vim_ext_txt_struc&gt; TO &lt;hf&gt;.
              ELSE.
* Type S: key field
                ASSIGN COMPONENT x_namtab-viewfield
                 OF STRUCTURE &lt;vim_extract_struc&gt; TO &lt;hf&gt;.
              ENDIF.
            ENDIF.
*            ASSIGN TOTAL+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH) TO &lt;HF&gt;.
            READ TABLE extract INTO total INDEX h_ix.
            dpl_sellist-value = &lt;hf&gt;.
            IF &lt;hf&gt; EQ space. dpl_sellist-initial = &apos;X&apos;. ENDIF.
            CLEAR dpl_sellist-converted.
            MODIFY &lt;h_sellist&gt; FROM dpl_sellist.
          ENDIF.
        ENDLOOP.
      ENDIF.
      h_flag = &lt;xact&gt;.
      PERFORM vim_modify_view_entry USING sy-tabix ee_rc.
      CLEAR vim_extcopy_mode.
      DELETE extract.                                       &quot;190298
      IF ee_rc EQ 0.
        IF h_flag EQ neuer_eintrag.
          ADD 1 TO vee_results-nbr_of_ins.
        ELSE.
          ADD 1 TO vee_results-nbr_of_upd.
        ENDIF.
      ELSE.
        IF h_flag EQ neuer_eintrag.
          vee_results-rc_ins = ee_rc.
        ELSE.
          vee_results-rc_upd = ee_rc.
        ENDIF.
      ENDIF.
    ELSEIF &lt;xact&gt; CO del_flags.
      PERFORM vim_mark_and_process USING sy-tabix &apos;DELE&apos;
                                         vee_results-nbr_of_del
                                         vee_results-rc_del.
      ee_rc = vee_results-rc_del.
    ELSEIF &lt;xact&gt; EQ task_add.
      PERFORM vim_mark_and_process USING sy-tabix &apos;TRIN&apos;
                                         vee_results-nbr_of_tin
                                         vee_results-rc_tin.
      ee_rc = vee_results-rc_tin.
    ELSEIF &lt;xact&gt; EQ task_del.
      PERFORM vim_mark_and_process USING sy-tabix &apos;TREX&apos;
                                         vee_results-nbr_of_tex
                                         vee_results-rc_tex.
      ee_rc = vee_results-rc_tex.
    ENDIF.
    IF ee_rc EQ 8. EXIT. ENDIF.
    IF &lt;status&gt;-bcfixdelinfosent EQ &apos;X&apos;.
      &lt;status&gt;-bcfixdelinfosent = &apos;Y&apos;.
    ENDIF.
  ENDLOOP.
  clear &lt;status&gt;-bcfixdelinfosent.
  vim_results_of_ext_mod = vee_results.
* CLEAR: REPLACE_MODE, VIM_SPECIAL_MODE, VIM_EXTERNAL_MODE.
  replace_mode = repmode_safe. vim_special_mode = specmode_safe.
  vim_external_mode = extmode_safe.
ENDFORM.                               &quot;external_edit</include_source>
   </include>
   <include NAME="LSVIMF2J" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_RESTORE_STATE_INFO                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_RESTORE_STATE_INFO.
  STATUS-DATA = &lt;STATUS&gt;-ST_DATA.
  STATUS-MODE =  &lt;STATUS&gt;-ST_MODE.
  STATUS-DELETE =  &lt;STATUS&gt;-ST_DELETE.
  STATUS-ACTION =  &lt;STATUS&gt;-ST_ACTION.
  TITLE         =  &lt;STATUS&gt;-TITLE.
  MAXLINES      =  &lt;STATUS&gt;-MAXLINES.
  F             =  &lt;STATUS&gt;-CUR_FIELD.
  O             =  &lt;STATUS&gt;-CUR_OFFSET.
  FUNCTION      =  &lt;STATUS&gt;-FCODE.
  L = &lt;STATUS&gt;-CUR_LINE.
ENDFORM.                               &quot;vim_restore_state_info</include_source>
   </include>
   <include NAME="LSVIMF2K" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_STORE_STATE_INFO                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_STORE_STATE_INFO.
  MOVE: STATUS-DATA TO &lt;STATUS&gt;-ST_DATA,
        STATUS-MODE TO &lt;STATUS&gt;-ST_MODE,
        STATUS-DELETE TO &lt;STATUS&gt;-ST_DELETE,
        STATUS-ACTION TO &lt;STATUS&gt;-ST_ACTION,
        TITLE         TO &lt;STATUS&gt;-TITLE,
        MAXLINES      TO &lt;STATUS&gt;-MAXLINES,
        F             TO &lt;STATUS&gt;-CUR_FIELD,
        O             TO &lt;STATUS&gt;-CUR_OFFSET,
        FUNCTION      TO &lt;STATUS&gt;-FCODE.
  IF L EQ 0.
    MOVE 1 TO &lt;STATUS&gt;-CUR_LINE.
  ELSE.
    MOVE L TO &lt;STATUS&gt;-CUR_LINE.
  ENDIF.
ENDFORM.                               &quot;vim_store_state_info</include_source>
   </include>
   <include NAME="LSVIMF2L" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CALL_DYNPRO                                              *
*---------------------------------------------------------------------*
*       UF170200: transp. mode: don&apos;t fill CORR_KEYTAB-TABKEY with
*                 more than 120 chars
*
*---------------------------------------------------------------------*
FORM call_dynpro.
  DATA: state_init TYPE c, rc LIKE sy-subrc,
        dpl_sel_entries TYPE i, cd_specmode_safe(1) TYPE c,
        addr_e071k LIKE e071k, cd_addr_71ktab LIKE e071k OCCURS 0,
        object_key TYPE ad_objkey,
        max_trsp_keylength_in_byte TYPE i,
*       viewcluster dequeue flag XB H626152
        f_return(1) TYPE c.

  FIELD-SYMBOLS: &lt;object_keyx&gt; TYPE x.

  max_trsp_keylength_in_byte = vim_max_trsp_keylength
   * cl_abap_char_utilities=&gt;charsize.
  CASE vim_adjust_middle_level_mode.
    WHEN space.
    WHEN subset OR &apos;X&apos;.
      vim_special_mode = vim_direct_upgrade.
      IF vim_adjust_middle_level_mode EQ subset.
        x_namtab[] = vim_adj_namtab.
      ENDIF.
    WHEN &apos;L&apos;.
      CLEAR vim_adjust_middle_level_mode. function = &apos;ENDE&apos;.
      EXIT.
  ENDCASE.
* IF &lt;STATUS&gt;-ALR_SETUP EQ SPACE.
  IF &lt;status&gt;-initializd EQ space.
    PERFORM init_state_vector.
  ENDIF.
  DESCRIBE TABLE dpl_sellist LINES dpl_sel_entries.
  IF x_header-selection EQ space.
    IF dpl_sel_entries GT 0.
      MOVE &apos;X&apos; TO x_header-selection.
      MODIFY x_header INDEX 1.
      ASSIGN dpl_sellist-*sys* TO &lt;vim_ck_sellist&gt;.
    ELSE.
      DESCRIBE TABLE dba_sellist.
      IF sy-tfill GT 0.
        MOVE &apos;X&apos; TO x_header-selection.
        MODIFY x_header INDEX 1.
*       ASSIGN DBA_SELLIST-*SYS* TO &lt;VIM_CK_SELLIST&gt;.
      ENDIF.
      ASSIGN dba_sellist-*sys* TO &lt;vim_ck_sellist&gt;.
    ENDIF.
  ELSE.
    IF dpl_sel_entries GT 0.
      ASSIGN dpl_sellist-*sys* TO &lt;vim_ck_sellist&gt;.
    ELSE.
      ASSIGN dba_sellist-*sys* TO &lt;vim_ck_sellist&gt;.
    ENDIF.
  ENDIF.
  PERFORM vim_maint_selflag USING &apos;I&apos;
                            CHANGING x_header-selection.
* Übergangslösung Sortierungsproblem Anfang
  IF &lt;status&gt;-alr_sorted EQ space.
    SORT total BY &lt;vim_xtotal_key&gt;.
    MOVE &apos;X&apos; TO &lt;status&gt;-alr_sorted.
  ENDIF.
* Übergangslösung Sortierungsproblem Ende
  PERFORM exclude_cua_functions.
  IF x_header-frm_on_aut NE space AND  &quot;4.5a: support indiv. auth. chck
     &lt;status&gt;-auth_check NE space.     &quot;auth check is requested
    vim_auth_action = view_action.
    vim_auth_event = vim_auth_requested_check.
    ASSIGN &lt;vim_ck_sellist&gt; TO &lt;vim_auth_sellist&gt;.
    PERFORM (x_header-frm_on_aut) IN PROGRAM.
    IF vim_auth_rc NE 0.
      PERFORM vim_process_message USING vim_auth_msgid &apos;I&apos; &apos;E&apos;
                                        vim_auth_msgno
                                        vim_auth_msgv1 vim_auth_msgv2
                                        vim_auth_msgv3 vim_auth_msgv4.
      CASE vim_auth_rc.
        WHEN 4.                        &quot;show only
          maint_mode = anzeigen.
          excl_cua_funct-function = &apos;AEND&apos;. COLLECT excl_cua_funct.
        WHEN 8.                        &quot;exit
          RAISE missing_corr_number.
      ENDCASE.
    ENDIF.
  ENDIF.
  IF maint_mode NE anzeigen AND maint_mode NE transportieren AND
     &lt;status&gt;-dlclalrckd EQ space.
    IF vim_system_type NE &apos;SAP&apos; AND
       x_header-customauth CO sap_only_classes.
*     MESSAGE I137(SV). &quot;keine Ãnderungen, Daten gehören SAP
      PERFORM vim_process_message USING &apos;SV&apos; &apos;I&apos; &apos;I&apos; &apos;137&apos;
                                         space space space space.
    ENDIF.
    MOVE &apos;X&apos; TO &lt;status&gt;-dlclalrckd.
  ENDIF.
  IF x_header-subsetflag NE space AND &lt;status&gt;-sbsid_rcvd CO &apos; R&apos;.
    PERFORM init_subset_keyfields.
  ENDIF.
  IF x_header-selection NE space AND &lt;status&gt;-selcd_rcvd EQ space.
    LOOP AT dpl_sellist WHERE ddic EQ space OR ( operator EQ &apos;GE&apos; OR
                                                 operator EQ &apos;GT&apos; OR
                                                 operator EQ &apos;LE&apos; OR
                                                 operator EQ &apos;LT&apos; ).
      MOVE &apos;X&apos; TO state_init.
      EXIT.
    ENDLOOP.
    IF sy-subrc NE 0. &quot;no entries in DPL_SELLIST -&gt; all entries req.
      DESCRIBE TABLE total.
      IF &lt;status&gt;-maxlines NE sy-tfill AND  &quot;missing entries in EXTRACT
         &lt;status&gt;-st_data EQ gesamtdaten.   &quot;and no selection made
        IF x_header-delmdtflag NE space.
*         DESCRIBE TABLE VIM_COLLAPSED_MAINKEYS. &quot;SW int.M. 1599934/1999
*         IF &lt;STATUS&gt;-MAXLINES NE SY-TFILL.&quot;missing entries in EXTRACT
          IF &lt;status&gt;-maxlines = 0.    &quot;SW int.M. 1599934/1999
            MOVE &apos;X&apos; TO state_init.
          ENDIF.
        ELSE.
          MOVE &apos;X&apos; TO state_init.
        ENDIF.
      ENDIF.
    ENDIF.
    IF state_init NE space.
      CLEAR: &lt;status&gt;-maxlines,
             &lt;status&gt;-cur_field,
             &lt;status&gt;-cur_offset.
      MOVE: 1 TO &lt;status&gt;-cur_line,
            1 TO &lt;status&gt;-firstline,
            nicht_geloescht TO &lt;status&gt;-st_delete,
            maint_mode TO &lt;status&gt;-st_action,
            list_bild TO &lt;status&gt;-st_mode.
      PERFORM set_status_nokeyselcnds.
    ENDIF.
    MOVE &apos;X&apos; TO &lt;status&gt;-selcd_rcvd.
  ENDIF.
  IF &lt;status&gt;-initializd EQ &apos;x&apos;.
    PERFORM set_status_nokeyselcnds.
  ENDIF.
  IF maint_mode NE anzeigen AND
     corr_nbr NE space AND corr_nbr NE &lt;status&gt;-corr_nbr.
    MOVE: &lt;status&gt;-corr_nbr TO &lt;status&gt;-l_corr_nbr,
          corr_nbr TO &lt;status&gt;-corr_nbr.
  ENDIF.
  IF maint_mode EQ transportieren.
    PERFORM request_corr_number.
    IF x_header-flag EQ vim_transport_denied.
      MESSAGE i142(sv).
      function = ucomm = end. EXIT.
    ENDIF.
  ELSEIF maint_mode EQ aendern.
    PERFORM check_transp_objs_for_maint USING rc.
    CASE rc.
      WHEN 4.
        maint_mode = anzeigen.
        excl_cua_funct-function = &apos;AEND&apos;. COLLECT excl_cua_funct.
*       viewcluster dequeue flag XB H626152B
*        maint_mode = aendern.
        function = ucomm = &apos;ANZG&apos;.
*        f_return = &apos;X&apos;.
        f_return = &apos; &apos;.
*       viewcluster dequeue flag XB H626152E
      WHEN 8.
        RAISE missing_corr_number.
    ENDCASE.
  ELSE.
    vim_client_state = vim_noact.
  ENDIF.
  IF f_return &lt;&gt; &apos;X&apos;.
    MOVE: maint_mode          TO status-action,
          &lt;status&gt;-st_delete  TO status-delete,
          &lt;status&gt;-st_data    TO status-data,
          &lt;status&gt;-title      TO title,
          &lt;status&gt;-firstline  TO firstline,
          &lt;status&gt;-mk_xt      TO mark_extract,
          &lt;status&gt;-mk_to      TO mark_total,
          &lt;status&gt;-cur_line   TO l,
          &lt;status&gt;-cur_field  TO f,
          &lt;status&gt;-cur_offset TO o,
          &lt;status&gt;-maxlines   TO maxlines,
          maint_mode          TO title-action,
          firstline           TO nextline.
    IF status-action EQ aendern AND &quot;ignore history when mode was chngd.
       &lt;status&gt;-st_action EQ hinzufuegen.
      MOVE: &lt;status&gt;-st_action TO status-action,
            &lt;status&gt;-st_action TO title-action.
    ENDIF.
    IF &lt;status&gt;-st_delete EQ geloescht.
      DESCRIBE TABLE extract LINES maxlines.
      IF maxlines EQ 0.
        CLEAR status-delete.
        MOVE list_bild TO &lt;status&gt;-st_mode.
      ENDIF.
    ELSEIF &lt;status&gt;-st_mode = detail_bild&quot;SW (1248405/98) ..
       AND &lt;status&gt;-st_action &lt;&gt; hinzufuegen.
      DESCRIBE TABLE extract LINES maxlines.
      IF maxlines EQ 0.
        MOVE list_bild TO &lt;status&gt;-st_mode.
*    nur ein Eintrag  -&gt; automatisch wieder auf Detailbild verzweigt
*    mehrere Einträge -&gt; Listbild, da kein Eintrag ausgezeichnet
      ENDIF.                             &quot;.. SW
    ENDIF.
    IF ( status-action EQ transportieren AND
                                                            &quot;UF28042000
        &lt;status&gt;-l_corr_nbr NE &lt;status&gt;-corr_nbr )
     OR ( vim_client_state EQ vim_log AND &apos;ST&apos; NS status-action ) .
      PERFORM prepare_corr.
    ENDIF.
    IF status-action EQ transportieren AND get_corr_keytab NE space.
      PERFORM get_keytab.
    ENDIF.
    IF status-action EQ transportieren AND &lt;status&gt;-crcntsknwn EQ space.
      LOOP AT vim_addr_e071k_tab INTO addr_e071k.
        addr_e071k-trkorr = &lt;status&gt;-corr_nbr.
        MODIFY vim_addr_e071k_tab FROM addr_e071k.
      ENDLOOP.
      LOOP AT total.    &quot;note entries already contained in CORR_KEYTAB
        MOVE &lt;vim_total_struc&gt; TO &lt;table1&gt;.
        IF x_header-bastab EQ space.     &quot;view
          PERFORM (corr_formname) IN PROGRAM (sy-repid)
                                  USING pruefen rc.
        ELSE.                            &quot;base table
          corr_keytab =  e071k.
          corr_keytab-objname = x_header-maintview.
          IF x_header-keylen GT max_trsp_keylength_in_byte.
*        IF x_header-keylen GT vim_max_trsp_keylength.     &quot;UF170200b
            MOVE &lt;vim_xtotal_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-maxtrkeyln).
*          MOVE total TO corr_keytab-tabkey(x_header-maxtrkeyln).
          ELSE.                                             &quot;UF170200e
            MOVE &lt;vim_xtotal_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-keylen).
*          MOVE total TO corr_keytab-tabkey(x_header-keylen).
          ENDIF.                                            &quot;UF170200
          PERFORM update_corr_keytab USING pruefen rc.
          IF rc EQ 0.
            IF x_header-texttbexst NE space AND  &quot;text table
               &lt;vim_xtotal_text&gt; NE &lt;text_initial_x&gt;.
*             &lt;total_text&gt; NE &lt;text_initial&gt;.
              corr_keytab =  e071k.
              corr_keytab-objname = x_header-texttab.
              IF x_header-textkeylen GT max_trsp_keylength_in_byte.
*           IF x_header-textkeylen GT vim_max_trsp_keylength. &quot;UF170200b
                MOVE &lt;vim_xtotal_text&gt; TO
                               &lt;vim_corr_keyx&gt;(x_header-maxtrkeyln).
*              MOVE &lt;total_text&gt; TO
*                             corr_keytab-tabkey(x_header-maxtrtxkln).
              ELSE.                                         &quot;UF170200e
                MOVE &lt;vim_xtotal_text&gt; TO
                               &lt;vim_corr_keyx&gt;(x_header-textkeylen).
*              MOVE &lt;total_text&gt; TO
*                             corr_keytab-tabkey(x_header-textkeylen).
              ENDIF.                                        &quot;UF170200
              PERFORM update_corr_keytab USING pruefen rc.
            ENDIF.
          ENDIF.
        ENDIF.
        IF rc = 0 AND x_header-texttbexst &lt;&gt; space AND &quot;SW Texttransl ..
          vim_texttab_is_ro EQ space.
          PERFORM vim_text_keytab_entry USING &lt;vim_xtotal_key&gt; pruefen rc.
        ENDIF.                           &quot;.. Texttransl
        IF rc EQ 0.
          MOVE transportieren TO &lt;action&gt;.
          IF x_header-adrnbrflag EQ &apos;O&apos; AND &lt;address_number&gt; NE space.
            PERFORM vim_address_keytab_entries USING pruefen rc.
          ELSEIF x_header-adrnbrflag EQ &apos;N&apos; AND &lt;address_number&gt; NE space.
            APPEND LINES OF vim_addr_e071k_tab TO cd_addr_71ktab.
            ASSIGN object_key TO &lt;object_keyx&gt; CASTING.
            MOVE &lt;vim_xtotal_key&gt; TO &lt;object_keyx&gt;(x_header-keylen).
*          object_key = &lt;vim_total_key&gt;.
            CALL FUNCTION &apos;ADDR_TRANSPORT_ENTRIES&apos;
              EXPORTING
                addrnumber = &lt;address_number&gt;
                table_name = vim_addr_basetable
                field_name = vim_addr_bastab_field
                objkey     = object_key
              TABLES
                e071k_tab  = cd_addr_71ktab.
            vim_exit_11_12_active = &apos;X&apos;.
            LOOP AT cd_addr_71ktab INTO corr_keytab WHERE
             mastername = vim_addr_e071k_master_46 OR    &quot;UF688403/2000
             mastername = vim_addr_e071k_master.
* Rel &lt; 4.6A: ignore old type address entries inserted only for downward
*             compatibility
              PERFORM update_corr_keytab USING pruefen rc.
              IF rc NE 0. EXIT. ENDIF.
            ENDLOOP.
            CLEAR vim_exit_11_12_active.
            REFRESH cd_addr_71ktab.
          ENDIF.
          IF rc EQ 0.
            IF x_header-frm_e071ks NE space.
              vim_exit_11_12_active = &apos;X&apos;.
              MOVE pruefen TO corr_action.
              PERFORM (x_header-frm_e071ks) IN PROGRAM (sy-repid).
              IF sy-subrc NE 0. CLEAR &lt;action&gt;. ENDIF.
              CLEAR vim_exit_11_12_active.
            ENDIF.
          ELSE.
            CLEAR &lt;action&gt;.
          ENDIF.
        ELSE.
          CLEAR &lt;action&gt;.
        ENDIF.
        IF maxlines GT 0 AND
           vim_special_mode NE vim_extedit.                &quot;SW 1.4.1998
          READ TABLE extract WITH KEY &lt;f1_x&gt;.    &quot;#EC WARNOK
          IF sy-subrc EQ 0.
            MOVE: &lt;mark&gt; TO &lt;xmark&gt;, &lt;action&gt; TO &lt;xact&gt;.
            MODIFY extract INDEX sy-tabix.
          ENDIF.
        ENDIF.
        MODIFY total.
      ENDLOOP.
      MOVE &apos;X&apos; TO &lt;status&gt;-crcntsknwn.
    ENDIF.
    IF vim_restore_mode NE space.
      status-mode = &lt;status&gt;-st_mode.
      CLEAR vim_restore_mode.
      EXIT.
    ENDIF.
    IF vim_special_mode NE vim_extedit.
      CASE vim_single_entry_function.
        WHEN space OR &apos;UPD&apos; OR &apos;SHOW&apos;.
          IF &lt;status&gt;-st_mode EQ detail_bild.
            MOVE: &apos;DETA&apos; TO function,
                  nextline TO firstline.
            IF old_nl NE 0.                                 &quot;GKPR - 0001009660
              nextline = old_nl.                            &quot;GKPR - 0001009660
              CLEAR old_nl.                                 &quot;GKPR - 0001009660
            ELSE.                                           &quot;GKPR - 0001009660
              nextline = firstline + l - 1.
            ENDIF.                                          &quot;GKPR - 0001009660
            DESCRIBE TABLE extract LINES maxlines.
            IF maxlines EQ 0.
              IF &lt;status&gt;-st_action EQ hinzufuegen.
                neuer = &apos;J&apos;.
              ELSE.
                PERFORM fill_extract.
              ENDIF.
            ENDIF.
*         CALL SCREEN DETAIL.
            PERFORM process_detail_screen USING &apos;C&apos;.
          ELSE.
            CALL SCREEN liste.
          ENDIF.
        WHEN &apos;INS&apos;.
          function = &apos;NEWL&apos;. PERFORM hinzufuegen.
        WHEN &apos;DEL&apos;.
          cd_specmode_safe = vim_special_mode.
          vim_special_mode = vim_extedit.
          READ TABLE total INTO extract INDEX 1. &lt;xact&gt; = geloescht.
          APPEND extract.
          PERFORM vim_external_edit.
          vim_special_mode = cd_specmode_safe.
          excl_cua_funct-function = &apos;UNDO&apos;. COLLECT excl_cua_funct.
          PERFORM selektiere USING geloescht.
      ENDCASE.
      MOVE: function TO ucomm.
* only relevant in viewcluster(navigation from detail screen):
      IF status-mode = detail_bild.
        last_act_entry = nextline.
      ELSE.
* navigation in viewcluster by tree-control: unuseable
        last_act_entry = &lt;status&gt;-firstline + &lt;status&gt;-cur_line - 1.
      ENDIF.
    ELSE.                                &quot;ext. edit.
      PERFORM vim_external_edit.
      &lt;status&gt;-maxlines = 0.             &quot;SW  int. Meldung 519239/1999
    ENDIF.
  ENDIF.
  IF function NE &apos;ORGD&apos; AND function NE &apos;ORGL&apos; AND
     function NE &apos;SAVE&apos; AND function NE &apos;TRSP&apos; AND function NE &apos;TRAE&apos;.
    IF x_header-subsetflag NE space AND &lt;status&gt;-sbsid_rcvd NE &apos;S&apos;.
      CLEAR &lt;status&gt;-sbsid_rcvd.
    ENDIF.
*   ELSEIF X_HEADER-SUBSETFLAG EQ SPACE AND
    IF x_header-selection NE space AND
       &lt;status&gt;-selcd_rcvd NE space.
      CLEAR &lt;status&gt;-selcd_rcvd.
    ENDIF.
    IF x_header-delmdtflag NE space.
      EXPORT vim_collapsed_mainkeys TO MEMORY ID vim_memory_id_1.
    ENDIF.
    ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
    vim_enqueue_range = x_header-subsetflag.
  ENDIF.
* MPRE 13.11.2088    1274142
  &quot; Non key fields of the view are hidden OR read only OR
  &quot; removed from screen manually, update flag is not set =&gt; activation
  &quot; links are not updated during BC Set activation
  &quot; To update activtion links, set update flag =&gt; calls after_save module.
  &quot; activation links are updated.
  IF vim_import_profile NE space AND
    VIM_SPECIAL_MODE = &apos;E&apos; AND
     NOT imp_results[] IS INITIAL AND
    ( vim_results_of_ext_mod-nbr_of_udl NE 0 OR
     vim_results_of_ext_mod-nbr_of_ins NE 0 OR
     vim_results_of_ext_mod-nbr_of_del NE 0 OR
     vim_results_of_ext_mod-nbr_of_upd NE 0 ).
    IF &lt;status&gt;-upd_flag EQ space.
      &lt;status&gt;-upd_flag = &apos;X&apos;.
    ENDIF.
  ENDIF.
* MPRE 13.11.2088    1274142
  IF vim_called_by_cluster = &apos;X&apos;.  &quot; MPRE 1449801
*    ucomm = function.
    IF function = &apos;BACK&apos;.        &quot; PATIDARP 1470418
      CLEAR last_view_info.
    ENDIF.
*    CLEAR function.             &quot; PATIDARP 1496366
  ENDIF.
ENDFORM.                    &quot;call_dynpro</include_source>
   </include>
   <include NAME="LSVIMF2M" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM KOPIERE_EINTRAG                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  ORIGIN                                                        *
*---------------------------------------------------------------------*
FORM kopiere_eintrag USING origin.
  DATA: ke_index LIKE sy-tabix, ke_rc LIKE sy-subrc, ke_hf TYPE i.
  field-symbols: &lt;x_origin&gt; type x.

  IF status-mode EQ list_bild AND function NE &apos;KOPF&apos; AND &quot;scrolling &amp;
     &lt;status&gt;-upd_flag EQ space.       &quot;no changes
    EXIT.
  ENDIF.
  assign origin to &lt;x_origin&gt; casting.
  IF vim_special_mode NE vim_delimit.
    IF x_header-guidflag &lt;&gt; space.
      PERFORM vim_make_guid using space.
    ENDIF.
    IF x_header-frm_on_new NE space.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        EXIT.
      ENDIF.
      PERFORM (x_header-frm_on_new) IN PROGRAM (sy-repid).
    ENDIF.
    IF &lt;f1_x&gt; EQ &lt;x_origin&gt;.
      PERFORM set_pf_status USING &apos;ERROR&apos;.
      MESSAGE e015(sv).
      EXIT.
    ELSE.
      neuer = &apos;J&apos;.
      PERFORM check_key.
      neuer = &apos;N&apos;.
      CHECK sy-subrc NE 0.
      MOVE: sy-subrc TO ke_rc,
            sy-tabix TO ke_index.
    ENDIF.
  ELSE.
    READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.         &quot;#EC WARNOK
    MOVE: sy-subrc TO ke_rc,
          sy-tabix TO ke_index.
  ENDIF.
* gültiger Eintrag.
  IF vim_special_mode NE vim_delimit.  &quot;copy mode
    IF x_header-bastab NE space AND x_header-texttbexst NE space AND
       &lt;status&gt;-upd_flag EQ &apos;E&apos;.
      PERFORM (vim_frm_text_upd_flag) IN PROGRAM.
    ENDIF.
    IF x_header-adrnbrflag NE space.
      PERFORM address_maintain.
    ENDIF.
    IF x_header-texttbexst &lt;&gt; space.   &quot;SW Textcopy
      PERFORM vim_copy_texttab_entry USING &lt;f1_x&gt; &lt;vim_xextract_key&gt;.
    ENDIF.
    IF vim_called_by_cluster NE space.
      PERFORM vim_store_state_info.
      CALL FUNCTION &apos;VIEWCLUSTER_COPY_DEPENDENT&apos;
           EXPORTING
                view_name   = x_header-viewname
                maintview   = x_header-maintview
                status_mode = status-mode
                workarea    = extract
                new_entry   = &lt;table1&gt;
                no_dialog   = vim_external_mode.
      PERFORM vim_restore_state_info.
    ENDIF.
  ENDIF.
  IF vim_special_mode NE vim_delimit OR ke_rc NE 0.
    &lt;action&gt; = neuer_eintrag.
    &lt;mark&gt; = nicht_markiert.
  ELSE.                                &quot;delimit mode and existing entry
    IF &lt;action&gt; EQ original. &lt;action&gt; = aendern. ENDIF.
  ENDIF.
  ADD 1 TO counter.
*  MOVE &lt;table1&gt; TO total(x_header-tablen).
  MOVE &lt;table1&gt; TO &lt;vim_total_struc&gt;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space AND
     &lt;status&gt;-upd_flag EQ &apos;X&apos; OR &lt;status&gt;-upd_flag EQ &apos;T&apos;.
    MOVE &lt;table1_xtext&gt; TO &lt;vim_xtotal_text&gt;.
    IF vim_special_mode NE vim_delimit OR ke_rc NE 0.
      MOVE neuer_eintrag TO &lt;action_text&gt;.
    ELSE.
      IF &lt;action_text&gt; EQ original. &lt;action_text&gt; = aendern. ENDIF.
    ENDIF.
  ENDIF.
  vim_copied_indices-ex_ix = nextline.
  vim_copied_indices-level = vim_copy_call_level.
  CASE ke_rc.
    WHEN 0.
      MODIFY total INDEX ke_index.
      READ TABLE vim_copied_indices WITH KEY ix = ke_index
                                    BINARY SEARCH
                                    TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        vim_copied_indices-ix = ke_index.
        INSERT vim_copied_indices INDEX sy-tabix.
      ENDIF.
    WHEN 4.
      INSERT total INDEX ke_index.
      READ TABLE vim_copied_indices WITH KEY ix = ke_index
                                    BINARY SEARCH
                                    TRANSPORTING NO FIELDS.
      vim_copied_indices-ix = ke_index.
      INSERT vim_copied_indices INDEX sy-tabix.
      ke_hf = sy-tabix + 1.
      LOOP AT vim_copied_indices FROM ke_hf.
        ADD 1 TO vim_copied_indices-ix.
        MODIFY vim_copied_indices.
      ENDLOOP.
    WHEN 8.
      APPEND total.
      vim_copied_indices-ix = ke_index.
      APPEND vim_copied_indices.
  ENDCASE.
  neuer = &apos;N&apos;.
  &lt;status&gt;-upd_flag = space.
  READ TABLE total WITH KEY &lt;x_origin&gt; BINARY SEARCH.       &quot;#EC WARNOK
  IF sy-subrc = 0 AND &lt;mark&gt; EQ markiert.
    &lt;mark&gt; = nicht_markiert.
    SUBTRACT 1 FROM mark_total.
    MODIFY total INDEX sy-tabix.
  ENDIF.
  IF status-mode EQ detail_bild.
    vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2N" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM KOPIERE                                                  *
*---------------------------------------------------------------------*
* Kopieren als... und teilweise Gültigkeit abgrenzen                  *
*---------------------------------------------------------------------*
FORM kopiere.
  DATA: z LIKE sy-tabix VALUE 1,
        stat TYPE c, dum1 TYPE i.
  status-action = kopieren.
  MOVE status-data TO stat.
  status-data = auswahldaten.
  title-data = auswahldaten.
  ADD 1 TO vim_copy_call_level.
  IF vim_special_mode EQ vim_delimit.
    title-action = vim_delimit.
*  ELSEIF &lt;STATUS&gt;-PROF_FOUND NE VIM_PR_INTO_DET.           &quot;UFprofile
*    TITLE-ACTION = KOPIEREN.
  ENDIF.
*  ASSIGN extract(x_header-keylen) TO &lt;orig_key&gt;.
  ASSIGN &lt;vim_xextract_key&gt; TO &lt;orig_key&gt;.
  IF status-mode EQ list_bild.
    LOOP AT extract.
      IF &lt;xmark&gt; NE markiert.
        DELETE extract.
      ELSE.
        &lt;xmark&gt; = nicht_markiert.
        MODIFY extract.
      ENDIF.
    ENDLOOP.
    mark_extract = &lt;status&gt;-mk_xt = 0.
    nextline = 1.
    DESCRIBE TABLE extract LINES maxlines.
    IF vim_copy_call_level = 1.
      VIM_NR_ENTRIES_TO_COPY = maxlines.            &quot;SW 510129/1999
    ENDIF.
    IF status-type EQ einstufig.
      IF vim_special_mode NE vim_delimit.
        MESSAGE s024(sv).
      ELSE.
        MESSAGE s124(sv).
      ENDIF.
      CALL SCREEN liste.
      IF function NE &apos;ABR &apos;.
        DESCRIBE TABLE vim_copied_indices.
        IF sy-tfill LT VIM_NR_ENTRIES_TO_COPY.     &quot;SW 510129/1999
          &quot;not all selected entries where proc.
          LOOP AT extract.
            READ TABLE vim_copied_indices
                 WITH KEY level = vim_copy_call_level ex_ix = z.
            IF sy-subrc EQ 0.
              DELETE extract.
            ELSE.
              &lt;xmark&gt; = markiert. MODIFY extract.
            ENDIF.
            ADD 1 TO z.
          ENDLOOP.
          PERFORM kopiere.
        ENDIF.
      ENDIF.
    ELSE.
      LOOP AT extract.
        IF vim_special_mode NE vim_delimit.
          neuer = &apos;J&apos;.
          MESSAGE s025(sv).
        ELSE.
          MESSAGE s125(sv).
        ENDIF.
        PERFORM move_extract_to_view_wa.
        PERFORM process_detail_screen USING &apos;C&apos;.
        neuer = &apos;N&apos;.
        &lt;status&gt;-upd_flag = space.
        IF temporal_delimitation_happened NE space.
          CLEAR temporal_delimitation_happened.
        ENDIF.
        IF vim_special_mode EQ vim_delimit.
          REFRESH vim_delim_entries.
        ENDIF.
        IF function EQ &apos;ABR &apos;.
          EXIT.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF vim_copy_call_level GT 1.
      SUBTRACT 1 FROM vim_copy_call_level.
      EXIT.
    ENDIF.
    IF vim_special_mode NE vim_delimit AND counter LE 1.
      PERFORM fill_extract.
      mark_extract = mark_total.
      title-data = gesamtdaten.
      IF counter EQ 1.
        READ TABLE vim_copied_indices INDEX 1.
        READ TABLE total INDEX vim_copied_indices-ix.
        IF x_header-delmdtflag EQ space.
          READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;      &quot;#EC WARNOK
                             TRANSPORTING NO FIELDS.
          nextline = sy-tabix.
        ELSE.
          nextline = 0.
          LOOP AT vim_collapsed_mainkeys.
            check &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*            WHERE mkey_bf EQ &lt;vim_tot_mkey_before&gt;.
            IF vim_mkey_after_exists NE space.
              CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_tot_mkey_afterx&gt;.
*              CHECK &lt;vim_collapsed_key_af&gt; EQ &lt;vim_tot_mkey_after&gt;.
            ENDIF.
            READ TABLE extract WITH KEY &lt;vim_collapsed_keyx&gt;&quot;#EC WARNOK
*            READ TABLE extract WITH KEY &lt;vim_collapsed_key&gt;
                               TRANSPORTING NO FIELDS.
            nextline = sy-tabix.
            EXIT.
          ENDLOOP.
          IF sy-subrc NE 0 OR nextline EQ 0.
            READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;    &quot;#EC WARNOK
                               TRANSPORTING NO FIELDS.
            IF sy-subrc NE 0.
              nextline = 1.
            ELSE.
              nextline = sy-tabix.
            ENDIF.
          ENDIF.
        ENDIF.
      ELSE.
        nextline = 1.
      ENDIF.
    ELSE.
      status-action = title-action = hinzufuegen.
      status-data = title-data = auswahldaten.
      &lt;status&gt;-selected = neuer_eintrag.
      REFRESH: extract, vim_delim_entries.
      CLEAR: vim_mainkey, temporal_delimitation_happened.
      TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
      mark_extract = 0.
      LOOP AT vim_copied_indices.
        READ TABLE total INDEX vim_copied_indices-ix.
        extract = total.
        APPEND extract.
        IF x_header-delmdtflag NE space.
          LOOP AT vim_collapsed_mainkeys.
            check &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_ext_mkey_beforex&gt;.
*                             WHERE mkey_bf EQ &lt;vim_ext_mkey_before&gt;.
            IF vim_mkey_after_exists NE space.
              CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_ext_mkey_afterx&gt;.
*              CHECK &lt;vim_collapsed_key_af&gt; EQ &lt;vim_ext_mkey_after&gt;.
            ENDIF.
            READ TABLE excl_cua_funct WITH KEY function = &apos;EXPA&apos;.
            IF sy-subrc NE 0.
              APPEND &apos;EXPA&apos; TO excl_cua_funct.
              vim_delim_expa_excluded = &apos;X&apos;.
            ENDIF.
            vim_collapsed_mainkeys-log_key =
                                        vim_collapsed_mainkeys-mkey_bf.
            CLEAR vim_collapsed_mainkeys-mkey_bf.
            MODIFY vim_collapsed_mainkeys. EXIT.
          ENDLOOP.
        ENDIF.
      ENDLOOP.
      vim_coll_mainkeys_beg_ix = 1.
      nextline = 1.
    ENDIF.
    l = 1.
    DESCRIBE TABLE extract LINES maxlines.
  ELSE.
* Detailbild
    CLEAR &lt;status&gt;-mark_only.          &quot;ufdetail
    IF vim_special_mode NE vim_delimit.
      neuer = &apos;J&apos;.
      MESSAGE s025(sv).
    ELSE.
      MESSAGE s125(sv).
    ENDIF.
    PERFORM process_detail_screen USING &apos;C&apos;.
    neuer = &apos;N&apos;.
    &lt;status&gt;-upd_flag = space.
    IF function NE &apos;IGN &apos; AND function NE &apos;ABR &apos;.
      IF vim_special_mode NE vim_delimit.
* copy mode
        IF status-mark EQ markiert.
          READ TABLE extract WITH KEY &lt;orig_key&gt; BINARY SEARCH.&quot;#EC WARNOK
          IF sy-subrc EQ 0.
            &lt;xmark&gt; = nicht_markiert.
            MODIFY extract INDEX sy-tabix.
            SUBTRACT 1 FROM mark_extract.
          ENDIF.
        ENDIF.
      ELSE.
* delimit mode
        IF temporal_delimitation_happened NE space.
          PERFORM after_temporal_delimitation.
        ENDIF.
      ENDIF.
      READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.       &quot;#EC WARNOK
      extract = total.
*     IF &lt;STATUS&gt;-DISPL_MODE EQ EXPANDED OR SY-SUBRC NE 0.
      IF x_header-delmdtflag NE space.
        PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                   &apos;D&apos; &lt;vim_begdate&gt;.
        IF sy-subrc EQ 0.
          PERFORM check_new_mainkey.
          IF sy-subrc EQ 0.
            READ TABLE vim_collapsed_mainkeys               &quot;#EC WARNOK
             WITH KEY &lt;vim_tot_mkey_beforex&gt;
*            READ TABLE vim_collapsed_mainkeys WITH KEY &lt;vim_total_key&gt;
                                             BINARY SEARCH
                                             TRANSPORTING NO FIELDS.
            &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
*            vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
            &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
*            vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
            INSERT vim_collapsed_mainkeys INDEX sy-tabix.
          ENDIF.
          CLEAR sy-subrc.
        ENDIF.
      ENDIF.
      IF x_header-delmdtflag EQ space OR sy-subrc LT 8.
        READ TABLE extract WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH&quot;#EC WARNOK
         TRANSPORTING NO FIELDS.       &quot;UF 333778/1999
        CASE sy-subrc.
          WHEN 0.         &quot;UF 333778/1999, for temporal delimitation
            MODIFY extract INDEX sy-tabix.
          WHEN 4.
            INSERT extract INDEX sy-tabix.
          WHEN 8.
            APPEND extract.
        ENDCASE.
        MOVE: sy-tabix TO exind,
              sy-tabix TO nextline.
        CLEAR: old_nl.                                &quot;GKPR - 0001009660
      ENDIF.
      IF looplines GT 0.
        IF nextline LE firstline.
          dum1 = ( firstline - nextline ) / looplines.
          ADD 1 TO dum1.
          DO dum1 TIMES.
            firstline = firstline - looplines + 1.
          ENDDO.
          IF firstline LE 0. firstline = 1. ENDIF.
        ELSE.
          dum1 = firstline + looplines - 1.
          IF nextline GT dum1.
            dum1 = ( nextline - firstline ) / looplines.
            DO dum1 TIMES.
              firstline = firstline + looplines - 1.
            ENDDO.
          ENDIF.
        ENDIF.
        l = nextline - firstline + 1.
      ELSE.
        l = nextline.
      ENDIF.
      MOVE: firstline TO &lt;status&gt;-firstline,
            l         TO &lt;status&gt;-cur_line.
      DESCRIBE TABLE extract LINES maxlines.
    ENDIF.
    MOVE: stat TO status-data,
          stat TO title-data.
  ENDIF.
  REFRESH vim_copied_indices.
  SUBTRACT 1 FROM vim_copy_call_level.
  IF vim_special_mode NE vim_delimit.
    MESSAGE s014(sv) WITH counter.
  ELSE.
    IF counter EQ 1.
      MESSAGE s122(sv).
    ELSE.
      MESSAGE s123(sv) WITH counter.
    ENDIF.
  ENDIF.
  status-action = aendern.
  IF title-action NE hinzufuegen.
    title-action = aendern.
  ENDIF.
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  IF function EQ &apos;ABR &apos;.
    vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
  ELSEIF function NE &apos;IGN &apos;.
    IF vim_special_mode EQ vim_delimit AND status-mode EQ detail_bild.
      function = &apos;DETA&apos;.
    ELSE.
      CLEAR function.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;kopiere</include_source>
   </include>
   <include NAME="LSVIMF2O" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM REPLACE                                                  *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM replace.
  DATA: firstline_safe TYPE i,
        w_field TYPE vimty_fields_type.

  DESCRIBE TABLE exclude_tab.
  IF sy-tfill GT 0.                    &quot;entries in old exclude_tab
    PERFORM consider_old_exclude_tab TABLES excl_rpl_tab.
  ENDIF.
  CALL FUNCTION &apos;REPLACE_GET_FIELD&apos;
    EXPORTING
      table                  = x_header-maintview
    IMPORTING
      name_of_selected_field = sel_field_for_replace
    TABLES
      exclude_fields         = excl_rpl_tab
    EXCEPTIONS
      cancelled_by_user      = 0004
      no_valid_fields        = 8.
  CASE sy-subrc.
    WHEN 4.
      function = &apos;ABR &apos;. EXIT.
    WHEN 8.
      MESSAGE s039(sv) WITH view_name. EXIT.
  ENDCASE.
**************&quot;HCG BC-Set Fix Values Authorithy-Check *****************
  IF vim_bc_chng_allowed = space. &quot;BC-Set Fixvalue change forbidden
    READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa                          &quot;#EC CI_SORTSEQ
                                     WITH KEY keys = &lt;vim_xtotal_key&gt;.

    READ TABLE vim_bc_entry_list_wa-fields INTO w_field
                WITH KEY fieldname = sel_field_for_replace.
    IF w_field-flag = vim_profile_fix.
      MESSAGE i184(sv).
    ENDIF.
    CHECK w_field-flag NE vim_profile_fix.
  ENDIF.
***********************************************************************
  LOOP AT x_namtab WHERE viewfield EQ sel_field_for_replace.&quot;#EC *
    IF x_header-bastab NE space AND x_header-texttbexst NE space
                                AND x_namtab-texttabfld NE space.
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                &lt;vim_ext_txt_struc&gt; TO &lt;replace_field&gt;.
    ELSE.
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                &lt;vim_extract_struc&gt; TO &lt;replace_field&gt;.
    ENDIF.
*    ASSIGN extract+x_namtab-position(x_namtab-flength)
*                              TO &lt;replace_field&gt; TYPE x_namtab-inttype.
    IF x_header-bastab NE space AND x_header-texttbexst NE space.
      MOVE x_namtab-texttabfld TO replace_texttable_field.
    ELSE.
      CLEAR replace_texttable_field.
    ENDIF.
  ENDLOOP.
  IF replace_texttable_field EQ space. &quot;view or base table field
    CONCATENATE x_header-maintview sel_field_for_replace
       INTO sel_field_for_replace_l SEPARATED BY &apos;-&apos;.
  ELSE.                                &quot;text table field
    CONCATENATE x_header-texttab sel_field_for_replace
       INTO sel_field_for_replace_l SEPARATED BY &apos;-&apos;.
  ENDIF.
  IF x_header-frm_bf_rpl NE space.
    PERFORM (x_header-frm_bf_rpl) IN PROGRAM (sy-repid).
  ENDIF.
* SET PF-STATUS &apos;REPLACE&apos;.
  PERFORM set_pf_status USING &apos;REPLACE&apos;.
  replace_mode = &apos;X&apos;. vim_special_mode = vim_replace.
  counter = 0.
  firstline_safe = firstline.
  LOOP AT extract.                                          &quot;#EC *
    CHECK &lt;xmark&gt; EQ markiert.
    nextline = exind = sy-tabix.
    IF replace_texttable_field EQ space.  &quot;view or base table field
      CALL FUNCTION &apos;REPLACE_SET_VALUE&apos;
        EXPORTING
          old_table = &lt;vim_xextract&gt;
        IMPORTING
          new_table = &lt;table1_x&gt;.
      IF x_header-bastab NE space AND x_header-texttbexst NE space.
        &lt;table1_xtext&gt; = &lt;vim_xextract_text&gt;.
      ENDIF.
    ELSE.                              &quot;text table field
      MOVE &lt;vim_extract_struc&gt; TO &lt;table1&gt;.
      CALL FUNCTION &apos;REPLACE_SET_VALUE&apos;
        EXPORTING
          old_table = &lt;vim_xextract_text&gt;
        IMPORTING
          new_table = &lt;table1_xtext&gt;.
    ENDIF.
    CASE status-type.
      WHEN einstufig.
        CALL SCREEN liste.
      WHEN zweistufig.
        PERFORM process_detail_screen USING &apos;C&apos;.
        &lt;vim_extract_struc&gt; = &lt;table1&gt;.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
          &lt;vim_xextract_text&gt; = &lt;table1_xtext&gt;.
        ENDIF.
    ENDCASE.
    CHECK ok_code NE &apos;IGN &apos;.
    IF function EQ &apos;ABR &apos;.
      EXIT.
    ENDIF.
    counter = counter + 1.
    SUBTRACT 1 FROM mark_extract.
    SUBTRACT 1 FROM mark_total.
  ENDLOOP.
  firstline = nextline = firstline_safe.
  replace_mode = vim_special_mode = space.
  MESSAGE s012(sv) WITH counter.
  IF x_header-frm_af_rpl NE space.
    PERFORM (x_header-frm_af_rpl) IN PROGRAM (sy-repid).
  ENDIF.
ENDFORM.                    &quot;replace</include_source>
   </include>
   <include NAME="LSVIMF2P" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CONSIDER_OLD_EXCLUDE_TAB                                 *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM CONSIDER_OLD_EXCLUDE_TAB
                  TABLES NEW_EXCLUDE_TAB STRUCTURE VIMEXCLFLD.
  DATA: BEGIN OF VIEWNAME_PATTERN,
          VIEWNAME LIKE VIMDESC-VIEWNAME,
          WILDCARD(1) TYPE C VALUE &apos;*&apos;,
        END OF VIEWNAME_PATTERN.

  VIEWNAME_PATTERN-VIEWNAME = X_HEADER-MAINTVIEW.
  CONDENSE VIEWNAME_PATTERN NO-GAPS.
  LOOP AT EXCLUDE_TAB WHERE FIELD CP VIEWNAME_PATTERN.
    SHIFT EXCLUDE_TAB-FIELD UP TO &apos;-&apos;. SHIFT EXCLUDE_TAB-FIELD.
    NEW_EXCLUDE_TAB-FIELDNAME = EXCLUDE_TAB-FIELD.
    COLLECT NEW_EXCLUDE_TAB.
  ENDLOOP.
ENDFORM.                               &quot;consider_old_exclude_tab</include_source>
   </include>
   <include NAME="LSVIMF2Q" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM SUCHEN                                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM suchen.
  DESCRIBE TABLE exclude_tab.
  IF sy-tfill GT 0.                    &quot;entries in old exclude_tab
    PERFORM consider_old_exclude_tab TABLES excl_que_tab.
  ENDIF.
  CALL FUNCTION &apos;QUERY_GET_OPERATION&apos;
       EXPORTING
            table             = x_header-maintview
       TABLES
            exclude_fields    = excl_que_tab
       EXCEPTIONS
            table_not_found   = 0004
            no_valid_fields   = 0008
            cancelled_by_user = 0012.
  CASE sy-subrc.
    WHEN 0.
    WHEN 8.
      MESSAGE s039(sv) WITH view_name.
      EXIT.
    WHEN OTHERS.
      EXIT.
  ENDCASE.
  status-data   = auswahldaten.
  title-data    = auswahldaten.
  IF title-action EQ geloescht.
    status-delete = nicht_geloescht.
    title-action = aendern.
  ENDIF.
  REFRESH extract.
  LOOP AT total.
    PERFORM select USING by_field_contents.
    CHECK sy-subrc EQ 0.
    extract = total.
    APPEND extract.
  ENDLOOP.
  &lt;status&gt;-selected = by_field_contents.
  DESCRIBE TABLE extract LINES maxlines.
  nextline = 1.
  IF maxlines EQ 0.
    PERFORM fill_extract.
    MESSAGE s004(sv).
    EXIT.
  ENDIF.
  IF maxlines EQ 1.
    MESSAGE s005(sv).
    IF status-type EQ zweistufig.
      PERFORM read_table USING maxlines.
      PERFORM process_detail_screen USING &apos;S&apos;.
    ENDIF.
  ELSE.
    IF status-mode EQ detail_bild.
      vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
    ENDIF.
  ENDIF.
  MESSAGE s006(sv) WITH maxlines.
  mark_extract = 0.
  LOOP AT extract.
    IF &lt;xmark&gt; EQ markiert.
      mark_extract = mark_extract + 1.
    ENDIF.
  ENDLOOP.
  IF x_header-delmdtflag &lt;&gt; space.        &quot;SW CSS-Problem 83157/1999
    LOOP AT extract.
      LOOP AT vim_collapsed_mainkeys.
        CHECK &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_ext_mkey_beforex&gt;
         AND &lt;vim_collapsed_keyx&gt; &lt;&gt; &lt;vim_xextract_key&gt;.
*      LOOP AT vim_collapsed_mainkeys WHERE
*                mkey_bf = &lt;vim_ext_mkey_before&gt;.
*        IF vim_collapsed_mainkeys-mainkey &lt;&gt; &lt;vim_extract_key&gt;.
        DELETE vim_collapsed_mainkeys.
*        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2R" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_IF_ENTRY_CAN_BE_DELETED                            *
*---------------------------------------------------------------------*
* check if entry of existency-M-table/view can be deleted             *
*---------------------------------------------------------------------*
* SY_SUBRC &lt;-- 0: yes, deleteable, others: no, not deleteable         *
*---------------------------------------------------------------------*
FORM check_if_entry_can_be_deleted.
  LOCAL: &lt;f1_x&gt;, total, &lt;vim_xextract_key&gt;.
  DATA: hf TYPE i, rec TYPE i VALUE 8.

  &lt;vim_xextract_key&gt; = &lt;f1_x&gt; = &lt;vim_xtotal_key&gt;.
  CLEAR &lt;vim_enddate_mask&gt;.
  READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH TRANSPORTING NO FIELDS.&quot;#EC WARNOK
  hf = sy-tabix.
  LOOP AT total FROM hf.
    IF &lt;vim_tot_mkey_beforex&gt; NE &lt;vim_f1_beforex&gt; OR
       ( vim_mkey_after_exists NE space AND
         &lt;vim_tot_mkey_afterx&gt; NE &lt;vim_f1_afterx&gt; ).
*    IF &lt;vim_tot_mkey_before&gt; NE &lt;vim_f1_before&gt; OR
*       ( vim_mkey_after_exists NE space AND
*         &lt;vim_tot_mkey_after&gt; NE &lt;vim_f1_after&gt; ).
      EXIT.
    ENDIF.
    CHECK &lt;action&gt; NE geloescht AND &lt;action&gt; NE neuer_geloescht AND
          &lt;action&gt; NE update_geloescht AND
          &lt;vim_xtotal_key&gt; NE &lt;vim_xextract_key&gt;.
    CLEAR rec. EXIT.
  ENDLOOP.
  sy-subrc = rec.
ENDFORM.                               &quot;check_if_entry_can_be_deleted</include_source>
   </include>
   <include NAME="LSVIMF2S" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       LOGICAL_DELETE_FROM_TOTAL                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM logical_delete_from_total USING value(cur_index) TYPE i.
  CASE &lt;action&gt;.
    WHEN neuer_eintrag.
      &lt;action&gt;         = neuer_geloescht.
    WHEN original.
      &lt;action&gt;         = geloescht.
    WHEN aendern.
      &lt;action&gt;         = update_geloescht.
  ENDCASE.
*  perform vim_bc_logs_maintain using geloescht
*                                     x_header
*                               changing vim_bc_entry_list.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    CASE &lt;action_text&gt;.
      WHEN neuer_eintrag.
        &lt;action_text&gt;         = neuer_geloescht.
      WHEN original.
        IF &lt;vim_xtotal_text&gt; NE &lt;text_initial_x&gt;.
*        IF &lt;total_text&gt; NE &lt;text_initial&gt;.
          &lt;action_text&gt;         = geloescht.
        ELSE.
          PERFORM (vim_frm_fill_textkey) IN PROGRAM (sy-repid)
                                       USING &lt;vim_total_struc&gt;
                                             &lt;vim_tot_txt_struc&gt;.
* Unicode: Form FILL_TEXTTAB_KEY_UC instead of FILL_TEXTTAB_KEY_UC
*                                       USING &lt;vim_total_key&gt;
*                                             &lt;total_text&gt;.
          &lt;action_text&gt;         = dummy_geloescht. &quot;always del texttbent
        ENDIF.
      WHEN aendern.
        &lt;action_text&gt;         = update_geloescht.
    ENDCASE.
  ENDIF.
  &lt;mark&gt;       = nicht_markiert.
  MODIFY total INDEX cur_index.
ENDFORM.                               &quot;logical_delete_from_total</include_source>
   </include>
   <include NAME="LSVIMF2T" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_LOESCHE                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM liste_loesche.
  DATA: rec LIKE sy-subrc,
        delete_fix_value(1) TYPE c,
        entry_contains_fix_val(1) TYPE c,
        w_field TYPE vimty_fields_type,
        bc_fix_del_info_sent(1) TYPE c VALUE &apos; &apos;.

  READ TABLE extract INDEX firstline.
  IF x_header-delmdtflag &lt;&gt; space.
    &lt;vim_h_old_mkey&gt;(x_header-keylen) = &lt;vim_xextract_key&gt;.
  ENDIF.
*  vim_old_viewkey = &lt;vim_extract_key&gt;.
  counter = 0.
  LOOP AT extract.
    CHECK &lt;xmark&gt; EQ markiert.
*   -------Authority check before deleting fix values from BC-Sets------
    delete_fix_value = vim_bc_chng_allowed.
    IF vim_bc_chng_allowed = space.  &quot;fix field changeability forced
      READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
      WITH TABLE KEY viewname = x_header-viewname
      keys = &lt;vim_xextract_key&gt;.
      IF sy-subrc = 0.
        CLEAR entry_contains_fix_val.
        LOOP at vim_bc_entry_list_wa-fields into w_field.
          IF w_field-flag = vim_profile_fix.
            entry_contains_fix_val = &apos;X&apos;.
          ENDIF.
        ENDLOOP.
        IF entry_contains_fix_val = &apos;X&apos;.
          IF bc_fix_del_info_sent EQ SPACE AND
             &lt;status&gt;-bcfixdelinfosent NE &apos;Y&apos;.&quot;HCG: del dependent VCL
            bc_fix_del_info_sent = &apos;X&apos;.
            &lt;status&gt;-bcfixdelinfosent = &apos;X&apos;.
            MESSAGE i177(SV).
          ENDIF.
        ELSE.
          delete_fix_value = &apos;X&apos;.
        ENDIF.
      ELSE.
        delete_fix_value = &apos;X&apos;.
      ENDIF.
    ENDIF.
    CHECK delete_fix_value EQ &apos;X&apos;.
*   -------------------------------------------------------------&quot;HCG---
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH. &quot;#EC WARNOK
    rec = sy-tabix.
    IF x_header-existency EQ &apos;M&apos;.      &quot;no mainkey delete allowed
      PERFORM check_if_entry_can_be_deleted.
      IF sy-subrc NE 0.
        &lt;xmark&gt; = uebergehen. ignored_entries_exist = &apos;X&apos;.
        MODIFY extract.
        &lt;mark&gt; = uebergehen.
        MODIFY total INDEX rec.
        CONTINUE.
      ENDIF.
    ENDIF.
    PERFORM delete_check_keyrange.
    CASE sy-subrc.
      WHEN 0.
      WHEN 4. CONTINUE.
      WHEN 8. EXIT.
    ENDCASE.
    counter = counter + 1.
    PERFORM logical_delete_from_total USING rec.
    IF x_header-delmdtflag NE space.
      IF vim_special_mode NE vim_upgrade.
        PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                   space &lt;vim_begdate&gt;.
      ELSE.
        CLEAR sy-subrc.
      ENDIF.
      CASE sy-subrc.
        WHEN 0. DELETE extract.
        WHEN 4.
          &lt;f1_x&gt; = &lt;vim_xtotal_key&gt;. CLEAR &lt;vim_enddate_mask&gt;.
          &lt;vim_h_old_mkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
*          vim_old_viewkey = &lt;f1&gt;.
          &lt;vim_h_mkey&gt; = &lt;vim_xtotal_key&gt;.
*          vim_mainkey = &lt;vim_total_key&gt;.
          rec = 8.
          LOOP AT total.
            PERFORM select USING &lt;status&gt;-selected.
            CHECK sy-subrc EQ 0.
            CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
               ( vim_mkey_after_exists EQ space OR
               &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ). &quot;same mainkey
*            CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_f1_before&gt; AND
*                  ( vim_mkey_after_exists EQ space OR
*                    &lt;vim_tot_mkey_after&gt; EQ &lt;vim_f1_after&gt; ).
            extract = total.
            PERFORM mod_extract_and_mainkey_tab USING &apos;M&apos; 0.
            CLEAR rec.
            EXIT.
          ENDLOOP.
          IF rec NE 0.
            DELETE extract.
          ENDIF.
      ENDCASE.
    ELSE.
      DELETE extract.
    ENDIF.
    mark_total  = mark_total - 1.
    mark_extract = mark_extract - 1.
  ENDLOOP.
  CHECK vim_special_mode NE vim_upgrade.
  DESCRIBE TABLE extract LINES maxlines.
  IF status-action EQ hinzufuegen.
    SUBTRACT nbr_of_added_dummy_entries FROM maxlines.
  ENDIF.
  IF ignored_entries_exist EQ space AND maxlines GT 0.
    MESSAGE s011(sv) WITH counter.
  ELSE.
    MESSAGE i011(sv) WITH counter.
  ENDIF.
  IF x_header-delmdtflag &lt;&gt; space.
    &lt;f1_x&gt; = &lt;vim_h_old_mkey&gt;.
  ENDIF.
*  &lt;f1&gt; = vim_old_viewkey.
  READ TABLE extract WITH KEY &lt;f1_x&gt;.                        &quot;#EC WARNOK
  IF sy-subrc EQ 0.           &quot;HCG Otherwise sy-tabix = 0; HW681892
    rec = firstline + looplines - 1.
    IF sy-tabix GT rec OR nextline GT maxlines.
      nextline = sy-tabix.
    ENDIF.
  ELSE.
    nextline = 1.
  ENDIF.
  IF maxlines EQ 0 AND status-action EQ hinzufuegen.
    status-action = aendern.
    title-action = aendern.
    l = 1. o = 0.
  ENDIF.
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2U" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_CK_APPEND_WHERETAB                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_CK_APPEND_WHERETAB TABLES VCAW_WHERETAB STRUCTURE VIMWHERETB
* Changed - Parameter passed by reference - ACHACHADI - Message 0120061532 0003423301 2008
                            USING LINE TYPE VIM_CK_SELCOND.
DATA: BEGIN OF HF, F1(1) TYPE C, F2 LIKE VIMSELLIST-VALUE, F3(1) TYPE C,
                  END OF HF.
DATA: len TYPE i,l_line(134) TYPE c.
CONSTANTS: wheretab_length TYPE i VALUE 72.
  CHECK NOT LINE IS INITIAL.
  IF LINE-VALUE EQ SPACE.
    HF = &apos;&apos;&apos; &apos;&apos;&apos;.
  ELSE.
    CONCATENATE: LINE-HK1
                 LINE-VALUE
                 LINE-HK2
      INTO HF.
  ENDIF.
  CONCATENATE: LINE-FIELD
               LINE-OPERATOR
               HF
               LINE-AND
    INTO VCAW_WHERETAB SEPARATED BY SPACE.
  IF SY-SUBRC EQ 0.
    APPEND VCAW_WHERETAB.
  ELSE.
    CONCATENATE: LINE-FIELD
                 LINE-OPERATOR
      INTO VCAW_WHERETAB SEPARATED BY SPACE.
    APPEND VCAW_WHERETAB.
    CONCATENATE: HF
                 LINE-AND
      INTO l_line SEPARATED BY SPACE.
    vcaw_wheretab = l_line.
    APPEND vcaw_wheretab.
    len = strlen( l_line ).
    IF len &gt; wheretab_length.
      CLEAR vcaw_wheretab.
      vcaw_wheretab = l_line+wheretab_length.
      APPEND vcaw_wheretab.
    ENDIF.
    IF line-and &lt;&gt; space.
      vcaw_wheretab = line-and.
        APPEND VCAW_WHERETAB.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;vim_ck_append_wheretab</include_source>
   </include>
   <include NAME="LSVIMF2V" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_KEY                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM check_key.
  DATA: s LIKE sy-tabix, mess_type(1) TYPE c VALUE &apos;E&apos;, ck_tabix TYPE i,   &quot;#EC NEEDED
        ck_check_tab LIKE vimdesc-viewname, ck_slcnds_nokey(1) TYPE c,     &quot;#EC NEEDED
        ck_clause TYPE vim_ck_selcond, ck_wa TYPE REF TO data,
        ck_wheretab LIKE vimwheretb OCCURS 10, ck_rc LIKE sy-subrc,
        oc_keys TYPE occheckkeyflds, n(1) TYPE n, ocmes TYPE fieldname,
        field1 TYPE fieldname, field2 TYPE fieldname,
        field3 TYPE fieldname, field4 TYPE fieldname,
        w_oc_keys TYPE occheckkey, fieldname TYPE fnam_____4.
  FIELD-SYMBOLS: &lt;ck_1&gt; TYPE ANY, &lt;noauth&gt; TYPE fieldname,
                 &lt;namtab&gt; TYPE vimnamtab, &lt;ck_wa&gt; TYPE ANY,
                 &lt;table1_txt_loc&gt; type any.

  CHECK neuer CO &apos;JX&apos;.
  IF vim_key_alr_checked NE space.
    READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.          &quot;#EC WARNOK
    EXIT.
  ELSE.
    vim_key_alr_checked = &apos;X&apos;.
  ENDIF.
* first check namespace
  IF x_header-customauth CO sap_cust_classes OR
     vim_ale_keyspec_check NE space OR
     vim_sync_keyspec_check NE space.
    PERFORM check_allowed_keyranges.
  ENDIF.
* check if user is authorised for this key
  IF NOT vim_oc_inst IS INITIAL.
    CALL METHOD vim_oc_inst-&gt;build_key_value_tab
      EXPORTING
        entry     = &lt;table1&gt;
      IMPORTING
        keyvalues = oc_keys.
    CALL METHOD vim_oc_inst-&gt;check_oc_authority
      EXPORTING
        activity        = &apos;02&apos;
      CHANGING
        key_values      = oc_keys
      EXCEPTIONS
        no_auth         = 1
*        key_incomplete  = 2
        wrong_parameter = 3
        OTHERS          = 4.
    CASE sy-subrc.
      WHEN 1.
        PERFORM set_pf_status USING &apos;ERROR&apos;.
        CLEAR vim_key_alr_checked.
        LOOP AT oc_keys INTO w_oc_keys WHERE noauth = &apos;X&apos;.    &quot;#EC CI_SORTSEQ
          n = n + 1.
          CONCATENATE &apos;FIELD&apos; n INTO ocmes.
          IF n &lt;= &apos;4&apos;.
            ASSIGN (ocmes) TO &lt;noauth&gt;.
            READ TABLE x_namtab ASSIGNING &lt;namtab&gt; WITH KEY
             viewfield = w_oc_keys-keyname.
            CHECK sy-subrc = 0.
            IF &lt;namtab&gt;-scrtext_s &lt;&gt; space.
              &lt;noauth&gt; = &lt;namtab&gt;-scrtext_s.
            ELSE.
              &lt;noauth&gt; = w_oc_keys-keyname.
            ENDIF.
          ELSE.
*            ocmiss4 = text-001.
          ENDIF.
        ENDLOOP.
        MESSAGE e757(sv) WITH field1 field2 field3 field4.
      WHEN OTHERS.
*     MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDCASE.
  ENDIF.
* second check if entry fits selection conditions
  IF x_header-selection NE space.
    if x_header-bastab &lt;&gt; space and x_header-texttbexst &lt;&gt; space.
      assign &lt;table1_text&gt; to &lt;table1_txt_loc&gt;.
    else.
      assign &lt;table1&gt; to &lt;table1_txt_loc&gt;.
    endif.
    CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
         EXPORTING
              tabname                   = x_header-maintview
              entry                     = &lt;table1&gt;
              entry_text                = &lt;table1_txt_loc&gt;
              ddic                      = &apos;J&apos;
              key                       = &apos;J&apos;
              ignore_blank_subsetfields = &apos;N&apos;
         TABLES
              x_namtab                  = x_namtab
              x_header                  = x_header
              sellist                   = &lt;vim_ck_sellist&gt;
         EXCEPTIONS
              entry_not_fits            = 1.
    IF sy-subrc EQ 1.
      PERFORM set_pf_status USING &apos;ERROR&apos;.
      CLEAR vim_key_alr_checked.
      MESSAGE e033(sv).
    ENDIF.
  ENDIF.                               &quot;x_header-selection ne space.
* Forkey-Check for subset fields in import mode
  IF vim_called_by_cluster = space AND
   ( vim_import_mode_active &lt;&gt; space OR
     vim_special_mode = vim_upgrade ).
    CALL FUNCTION &apos;VIEW_FORKEY_CHECK&apos;
         EXPORTING
              viewname     = view_name
              entry        = &lt;table1&gt;
         TABLES
              namtab       = x_namtab
         EXCEPTIONS
              forkey_error = 1.
    IF sy-subrc EQ 1.
      PERFORM set_pf_status USING &apos;ERROR&apos;.
      CLEAR vim_key_alr_checked.
      MESSAGE ID sy-msgid TYPE &apos;E&apos; NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
* third check against TOTAL anyway
  READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.            &quot;#EC WARNOK
  ck_tabix = sy-tabix.
* fourth check against db if not found and nokey-selconds exist
  IF sy-subrc NE 0 AND                 &quot;entry not found in TOTAL and
     x_header-selection NE space AND   &quot;selconds exist and
   &lt;status&gt;-nokeyslcds NE space.       &quot;nokey-selconds: check against db
    IF x_header-bastab EQ space.
      ck_check_tab = x_header-roottab.
    ELSE.
      ck_check_tab = x_header-maintview.
    ENDIF.
    LOOP AT x_namtab WHERE keyflag NE space. &quot;all keyfields
      IF x_header-bastab NE space AND x_header-texttbexst NE space.
        CHECK x_namtab-texttabfld EQ space. &quot;ignore texttab-keyfields
      ELSEIF x_header-bastab EQ space. &quot;view -&gt; safety check langu key
        CHECK x_namtab-bastabname EQ x_header-roottab.
      ENDIF.
      PERFORM vim_ck_append_wheretab TABLES ck_wheretab
                                     USING ck_clause.
      IF x_header-bastab EQ space.
        ck_clause-field = x_namtab-bastabfld.
      ELSE.
        ck_clause-field = x_namtab-viewfield.
      ENDIF.
      ck_clause-operator = &apos;EQ&apos;.
      ck_clause-hk1 = &apos;&apos;&apos;&apos;.
      ck_clause-hk2 = &apos;&apos;&apos;&apos;.
      ck_clause-and = &apos;AND&apos;.
      IF x_namtab-inttype CO &apos;DTN&apos;.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
         TO &lt;ck_1&gt; CASTING TYPE c.
*        ASSIGN &lt;f1&gt;+x_namtab-position(x_namtab-flength) TO &lt;ck_1&gt;
*                                                        TYPE &apos;C&apos;.
*      ELSEIF x_namtab-inttype CO &apos;IPX&apos;.
      ELSE.
       CONCATENATE x_header-maintview x_namtab-viewfield INTO fieldname
           SEPARATED BY &apos;-&apos;.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
         TO &lt;ck_1&gt; CASTING TYPE (fieldname).
*        ASSIGN &lt;f1&gt;+x_namtab-position(x_namtab-flength) TO &lt;ck_1&gt;
*                                            TYPE x_namtab-inttype.
*      ELSE.
*        ASSIGN &lt;f1&gt;+x_namtab-position(x_namtab-flength) TO &lt;ck_1&gt;.
      ENDIF.
      ck_clause-value = &lt;ck_1&gt;.
      CONDENSE ck_clause-value.             &quot;IG CM 446319 2005.
    ENDLOOP.
    CLEAR ck_clause-and.
    PERFORM vim_ck_append_wheretab TABLES ck_wheretab
                                   USING ck_clause.
    CREATE DATA ck_wa TYPE (ck_check_tab).
    ASSIGN ck_wa-&gt;* TO &lt;ck_wa&gt;.
    SELECT SINGLE * INTO &lt;ck_wa&gt; FROM (ck_check_tab)        &quot;Note-1859065
                                 WHERE (ck_wheretab).
    IF sy-subrc EQ 8.                  &quot;key not qualified
      RAISE impossible_error.                               &quot;#EC FB_RAIS_EX
    ENDIF.
    ck_rc = sy-subrc.
  ELSE. &quot;entry found in TOTAL or no nokey-selconds
    ck_rc = sy-subrc.
  ENDIF.                               &quot;x_header-selection ne space.
  IF ck_rc NE 0 AND vim_called_by_cluster NE space.
    CALL FUNCTION &apos;VIEWCLUSTER_CHECK_MASTER_ENTRY&apos;
         EXPORTING
              check_entry   = &lt;table1&gt;
              view_name     = x_header-viewname
         EXCEPTIONS
              invalid_key   = 1
              invalid_value = 2.
    IF sy-subrc NE 0.
      IF status-mode EQ list_bild.
        SET CURSOR FIELD sy-msgv1 LINE l.
      ELSE.
        SET CURSOR FIELD sy-msgv1.
      ENDIF.
      CLEAR vim_key_alr_checked.
      PERFORM set_pf_status USING &apos;ERROR&apos;.
      MESSAGE ID sy-msgid TYPE &apos;E&apos; NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
  sy-subrc = ck_rc. sy-tabix = ck_tabix.
  CHECK ck_rc EQ 0.
  IF x_header-delmdtflag NE space AND status-mode EQ detail_bild.
    mess_type = &apos;S&apos;.
  ENDIF.
  PERFORM set_pf_status USING &apos;ERROR&apos;.
  CLEAR vim_key_alr_checked.
  IF &lt;action&gt; EQ geloescht
  OR &lt;action&gt; EQ neuer_geloescht
  OR &lt;action&gt; EQ update_geloescht.
    MESSAGE ID &apos;SV&apos; TYPE mess_type NUMBER &apos;010&apos;.
  ELSE.
    MESSAGE ID &apos;SV&apos; TYPE mess_type NUMBER &apos;009&apos;.
  ENDIF.
  IF x_header-delmdtflag NE space AND status-mode EQ detail_bild.
    &lt;vim_h_old_mkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
*    vim_old_viewkey = &lt;f1&gt;.
    TRANSLATE neuer USING &apos;JX&apos;.
    CLEAR: function, ok_code. LEAVE SCREEN.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2W" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM HINZUFUEGEN                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM hinzufuegen.
  DATA: h_screenmode(1) TYPE c VALUE &apos;S&apos;.
  CASE status-action.
    WHEN hinzufuegen.
      nextline = maxlines.
    WHEN aendern.
      REFRESH extract.
      maxlines = 0.
      nextline = &lt;status&gt;-cur_line = 1.
      IF status-type EQ zweistufig.
        firstline = &lt;status&gt;-firstline = nextline.
      ENDIF.
      IF vim_single_entry_function EQ &apos;INS&apos;.
        h_screenmode = &apos;C&apos;.
      ENDIF.
    WHEN OTHERS.
      MESSAGE i001(sv).
      EXIT.
  ENDCASE.
  MOVE &lt;initial&gt; TO &lt;table1&gt;.
  IF x_header-clidep NE space.
    MOVE sy-mandt TO &lt;client&gt;.
  ENDIF.
  MOVE &lt;table1&gt; TO &lt;vim_extract_struc&gt;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    MOVE: &lt;text_initial&gt; TO &lt;table1_text&gt;,
          &lt;table1_xtext&gt; TO &lt;vim_xextract_text&gt;.
*          &lt;table1_text&gt; TO &lt;extract_text&gt;.
  ENDIF.
  status-action = hinzufuegen.
  &lt;status&gt;-selected = neuer_eintrag.
  status-data   = auswahldaten.
  title-action  = hinzufuegen.
  title-data    = auswahldaten.
  neuer  = &apos;J&apos;.
  IF status-type EQ zweistufig.
    PERFORM process_detail_screen USING h_screenmode.
  ELSE.
    IF vim_single_entry_function EQ &apos;INS&apos;.
      nbr_of_added_dummy_entries = 1.
    ELSEIF looplines EQ 0.
      MOVE 50 TO nbr_of_added_dummy_entries.
    ELSE.
      MOVE looplines TO nbr_of_added_dummy_entries.
    ENDIF.
    MOVE leer TO &lt;xact&gt;. clear &lt;xmark&gt;.
    DO nbr_of_added_dummy_entries TIMES.
      APPEND extract.
    ENDDO.
    IF h_screenmode EQ &apos;S&apos;.
      SET SCREEN liste.
      LEAVE SCREEN.
    ELSE.
      CALL SCREEN liste.
    ENDIF.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2X" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_NEW_MAINKEY                                        *
*---------------------------------------------------------------------*
* check if current mainkey is a new one                               *
*---------------------------------------------------------------------*
* &lt;-- SY-SUBRC : 0 -&gt; mainkey is new, others -&gt; mainkey already exists*
*---------------------------------------------------------------------*
FORM check_new_mainkey.
  LOCAL: total, &lt;table1&gt;.
  DATA: hf TYPE i, rec TYPE i.

  MOVE: &lt;vim_xtotal_key&gt; TO &lt;f1_x&gt;.
  READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH TRANSPORTING NO FIELDS.&quot;#EC WARNOK
  IF sy-subrc EQ 0.&quot;new entry already inserted into TOTAL
    hf = sy-tabix - 1.
    READ TABLE total INDEX hf.         &quot;read previous entry
    IF &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
       ( vim_mkey_after_exists EQ space OR
         &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ). &quot;same mainkey
*    IF &lt;vim_tot_mkey_before&gt; EQ &lt;vim_f1_before&gt; AND
*       ( vim_mkey_after_exists EQ space OR
*         &lt;vim_tot_mkey_after&gt; EQ &lt;vim_f1_after&gt; ). &quot;same mainkey
      rec = 8.                         &quot;-&gt; mainkey already exists
    ELSE. &quot;not the same mainkey -&gt; check also next entry
      hf = hf + 2.
      READ TABLE total INDEX hf.       &quot;read next entry
      IF &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
         ( vim_mkey_after_exists EQ space OR
           &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ). &quot;same mainkey
*      IF &lt;vim_tot_mkey_before&gt; EQ &lt;vim_f1_before&gt; AND
*         ( vim_mkey_after_exists EQ space OR
*           &lt;vim_tot_mkey_after&gt; EQ &lt;vim_f1_after&gt; ). &quot;same mainkey
        rec = 8.                       &quot;-&gt; mainkey already exists
      ENDIF.
    ENDIF.
  ENDIF.
  sy-subrc = rec.
ENDFORM.                               &quot;check_new_mainkey</include_source>
   </include>
   <include NAME="LSVIMF2Y" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM NICHT_VORHANDEN                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM nicht_vorhanden USING rc tabind.
  DATA: dum TYPE i VALUE 0.
  FIELD-SYMBOLS &lt;tot_mkey_beforex&gt; TYPE X.

*  MOVE &lt;table1&gt; TO total.
  move &lt;table1&gt; to &lt;vim_total_struc&gt;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    MOVE &lt;table1_xtext&gt; TO &lt;vim_xtotal_text&gt;.
* nec. if special types in texttab
*    MOVE &lt;table1_text&gt; TO &lt;total_text&gt;.
    IF &lt;status&gt;-upd_flag EQ &apos;X&apos; OR &lt;status&gt;-upd_flag EQ &apos;T&apos;.
      &lt;action_text&gt; = neuer_eintrag.
    ELSE.
      CLEAR &lt;action_text&gt;.
    ENDIF.
  ENDIF.
  &lt;action&gt;          = neuer_eintrag.
  CLEAR &lt;mark&gt;.                                          &quot;HCG HW785631
  CASE rc.                                                  &quot;aro
    WHEN 0.                                                 &quot;aro
      MODIFY total INDEX tabind.  &quot;#EC *                          &quot;aro
    WHEN 4.
      INSERT total INDEX tabind. &quot;#EC *
    WHEN 8.                                                 &quot;aro
      APPEND total. &quot;#EC *
  ENDCASE.                                                  &quot;aro
  IF vim_special_mode NE vim_upgrade AND                    &quot;aro
     status-action NE kopieren.                             &quot;aro
    IF status-mode EQ list_bild.
      IF vim_single_entry_function EQ space.
        CLEAR &lt;xmark&gt;.
        APPEND extract. &quot;#EC *
      ELSE.
        nbr_of_added_dummy_entries = 0.
      ENDIF.
      extract = total.
      MODIFY extract INDEX nextline. &quot;#EC *
    ELSE.
      IF x_header-delmdtflag NE space.
        PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                   &apos;D&apos; &lt;vim_begdate&gt;.
        IF sy-subrc EQ 0.
          PERFORM check_new_mainkey.
          IF sy-subrc EQ 0.
            READ TABLE vim_collapsed_mainkeys WITH KEY &lt;vim_xtotal_key&gt; &quot;#EC WARNOK
                                             BINARY SEARCH
                                         TRANSPORTING NO FIELDS.
            &lt;vim_collapsed_keyx&gt; = &lt;vim_xtotal_key&gt;.
*           vim_collapsed_mainkeys-mainkey = &lt;vim_total_key&gt;.
            ASSIGN &lt;vim_tot_mkey_before&gt; TO &lt;tot_mkey_beforex&gt; CASTING.
* &quot;HCG      &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_before&gt;. hex=char!
            &lt;vim_collapsed_mkey_bfx&gt; = &lt;tot_mkey_beforex&gt;.
*           vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
            INSERT vim_collapsed_mainkeys INDEX sy-tabix. &quot;#EC *
          ENDIF.
          CLEAR sy-subrc.
        ENDIF.
      ENDIF.
      IF x_header-delmdtflag EQ space OR sy-subrc LT 8.
        extract = total.
        APPEND extract. &quot;#EC *
        exind = sy-tabix.
      ENDIF.
    ENDIF.
  ENDIF.                                                    &quot;aro
  neuer = &apos;N&apos;.
  DESCRIBE TABLE extract LINES maxlines.
  IF status-mode EQ list_bild.                              &quot;aro
    SUBTRACT nbr_of_added_dummy_entries FROM maxlines.
    dum = maxlines - firstline - sy-loopc + 1.              &quot;aro
    IF dum EQ 0.                                            &quot;aro
      destpage = maxlines.
    ENDIF.                                                  &quot;aro
  ENDIF.                                                    &quot;aro
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF2Z" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM UPDATE_ENTRY                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM update_entry USING value(ue_total_only).
  DATA: rec LIKE sy-subrc, tabix LIKE sy-tabix.
  tabix = sy-tabix.
  IF &lt;status&gt;-upd_flag EQ &apos;X&apos; OR &lt;status&gt;-upd_flag EQ &apos;E&apos; OR
     &lt;status&gt;-upd_flag EQ &apos;Y&apos;.
    IF x_header-customauth CO sap_cust_ctrl_classes OR
       vim_ale_keyspec_check NE space OR
       vim_sync_keyspec_check NE space.
      PERFORM check_allowed_keyranges.
    ENDIF.
    MOVE &lt;table1&gt; TO &lt;vim_total_struc&gt;.
*    WRITE &lt;table1&gt; TO total(x_header-tablen).
    IF &lt;xact&gt; EQ original.
      &lt;action&gt;          = aendern.
    ELSE.
      &lt;action&gt;          = &lt;xact&gt;.
    ENDIF.
  ENDIF.
  IF x_header-bastab NE space AND x_header-texttbexst NE space AND
     &lt;status&gt;-upd_flag EQ &apos;X&apos; OR &lt;status&gt;-upd_flag EQ &apos;T&apos; OR
     &lt;status&gt;-upd_flag EQ &apos;Y&apos;.
    IF x_header-customauth CO sap_cust_ctrl_classes OR
       vim_ale_keyspec_check NE space OR
       vim_sync_keyspec_check NE space.
      PERFORM check_allowed_keyranges.
    ENDIF.
    IF &lt;status&gt;-upd_flag NE &apos;Y&apos;.
      IF &lt;vim_xtotal_text&gt; EQ &lt;text_initial_x&gt;.
        &lt;action_text&gt; = neuer_eintrag.
      ELSE.
        IF &lt;xact_text&gt; EQ original.
          &lt;action_text&gt;          = aendern.
        ELSE.
          &lt;action_text&gt;          = &lt;xact_text&gt;.
        ENDIF.
      ENDIF.
    ENDIF.
    MOVE &lt;table1_xtext&gt; TO &lt;vim_xtotal_text&gt;.
*    MOVE &lt;table1_text&gt; TO &lt;total_text&gt;.
  ENDIF.
  IF replace_mode NE space.
    &lt;mark&gt; = nicht_markiert.
  ELSE.
    &lt;mark&gt; = &lt;xmark&gt;.
  ENDIF.
  MODIFY total  INDEX tabix.                                &quot;#EC *
  IF ue_total_only EQ space.
    IF x_header-delmdtflag NE space.
      PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                 &apos;X&apos; &lt;vim_begdate&gt;.
      rec = sy-subrc.
    ENDIF.
* do not refresh EXTRACT when there is no function &quot;SRE
* Check for STATUS-ACTION also 26.05.2008          &quot;1073364
    IF ( NOT function IS INITIAL ) OR
       ( &lt;action&gt; NE space ) OR
       ( &lt;status&gt;-upd_flag NE space ).             &quot;1245450
      &quot; Include UPD_FLAG also
      extract = total.
    ENDIF.
* End of change
    IF x_header-delmdtflag EQ space OR rec LT 8.
      IF vim_import_profile = space.
        READ TABLE extract WITH KEY &lt;vim_xextract_key&gt;      &quot;#EC WARNOK
                                              TRANSPORTING NO FIELDS.
        IF sy-tabix NE 0.
          MODIFY extract INDEX sy-tabix.                &quot;HCG HW664505
        ELSE.
          MODIFY extract INDEX index.
        ENDIF.
      ELSE.
        MODIFY extract INDEX index.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;update_entry</include_source>
   </include>
   <include NAME="LSVIMF30" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VORHANDEN                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VORHANDEN.
  PERFORM UPDATE_ENTRY USING SPACE.
ENDFORM.                               &quot;vorhanden</include_source>
   </include>
   <include NAME="LSVIMF31" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM UPDATE_TAB                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM update_tab.
  DATA: rc_safe LIKE sy-subrc, tabix LIKE sy-tabix, h_ix TYPE i,
        begdate_safe TYPE d, enddate_safe TYPE d.                    &quot;#EC NEEDED
  CHECK status-action NE anzeigen.
  CHECK status-action NE transportieren.
  CHECK status-delete NE geloescht.
  IF &lt;status&gt;-upd_flag EQ space.
    neuer = &apos;N&apos;.
    EXIT.
  ENDIF.
  IF status-type EQ einstufig AND status-action EQ hinzufuegen.
    IF ( ( x_header-bastab EQ space OR x_header-texttbexst EQ space )
           AND &lt;table2_x&gt; EQ &lt;initial_x&gt;
         OR x_header-bastab NE space AND x_header-texttbexst NE space
           AND &lt;vim_xextract_enti&gt; EQ &lt;initial_x&gt;
         OR ( vim_special_mode EQ vim_upgrade OR
           vim_single_entry_function NE space ) )
        AND &lt;xact&gt; EQ leer.            &quot;int943578/2000
      neuer = &apos;J&apos;.
    ELSE.
      neuer = &apos;N&apos;.
    ENDIF.
  ENDIF.
  IF x_header-frm_h_flds NE space.
    PERFORM (x_header-frm_h_flds) IN PROGRAM.               &quot;Zp 21
  ENDIF.
  IF neuer EQ &apos;J&apos;.
    IF x_header-guidflag &lt;&gt; space.
      PERFORM vim_make_guid USING space.
    ENDIF.
    IF x_header-frm_on_new NE space.
      PERFORM (x_header-frm_on_new) IN PROGRAM.             &quot;Zp 05
    ENDIF.
    PERFORM check_key.
    MOVE: sy-subrc TO rc_safe, sy-tabix TO tabix.
    IF x_header-adrnbrflag NE space.
      IF vim_special_mode NE vim_upgrade.
        PERFORM address_maintain.
      ELSE.
        PERFORM vim_address_adjust.
      ENDIF.
    ENDIF.
    IF vim_called_by_cluster NE space AND vim_extcopy_mode NE space.
      h_ix = nextline + 1.
      READ TABLE extract INDEX h_ix.
      DELETE extract INDEX h_ix.
      IF x_header-texttbexst &lt;&gt; space. &quot;SW Textcopy
        PERFORM vim_copy_texttab_entry USING &lt;f1_x&gt; &lt;vim_xextract_key&gt;.
      ENDIF.
      PERFORM vim_store_state_info.
      CALL FUNCTION &apos;VIEWCLUSTER_COPY_DEPENDENT&apos;
           EXPORTING
                view_name   = x_header-viewname
                maintview   = x_header-maintview
                status_mode = status-mode
                workarea    = extract
                new_entry   = &lt;table1&gt;
                no_dialog   = vim_external_mode.
    ENDIF.
    PERFORM nicht_vorhanden USING rc_safe tabix.
  ELSE.
    IF vim_special_mode EQ vim_upgrade.
      PERFORM vim_address_adjust.
    ENDIF.
    IF vim_called_by_cluster NE space.
      CALL FUNCTION &apos;VIEWCLUSTER_CHECK_MASTER_ENTRY&apos;
           EXPORTING
                check_entry   = &lt;table1&gt;
                view_name     = x_header-viewname
           EXCEPTIONS
                invalid_key   = 1
                invalid_value = 2.
      IF sy-subrc NE 0.
        IF status-mode EQ list_bild.
          SET CURSOR FIELD sy-msgv1 LINE l.
        ELSE.
          SET CURSOR FIELD sy-msgv1.
        ENDIF.
        MESSAGE ID sy-msgid TYPE &apos;E&apos; NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.
    MOVE exind TO index.
    READ TABLE total WITH KEY &lt;f1_x&gt; BINARY SEARCH.         &quot;#EC WARNOK
    IF vim_special_mode NE vim_upgrade.
      PERFORM vorhanden.               &quot;update both tables
    ELSE.
      PERFORM update_entry USING &apos;X&apos;.
    ENDIF.
  ENDIF.
  MOVE space TO &lt;status&gt;-upd_flag.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF32" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM READ_TABLE                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  IND                                                           *
*---------------------------------------------------------------------*
FORM read_table USING ind.
  IF replace_mode NE space OR vim_special_mode EQ vim_delete.
    EXIT.
  ENDIF.
  READ TABLE extract INDEX ind.
  MOVE sy-tabix TO exind.
  IF sy-subrc NE 0.
    MOVE &lt;initial&gt; TO &lt;table1&gt;.
    MOVE &lt;table1&gt; TO &lt;vim_extract_struc&gt;.
    IF x_header-bastab NE space AND x_header-texttbexst NE space.
      MOVE: &lt;text_initial_x&gt; TO &lt;vim_xextract_text&gt;,
            &lt;text_initial_x&gt; to &lt;table1_xtext&gt;.
*            &lt;table1_text&gt; TO &lt;extract_text&gt;.
    ENDIF.
    IF status-mode EQ detail_bild AND status-action EQ hinzufuegen AND
       neuer EQ &apos;N&apos;.                   &quot;e.g. &apos;PREV&apos; without input
      neuer = &apos;J&apos;.
    ENDIF.
  ELSE.
    PERFORM move_extract_to_view_wa.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF33" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_IF_ENTRY_IS_TO_DISPLAY                             *
*---------------------------------------------------------------------*
* &lt;--- SY_SUBRC - 0: display entry, expanded mode or new entry        *
*               - 4: display entry, collapsed mode and actual entry   *
*               - 8: don&apos;t display entry, collapsed mode              *
*---------------------------------------------------------------------*
FORM check_if_entry_is_to_display USING value(key_local) TYPE char01
                                        value(key_in)    TYPE any
                                        value(mod_flag)  TYPE char01
                                        value(begdate)   TYPE d.
  DATA: rec TYPE i, act_entry_flag(1) TYPE c.
  LOCAL: total, extract.
  FIELD-SYMBOLS: &lt;key_x&gt; TYPE x, &lt;key_h&gt; TYPE x.


  CLEAR: &lt;table1_wa&gt;.
  &lt;f1_wax&gt; = &lt;f1_x&gt;.
  ASSIGN: key_in TO &lt;key_h&gt; CASTING,
          &lt;key_h&gt;(x_header-keylen) TO &lt;key_x&gt;.
  MOVE &lt;key_x&gt; TO &lt;f1_x&gt;.
  IF mod_flag NE space AND
     x_header-delmdtflag EQ &apos;E&apos; AND begdate LE sy-datum AND
     &lt;vim_enddate_mask&gt; GE sy-datum OR x_header-delmdtflag EQ &apos;B&apos; AND
     begdate GE sy-datum AND &lt;vim_enddate_mask&gt; LE sy-datum.
    act_entry_flag = &apos;X&apos;.
  ENDIF.
  LOOP AT vim_collapsed_mainkeys FROM vim_coll_mainkeys_beg_ix.
    CHECK &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_f1_beforex&gt;.
*                                 WHERE mkey_bf EQ &lt;vim_f1_before&gt;.
    IF vim_mkey_after_exists NE space.
      CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_f1_afterx&gt;.
*      CHECK &lt;vim_collapsed_key_af&gt; EQ &lt;vim_f1_after&gt;.
    ENDIF.
    vim_last_coll_mainkeys_ix = sy-tabix.
    IF act_entry_flag NE space.
      IF mod_flag EQ &apos;D&apos;.
        READ TABLE extract WITH KEY &lt;vim_collapsed_keyx&gt;    &quot;#EC WARNOK
                           TRANSPORTING NO FIELDS.
        IF sy-subrc EQ 0.
          DELETE extract INDEX sy-tabix.
        ENDIF.
      ENDIF.
      IF &lt;key_x&gt; NE &lt;vim_collapsed_keyx&gt;.
*      IF key_in NE vim_collapsed_mainkeys-mainkey.
        &lt;vim_collapsed_keyx&gt; = &lt;key_x&gt;.
*        vim_collapsed_mainkeys-mainkey = key_in.
        &lt;vim_xtotal_key&gt; = &lt;key_x&gt;.
        if &lt;vim_collapsed_mkey_bfx&gt; ne &lt;vim_tot_mkey_beforex&gt;.
          &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_tot_mkey_beforex&gt;.
        endif.
*        vim_collapsed_mainkeys-mkey_bf = &lt;vim_tot_mkey_before&gt;.
        MODIFY vim_collapsed_mainkeys.
      ENDIF.
      rec = 4.
    ELSE.
      IF &lt;key_x&gt; NE &lt;vim_collapsed_keyx&gt;.
*      IF key_in NE vim_collapsed_mainkeys-mainkey.
        rec = 8.
      ELSE.
        rec = 4.
      ENDIF.
    ENDIF.
    EXIT.
  ENDLOOP.
  IF sy-subrc NE 0.
    CLEAR rec.
  ENDIF.
  IF key_local NE space.
    &lt;f1_x&gt; = &lt;f1_wax&gt;.
  ENDIF.
  sy-subrc = rec.
ENDFORM.                               &quot;check_if_entry_is_to_display</include_source>
   </include>
   <include NAME="LSVIMF35" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_AND_MODIFY_MAINKEY_TAB                             *
*---------------------------------------------------------------------*
* ...............                                                     *
*---------------------------------------------------------------------*
FORM check_and_modify_mainkey_tab USING cammt_rec.
  CHECK vim_ignore_collapsed_mainkeys EQ space.
  IF vim_no_mainkey_exists EQ vim_no_mkey_not_procsd OR
     &lt;vim_tot_mkey_beforex&gt; NE &lt;vim_mkey_beforex&gt; OR
     ( vim_mkey_after_exists NE space AND
       &lt;vim_tot_mkey_afterx&gt; NE &lt;vim_mkey_afterx&gt; ).
*     &lt;vim_tot_mkey_before&gt; NE &lt;vim_mkey_before&gt; OR
*     ( vim_mkey_after_exists NE space AND
*       &lt;vim_tot_mkey_after&gt; NE &lt;vim_mkey_after&gt; ).
    IF cammt_rec NE 9 AND cammt_rec NE 0.
      PERFORM mod_extract_and_mainkey_tab USING &apos;A&apos; 0.
      CLEAR cammt_rec.
    ENDIF.
    &lt;vim_h_mkey&gt;(x_header-keylen) = &lt;vim_xtotal_key&gt;.
*    vim_mainkey = &lt;vim_total_key&gt;.
    extract = total. &quot;this statement is necessary, do not delete it !!
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_procsd_patt.
  ELSE.
    CHECK cammt_rec NE 9 AND cammt_rec NE 0.
  ENDIF.
  PERFORM check_if_entry_is_to_display USING space &lt;vim_xtotal_key&gt;
                                             &apos;X&apos; &lt;vim_begdate&gt;.
  cammt_rec = sy-subrc.
ENDFORM.                               &quot;modify_mainkey_tab</include_source>
   </include>
   <include NAME="LSVIMF36" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM MOD_EXTRACT_AND_MAINKEY_TAB                              *
*---------------------------------------------------------------------*
*       Modify EXTRACT and mainkey table                              *
*---------------------------------------------------------------------*
FORM mod_extract_and_mainkey_tab USING value(meamt_mode) TYPE c
                                       value(meamt_index) TYPE i.
  CASE meamt_mode.
    WHEN &apos;A&apos;.
      APPEND extract.
    WHEN &apos;I&apos;.
      IF meamt_index EQ 0.
        INSERT extract.                                &quot;#EC *
      ELSE.
        INSERT extract INDEX meamt_index.
      ENDIF.
    WHEN &apos;M&apos;.
      IF meamt_index EQ 0.
        MODIFY extract.                                &quot;#EC *
      ELSE.
        MODIFY extract INDEX meamt_index.
      ENDIF.
  ENDCASE.
  LOOP AT vim_collapsed_mainkeys.
    CHECK &lt;vim_collapsed_mkey_bfx&gt; EQ &lt;vim_mkey_beforex&gt;
     AND &lt;vim_collapsed_keyx&gt; NE &lt;vim_xextract_key&gt;.
*  LOOP AT vim_collapsed_mainkeys WHERE mkey_bf EQ &lt;vim_mkey_before&gt;
*                                   AND mainkey NE &lt;vim_extract_key&gt;.
    IF vim_mkey_after_exists NE space.
      CHECK &lt;vim_collapsed_key_afx&gt; EQ &lt;vim_mkey_afterx&gt;.
*      CHECK &lt;vim_collapsed_key_af&gt; EQ &lt;vim_mkey_after&gt;.
    ENDIF.
    &lt;vim_collapsed_keyx&gt; = &lt;vim_xextract_key&gt;.
*    vim_collapsed_mainkeys-mainkey = &lt;vim_extract_key&gt;.
* changed XB. 12.06.02  BCEK060520/BCEK060521 -------begin----------
    if &lt;vim_collapsed_mkey_bfx&gt; NE &lt;vim_ext_mkey_beforex&gt;.
      &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_ext_mkey_beforex&gt;.
*    vim_collapsed_mainkeys-mkey_bf = &lt;vim_ext_mkey_before&gt;.
    endif.
* changed XB. 12.06.02  BCEK060520/BCEK060521 ---------end-----------
    MODIFY vim_collapsed_mainkeys.
  ENDLOOP.
ENDFORM.                               &quot;mod_extract_and_mainkey_tab.</include_source>
   </include>
   <include NAME="LSVIMF37" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM FILL_EXTRACT                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM FILL_EXTRACT.
  DATA: REC LIKE SY-SUBRC VALUE 9, TOTAL_SAFE(4096) TYPE C, INDEI TYPE I, &quot;#EC NEEDED
                    HF TYPE I VALUE 1.                                    &quot;#EC NEEDED
  FIELD-SYMBOLS: &lt;BEGDATE_MASK&gt;.
  REFRESH: EXTRACT. CLEAR EXTRACT.
  CLEAR VIM_MAINKEY.
  TRANSLATE VIM_NO_MAINKEY_EXISTS USING VIM_NO_MKEY_NOT_PROCSD_PATT.
  IF X_HEADER-DELMDTFLAG NE SPACE.
    ASSIGN &lt;VIM_NEW_BEGDATE&gt; TO &lt;BEGDATE_MASK&gt; TYPE &apos;C&apos;.
  ENDIF.
  LOOP AT TOTAL.
    PERFORM NORMAL_SELECT.
    CHECK SY-SUBRC EQ 0.
    IF X_HEADER-DELMDTFLAG NE SPACE AND
       VIM_IGNORE_COLLAPSED_MAINKEYS EQ SPACE.
      PERFORM CHECK_AND_MODIFY_MAINKEY_TAB USING REC.
      IF REC NE 0.
        VIM_COLL_MAINKEYS_BEG_IX = VIM_LAST_COLL_MAINKEYS_IX.
      ENDIF.
      CHECK REC LT 8.
      IF REC EQ 4. REC = 9. ENDIF.
    ENDIF.
    EXTRACT = TOTAL.
    APPEND EXTRACT.
  ENDLOOP.
  VIM_COLL_MAINKEYS_BEG_IX = 1.
  IF REC NE 9 AND REC NE 0.
    PERFORM MOD_EXTRACT_AND_MAINKEY_TAB USING &apos;A&apos; 0.
  ENDIF.
  DESCRIBE TABLE EXTRACT LINES MAXLINES.
  MARK_EXTRACT = MARK_TOTAL.
  STATUS-DATA = GESAMTDATEN.
  TITLE-DATA  = GESAMTDATEN.
  CLEAR &lt;STATUS&gt;-SELECTED.
* &lt;STATUS&gt;-DISPL_MODE = EXPANDED. &quot;default display mode
  IF MAXLINES EQ 0.
    PERFORM VIM_SEND_SV005_OR_SV766 USING &apos;766&apos;
                                          &apos;RESET&apos;.
    IF FUNCTION NE &apos;DELE&apos; AND FUNCTION NE &apos;SAVE&apos;.           &quot;HWR
      IF X_HEADER-SELECTION EQ SPACE AND FILL_EXTR_FIRST_PROC EQ SPACE.
        IF NOT VIM_OC_INST IS INITIAL
* data access restricted?
          AND ( ( &lt;STATUS&gt;-ST_ACTION = AENDERN
                AND NOT VIM_OC_INST-&gt;OC_SELCRIT_MAINT_TAB IS INITIAL )
          OR ( &apos;ST&apos; CS &lt;STATUS&gt;-ST_ACTION
                AND NOT VIM_OC_INST-&gt;OC_SELCRIT_READ_TAB IS INITIAL ) ).
          MESSAGE S766(SV).
*   Eingeschränkte Anzeige von Datensätzen.
        ELSE.
          MESSAGE S065(SV).            &quot;keine Einträge vorhanden
        ENDIF.
        MOVE &apos;X&apos; TO FILL_EXTR_FIRST_PROC.
      ELSE.
        CLEAR &lt;TABLE1&gt;.                                     &quot;GKPR/1045371
        MESSAGE S004(SV). &quot;keine Einträge gemäß Selektion gefunden
      ENDIF.
    ENDIF.                                                  &quot;HWR
    EXIT.
*  ELSEIF maxlines EQ 1.
  ELSEIF MAXLINES EQ 1 AND FUNCTION NE &apos;CMPR&apos;.              &quot;822766
    PERFORM VIM_MAINTAIN_SINGLE_SET.    &quot;UFint2329966/2000
  ELSEIF NOT VIM_OC_INST IS INITIAL AND
   FUNCTION NE &apos;DELE&apos; AND FUNCTION NE &apos;SAVE&apos;.
* data access restricted?
    IF ( &lt;STATUS&gt;-ST_ACTION = AENDERN
         AND NOT VIM_OC_INST-&gt;OC_SELCRIT_MAINT_TAB IS INITIAL )
     OR ( &apos;ST&apos; CS &lt;STATUS&gt;-ST_ACTION
          AND NOT VIM_OC_INST-&gt;OC_SELCRIT_READ_TAB IS INITIAL ).
      PERFORM VIM_SEND_SV005_OR_SV766 USING &apos;766&apos;
                                          &apos;SENDIT&apos;.
*   Eingeschränkte Anzeige von Datensätzen.
    ENDIF.
  ELSE.
    PERFORM VIM_SEND_SV005_OR_SV766 USING &apos;766&apos;
                                          &apos;RESET&apos;.
  ENDIF.
ENDFORM.                    &quot;fill_extract</include_source>
   </include>
   <include NAME="LSVIMF38" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM SELECT                                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  PARAM                                                         *
*  &lt;--  SY-SUBRC                                                      *
*---------------------------------------------------------------------*
FORM select USING param.
  FIELD-SYMBOLS: &lt;vim_tot_txt_struc_loc&gt; TYPE ANY.

  sy-subrc = 8.
  IF param EQ space AND status-action NE transportieren.
    &quot;normal selection (not deleted entries)
    PERFORM normal_select.
  ELSE.
    CASE param.
      WHEN geloescht.
        CHECK &lt;action&gt;         EQ geloescht
        OR    &lt;action&gt;         EQ neuer_geloescht
        OR    &lt;action&gt;         EQ update_geloescht.
        CLEAR sy-subrc.
        IF x_header-selection NE space.
          IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
            ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ELSE.
            ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ENDIF.
          CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
            EXPORTING
              tabname                   = x_header-maintview
              entry                     = total
              entry_text                = &lt;vim_tot_txt_struc_loc&gt;
              ddic                      = &apos;N&apos;
              key                       = &apos;N&apos;
              ignore_blank_subsetfields = &apos;N&apos;
            TABLES
              x_namtab                  = x_namtab
              x_header                  = x_header
              sellist                   = dpl_sellist
            EXCEPTIONS
              entry_not_fits            = 1
              no_value_for_subset_ident = 2.
          IF sy-subrc EQ 2.
            RAISE no_value_for_subset_ident.
          ENDIF.
        ENDIF.
      WHEN markiert.
        IF status-delete EQ geloescht.
          CHECK &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ neuer_geloescht OR
                &lt;action&gt; EQ update_geloescht.
        ENDIF.
        CHECK &lt;mark&gt;   EQ param.
        CLEAR sy-subrc.
        IF x_header-selection NE space.
          IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
            ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ELSE.
            ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ENDIF.

          CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
            EXPORTING
              tabname                   = x_header-maintview
              entry                     = total
              entry_text                = &lt;vim_tot_txt_struc_loc&gt;
              ddic                      = &apos;N&apos;
              key                       = &apos;N&apos;
              ignore_blank_subsetfields = &apos;N&apos;
            TABLES
              x_namtab                  = x_namtab
              x_header                  = x_header
              sellist                   = dpl_sellist
            EXCEPTIONS
              entry_not_fits            = 1
              no_value_for_subset_ident = 2.
          IF sy-subrc EQ 2.
            RAISE no_value_for_subset_ident.
          ENDIF.
        ENDIF.
      WHEN bcset_only.               &quot;HCG Display only data from BC-Set
        IF vim_actlinks NE x_header-viewname.
          PERFORM vim_bc_logs_get USING view_name x_header x_namtab[]
                          CHANGING vim_bc_entry_list.
          vim_actlinks = x_header-viewname.&quot;For which actlinks are valid
        ENDIF.
        READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
                 WITH TABLE KEY viewname = x_header-maintview &quot;HCG 9/04
                                  keys = &lt;vim_xtotal_key&gt;.
        IF sy-subrc NE 0. sy-subrc = 8. ENDIF.
        CHECK sy-subrc EQ 0.
        IF x_header-selection NE space.
          IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
            ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ELSE.
            ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ENDIF.
          CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
            EXPORTING
              tabname                   = x_header-maintview
              entry                     = total
              entry_text                = &lt;vim_tot_txt_struc_loc&gt;
              ddic                      = &apos;N&apos;
              key                       = &apos;N&apos;
              ignore_blank_subsetfields = &apos;N&apos;
            TABLES
              x_namtab                  = x_namtab
              x_header                  = x_header
              sellist                   = dpl_sellist
            EXCEPTIONS
              entry_not_fits            = 1
              no_value_for_subset_ident = 2.
          IF sy-subrc EQ 2.
            RAISE no_value_for_subset_ident.
          ENDIF.
        ENDIF.
      WHEN by_field_contents.
        PERFORM normal_select.
        CHECK sy-subrc EQ 0.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
* table with texttable
          CALL FUNCTION &apos;QUERY_CHECK&apos;
            EXPORTING
              record            = &lt;vim_total_struc&gt;
              textrecord        = &lt;vim_tot_txt_struc&gt;
            EXCEPTIONS                                      &quot;#EC FB_RC
              no_hits_in_record = 4
              parameter_error   = 8.
        ELSE.
* view or single table
          CALL FUNCTION &apos;QUERY_CHECK&apos;
               EXPORTING
                    record            = &lt;vim_total_struc&gt;
*                  record            = total
               EXCEPTIONS                                   &quot;#EC FB_RC
                    no_hits_in_record = 4
                    parameter_error   = 8.
        ENDIF.
      WHEN OTHERS.                     &quot;neuer_eintrag or aendern
       IF x_header-bastab NE space AND x_header-texttbexst NE space AND
                  param EQ aendern.
          CHECK &lt;action&gt; EQ param OR &lt;action_text&gt; EQ param OR
                &lt;action&gt; NE neuer_eintrag AND
                &lt;action_text&gt; EQ neuer_eintrag.
        ELSE.
          CHECK &lt;action&gt; EQ param.
        ENDIF.
        CLEAR sy-subrc.
        IF x_header-selection NE space.
          IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
            ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ELSE.
            ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
          ENDIF.

          CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
            EXPORTING
              tabname                   = x_header-maintview
              entry                     = total
              entry_text                = &lt;vim_tot_txt_struc_loc&gt;
              ddic                      = &apos;N&apos;
              key                       = &apos;N&apos;
              ignore_blank_subsetfields = &apos;N&apos;
            TABLES
              x_namtab                  = x_namtab
              x_header                  = x_header
              sellist                   = dpl_sellist
            EXCEPTIONS
              entry_not_fits            = 1
              no_value_for_subset_ident = 2.
          IF sy-subrc EQ 2.
            RAISE no_value_for_subset_ident.
          ENDIF.
        ENDIF.
    ENDCASE.
  ENDIF.&quot;param eq space and status-action ne transportieren
ENDFORM.                    &quot;select</include_source>
   </include>
   <include NAME="LSVIMF39" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM NORMAL_SELECT                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
* &lt;--- sy-subrc                                                       *
*---------------------------------------------------------------------*
FORM normal_select.
  FIELD-SYMBOLS: &lt;ns_tab&gt; TYPE table, &lt;vim_tot_txt_struc_loc&gt; TYPE ANY.
  sy-subrc = 8.
  CHECK &lt;action&gt; NE neuer_geloescht
    AND &lt;action&gt; NE update_geloescht
    AND &lt;action&gt; NE geloescht.
  CLEAR sy-subrc.
  IF x_header-selection NE space.
    IF vim_special_adjust_mode NE space.
      ASSIGN dba_sellist[] TO &lt;ns_tab&gt;.
    ELSE.
      ASSIGN dpl_sellist[] TO &lt;ns_tab&gt;.
    ENDIF.
    IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
      ASSIGN &lt;vim_tot_txt_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
    ELSE.
      ASSIGN &lt;vim_total_struc&gt; TO &lt;vim_tot_txt_struc_loc&gt;.
    ENDIF.
    CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
      EXPORTING
        tabname                   = x_header-maintview
        entry                     = total
        entry_text                = &lt;vim_tot_txt_struc_loc&gt;
        ddic                      = &apos;N&apos;
        key                       = &apos;N&apos;
        ignore_blank_subsetfields = &apos;N&apos;
      TABLES
        x_namtab                  = x_namtab
        x_header                  = x_header
        sellist                   = &lt;ns_tab&gt;
      EXCEPTIONS
        entry_not_fits            = 1
        no_value_for_subset_ident = 2.
    IF sy-subrc EQ 2.
      RAISE no_value_for_subset_ident.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;NORMAL_SELECT</include_source>
   </include>
   <include NAME="LSVIMF3A" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM SELEKTIERE                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  PARAM                                                         *
*---------------------------------------------------------------------*
FORM selektiere USING param.
  DATA: rec LIKE sy-subrc VALUE 9, s_screenmode(1) TYPE c VALUE &apos;S&apos;. &quot;#EC NEEDED
  IF status-action EQ hinzufuegen.
    status-action = aendern.
    title-action = aendern.
  ENDIF.
  IF status-mode EQ detail_bild.
    PERFORM update_tab.
  ENDIF.
  REFRESH extract. CLEAR vim_mainkey. l = 1.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  LOOP AT total.
    PERFORM select USING param.
    CHECK sy-subrc EQ 0.
    IF x_header-delmdtflag NE space.
      PERFORM check_and_modify_mainkey_tab USING rec.
      IF rec NE 0.
        vim_coll_mainkeys_beg_ix = vim_last_coll_mainkeys_ix.
      ENDIF.
      CHECK rec LT 8.
      IF rec EQ 4. rec = 9. ENDIF.
    ENDIF.
    extract = total.
    APPEND extract.
  ENDLOOP.
  vim_coll_mainkeys_beg_ix = 1.
  IF rec NE 9 AND rec NE 0.
    PERFORM mod_extract_and_mainkey_tab USING &apos;A&apos; 0.
  ENDIF.
  IF param EQ geloescht.
    status-delete = geloescht.
    title-action  = geloescht.
  ENDIF.
  &lt;status&gt;-selected = param.
  DESCRIBE TABLE extract LINES maxlines.
  status-data   = auswahldaten.
  title-data    = auswahldaten.
  nextline = 1.
  IF maxlines EQ 0.
    status-delete = nicht_geloescht.
    title-action  = nicht_geloescht.
    PERFORM fill_extract.
    PERFORM set_pf_status USING status.
    MESSAGE i004(sv).
    SET SCREEN liste.
    LEAVE SCREEN.
  ENDIF.
  IF maxlines EQ 1.
    MESSAGE s005(sv).
    IF vim_single_entry_function NE space.
      IF status-type EQ zweistufig.
        &lt;status&gt;-firstline = &lt;status&gt;-cur_line = nextline.
        PERFORM process_detail_screen USING &apos;C&apos;.
      ELSE.
        CALL SCREEN liste.
      ENDIF.
    ELSE.
      IF status-type EQ zweistufig.
        &lt;status&gt;-firstline = &lt;status&gt;-cur_line = nextline.
        PERFORM process_detail_screen USING &apos;S&apos;.
      ENDIF.
    ENDIF.
  ELSE.
    IF status-mode EQ detail_bild.
      vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
    ENDIF.
    MESSAGE s006(sv) WITH maxlines.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3B" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM LOGICAL_UNDELETE_TOTAL                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM logical_undelete_total USING value(cur_index) TYPE i.
  CASE &lt;action&gt;.
    WHEN neuer_geloescht.
      &lt;action&gt; = neuer_eintrag.
    WHEN geloescht.
      &lt;action&gt; = original.
    WHEN update_geloescht.
      &lt;action&gt; = aendern.
  ENDCASE.
*  perform vim_bc_logs_maintain using zurueckholen
*                                           x_header
*                                     changing vim_bc_entry_list.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    CASE &lt;action_text&gt;.
      WHEN neuer_geloescht.
        &lt;action_text&gt;         = neuer_eintrag.
      WHEN geloescht.
        &lt;action_text&gt;         = original.
      WHEN update_geloescht.
        &lt;action_text&gt;         = aendern.
      WHEN dummy_geloescht.
        &lt;action_text&gt;         = original.
        &lt;vim_xtotal_text&gt; = &lt;text_initial_x&gt;.
*        &lt;TOTAL_TEXT&gt; = &lt;TEXT_INITIAL&gt;.
    ENDCASE.
  ENDIF.
  &lt;mark&gt; = nicht_markiert.
  MODIFY total INDEX cur_index.
ENDFORM.                               &quot;logical_undelete_total</include_source>
   </include>
   <include NAME="LSVIMF3C" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_ZURUECKHOLEN                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM LISTE_ZURUECKHOLEN.
  DATA: IX TYPE I.
* IF STATUS-ACTION NE AENDERN OR STATUS-DELETE NE GELOESCHT.
*   MESSAGE I001(SV).
*   EXIT.
* ENDIF.
  COUNTER = 0.
  LOOP AT EXTRACT.
    CHECK &lt;XMARK&gt; EQ MARKIERT.
    IF X_HEADER-DELMDTFLAG NE SPACE.
      IX = SY-TABIX.
      PERFORM MOVE_EXTRACT_TO_VIEW_WA.
      PERFORM TEMPORAL_DELIMITATION.
    ENDIF.
    COUNTER = COUNTER + 1.
    READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.&quot;#EC WARNOK
    PERFORM LOGICAL_UNDELETE_TOTAL USING SY-TABIX.
    MARK_TOTAL  = MARK_TOTAL - 1.
    MARK_EXTRACT = MARK_EXTRACT - 1.
    IF REPLACE_MODE NE SPACE AND VIM_EXTERNAL_MODE EQ SPACE.
      &lt;XACT&gt; = &lt;ACTION&gt;. &lt;XMARK&gt; = NICHT_MARKIERT.
      MODIFY EXTRACT.                  &quot;no deletion in upgrade mode
    ELSE.
      IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE.
        CLEAR VIM_DELIM_ENTRIES.
        VIM_DELIM_ENTRIES-INDEX3 = IX.
        APPEND VIM_DELIM_ENTRIES.
      ELSE.
        DELETE EXTRACT.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE.
    PERFORM AFTER_TEMPORAL_DELIMITATION.
    CLEAR TEMPORAL_DELIMITATION_HAPPENED.
  ENDIF.
  CHECK REPLACE_MODE EQ SPACE.
  DESCRIBE TABLE EXTRACT LINES MAXLINES.
  IF IGNORED_ENTRIES_EXIST EQ SPACE.
    MESSAGE S002(SV) WITH COUNTER.
  ELSE.
    MESSAGE W002(SV) WITH COUNTER.
  ENDIF.
  IF MAXLINES EQ 0.
    TITLE-ACTION = AENDERN.
    STATUS-DELETE = NICHT_GELOESCHT.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3D" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM MARKIERE_ALLE                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  ACTION                                                        *
*---------------------------------------------------------------------*
FORM MARKIERE_ALLE USING ACTION.
  CHECK MAXLINES NE 0.
  LOOP AT EXTRACT.
    CHECK &lt;XACT&gt; NE LEER.
    CHECK &lt;XMARK&gt; NE ACTION.
    READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.&quot;#EC WARNOK
    &lt;XMARK&gt; = ACTION.
    &lt;MARK&gt;  = ACTION.
    MODIFY TOTAL INDEX SY-TABIX.
    MODIFY EXTRACT.
    IF ACTION EQ MARKIERT.
      ADD: 1 TO MARK_EXTRACT,
           1 TO MARK_TOTAL.
    ELSE.
      SUBTRACT: 1 FROM MARK_EXTRACT,
                1 FROM MARK_TOTAL.
      CLEAR BLOCK_SW.
    ENDIF.
  ENDLOOP.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3E" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM MARKIERE                                                 *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  I                                                             *
*---------------------------------------------------------------------*
FORM MARKIERE USING I.
  READ TABLE EXTRACT INDEX I.
  READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.&quot;#EC WARNOK
  IF &lt;XMARK&gt; EQ MARKIERT.
    &lt;XMARK&gt; = NICHT_MARKIERT.
    &lt;MARK&gt;  = NICHT_MARKIERT.
    MARK_EXTRACT = MARK_EXTRACT - 1.
    MARK_TOTAL  = MARK_TOTAL  - 1.
  ELSE.
    &lt;XMARK&gt; = MARKIERT.
    &lt;MARK&gt;  = MARKIERT.
    MARK_EXTRACT = MARK_EXTRACT + 1.
    MARK_TOTAL  = MARK_TOTAL  + 1.
  ENDIF.
  MODIFY TOTAL INDEX SY-TABIX.
  MODIFY EXTRACT INDEX I.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3F" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM MARKIERE_BLOCK                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM MARKIERE_BLOCK.
  INDEX = FIRSTLINE + L - 1.
  IF L EQ 0 OR INDEX GT MAXLINES.
    MESSAGE S032(SV).
    EXIT.
  ENDIF.
  PERFORM MARKIERE USING INDEX.
  IF BLOCK_SW EQ MARKIERT.
    BLOCK_2 = INDEX.
    BLOCK_SW = NICHT_MARKIERT.
  ELSE.
    BLOCK_1 = INDEX.
    BLOCK_SW = MARKIERT.
    MESSAGE S066(SV).                  &quot;Bitte Blockende markieren
    EXIT.
  ENDIF.
  COUNTER = 0.
  LOOP AT EXTRACT.
    COUNTER = COUNTER + 1.
    IF BLOCK_1 LE BLOCK_2.
      CHECK COUNTER BETWEEN BLOCK_1 AND BLOCK_2.
    ELSE.
      CHECK COUNTER BETWEEN BLOCK_2 AND BLOCK_1.
    ENDIF.
    READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.&quot;#EC WARNOK
    IF &lt;XMARK&gt; NE MARKIERT.
      MARK_EXTRACT = MARK_EXTRACT + 1.
      MARK_TOTAL  = MARK_TOTAL  + 1.
    ENDIF.
    &lt;XMARK&gt; = MARKIERT.
    &lt;MARK&gt;  = MARKIERT.
    MODIFY TOTAL INDEX SY-TABIX.
    MODIFY EXTRACT.
  ENDLOOP.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3G" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_MARKIERE                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM LISTE_MARKIERE.
  INDEX = FIRSTLINE + L - 1.
  IF L EQ 0 OR INDEX GT MAXLINES.
    MESSAGE S032(SV).
    EXIT.
  ENDIF.
  PERFORM MARKIERE USING INDEX.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3H" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM F4_POSITIONIEREN                                         *
*---------------------------------------------------------------------*
*       called externally from POPUP_GET_VALUES_USER_HELP             *
*---------------------------------------------------------------------*
form f4_positionieren using value(tabname) type tabname                            &quot;#EC NEEDED
                            value(fieldname) type fieldname
                            value(display)
                      changing returncode                                          &quot;#EC NEEDED
                               value type any.
  statics: field_tab type table of dfies initial size 20.

  data: tabval(132) type c,
        v_tab like table of tabval initial size 500,
        w_dfies type dfies,
        return_tab type table of ddshretval initial size 1,
        begin of out_conv_function,                                                &quot;#EC NEEDED
         prefix(16) type c value &apos;CONVERSION_EXIT_&apos;,
         exit like vimnamtab-convexit,
         suffix(7) type c value &apos;_OUTPUT&apos;,
        end of out_conv_function,
        f4_length type i,    &quot;total length of to be displayed fields               &quot;#EC NEEDED
        progname type sy-repid,                                   &quot;#EC NEEDED
        value_bef_f4 type help_info-fldvalue.

  data: begin of  dynpfields  occurs 1.                     &quot;BEGIN GKPR/1020911
          include structure dynpread.
  data: end of dynpfields.
  data: sy_repid like sy-repid,
        sy_dynnr like sy-dynnr.                             &quot;END GKPR/1020911

  field-symbols: &lt;hf1&gt;, &lt;dfies&gt; type dfies, &lt;retval&gt; type ddshretval.

  move &apos;SAPLSPO4&apos; to sy_repid.                              &quot;BEGIN GKPR/1020911
* BEGIN 563161 2008/DUTTAN/08.07.2008
* move &apos;0300&apos; to sy_dynnr.
  move sy-dynnr to sy_dynnr.
* END 563161 2008
  move &apos;SVALD-VALUE&apos; to dynpfields-fieldname.
*  dynpfields-stepl = 1.                                   &quot;GKPR/1021700
  append dynpfields.
  call function &apos;DYNP_VALUES_READ&apos;
            exporting
              dyname                         = sy_repid
              dynumb                         = sy_dynnr
*             TRANSLATE_TO_UPPER             = &apos; &apos;
*             REQUEST                        = &apos; &apos;
*             PERFORM_CONVERSION_EXITS       = &apos; &apos;
*             PERFORM_INPUT_CONVERSION       = &apos; &apos;
*             DETERMINE_LOOP_INDEX           = &apos; &apos;
            tables
              dynpfields                     = dynpfields
           exceptions
              invalid_abapworkarea           = 1
              invalid_dynprofield            = 2
              invalid_dynproname             = 3
              invalid_dynpronummer           = 4
              invalid_request                = 5
              no_fielddescription            = 6
              invalid_parameter              = 7
              undefind_error                 = 8
              double_conversion              = 9
              stepl_not_found                = 10
              others                         = 11.
  if sy-subrc &lt;&gt; 0.
    message i089(ec).
  endif.

  if sy-subrc eq 0.
    read table dynpfields index 1.
    move: dynpfields-fieldvalue to value_bef_f4.
  endif.                                                    &quot;END GKPR/1020911

  read table field_tab index 1 assigning &lt;dfies&gt;.
  if sy-subrc &lt;&gt; 0 or &lt;dfies&gt;-tabname &lt;&gt; x_header-maintview.
    refresh field_tab.

* xb  06.02 csn ext.237151 2002, BCEK061005 ---------begin----------
* check the total display length of F4-List
    f4_length = 0.
    if x_header-tablen &gt; 1000.
      loop at x_namtab.
        if x_header-clidep ne space.       &quot;ignore client field
          check sy-tabix ne 1.
        endif.
        if x_namtab-keyflag ne space or    &quot;all key fields or
           x_namtab-datatype eq &apos;CHAR&apos; and &quot;all possibly text fields
           x_namtab-flength  ge 10     and
           x_namtab-lowercase  ne space.

          f4_length = f4_length + x_namtab-outputlen.
        endif.
      endloop.
    endif.

    if f4_length &lt; 1000.          &quot;check the fields length
* xb  06.02 csn ext.237151 2002, BCEK061005 ----------end-----------
      loop at x_namtab.
        if x_header-clidep ne space.       &quot;ignore client field
          check sy-tabix ne 1.
        endif.
        check x_namtab-readonly &lt;&gt; vim_hidden.                  &quot;Subviews
        if x_header-bastab ne space and x_header-texttbexst ne space.
          check x_namtab-keyflag ne space and   &quot;all entity keyfields
                x_namtab-texttabfld eq space or                 &quot;or
            x_namtab-keyflag eq space and   &quot;all texttab function fields
                x_namtab-texttabfld ne space.
        else.
          check x_namtab-keyflag ne space or    &quot;all key fields or
               x_namtab-datatype eq &apos;CHAR&apos; and &quot;all possibly text fields
                x_namtab-flength  ge 10     and
                x_namtab-lowercase  ne space.
        endif.
        if x_namtab-texttabfld ne space.
          w_dfies-tabname = x_header-texttab.
        else.
          w_dfies-tabname = x_header-maintview.              &quot;Subviews
        endif.
        w_dfies-fieldname = x_namtab-viewfield.
        append w_dfies to field_tab.
      endloop.
    else.
* xb  06.02 csn ext.237151 2002, BCEK061005 ---------begin----------
      message i810(sv) with x_header-viewname.
*   Die gesamte Länge der View &amp; ist mehr als 1000 Charakter. Nur Key
*   Field wird gezeigt.
      loop at x_namtab.
        if x_header-clidep ne space.       &quot;ignore client field
          check sy-tabix ne 1.
        endif.
        check x_namtab-readonly &lt;&gt; vim_hidden.                  &quot;Subviews
        if x_header-bastab ne space and x_header-texttbexst ne space.
          check x_namtab-keyflag ne space and   &quot;all entity keyfields
                x_namtab-texttabfld eq space or                 &quot;or
            x_namtab-keyflag eq space and   &quot;all texttab function fields
                x_namtab-texttabfld ne space.
        else.
          check x_namtab-keyflag ne space.    &quot;all key fields
        endif.
        if x_namtab-texttabfld ne space.
          w_dfies-tabname = x_header-texttab.
        else.
          w_dfies-tabname = x_header-maintview.              &quot;Subviews
        endif.
        w_dfies-fieldname = x_namtab-viewfield.
        append w_dfies to field_tab.
      endloop.
* xb  06.02 csn ext.237151 2002, BCEK061005 ----------end-----------
    endif.
  endif.


  loop at extract.
    loop at field_tab assigning &lt;dfies&gt;.
      read table x_namtab with key viewfield = &lt;dfies&gt;-fieldname.
      if x_header-bastab ne space and x_header-texttbexst ne space.
        if x_namtab-keyflag eq space and x_namtab-texttabfld ne space.
* Type S: text field
          assign component x_namtab-viewfield
           of structure &lt;vim_ext_txt_struc&gt; to &lt;hf1&gt;.
        elseif x_namtab-keyflag ne space
         and x_namtab-texttabfld eq space.
* Type S: key field
          assign component x_namtab-viewfield
           of structure &lt;vim_extract_struc&gt; to &lt;hf1&gt;.
        endif.
      else.
* viewfield
        assign component x_namtab-viewfield
         of structure &lt;vim_extract_struc&gt; to &lt;hf1&gt;.
      endif.
      check &lt;hf1&gt; is assigned.
*        IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
*          CHECK X_NAMTAB-KEYFLAG NE SPACE AND   &quot;all entity keyfields
*                X_NAMTAB-TEXTTABFLD EQ SPACE OR             &quot;or
*                X_NAMTAB-KEYFLAG EQ SPACE AND   &quot;all texttab function
*                X_NAMTAB-TEXTTABFLD NE SPACE.
*        ENDIF.
*        ASSIGN EXTRACT+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH) TO &lt;HF1&gt;
*               TYPE &apos;C&apos;.
      write &lt;hf1&gt; to tabval(x_namtab-outputlen).
      append tabval to v_tab.
      clear tabval.
    endloop.
  endloop.
*  &quot;HCG Look first in valuetable of tables  for V_TCURR (Performance)
*  &quot;HCG Special handling due to cust issues 272054/2003 or 130305/2000
  if x_header-viewname = &apos;V_TCURR&apos;.
    read table x_namtab with key viewfield = fieldname.
    call function &apos;F4IF_FIELD_VALUE_REQUEST&apos;
            exporting
                tabname             = x_namtab-bastabname
                fieldname           = fieldname
*            SEARCHHELP          = &apos; &apos;
*            SHLPPARAM           = &apos; &apos;
*            dynpprog            = progname
*            dynpnr              = dynnr
*            dynprofield         = &apos; &apos;
*            stepl               = dynp_stepl
             value               = value_bef_f4             &quot;GKPR/1020911
*            MULTIPLE_CHOICE     = &apos; &apos;
*            DISPLAY             = &apos; &apos;
*            SUPPRESS_RECORDLIST = &apos; &apos;
*              callback_program    = progname
*              callback_form       = &apos;CALLBACK_F4&apos;
           tables
                return_tab          = return_tab
           exceptions
                field_not_found     = 1
                no_help_for_field   = 2
                inconsistent_help   = 3
                no_values_found     = 4
                others              = 5.
    case sy-subrc.
      when 0.
        read table return_tab index 1 assigning &lt;retval&gt;.
        if sy-subrc = 0.
          value = &lt;retval&gt;-fieldval.
        endif.
      when others.
*     should not happen for V_TCURR
       message id sy-msgid type sy-msgty number sy-msgno  &quot;n1542679 PATIDARP
         with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    endcase.
  else.
    call function &apos;F4IF_INT_TABLE_VALUE_REQUEST&apos;
      exporting
*     DDIC_STRUCTURE         = &apos; &apos;
        retfield               = fieldname
*     PVALKEY                = &apos; &apos;
*     DYNPPROG               = &apos; &apos;
*     DYNPNR                 = &apos; &apos;
*     DYNPROFIELD            = &apos; &apos;
*     STEPL                  = 0
*     WINDOW_TITLE           =
      value                  = value_bef_f4                 &quot;GKPR/1020911
*     VALUE_ORG              = &apos;C&apos;
*     MULTIPLE_CHOICE        = &apos; &apos;
        display                = display
*     CALLBACK_PROGRAM       = &apos; &apos;
*     CALLBACK_FORM          = &apos; &apos;
*     MARK_TAB               =
      tables
        value_tab              = v_tab
        field_tab              = field_tab
        return_tab             = return_tab
*     DYNPFLD_MAPPING        =
      exceptions
        parameter_error        = 1
        no_values_found        = 2
        others                 = 3.
    if sy-subrc = 0.
      read table return_tab index 1 assigning &lt;retval&gt;.
      if sy-subrc = 0.
        value = &lt;retval&gt;-fieldval.
      endif.
    else.
      message id sy-msgid type sy-msgty number sy-msgno
              with sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    endif.
  endif.
endform.                               &quot;f4_positionieren</include_source>
   </include>
   <include NAME="LSVIMF3I" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM POPUP_POSITIONIEREN                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM popup_positionieren.
  DATA: pp_program LIKE sy-repid, hf1 TYPE i, hf2 TYPE i,
        dummy type xfeld.                          &quot;#EC NEEDED

  IF status-action NE anzeigen AND status-action NE transportieren
  AND status-mode NE list_bild.
    PERFORM update_tab.
  ENDIF.
  pp_program = sy-repid.
  &lt;table1&gt; = &lt;initial&gt;.
  CALL FUNCTION &apos;TABLE_GET_KEY_TO_SET_CUR_ROW&apos;
       EXPORTING
            table             = x_header-maintview          &quot;Subviews
            f4_programname    = pp_program
            f4_formname       = &apos;F4_POSITIONIEREN&apos;
       IMPORTING
            table_key         = dummy
       TABLES
            sellist           = &lt;vim_ck_sellist&gt;
            exclude_fields    = excl_pos_tab
       CHANGING
            table_key_new     = &lt;f1_x&gt;
       EXCEPTIONS
            cancelled_by_user = 01
            table_not_found   = 02.
  CHECK sy-subrc EQ 0000.
  IF x_header-frm_h_flds NE space.
    PERFORM (x_header-frm_h_flds) IN PROGRAM. &quot;#EC *
  ENDIF.
  IF x_header-frm_rp_pos NE space.
    PERFORM (x_header-frm_rp_pos) IN PROGRAM. &quot;#EC *
  ELSEIF status-action EQ hinzufuegen AND status-mode EQ list_bild.
    nextline = 0.
    LOOP AT extract. &quot;#EC *
      IF &lt;xact&gt; EQ leer. EXIT. ENDIF.
*      CHECK &lt;vim_extract_key&gt; LE &lt;f1&gt;.
      CHECK &lt;vim_xextract_key&gt; LE &lt;f1_x&gt;.
      hf1 = sy-tabix.
      CHECK &lt;vim_xextract_key&gt; EQ &lt;f1_x&gt;.
      nextline = sy-tabix. EXIT.
    ENDLOOP.
    IF nextline EQ 0.
      IF hf1 EQ maxlines.
        nextline = hf1.
      ELSE.
        nextline = hf1 + 1.
      ENDIF.
    ENDIF.
  ELSE.
*    READ TABLE extract WITH KEY &lt;f1&gt; BINARY SEARCH
*                                     TRANSPORTING NO FIELDS.
    READ TABLE extract WITH KEY &lt;f1_x&gt; BINARY SEARCH                &quot;#EC WARNOK
                                       TRANSPORTING NO FIELDS.
    nextline = sy-tabix.
    CLEAR old_nl.                                           &quot;GKPR - 0001009660
    IF sy-subrc = 8 AND nextline GT 1.
      nextline = nextline - 1.                              &quot;last entry
    ENDIF.
  ENDIF.
  IF status-mode EQ detail_bild.
    READ TABLE extract INDEX nextline.   &quot;#EC *                   &quot;ufdetailb
    IF &lt;xmark&gt; &lt;&gt; markiert.
      CLEAR &lt;status&gt;-mark_only.
    ENDIF.                                                  &quot;ufdetaile
    hf2 = firstline + looplines - 1.
    IF looplines EQ 0.
      l = 1. MOVE: l TO &lt;status&gt;-cur_line,
                   nextline TO &lt;status&gt;-firstline.
      hf1 = 0.
    ELSEIF nextline GE firstline AND nextline LE hf2.
* nothing to scroll.
    ELSEIF nextline LT firstline.                  &quot;xb2002 int405493/99
* if the nextline less than firstline, move the nextline to firstline.
      firstline = nextline.
    ELSE.                                           &quot;xb2002 int405493/99
* if the nextline larger than firstline, move the nextline to firstline.
       firstline = nextline.
    ENDIF.
    l = nextline - firstline + 1.
    MOVE: firstline TO &lt;status&gt;-firstline,
          l         TO &lt;status&gt;-cur_line.
  ELSE.
    MOVE 1 TO l.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3J" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM CHECK_UPD                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM CHECK_UPD.
  data: leave.
  CHECK STATUS-ACTION NE ANZEIGEN.
  IF &lt;STATUS&gt;-UPD_FLAG EQ SPACE.
    IF STATUS-ACTION EQ TRANSPORTIEREN.
      MOVE &lt;STATUS&gt;-KEYTBMODFD TO &lt;STATUS&gt;-UPD_FLAG.
    ELSE.
      LOOP AT TOTAL.
*       CHECK &lt;ACTION&gt; NE NEUER_GELOESCHT AND &lt;ACTION&gt; NE ORIGINAL.
        CHECK &lt;ACTION&gt; NE ORIGINAL.
        MOVE &apos;X&apos; TO &lt;STATUS&gt;-UPD_FLAG.
        EXIT.
      ENDLOOP.
      IF &lt;STATUS&gt;-UPD_FLAG EQ SPACE AND X_HEADER-BASTAB NE SPACE AND
         X_HEADER-TEXTTBEXST NE SPACE.
        LOOP AT TOTAL.
*         CHECK &lt;ACTION_TEXT&gt; NE NEUER_GELOESCHT AND
          CHECK &lt;ACTION_TEXT&gt; NE ORIGINAL.
          MOVE &apos;X&apos; TO &lt;STATUS&gt;-UPD_FLAG.
          EXIT.
        ENDLOOP.
      ENDIF.
      IF &lt;STATUS&gt;-UPD_FLAG EQ SPACE AND X_HEADER-TEXTTBEXST &lt;&gt; SPACE.
        PERFORM VIM_CHECK_UPD_TEXTTAB. &quot;SW Texttransl
      ENDIF.
      IF &lt;STATUS&gt;-UPD_FLAG EQ SPACE AND X_HEADER-ADRNBRFLAG EQ &apos;N&apos;.
        DESCRIBE TABLE VIM_ADDRESSES_TO_SAVE.
        IF SY-TFILL GT 0.
          MOVE &apos;X&apos; TO &lt;STATUS&gt;-UPD_FLAG.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
  IF X_HEADER-FRM_AF_CHK NE SPACE AND STATUS-ACTION NE TRANSPORTIEREN.
    PERFORM (X_HEADER-FRM_AF_CHK) IN PROGRAM (SY-REPID).
  ENDIF.
  if &lt;status&gt;-upd_flag = space and vim_called_by_cluster = space and
   ( function = back OR function = end ).
    perform vim_add_img_notices_pai using &apos;E&apos;
                                    changing leave.
    if leave = space.
      clear function.
    endif.
  endif.
  MOVE &apos;X&apos; TO &lt;STATUS&gt;-UPD_CHECKD.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3K" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM BLAETTERN                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM BLAETTERN.
  DATA: B_OVERLAPPING(1) TYPE C VALUE &apos;X&apos;.
  IF MAXLINES EQ 0.
    EXIT.
  ENDIF.
  IF STATUS-ACTION EQ KOPIEREN OR LOOPLINES EQ 1.
    CLEAR B_OVERLAPPING.
  ENDIF.
  CALL FUNCTION &apos;SCROLLING_IN_TABLE&apos;
       EXPORTING
            ENTRY_TO       = MAXLINES
            LOOPS          = LOOPLINES
            OK_CODE        = FUNCTION
            ENTRY_ACT      = FIRSTLINE
            LAST_PAGE_FULL = &apos; &apos;
*           OVERLAPPING    = &apos;X&apos;
            OVERLAPPING    = B_OVERLAPPING
       IMPORTING
            ENTRY_NEW      = NEXTLINE.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3L" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM IGNORIEREN                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM IGNORIEREN. &quot;wird nur noch auf Detailbild prozessiert
  &lt;STATUS&gt;-UPD_FLAG = SPACE.
  IF STATUS-ACTION EQ KOPIEREN OR VIM_SPECIAL_MODE EQ VIM_DELETE.
    SET SCREEN 0.
    LEAVE SCREEN.
  ENDIF.
* IF MAXLINES LE 1.
*   STATUS-ACTION = AENDERN.
*   TITLE-ACTION  = AENDERN.
*   PERFORM FILL_EXTRACT.
* ELSE.
*   SORT EXTRACT.
* ENDIF.
  NEUER = &apos;N&apos;.
  IF REPLACE_MODE EQ SPACE.
    CLEAR FUNCTION.
*   IF STATUS-MODE EQ DETAIL_BILD.
*     FUNCTION = &apos;DETA&apos;.
*     SET SCREEN DETAIL.
    IF STATUS-ACTION EQ HINZUFUEGEN.
      FUNCTION = &apos;NEWL&apos;.
      PERFORM HINZUFUEGEN.
    ELSE.
      SET SCREEN LISTE.
      LEAVE SCREEN.
    ENDIF.
*   ELSE.
*     NEXTLINE = 1.
*     SET SCREEN LISTE.
*   ENDIF.
  ELSE.
    CLEAR VIM_ACT_DYNP_VIEW. SET SCREEN 0. LEAVE SCREEN.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3M" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_ABBRECHEN                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM LISTE_ABBRECHEN.
* CHECK REPLACE_MODE EQ SPACE.
*(DEL)  IF STATUS-ACTION EQ ANZEIGEN.
*(DEL)    MESSAGE I001(SV).
*(DEL)    EXIT.
*(DEL)  ENDIF.
  IF SY-DATAR NE SPACE.
    CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
         EXPORTING
              TITEL          = SVIM_TEXT_005
              TEXTLINE1      = SVIM_TEXT_009
              TEXTLINE2      = SVIM_TEXT_006
              DEFAULTOPTION  = &apos;N&apos;
              CANCEL_DISPLAY = &apos; &apos;
         IMPORTING
              ANSWER         = ANSWER.
    IF ANSWER EQ &apos;J&apos;.
      NEUER = &apos;N&apos;.
      IF STATUS-ACTION EQ KOPIEREN.
        SET SCREEN 0.
      ELSE.
        SET SCREEN LISTE.
        NEXTLINE = FIRSTLINE.
      ENDIF.
      CLEAR &lt;STATUS&gt;-UPD_FLAG.
      LEAVE SCREEN.
    ELSE.
      CLEAR FUNCTION.
    ENDIF.
  ELSE.
    IF VIM_SINGLE_ENTRY_FUNCTION NE SPACE.
      TRANSLATE STATUS-ACTION USING &apos;AU&apos;. STATUS-MODE = GESAMTDATEN.
    ENDIF.
    CASE STATUS-ACTION.
      WHEN HINZUFUEGEN. PERFORM LISTE_BACK.
      WHEN KOPIEREN.    SET SCREEN 0.
      WHEN OTHERS.
        FUNCTION = &apos;BACK&apos;. SET SCREEN 0. CLEAR VIM_ACT_DYNP_VIEW.
        PERFORM UPDATE_STATUS.
    ENDCASE.
    LEAVE SCREEN.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3N" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM LISTE_BACK                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM liste_back.
  IF status-action EQ hinzufuegen.
    status-action = &lt;status&gt;-st_action = aendern.
    title-action  = aendern.
    CLEAR &lt;status&gt;-selected.
    neuer = &apos;N&apos;.
  ENDIF.
  IF status-delete = geloescht.
    status-delete = &lt;status&gt;-st_delete = nicht_geloescht.
    title-action  = aendern.
    PERFORM markiere_alle USING nicht_markiert.
  ENDIF.
  IF x_header-delmdtflag NE space.
    LOOP AT vim_collapsed_mainkeys.
      IF vim_collapsed_mainkeys-mkey_bf EQ space.
        vim_collapsed_mainkeys-mkey_bf = vim_collapsed_mainkeys-log_key.
        CLEAR vim_collapsed_mainkeys-log_key.
      ENDIF.
      &lt;f1_x&gt; = &lt;vim_h_coll_mkey&gt;.
*      &lt;f1&gt; = vim_collapsed_mainkeys-mainkey.
      &lt;vim_enddate_mask&gt; = space.
      &lt;vim_h_coll_mkey&gt; = &lt;f1_x&gt;.
*      vim_collapsed_mainkeys-mainkey = &lt;f1&gt;.
      MODIFY vim_collapsed_mainkeys.
    ENDLOOP.
    IF vim_delim_expa_excluded NE space.
      DELETE excl_cua_funct WHERE function EQ &apos;EXPA&apos;.
      CLEAR vim_delim_expa_excluded.
    ENDIF.
    IF status-action = aendern AND title-action = hinzufuegen.
      title-action  = aendern.
    ENDIF.
  ENDIF.
  PERFORM fill_extract.
  nextline = 1.
  mark_extract = mark_total.
  SET SCREEN liste.
  LEAVE SCREEN.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3O" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM BEENDEN                                                  *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM beenden.
  DATA: line1(30) TYPE c,
        handle TYPE ad_handle,
        adrnum TYPE ad_addrnum.

  CASE function.
    WHEN &apos;ANZG&apos;.
      line1 = svim_text_001.
    WHEN &apos;ATAB&apos;.
      line1 = svim_text_008.
    WHEN &apos;ENDE&apos;.
      line1 = svim_text_003.
  ENDCASE.
  CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
       EXPORTING
            titel     = line1
            textline1 = svim_text_018  &quot;Daten wurden verändert.
            textline2 = svim_text_019  &quot;Änderungen vorher sichern ?
       IMPORTING
            answer    = answer.
  CASE answer.
    WHEN &apos;J&apos;.
      sy-subrc = 0.
    WHEN &apos;N&apos;.
      CLEAR &lt;status&gt;-upd_flag.
      IF maint_mode EQ transportieren.
        &lt;status&gt;-keytbinvld = &apos;X&apos;.
      ELSEIF maint_mode EQ aendern. &quot;AND x_header-adrnbrflag EQ &apos;N&apos;.
* reset unsaved addresses                          UF557286/2000b
        LOOP AT vim_addresses_to_save.
          IF vim_addresses_to_save-addrnumber CP &apos;@NEW*&apos;.
            CLEAR adrnum.
            handle = vim_addresses_to_save-handle.
          ELSE.
            CLEAR handle.
            adrnum = vim_addresses_to_save-addrnumber.
          ENDIF.
          CALL FUNCTION &apos;ADDR_SINGLE_RESET&apos;
               EXPORTING
                    address_number = adrnum
                    address_handle = handle
               EXCEPTIONS
                    OTHERS         = 1.
          IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
          ENDIF.
        ENDLOOP.
        REFRESH vim_addresses_to_save.
      ENDIF.                                            &quot;UF557286/2000e
      sy-subrc = 8.
    WHEN &apos;A&apos;.
      sy-subrc = 12.
  ENDCASE.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3P" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM ANZG_TO_AEND                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM anzg_to_aend.
  DATA: rc LIKE sy-subrc, dummy TYPE scpr_id, value(200) TYPE c,       &quot;#EC NEEDED
        value_is_external TYPE xfeld, lfieldname TYPE fnam_____4, &quot;#EC NEEDED
        keyvalues TYPE occheckkeyflds, w_keyvalue TYPE occheckkey,
        oc_rangetab TYPE TABLE OF vimsellist, lines TYPE i,
        any_substflds_initial TYPE xfeld, field1 LIKE sy-msgv1, &quot;#EC NEEDED
        field2 LIKE sy-msgv2, field3 LIKE sy-msgv3,
        field4 LIKE sy-msgv4.
  FIELD-SYMBOLS: &lt;w_dba_sel&gt; TYPE vimsellist, &lt;x_namtab&gt; TYPE vimnamtab,
                 &lt;value&gt; TYPE c.                            &quot;#EC NEEDED

  IF status-action NE anzeigen AND status-action NE transportieren.
    MESSAGE i001(sv).
  ELSE.
    IF status-action EQ anzeigen.
* check authority
      IF x_header-newgener EQ space. &quot;4.5a: support individual auth.chck
        CALL FUNCTION &apos;VIEW_AUTHORITY_CHECK&apos;
           EXPORTING
                view_action                = aendern
                view_name                  = view_name
                no_warning_for_clientindep = vim_no_warning_for_cliindep
           CHANGING
                org_crit_inst              = vim_oc_inst
           EXCEPTIONS
                no_authority                   = 8
                no_clientindependent_authority = 9
                no_linedependent_authority     = 11.
        rc = sy-subrc.
        IF sy-subrc = 11.
          MOVE: sy-msgid TO vim_auth_msgid,
                sy-msgno TO vim_auth_msgno,
                sy-msgv1 TO vim_auth_msgv1,
                sy-msgv2 TO vim_auth_msgv2,
                sy-msgv3 TO vim_auth_msgv3,
                sy-msgv4 TO vim_auth_msgv4.
        ENDIF.
      ENDIF.
      IF x_header-frm_on_aut NE space.
        vim_auth_action = aendern.
        vim_auth_event = vim_auth_switch_to_update_mode.
        ASSIGN &lt;vim_ck_sellist&gt; TO &lt;vim_auth_sellist&gt;.
        PERFORM (x_header-frm_on_aut) IN PROGRAM.
        IF vim_auth_rc NE 0. rc = 10. ENDIF.
      ENDIF.
    ENDIF.
    CASE rc.
      WHEN 0.
        IF NOT vim_oc_inst IS INITIAL AND vim_called_by_cluster = space.
* check line-dependent authorisation (viewclusters: will be done in
* viewcluster maintenance.)
* 1st: check non-subset-values
          INSERT LINES OF dba_sellist[] INTO TABLE oc_rangetab.
          LOOP AT x_namtab ASSIGNING &lt;x_namtab&gt; WHERE keyflag &lt;&gt; space
           AND readonly = subset.
            DELETE oc_rangetab WHERE viewfield = &lt;x_namtab&gt;-viewfield.
          ENDLOOP.
          IF sy-subrc = 0.
            DESCRIBE TABLE oc_rangetab LINES lines.
            if lines &gt; 0.
              READ TABLE oc_rangetab ASSIGNING &lt;w_dba_sel&gt; INDEX lines.
              CLEAR &lt;w_dba_sel&gt;-and_or.
            endif.
          ENDIF.
          CALL METHOD vim_oc_inst-&gt;check_oc_auth_vim_sellist
            EXPORTING
              sellist    = oc_rangetab
              action     = &apos;02&apos;
*          CHANGING
*            KEY_FIELDS =
            EXCEPTIONS
              no_auth    = 1
              OTHERS     = 2.
          IF sy-subrc &lt;&gt; 0.
            MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
             WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            EXIT.
          ENDIF.
          IF x_header-subsetflag &lt;&gt; space.
* 2nd: check subset values
            CALL METHOD vim_oc_inst-&gt;build_key_value_tab
              EXPORTING
                entry     = &lt;initial&gt;
              IMPORTING
                keyvalues = keyvalues.
            LOOP AT keyvalues INTO w_keyvalue.
              READ TABLE x_namtab ASSIGNING &lt;x_namtab&gt;
               WITH KEY viewfield = w_keyvalue-keyname.
              CHECK &lt;x_namtab&gt;-readonly &lt;&gt; subset.
              DELETE keyvalues.
            ENDLOOP.
            CALL METHOD vim_oc_inst-&gt;check_oc_authority
              EXPORTING
                activity        = &apos;02&apos;
              CHANGING
                key_values      = keyvalues
              EXCEPTIONS
                no_auth         = 1
                key_incomplete  = 2
*              WRONG_PARAMETER = 3
                OTHERS          = 4.
            IF sy-subrc = 1.
              MOVE: sy-msgv1 TO field1, sy-msgv2 TO field2,
                    sy-msgv3 TO field3, sy-msgv4 TO field4.
* no authorisation for current subset values
              MESSAGE i763(sv) WITH field1 field2 field3 field4. &quot;#EC *
*   Sie haben keine Pflegeberechtigung für die angezeigten Datensätze.
              LOOP AT keyvalues INTO w_keyvalue WHERE noauth &lt;&gt; space.    &quot;#EC CI_SORTSEQ
                READ TABLE dba_sellist ASSIGNING &lt;w_dba_sel&gt;
                 WITH KEY viewfield = w_keyvalue-keyname.
                CLEAR: &lt;w_dba_sel&gt;-value, &lt;w_dba_sel&gt;-initial,
                       &lt;w_dba_sel&gt;-from_auth.                &quot;UF210200
              ENDLOOP.
*              CALL METHOD vim_oc_inst-&gt;convert_oc_selections
*                        EXPORTING
*                            activity   = &apos;02&apos;
*                        IMPORTING
*                            oc_vimsell = oc_rangetab.
** if possible: fill subset selection in RANGETAB from authority
** (authority object S_TABU_LIN)
*              PERFORM vim_merge_sellists USING    oc_rangetab
*                                                  x_namtab[]
*                                                  &apos;X&apos;
*                                         CHANGING x_header[]
*                                                  dba_sellist
*                                                  rc.
*              PERFORM check_all_substfields TABLES dba_sellist
*                      CHANGING any_substflds_initial.
*              IF any_substflds_initial &lt;&gt; space.
              CALL FUNCTION &apos;TABLE_RANGE_INPUT&apos;
                   EXPORTING
                        table             = x_header-viewname
                        oc_inst           = vim_oc_inst
                   TABLES
                        sellist           = dba_sellist
                        x_header          = x_header
                        x_namtab          = x_namtab
                   EXCEPTIONS
                        cancelled_by_user = 1
                        no_input          = 2
                        OTHERS            = 3.
              IF sy-subrc &lt;&gt; 0.
                EXIT.
              ENDIF.
*              refresh vim_dba_sel_kept.            &quot;UF210200
*              ENDIF.
            ENDIF.
          ELSE.
* new selection because of different authorisation? --&gt; Message
* &gt;&gt;&gt;check whether there&apos;s really a difference between upd and show&lt;&lt;&lt;
            MESSAGE s764(sv).
*   Veränderte Auswahl von Datensätzen.
          ENDIF.                       &quot;subsets exist
        ENDIF.                         &quot;oc exists
        IF status-action EQ transportieren.
          function = switch_transp_to_upd_mode.
          CLEAR &lt;status&gt;-crcntsknwn.
          IF &lt;status&gt;-corr_enqud NE space.
            CALL FUNCTION &apos;DEQUEUE_E_TRKORR&apos;
                 EXPORTING
                      trkorr = &lt;status&gt;-corr_nbr.
*             X_TRKORR = E02.
            CLEAR &lt;status&gt;-corr_enqud.
          ENDIF.
          IF x_header-cursetting NE space.
            CLEAR: vim_corr_obj_viewname, &lt;status&gt;-tr_alrchkd.
          ENDIF.
        ELSE.
          CLEAR vim_corr_obj_viewname.
          IF &lt;status&gt;-prof_found = vim_profile_found    &quot;UF profileb
             AND vim_pr_records = 0.
* get records the profile contains
            PERFORM get_pr_nbr_records USING vim_profile_values
                                             x_header
                                       CHANGING rc
                                                dummy
                                                vim_pr_records
                                                vim_pr_tab
                                                vim_pr_fields.
* check key-status
            PERFORM get_profile_status CHANGING vim_pr_tab
                                                vim_pr_fields.
            PERFORM bcset_key_check_in_total.
          ENDIF.                       &quot;UF profileb
        ENDIF.
*       SET SCREEN 0.
*       LEAVE SCREEN.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      WHEN 8.                          &quot;no authority for update
        MESSAGE i051(sv).              &quot;only show allowed
      WHEN 9.
        MESSAGE ID &apos;TB&apos; TYPE &apos;I&apos; NUMBER 109.      &quot;no cli-indep auth
      WHEN 10 OR 11.
        MESSAGE ID vim_auth_msgid TYPE &apos;I&apos; NUMBER vim_auth_msgno
                WITH vim_auth_msgv1 vim_auth_msgv2  vim_auth_msgv3
                     vim_auth_msgv4.
    ENDCASE.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3Q" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM AEND_TO_ANZG                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM aend_to_anzg.
* was not used &apos;til 4.6C
  IF status-action EQ anzeigen.
    MESSAGE i001(sv).
  ELSE.
    IF NOT vim_oc_inst IS INITIAL.
* new selection because of different authorisation? --&gt; Message
* &gt;&gt;&gt;check whether there&apos;s really a difference between upd and show&lt;&lt;&lt;
      MESSAGE s764(sv).
*   Veränderte Auswahl von Datensätzen.
    ENDIF.
*    CLEAR: &lt;status&gt;-mk_xt,
*           &lt;status&gt;-mk_to,
*           block_sw.
*    PERFORM beenden.
  ENDIF.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF3R" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_SAPSCRIPT_FORM_MAINT.                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_SAPSCRIPT_FORM_MAINT.
  LOCAL: STATUS-MODE.
  DATA: VSFM_TABLE LIKE VIMDESC-VIEWNAME, VSFM_FLAG(1) TYPE C,
        VSFM_FIELD LIKE VIMNAMTAB-VIEWFIELD, VSFM_HF TYPE I.

  IF X_HEADER-SCRFRMFLAG EQ SPACE.
    MESSAGE E001(SV).
    EXIT.
  ENDIF.
  IF VIM_NBR_OF_SCRFRM_POINTERS GT 1.
    IF STATUS-MODE EQ DETAIL_BILD. GET CURSOR FIELD F. ENDIF.
    SPLIT F AT &apos;-&apos; INTO VSFM_TABLE VSFM_FIELD.
    IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE AND
       VSFM_TABLE EQ X_HEADER-TEXTTAB.
      VSFM_FLAG = &apos;X&apos;.
    ENDIF.
    READ TABLE X_NAMTAB WITH KEY VIEWFIELD = VSFM_FIELD
                                 TEXTTABFLD = VSFM_FLAG.
    IF X_NAMTAB-DOMNAME NE VIM_SCRFORM_DOMAIN.
      MESSAGE S161(SV). &quot; Bitte stellen Sie den Cursor auf einen Formula
      CLEAR FUNCTION.
      EXIT.
    ENDIF.
*    ASSIGN &lt;TABLE1&gt;+X_NAMTAB-POSITION(X_NAMTAB-FLENGTH)
*                                       TO &lt;VIM_SCRFORM_NAME&gt;.
    ASSIGN component x_namtab-viewfield of structure &lt;TABLE1&gt;
     TO &lt;VIM_SCRFORM_NAME&gt;.
    IF STATUS-MODE EQ LIST_BILD.
      VSFM_HF = FIRSTLINE + L - 1.
      STATUS-MODE = DETAIL_BILD.
    ELSE.
      VSFM_HF = NEXTLINE.
    ENDIF.
    READ TABLE EXTRACT INDEX VSFM_HF.
    PERFORM MOVE_EXTRACT_TO_VIEW_WA.
  ENDIF.
  IF STATUS-MODE EQ LIST_BILD.
    LOOP AT EXTRACT.
      CHECK &lt;XMARK&gt; EQ MARKIERT.
      PERFORM MOVE_EXTRACT_TO_VIEW_WA.
      CALL FUNCTION &apos;EDIT_FORM&apos;
           EXPORTING
                FORM              = &lt;VIM_SCRFORM_NAME&gt;
*           LANGUAGE          = SY-LANGU
                DISPLAY           = &apos;X&apos;
*           COMPONENT         = &apos;HEADER&apos;
           EXCEPTIONS
                UNKNOWN_ACTIVITY  = 1
                UNKNOWN_COMPONENT = 2.
      IF SY-SUBRC NE 0.
        MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO WITH
                SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
        CONTINUE.
      ENDIF.
      &lt;XMARK&gt; = NICHT_MARKIERT.
      MODIFY EXTRACT.
      READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.&quot;#EC WARNOK
      &lt;MARK&gt; = NICHT_MARKIERT.
      MODIFY TOTAL INDEX SY-TABIX.
      SUBTRACT: 1 FROM MARK_EXTRACT,
                1 FROM MARK_TOTAL.
    ENDLOOP.
  ELSE.                                &quot;detail bild
    CALL FUNCTION &apos;EDIT_FORM&apos;
         EXPORTING
              FORM              = &lt;VIM_SCRFORM_NAME&gt;
*             LANGUAGE          = SY-LANGU
              DISPLAY           = &apos;X&apos;
*             COMPONENT         = &apos;HEADER&apos;
         EXCEPTIONS
              UNKNOWN_ACTIVITY  = 1
              UNKNOWN_COMPONENT = 2.
    IF SY-SUBRC NE 0.
      MESSAGE ID SY-MSGID TYPE &apos;I&apos; NUMBER SY-MSGNO WITH
              SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      CLEAR FUNCTION. EXIT.
    ENDIF.
    IF &lt;XMARK&gt; EQ MARKIERT.
      &lt;XMARK&gt; = NICHT_MARKIERT.
      MODIFY EXTRACT INDEX NEXTLINE.
      READ TABLE TOTAL WITH KEY &lt;VIM_xEXTRACT_KEY&gt; BINARY SEARCH.&quot;#EC WARNOK
      &lt;MARK&gt; = NICHT_MARKIERT.
      MODIFY TOTAL INDEX SY-TABIX.
      SUBTRACT: 1 FROM MARK_EXTRACT,
                1 FROM MARK_TOTAL.
    ENDIF.
  ENDIF.                               &quot;status-mode eq list_bild
  CLEAR FUNCTION.
ENDFORM.                               &quot;vim_sapscript_form_maint</include_source>
   </include>
   <include NAME="LSVIMF3S" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_CHECK_ALE_EDIT_LOCK                                  *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_CHECK_ALE_EDIT_LOCK USING VALUE(VCAEL_OBJECT) LIKE E071-OBJECT
                                   VCAEL_LOCK TYPE C.
  DATA: OBJ_TYPE LIKE OBJH-OBJECTTYPE, OBJ_NAME LIKE OBJH-OBJECTNAME.

* OBJ_NAME = VIEW_NAME.
  OBJ_NAME = MASTER_NAME.
  CASE VCAEL_OBJECT.
    WHEN VIM_VIEW_TYPE.                &quot;-&gt; view
      OBJ_TYPE = VIM_VIEW.
    WHEN TRANSP_OBJECT.                &quot;-&gt; tables
      OBJ_TYPE = VIM_TABL.
    WHEN VIM_CLUS_TYPE.                &quot;-&gt; viewcluster
      OBJ_TYPE = VIM_CLST.
    WHEN VIM_TRAN_TYPE.                &quot;-&gt; individual transaction
      OBJ_TYPE = VIM_TRAN.
    WHEN OTHERS.                       &quot;-&gt; may be LOGO object ?
      OBJ_TYPE = VIM_LOGO. OBJ_NAME = VCAEL_OBJECT.
*     SELECT SINGLE * FROM OBJH WHERE OBJECTNAME EQ OBJ_NAME &quot;required ?
*                                 AND OBJECTTYPE EQ OBJ_TYPE.
*     IF SY-SUBRC NE 0. CLEARVCAEL_LOCK. EXIT. ENDIF. &quot;no logo-object
  ENDCASE.
  CALL FUNCTION &apos;ALE_EDIT_CHECK&apos;
       EXPORTING
            OBJECTTYPE      = OBJ_TYPE
            OBJECTNAME      = OBJ_NAME
       IMPORTING
            SOMEKEYS_NOEDIT = VIM_ALE_KEYSPEC_CHECK
       EXCEPTIONS
            NO_CALL         = 1
            NO_EDIT         = 2.
  IF SY-SUBRC GT 1.
    VCAEL_LOCK = &apos;X&apos;.
    VIM_ALE_MSGID = SY-MSGID. VIM_ALE_MSGNO = SY-MSGNO.
    VIM_ALE_MSGV1 = SY-MSGV1. VIM_ALE_MSGV2 = SY-MSGV2.
    VIM_ALE_MSGV3 = SY-MSGV3. VIM_ALE_MSGV4 = SY-MSGV4.
  ELSE.
    CLEAR VCAEL_LOCK.
    IF VIM_ALE_KEYSPEC_CHECK NE SPACE AND OBJ_TYPE NE VIM_LOGO.
      VIM_ALE_KEYSPEC_OBJTAB-ONAME = OBJ_NAME.
      VIM_ALE_KEYSPEC_OBJTAB-OTYPE = OBJ_TYPE.
      APPEND VIM_ALE_KEYSPEC_OBJTAB.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot;vim_check_ale_edit_lock</include_source>
   </include>
   <include NAME="LSVIMF3T" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_SET_ALE_EDIT_LOCK                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM VIM_SET_ALE_EDIT_LOCK.
  DATA: I_EDITLOCK(1) TYPE C.

  VIM_LAST_OBJH_VIEW = VIEW_NAME.
  REFRESH VIM_ALE_KEYSPEC_OBJTAB.
  IF X_HEADER-FLAG EQ SPACE.           &quot;standard transport required
    PERFORM VIM_CHECK_ALE_EDIT_LOCK USING E071-OBJECT I_EDITLOCK.
    VIM_ALE_EDIT_LOCK = I_EDITLOCK.
    IF VIM_ALE_EDIT_LOCK NE SPACE. EXIT. ENDIF.
  ENDIF.
  IF X_HEADER-FRM_E071 NE SPACE. &quot;individual transport objects exist
    IF VIM_CORR_OBJ_VIEWNAME NE X_HEADER-VIEWNAME.
      PERFORM (X_HEADER-FRM_E071) IN PROGRAM (SY-REPID).
      CLEAR VIM_CORR_OBJ_VIEWNAME.
    ENDIF.
    LOOP AT VIM_CORR_OBJTAB.
      PERFORM VIM_CHECK_ALE_EDIT_LOCK USING VIM_CORR_OBJTAB-OBJECT
                                            I_EDITLOCK.
      VIM_ALE_EDIT_LOCK = I_EDITLOCK.
      IF VIM_ALE_EDIT_LOCK NE SPACE. EXIT. ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.                               &quot;vim_set_ale_edit_lock</include_source>
   </include>
   <include NAME="LSVIMF3U" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM JUSTIFY_ACTION_MODE                                      *
*---------------------------------------------------------------------*
* ggf. VIEW_ACTION aendern und View entsperren                        *
*---------------------------------------------------------------------*
FORM justify_action_mode.
  TABLES: scdtsync.
  DATA: action_changed(1) TYPE c, assigned(1) TYPE c.
  DATA: i_statetab LIKE adrstatus OCCURS 0 WITH HEADER LINE,
        i_messnbr LIKE sy-msgno, viewtype,                  &quot;#EC TYPES_MISS
        msg_v1 LIKE sy-msgv1.
  STATICS: vim_old_cluster TYPE vcl_name.&quot;Avoid sync_key_lock messages

  FIELD-SYMBOLS: &lt;f_fld_value&gt; TYPE ANY.  &quot; XB H612358

  IF fcode = vim_read_text.            &quot;SW Textimp ...
    PERFORM vim_read_texttab_all_langus.
    EXIT.
  ENDIF.                               &quot;... SW Textimp

* XB H612358B
* check if the time-field exists: Yes, then reset initial value.
  LOOP AT x_namtab WHERE datatype = &apos;TIMS&apos;.
    ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;initial&gt;
         TO &lt;f_fld_value&gt;.
    IF &lt;f_fld_value&gt; &lt;&gt; space.
      CLEAR &lt;f_fld_value&gt; WITH space.
    ENDIF.
  ENDLOOP.
* XB H612358B

  IF x_header-selection EQ space.
    DESCRIBE TABLE dba_sellist.
    IF sy-tfill GT 0.
      MOVE &apos;X&apos; TO x_header-selection.
      MODIFY x_header INDEX 1.
*      IF last_view_info EQ view_name.                       &quot;UF443580b
** &lt;initial&gt; not yet filled in INITIALISIEREN
*        PERFORM vim_set_init_from_sellist USING x_header-maintview
*                                                x_namtab[]
*                                                dba_sellist[]
*                                                vim_hidden
*                                          CHANGING &lt;initial&gt;.
*      ENDIF.                                                &quot;UF443580e
    ELSE.
      DESCRIBE TABLE dpl_sellist.
      IF sy-tfill GT 0.
        MOVE &apos;X&apos; TO x_header-selection.
        MODIFY x_header INDEX 1.
      ENDIF.
    ENDIF.
  ELSEIF x_header-selection = &apos;X&apos;.     &quot;XB BCEK064860 begin
*&lt;inital&gt; not filled because the F3. XB int4436226
    DESCRIBE TABLE dba_sellist.
    IF sy-tfill GT 0.
      IF last_view_info EQ view_name.                       &quot;UF443580b
* &lt;initial&gt; not yet filled in INITIALISIEREN
* because with F3 the last_view_info exists.
        PERFORM vim_set_init_from_sellist USING x_header-maintview
                                                x_namtab[]
                                                dba_sellist[]
                                                vim_hidden
                                          CHANGING &lt;initial&gt;.
      ENDIF.                                                &quot;UF443580e
    ENDIF.           &quot;XB BCEK064860 end
  ENDIF.
  IF x_header-adrnbrflag NE space.
* 4.0: check if new version of address maintenance must be used
    CALL FUNCTION &apos;ADDR_TSADRV_READ&apos;
      EXPORTING
        ddic_tablename  = vim_addr_basetable
        ddic_fieldname  = vim_addr_bastab_field
      IMPORTING
        tsadrv_wa       = vim_tsadrv
      EXCEPTIONS
        entry_not_found = 1.
    IF sy-subrc NE 0.                  &quot;no tsadrv entry found...
      IF x_header-adrnbrflag EQ &apos;N&apos;.   &quot;new version requires entry
        MESSAGE i287(am) WITH vim_addr_basetable vim_addr_bastab_field.
        CLEAR x_header-adrnbrflag. MODIFY x_header INDEX 1.
      ELSE. &quot;old version runs but is old fashioned....
        IF vim_system_type EQ &apos;SAP&apos;.   &quot;sap system
          MESSAGE i290(am) WITH vim_addr_basetable  &quot;...send message
                                vim_addr_bastab_field.
        ELSE.
          MESSAGE i291(am) WITH vim_addr_basetable  &quot;...send message
                                vim_addr_bastab_field.
        ENDIF.
      ENDIF.
    ELSE.                              &quot;entry found....
      IF vim_tsadrv-addr_group IS INITIAL. &quot;...but not complete
*       I_TSADRV-ADDR_GROUP = &apos;CA01&apos;. &quot;default: Customizing Address
        IF x_header-adrnbrflag EQ &apos;N&apos;. &quot;new version
          i_messnbr = &apos;292&apos;.
        ELSE.                          &quot;old version
          IF vim_system_type EQ &apos;SAP&apos;. &quot;sap system
            i_messnbr = &apos;288&apos;.
          ELSE.                        &quot;customer system
            i_messnbr = &apos;289&apos;.
          ENDIF.
        ENDIF.
        MESSAGE ID &apos;AM&apos; TYPE &apos;I&apos; NUMBER i_messnbr
                        WITH vim_addr_basetable
                             vim_addr_bastab_field
                             vim_tsadrv-tablename
                             vim_tsadrv-fieldname.
        CLEAR x_header-adrnbrflag. MODIFY x_header INDEX 1.
      ELSE.                            &quot;entry in TSADRV is complete
        vim_addr_group = vim_tsadrv-addr_group.
        IF x_header-adrnbrflag EQ &apos;O&apos;.
          CALL FUNCTION &apos;ADDR_GET_STATUS_INFO&apos;
            TABLES
              status_table = i_statetab.
          READ TABLE i_statetab WITH KEY
               constant = vim_tsadrv-addr_group.
          IF sy-subrc NE 0. CLEAR i_statetab-value. ENDIF.
          TRANSLATE i_statetab-value USING &apos; OXN&apos;.
          x_header-adrnbrflag = i_statetab-value.
          MODIFY x_header INDEX 1.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
  PERFORM vim_process_assigns.
  IF &lt;status&gt;-initializd EQ space.     &quot;not processed yet
* reset dropdown lists
    CALL FUNCTION &apos;VRM_REFRESH_VALUES&apos;.
    IF x_header-frm_af_ini NE space.   &quot;user exit exists AND
* set environment for user exit.
      ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
      vim_enqueue_range = x_header-subsetflag. assigned = &apos;X&apos;.
* perform user exit -&gt; 3.0B processed in JUSTIFY_ACTION_MODE
      PERFORM (x_header-frm_af_ini) IN PROGRAM (sy-repid).
    ENDIF.
* backup DBA_SELLIST
*    REFRESH vim_dba_sel_kept.                        &quot;UF210200b
*    APPEND LINES OF dba_sellist TO vim_dba_sel_kept.
* remove multiple values for subsets
    DELETE dba_sellist WHERE ddic = &apos;M&apos;.
    DESCRIBE TABLE dba_sellist.
    IF sy-tfill GT 0.
      READ TABLE dba_sellist INDEX sy-tfill.
      CLEAR dba_sellist-and_or.
      MODIFY dba_sellist INDEX sy-tabix.
    ENDIF.                                                  &quot;UF210200e
  ENDIF.
  IF view_action EQ aendern AND
     function EQ switch_to_update_mode AND
     vim_enq_s_u_rc NE 0.
    MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
  ENDIF.
  IF x_header-existency EQ rdonly AND  &quot;read only view
     ( view_action EQ aendern OR       &quot;update or
       view_action EQ transportieren ).&quot;transport request
    MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
    MESSAGE i044(sv).
  ENDIF.
  IF &lt;status&gt;-corr_nbr EQ vim_locked_in_corr AND &quot;object locked and
     ( view_action EQ aendern OR       &quot;update or
       view_action EQ transportieren ).&quot;transport request
    MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
  ENDIF.
  IF view_action EQ aendern AND fcode NE read.  &quot;BC-Set Flag not set yet
*---Lock for Synchronizer--------------------------------HCG 08/2003---*
    IF vim_last_objh_view NE view_name.
      IF x_header-bastab EQ space.
        viewtype = &apos;V&apos;.
      ELSE.
        viewtype = &apos;S&apos;.
      ENDIF.
      SELECT SINGLE * FROM scdtsync.                        &quot;#EC WARNOK
      IF sy-subrc EQ 0.
        CALL FUNCTION &apos;SCTM_CHECK_VIEW_EDIT&apos;
          EXPORTING
            viewname        = view_name
            viewtype        = viewtype
            bcset           = vim_bcset_id &quot;if NE space -&gt; BC-set act.
          IMPORTING
            edit_flag       = vim_sync_edit_lock
            kespec_flag     = vim_sync_keyspec_check
            sourcesys       = vim_sctm_sourcesys
          EXCEPTIONS
            no_sync_present
            old_sync_system
            rfc_failure.
        IF sy-subrc = 3.   &quot;1 and 2: Message already sent by function
          IF vim_import_profile EQ space.
            MESSAGE w183(sv) WITH sy-msgv1 sy-msgv2.        &quot;#EC *
          ELSE.
            vim_import_no_message = &apos;X&apos;.
            PERFORM vim_process_message USING &apos;SV&apos; &apos;W&apos; &apos;W&apos; &apos;183&apos;
                                        sy-msgv1 sy-msgv2 space space.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.                            &quot;vim_last_objh_view NE view_name
    IF vim_sync_edit_lock NE space AND      &quot;Table locked completely
       vim_sync_keyspec_check EQ space.
      MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
      MOVE vim_sctm_sourcesys TO msg_v1.
      IF vim_import_profile NE space.
        vim_no_dialog = &apos;X&apos;.
        vim_import_no_message = &apos;X&apos;.
        PERFORM vim_process_message
                USING
                  &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;181&apos; msg_v1 space space space.
      ELSE.
        PERFORM vim_process_message
                          USING
                          &apos;SV&apos; &apos;I&apos; &apos;I&apos; &apos;181&apos; msg_v1 space space space.
      ENDIF.
    ELSEIF vim_sync_keyspec_check NE space.      &quot;Table locked partly
      IF vim_import_profile EQ space.       &quot;BC-Set act: only message
        MOVE vim_sctm_sourcesys TO msg_v1. &quot;in log when key is locked
        IF vim_calling_cluster NE vim_old_cluster OR
          vim_called_by_cluster EQ space.
          MOVE vim_calling_cluster TO vim_old_cluster.
          PERFORM vim_process_message
                  USING
                    &apos;SV&apos; &apos;I&apos; &apos;I&apos; &apos;180&apos; msg_v1 space space space.
        ENDIF.
      ENDIF.
    ENDIF.
*----------------------------------------------------------------------*
    IF vim_last_objh_view NE view_name.
      PERFORM vim_set_ale_edit_lock.
    ENDIF.
    IF vim_ale_edit_lock NE space.
      MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
      PERFORM vim_process_message
            USING
              vim_ale_msgid &apos;I&apos; &apos;I&apos; vim_ale_msgno
              vim_ale_msgv1 vim_ale_msgv2
              vim_ale_msgv3 vim_ale_msgv4.
    ENDIF.
  ENDIF.
  IF x_header-frm_on_aut NE space AND  &quot;45a: support indiv. auth. chck
     &lt;status&gt;-initializd EQ space.     &quot;not processed yet
    vim_auth_action = view_action.
    vim_auth_event = vim_auth_initial_check.
    ASSIGN dba_sellist[] TO &lt;vim_auth_sellist&gt;.
    PERFORM (x_header-frm_on_aut) IN PROGRAM.
    IF vim_auth_rc NE 0.
      MESSAGE ID vim_auth_msgid TYPE &apos;I&apos; NUMBER vim_auth_msgno
              WITH vim_auth_msgv1 vim_auth_msgv2
                   vim_auth_msgv3 vim_auth_msgv4.
      CASE vim_auth_rc.
        WHEN 4.                        &quot;show only
          MOVE anzeigen TO view_action. action_changed = &apos;X&apos;.
        WHEN 8.                        &quot;exit
          RAISE missing_corr_number.
      ENDCASE.
    ENDIF.
  ENDIF.
  IF action_changed NE space.
    IF assigned EQ space.
      ASSIGN dba_sellist-*sys* TO &lt;vim_sellist&gt;.
      vim_enqueue_range = x_header-subsetflag.
    ENDIF.
    PERFORM enqueue USING &apos;D&apos; x_header-frm_af_enq. &quot;dequeue view
  ENDIF.
  IF x_header-texttbexst &lt;&gt; space.     &quot;SW Texttransl
    PERFORM vim_actualize_d0100.
  ENDIF.
ENDFORM.                    &quot;justify_action_mode</include_source>
   </include>
   <include NAME="LSVIMF3V" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM SET_TITLE                                                *
*---------------------------------------------------------------------*
* Titel setzen: entweder allgemein oder angegeb. Programm             *
*---------------------------------------------------------------------*
FORM set_title USING st_title st_title_text.
  DATA: st_state LIKE sy-pfkey.
  CASE x_header-gui_prog.
    WHEN master_fpool.
      MOVE st_title TO st_state.
      CALL FUNCTION &apos;VIEW_SET_PF_STATUS&apos;
        EXPORTING
          status         = st_state
          title          = &apos;X&apos;
          title_text     = st_title_text
          objimp         = x_header-importable
        TABLES
          excl_cua_funct = excl_cua_funct.
    WHEN sy-repid.
      SET TITLEBAR st_title WITH st_title_text.
    WHEN OTHERS.
      RAISE wrong_gui_programm.
  ENDCASE.
ENDFORM.                    &quot;SET_TITLE</include_source>
   </include>
   <include NAME="LSVIMF3W" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM SET_PF_STATUS                                            *
*---------------------------------------------------------------------*
* PF-Status setzen: entweder allgemein oder angegeb. Programm         *
*---------------------------------------------------------------------*
FORM set_pf_status USING value(sps_status).
  DATA: sps_state LIKE sy-pfkey, sps_stat TYPE state_vector.
  CASE x_header-gui_prog.
    WHEN master_fpool.
      MOVE sps_status TO sps_state.
      CALL FUNCTION &apos;VIEW_SET_PF_STATUS&apos;
        EXPORTING
          status         = sps_state
          objimp         = x_header-importable
        TABLES
          excl_cua_funct = excl_cua_funct.
    WHEN sy-repid.
      MOVE sps_status TO sps_stat.
      IF sps_stat-action EQ anzeigen OR
         sps_stat-action EQ transportieren OR
         ( sy-mandt EQ &apos;000&apos; AND vim_system_type NE &apos;SAP&apos; ) OR
         x_header-importable = vim_not_importable.
        vim_comp_menue_text = svim_text_045.
      ELSE.
        vim_comp_menue_text = svim_text_046.
      ENDIF.
      vim_pr_stat_txt_ch = svim_text_prb.
      vim_pr_stat_txt_ta = svim_text_prc.
      vim_pr_stat_txt_me = svim_text_pri.
      vim_pr_stat_txt_or = svim_text_prj.
      VIM_SLCT_FUNCTIONTEXT = svim_text_det.  &quot;#EC NOTEXT
      SET PF-STATUS sps_status EXCLUDING excl_cua_funct.
    WHEN OTHERS.
      RAISE wrong_gui_programm.                             &quot;#EC FB_RAIS_EX
  ENDCASE.
ENDFORM.                    &quot;SET_PF_STATUS</include_source>
   </include>
   <include NAME="LSVIMF3X" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM EXCLUDE_CUA_FUNCTIONS                                    *
*---------------------------------------------------------------------*
* ggf. Funktionen ausschließen                                        *
*---------------------------------------------------------------------*
FORM exclude_cua_functions.
  MOVE &apos;SLCT&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  IF x_header-delmdtflag EQ space.
    MOVE &apos;DELM&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    MOVE &apos;EXPA&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    TRANSLATE x_header-existency USING &apos;MU&apos;.
    MODIFY x_header INDEX 1.
  ELSEIF vim_begdate_is_ro NE space.
    MOVE &apos;DELM&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    MODIFY x_header INDEX 1.
  ENDIF.
  CASE x_header-existency.
    WHEN &apos;U&apos;.                          &quot;update only
      MOVE &apos;NEWL&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      MOVE &apos;ALNW&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      MOVE &apos;ALOE&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      MOVE &apos;DELE&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      MOVE &apos;KOPE&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      MOVE &apos;DELM&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    WHEN &apos;M&apos;.                          &quot;update only for main key
      MOVE &apos;NEWL&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    WHEN &apos;R&apos;.                          &quot;read only
      MOVE &apos;AEND&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ENDCASE.
  IF x_header-clidep EQ space OR sy-mandt EQ &apos;000&apos;.
    MOVE &apos;COMP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    IF x_header-clidep EQ space.
      MOVE &apos;CMPO&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ENDIF.
  ENDIF.
  IF x_header-flag NE space AND x_header-cursetting EQ &apos;Y&apos; AND
     NOT ( x_header-frm_e071 NE space OR x_header-frm_e071ks NE space OR
           x_header-frm_e071ka NE space ).
    MOVE &apos;TRSP&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ENDIF.
  IF x_header-adrnbrflag EQ space.
    MOVE &apos;ADDR&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ELSE.
    LOOP AT excl_cua_funct WHERE function EQ &apos;ADDR&apos;.
      DELETE excl_cua_funct.
    ENDLOOP.
  ENDIF.
  IF x_header-scrfrmflag EQ space.
    MOVE &apos;SCRF&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ELSE.
    LOOP AT excl_cua_funct WHERE function EQ &apos;SCRF&apos;.
      DELETE excl_cua_funct.
    ENDLOOP.
  ENDIF.
  IF x_header-texttbexst EQ space.     &quot;SW Texttransl
    MOVE &apos;LANG&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    MOVE &apos;TEXT&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ENDIF.
  IF vim_coming_from_img = &apos;N&apos;.        &quot;UF profiles
* profiles can&apos;t be activated
    MOVE &apos;GPRF&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    MOVE &apos;UPRF&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ELSE.
    IF maint_mode = anzeigen.
* profile activating not allowed
      MOVE &apos;UPRF&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
    ELSE.
      DELETE excl_cua_funct WHERE function = &apos;UPRF&apos;.
    ENDIF.
  ENDIF.
  IF &lt;status&gt;-bcfixnochg = space.
    MOVE &apos;BCCH&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
*   MOVE &apos;BCSH&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
  ELSE.
    DELETE excl_cua_funct WHERE function = &apos;BCCH&apos;.
*    DELETE excl_cua_funct WHERE function = &apos;BCSH&apos;.   &quot;HCG HW681286
  ENDIF.
ENDFORM.                    &quot;EXCLUDE_CUA_FUNCTIONS</include_source>
   </include>
   <include NAME="LSVIMF3Y" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM SET_STATUS_NOKEYSELCNDS                                  *
*---------------------------------------------------------------------*
* ........                                                            *
*---------------------------------------------------------------------*
FORM SET_STATUS_NOKEYSELCNDS.
  CLEAR &lt;STATUS&gt;-NOKEYSLCDS.
* LOOP AT DPL_SELLIST.
  LOOP AT &lt;VIM_CK_SELLIST&gt; INTO DPL_SELLIST.
    READ TABLE X_NAMTAB INDEX DPL_SELLIST-TABIX.
    IF X_NAMTAB-KEYFLAG EQ SPACE.
      &lt;STATUS&gt;-NOKEYSLCDS = &apos;X&apos;. EXIT.
    ENDIF.
  ENDLOOP.
  &lt;STATUS&gt;-INITIALIZD = &apos;X&apos;.
ENDFORM.                               &quot;set_status_nokeyselcnds</include_source>
   </include>
   <include NAME="LSVIMF3Z" SQLX="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM INIT_STATE_VECTOR                                        *
*---------------------------------------------------------------------*
* viewspezif. Statusvektor initialisieren                             *
*---------------------------------------------------------------------*
FORM INIT_STATE_VECTOR.
* IF &lt;STATUS&gt;-ALR_SETUP EQ SPACE.
  NEXTLINE = 1.
  MOVE: NICHT_GELOESCHT   TO &lt;STATUS&gt;-ST_DELETE,
        GESAMTDATEN       TO &lt;STATUS&gt;-ST_DATA,
        GESAMTDATEN       TO TITLE-DATA,
        LIST_BILD         TO &lt;STATUS&gt;-ST_MODE,
        LIST_BILD         TO TITLE-MODE,
        MAINT_MODE        TO &lt;STATUS&gt;-ST_ACTION,
        MAINT_MODE        TO TITLE-ACTION,
        &lt;STATUS&gt;-CORR_NBR TO &lt;STATUS&gt;-L_CORR_NBR,
        CORR_NBR          TO &lt;STATUS&gt;-CORR_NBR,
        TITLE             TO &lt;STATUS&gt;-TITLE,
        1                 TO &lt;STATUS&gt;-CUR_LINE,
        1                 TO &lt;STATUS&gt;-FIRSTLINE,
        0                 TO &lt;STATUS&gt;-MK_XT,
        0                 TO &lt;STATUS&gt;-MK_TO,
        0                 TO &lt;STATUS&gt;-MAXLINES,
        0                 TO &lt;STATUS&gt;-CUR_OFFSET,
        SPACE             TO &lt;STATUS&gt;-FCODE,
        SPACE             TO &lt;STATUS&gt;-CUR_FIELD,
        SPACE             TO &lt;STATUS&gt;-UPD_FLAG,
        SPACE             TO &lt;STATUS&gt;-CRCNTSKNWN,
        SPACE             TO &lt;STATUS&gt;-KEYTBMODFD,
        SPACE             TO &lt;STATUS&gt;-DLCLALRCKD,
        SPACE             TO &lt;STATUS&gt;-TR_ALRCHKD,
*         &apos;X&apos;               TO &lt;STATUS&gt;-ALR_SETUP,
        &apos;x&apos;               TO &lt;STATUS&gt;-INITIALIZD,
        NICHT_MARKIERT    TO BLOCK_SW.
  IF MAINT_MODE = STATUS-ACTION OR MAINT_MODE = ANZEIGEN.  &quot;UF profilesb
    CLEAR &lt;STATUS&gt;-PROF_FOUND.
  ENDIF.                               &quot;UF profilese
  CLEAR &lt;STATUS&gt;-NEWADRCNT.
* ENDIF.
  CLEAR FILL_EXTR_FIRST_PROC.
* Übergangslösung Sortierungsproblem Anfang
* CLEAR &lt;STATUS&gt;-ALR_SORTED.
  TRANSLATE &lt;STATUS&gt;-ALR_SORTED USING &apos;RXX &apos;.
* Übergangslösung Sortierungsproblem Ende
  CLEAR: VIM_OLD_VIEWKEY, VIM_OLD_ST_SELECTED.
  TRANSLATE VIM_NO_MAINKEY_EXISTS USING VIM_NO_MKEY_NOT_PROCSD_PATT.
  LAST_CORR_NUMBER = &lt;STATUS&gt;-L_CORR_NBR.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF40" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM SET_NUMBERED_TEXTS                                       *
*---------------------------------------------------------------------*
* numerierte Texte aus Textpool übernehmen                            *
*---------------------------------------------------------------------*
FORM SET_NUMBERED_TEXTS.
  DATA: NAME(20) TYPE C.
  FIELD-SYMBOLS: &lt;M1&gt;.
  READ TEXTPOOL MASTER_FPOOL INTO TEXTPOOL_TAB LANGUAGE SY-LANGU.
  SORT TEXTPOOL_TAB BY ID KEY.
  MOVE NBRD_TEXTS_PREFIX TO NAME.
  LOOP AT TEXTPOOL_TAB WHERE ID EQ &apos;I&apos;.
    WRITE TEXTPOOL_TAB-KEY TO NAME+NBRD_TEXTS_PREFIX_LENGTH.
    ASSIGN (NAME) TO &lt;M1&gt;.
    IF SY-SUBRC = 0.
      &quot; not all text elements are needed ???
      MOVE TEXTPOOL_TAB-ENTRY TO &lt;M1&gt;.
    ENDIF.
  ENDLOOP.
ENDFORM.</include_source>
   </include>
   <include NAME="LSVIMF41" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM SET_POSITION_INFO                                        *
*---------------------------------------------------------------------*
* fill position info                                                  *
*---------------------------------------------------------------------*
* SPI_POSITION      ---&gt; current position                             *
* SPI_ENTRIES       ---&gt; total number of entries                      *
* VIM_POSITION_INFO &lt;--- (global) string filled with position info    *
*---------------------------------------------------------------------*
FORM SET_POSITION_INFO USING VALUE(SPI_POSITION) TYPE I
                             VALUE(SPI_ENTRIES) TYPE I.
  DATA: HF1 TYPE I, HF2 TYPE I, HF3 TYPE I,
        P_VIM_POSITION_INFO_LEN TYPE I.

  MOVE VIM_POSITION_INFO_MASK TO VIM_POSITION_INFO.
  HF1 = VIM_POSITION_INFO_LG1 + 1.
  IF SPI_ENTRIES EQ 0.
    HF3 = 0.
  ELSE.
    HF3 = SPI_POSITION.
  ENDIF.
  WRITE HF3 TO
    VIM_POSITION_INFO+HF1(VIM_POSITION_INFO_LG3) NO-SIGN.
  HF1 = VIM_POSITION_INFO_LG1 + VIM_POSITION_INFO_LG2
                                    + VIM_POSITION_INFO_LG3 + 3.
  WRITE SPI_ENTRIES TO
    VIM_POSITION_INFO+HF1(VIM_POSITION_INFO_LG3) NO-SIGN.
  DO.
    CONDENSE VIM_POSITION_INFO.
* XB 585898B
* call methode to caculat the visible length of vim_position_info
    CALL METHOD cl_scp_linebreak_util=&gt;get_visual_stringlength
      EXPORTING
        im_string               = VIM_POSITION_INFO
        IM_LANGU                = SY-LANGU
      IMPORTING
        EX_POS_VIS              = P_VIM_POSITION_INFO_LEN
*      EXCEPTIONS
*        INVALID_TEXT_ENVIROMENT = 1
*        others                  = 2
        .
    IF sy-subrc &lt;&gt; 0.
*     MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.

*    HF2 = VIM_POSITION_INFO_LEN - STRLEN( VIM_POSITION_INFO ).
    HF2 = VIM_POSITION_INFO_LEN - P_VIM_POSITION_INFO_LEN.
* XB 585898E
    IF HF2 GT 0.
      SHIFT VIM_POSITION_INFO RIGHT BY HF2 PLACES.
    ENDIF.
    IF HF2 GE 0. EXIT. ENDIF.
    HF1 = STRLEN( SVIM_TEXT_028 ).
    REPLACE SVIM_TEXT_028 LENGTH HF1 WITH &apos;/&apos; INTO VIM_POSITION_INFO.
    IF SY-SUBRC NE 0.
      HF1 = STRLEN( SVIM_TEXT_027 ) + HF2 - 1.
      IF HF1 GT 0.
        WRITE &apos;.&apos; TO VIM_POSITION_INFO+HF1(1).
        ADD 1 TO HF1. HF2 = - HF2.
        WRITE &apos;          &apos; TO VIM_POSITION_INFO+HF1(HF2).
      ELSE.
        EXIT.
      ENDIF.
    ENDIF.
  ENDDO.
ENDFORM.                               &quot;set_position_info</include_source>
   </include>
   <include NAME="LSVIMF42" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_ASSIGN_MAINKEY_AFTER                                 *
*---------------------------------------------------------------------*
* assign symbols to after-date-part of mainkey                        *
*---------------------------------------------------------------------*
FORM vim_assign_mainkey_after USING value(vama_tabix) TYPE i.
  DATA: vama_ix TYPE i, length TYPE i.
  FIELD-SYMBOLS: &lt;x_namtab&gt; TYPE vimnamtab.

  vama_ix = vama_tabix + 1.
  READ TABLE x_namtab ASSIGNING &lt;x_namtab&gt; INDEX vama_ix.
  IF sy-subrc EQ 0 AND                 &quot;entry found and
   &lt;x_namtab&gt;-texttabfld EQ space AND  &quot;key continues
   &lt;x_namtab&gt;-position LT x_header-keylen. &quot;after date field
    vama_ix = x_header-keylen - &lt;x_namtab&gt;-position.
    ASSIGN: &lt;table1_x&gt;+&lt;x_namtab&gt;-position(vama_ix)
                              TO &lt;vim_f1_afterx&gt;,
            &lt;vim_h_coll_mkey&gt;+&lt;x_namtab&gt;-position(vama_ix)
                              TO &lt;vim_collapsed_key_afx&gt;,
            &lt;vim_h_mkey&gt;+&lt;x_namtab&gt;-position(vama_ix)
                              TO &lt;vim_mkey_afterx&gt;,
            &lt;vim_h_old_mkey&gt;+&lt;x_namtab&gt;-position(vama_ix)
                              TO &lt;vim_old_mkey_afterx&gt;. &quot; TYPE &apos;C&apos;.
    IF x_header-generictrp &lt;&gt; &apos;X&apos;.
** charlike key or non-unicode-system (FS is only assigned for
** downward compatibility).
      length = &lt;x_namtab&gt;-position
                DIV cl_abap_char_utilities=&gt;charsize.
      vama_ix = vama_ix DIV cl_abap_char_utilities=&gt;charsize.
      ASSIGN: &lt;table1&gt;+length(vama_ix)
                                TO &lt;vim_f1_after&gt;,
              vim_collapsed_mainkeys-mainkey+length(vama_ix)
                                TO &lt;vim_collapsed_key_af&gt;,
              vim_mainkey+length(vama_ix)
                                TO &lt;vim_mkey_after&gt;,
              vim_old_viewkey+length(vama_ix)
                                TO &lt;vim_old_mkey_after&gt;.
    ELSE.
      ASSIGN: &lt;vim_f1_afterx&gt; TO &lt;vim_f1_after&gt;,
              &lt;vim_collapsed_key_afx&gt; TO &lt;vim_collapsed_key_af&gt;,
              &lt;vim_mkey_afterx&gt; TO &lt;vim_mkey_after&gt;,
              &lt;vim_old_mkey_afterx&gt; TO &lt;vim_old_mkey_after&gt;.
    ENDIF.
    vim_mkey_after_exists = &apos;X&apos;.
    CLEAR vim_no_mainkey_exists.
  ELSE.
    CLEAR vim_mkey_after_exists.
  ENDIF.
ENDFORM.                               &quot;vim_asign_mainkey_after</include_source>
   </include>
   <include NAME="LSVIMF43" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_ASSIGN_MKEY_AFTER_2                                  *
*---------------------------------------------------------------------*
* assign symbols to after-date-part of mainkey part 2                 *
*---------------------------------------------------------------------*
FORM vim_assign_mkey_after_2 USING value(vama2_tabix) TYPE i.
  LOCAL:x_namtab.
  DATA: vama_ix TYPE i, keylen TYPE i, position TYPE i.
  FIELD-SYMBOLS: &lt;x_namtab&gt; TYPE vimnamtab.

  check vim_mkey_after_exists &lt;&gt; space.
  vama_ix = vama2_tabix + 1.
  READ TABLE x_namtab ASSIGNING &lt;x_namtab&gt; INDEX vama_ix.
  vama_ix = x_header-keylen - &lt;x_namtab&gt;-position.
  ASSIGN: &lt;vim_xtotal&gt;+&lt;x_namtab&gt;-position(vama_ix)
                            TO &lt;vim_tot_mkey_afterx&gt;,
          &lt;vim_xextract&gt;+&lt;x_namtab&gt;-position(vama_ix)
                            TO &lt;vim_ext_mkey_afterx&gt;.
  IF x_header-generictrp &lt;&gt; &apos;X&apos;.
* charlike key or non-unicode-system (FS is only assigned for
* downward compatibility).
    keylen = x_header-keylen / cl_abap_char_utilities=&gt;charsize.
    position = &lt;x_namtab&gt;-position / cl_abap_char_utilities=&gt;charsize.
    vama_ix = keylen - position.
    ASSIGN: &lt;vim_ctotal&gt;+position(vama_ix)
                              TO &lt;vim_tot_mkey_after&gt; TYPE &apos;C&apos;,
            &lt;vim_cextract&gt;+position(vama_ix)
                              TO &lt;vim_ext_mkey_after&gt; TYPE &apos;C&apos;.
  ELSE.
    ASSIGN: &lt;vim_xtotal&gt;+&lt;x_namtab&gt;-position(vama_ix)
             TO &lt;vim_tot_mkey_after&gt;,
            &lt;vim_xextract&gt;+&lt;x_namtab&gt;-position(vama_ix)
             TO &lt;vim_ext_mkey_after&gt;.
  ENDIF.
ENDFORM.                               &quot;vim_assign_mkey_after_2</include_source>
   </include>
   <include NAME="LSVIMF44" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM VIM_PROCESS_ASSIGNS                                      *
*---------------------------------------------------------------------*
* process assigns                                                     *
*---------------------------------------------------------------------*
FORM vim_process_assigns.
  DATA: length TYPE i, keydate_alr_assigned(1) TYPE c,
        tablength TYPE i, texttablength TYPE i, keylen_bef_date TYPE i,
        xlength type i.

  TRANSLATE vim_prtfky_assigned USING &apos;XY&apos;.
  ASSIGN: &lt;initial&gt; TO &lt;initial_x&gt; CASTING,
          total TO &lt;vim_ctotal&gt; CASTING TYPE c,
          total TO &lt;vim_total_struc&gt; CASTING TYPE (x_header-maintview),
          total to &lt;vim_xtotal&gt; casting,
          extract TO &lt;vim_cextract&gt; CASTING TYPE c,
          extract TO &lt;vim_extract_struc&gt;
           CASTING TYPE (x_header-maintview),
          extract to &lt;vim_xextract&gt; casting,
          corr_keytab-tabkey to &lt;vim_corr_keyx&gt; casting.
  tablength = x_header-after_tabc / cl_abap_char_utilities=&gt;charsize.
  texttablength =
   x_header-aft_txttbc / cl_abap_char_utilities=&gt;charsize.

  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    length = tablength + texttablength.
    xlength = x_header-texttablen + x_header-tablen.
    ASSIGN: &lt;vim_ctotal&gt;+tablength(texttablength) TO &lt;total_text&gt;,
            &lt;vim_xtotal&gt;+x_header-after_tabc(x_header-texttablen)
             to &lt;vim_xtotal_text&gt;,
            &lt;vim_xtotal_text&gt; to &lt;vim_tot_txt_struc&gt;
             casting type (x_header-texttab),
            &lt;vim_cextract&gt;(tablength) TO &lt;extract_enti&gt;,
            &lt;vim_cextract&gt;+tablength(texttablength) TO &lt;extract_text&gt;,
            &lt;vim_xextract&gt;+x_header-after_tabc(x_header-texttablen)
             to &lt;vim_xextract_text&gt;,
            &lt;vim_xextract_text&gt; to &lt;vim_ext_txt_struc&gt;
             casting type (x_header-texttab).
ELSE.
    length = tablength.
    xlength = x_header-tablen.
  ENDIF.
  ASSIGN: &lt;vim_ctotal&gt;+length(1) TO &lt;action&gt;,
          &lt;action&gt;+1(1) TO &lt;mark&gt;,
          &lt;vim_cextract&gt;(length) TO &lt;table2&gt;,
          &lt;vim_xextract&gt;(xlength) to &lt;table2_x&gt;,
          &lt;vim_xextract&gt;(x_header-tablen) to &lt;vim_xextract_enti&gt;,
          &lt;vim_cextract&gt;+length(1) TO &lt;xact&gt;,
          &lt;xact&gt;+1(1)  TO &lt;xmark&gt;,
          &lt;vim_ctotal&gt;(vim_ctabkeylen) TO &lt;vim_total_key&gt;,
          &lt;vim_cextract&gt;(vim_ctabkeylen) TO &lt;vim_extract_key&gt;,
          &lt;vim_xtotal&gt;(x_header-keylen) TO &lt;vim_xtotal_key&gt;,
          &lt;vim_xextract&gt;(x_header-keylen) TO &lt;vim_xextract_key&gt;.

  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    ASSIGN: &lt;mark&gt;+1(1) TO &lt;action_text&gt;,
            &lt;xmark&gt;+1(1) TO &lt;xact_text&gt;.
  ENDIF.
  IF x_header-adrnbrflag NE space.
    assign vim_addresses_to_save-handle to &lt;vim_addr_handle_x&gt; casting.
    LOOP AT x_namtab WHERE domname IN adrnbr_domain.
      ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
       &lt;vim_total_struc&gt; TO &lt;vim_total_address_number&gt;.
      EXIT.
    ENDLOOP.
  ENDIF.
  IF x_header-delmdtflag NE space.
    LOOP AT x_namtab WHERE domname EQ vim_delim_date_domain
                       AND ( rollname in vim_begda_types or
                             rollname in vim_endda_types ).
      IF x_namtab-rollname in vim_begda_types.
* begin date
        IF x_header-delmdtflag EQ &apos;E&apos;.
* end date is key field
          IF x_namtab-texttabfld EQ space.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_total_struc&gt; TO &lt;vim_begdate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_begdate&gt; TYPE &apos;D&apos;.
          ENDIF.
        ELSE.                          &quot;begin date is key field
          CHECK keydate_alr_assigned EQ space OR
                keydate_alr_assigned EQ &apos;E&apos; AND
                x_namtab-texttabfld NE space OR
                keydate_alr_assigned EQ &apos;T&apos; AND
                x_namtab-texttabfld EQ space.
          IF x_namtab-texttabfld EQ space.
            TRANSLATE keydate_alr_assigned USING &apos; ETX&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_total_struc&gt; TO &lt;vim_enddate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                  TO &lt;vim_enddate&gt; TYPE &apos;D&apos;.
            IF x_namtab-position GT 0.
              ASSIGN: &lt;vim_xtotal&gt;(x_namtab-position)
                       TO &lt;vim_tot_mkey_beforex&gt; casting,
                      &lt;vim_xextract&gt;(x_namtab-position)
                       TO &lt;vim_ext_mkey_beforex&gt; casting.
* for downward compatibility only:
              keylen_bef_date =
               x_namtab-position DIV cl_abap_char_utilities=&gt;charsize.
              ASSIGN: &lt;vim_ctotal&gt;(keylen_bef_date)
                                     TO &lt;vim_tot_mkey_before&gt; TYPE &apos;C&apos;,
                      &lt;vim_cextract&gt;(keylen_bef_date)
                                     TO &lt;vim_ext_mkey_before&gt; TYPE &apos;C&apos;.
            ELSE.
              ASSIGN:
*      begin correction if position &lt;= 0, should be fitted to unicode.
                      vim_dummy_mainkey TO &lt;vim_tot_mkey_beforex&gt;
                                                              casting ,
                      vim_dummy_mainkey TO &lt;vim_tot_mkey_beforex&gt;
                                                              casting ,
*      end correction von XB am 22.03.02 for csn int1332679 2002
                      vim_dummy_mainkey TO &lt;vim_tot_mkey_before&gt;
                                                              TYPE &apos;C&apos;,
                      &lt;vim_tot_mkey_before&gt; TO &lt;vim_ext_mkey_before&gt;
                                                              TYPE &apos;C&apos;.
            ENDIF.
            IF vim_mkey_after_exists NE space.
              PERFORM vim_assign_mkey_after_2 USING sy-tabix.
            ENDIF.
          ELSE.
            TRANSLATE keydate_alr_assigned USING &apos; TEX&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_tot_txt_struc&gt; TO &lt;vim_text_enddate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                  TO &lt;vim_text_enddate&gt; TYPE &apos;D&apos;.
          ENDIF.
        ENDIF.                         &quot;x_header-delmdtflag eq &apos;E&apos;
      ELSE.
* end date
        IF x_header-delmdtflag EQ &apos;E&apos;.
* end date is key field
          CHECK keydate_alr_assigned EQ space OR
                keydate_alr_assigned EQ &apos;E&apos; AND
                x_namtab-texttabfld NE space OR
                keydate_alr_assigned EQ &apos;T&apos; AND
                x_namtab-texttabfld EQ space.
          IF x_namtab-texttabfld EQ space.
            TRANSLATE keydate_alr_assigned USING &apos; ETX&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_total_struc&gt; TO &lt;vim_enddate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                  TO &lt;vim_enddate&gt; TYPE &apos;D&apos;.
            IF x_namtab-position GT 0.
              ASSIGN: &lt;vim_xtotal&gt;(x_namtab-position)
                       TO &lt;vim_tot_mkey_beforex&gt; casting,
                      &lt;vim_xextract&gt;(x_namtab-position)
                       TO &lt;vim_ext_mkey_beforex&gt; casting.
* for downward compatibility only:
              keylen_bef_date =
               x_namtab-position DIV cl_abap_char_utilities=&gt;charsize.
              ASSIGN:
                      &lt;vim_ctotal&gt;(keylen_bef_date)
                                     TO &lt;vim_tot_mkey_before&gt; TYPE &apos;C&apos;,
                      &lt;vim_cextract&gt;(keylen_bef_date)
                                     TO &lt;vim_ext_mkey_before&gt; TYPE &apos;C&apos;.
*              ASSIGN: total(x_namtab-position)
*                                     TO &lt;vim_tot_mkey_before&gt; TYPE &apos;C&apos;,
*                      extract(x_namtab-position)
*                                     TO &lt;vim_ext_mkey_before&gt; TYPE &apos;C&apos;.
            ELSE.
              ASSIGN:
*      begin correction if position &lt;= 0, should be fitted to unicode.
                      vim_dummy_mainkey TO &lt;vim_tot_mkey_beforex&gt;
                                                              casting ,
                      vim_dummy_mainkey TO &lt;vim_ext_mkey_beforex&gt;
                                                              casting ,
*      end correction von XB am 22.03.02 for csn int1332679 2002
                      vim_dummy_mainkey TO &lt;vim_tot_mkey_before&gt;
                                                              TYPE &apos;C&apos;,
                      &lt;vim_tot_mkey_before&gt; TO &lt;vim_ext_mkey_before&gt;
                                                              TYPE &apos;C&apos;.
            ENDIF.
            IF vim_mkey_after_exists NE space.
              PERFORM vim_assign_mkey_after_2 USING sy-tabix.
            ENDIF.
          ELSE.
            TRANSLATE keydate_alr_assigned USING &apos; TEX&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_tot_txt_struc&gt; TO &lt;vim_text_enddate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                  TO &lt;vim_text_enddate&gt; TYPE &apos;D&apos;.
          ENDIF.
        ELSE.                          &quot;begin date is key field
          IF x_namtab-texttabfld EQ space.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
             &lt;vim_total_struc&gt; TO &lt;vim_begdate&gt;.
*            ASSIGN total+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_begdate&gt; TYPE &apos;D&apos;.
          ENDIF.
        ENDIF.                         &quot;x_header-delmdtflag eq &apos;E&apos;
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.                               &quot;vim_process_assigns</include_source>
   </include>
   <include NAME="LSVIMF45" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*---------------------------------------------------------------------*
*       FORM INITIALISIEREN                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM initialisieren.
  LOCAL: counter.                                           &quot;#EC *
  TYPES: BEGIN OF i_fnamecnt,
           name LIKE vimsellist-viewfield,                  &quot;#EC *
           cnt TYPE i,
         END OF i_fnamecnt.
  DATA: keydate_alr_assigned(1) TYPE c,
        program LIKE d020s-prog,                            &quot;#EC NEEDED
        namlen TYPE i,                                      &quot;#EC NEEDED
        length TYPE i,
        name(25) TYPE c,
        fname(50) TYPE c,
        dynnr LIKE liste,                                    &quot;#EC NEEDED
        i_fnametb TYPE SORTED TABLE OF i_fnamecnt WITH UNIQUE KEY name,
        i_fnameln TYPE i_fnamecnt, initexclfldtabs(1) TYPE c,
        i_objtype LIKE objh-objecttype,
        f_fieldname(50) TYPE c.
  DATA: h_f1(70) TYPE c, h_f2(8)  TYPE c, h_f3(20) TYPE c.                         &quot;#EC NEEDED
  FIELD-SYMBOLS: &lt;m1&gt;, &lt;mili&gt; TYPE ANY, &lt;x_namtab&gt; TYPE vimnamtab,&quot;#EC *
                 &lt;f_fld_value&gt; TYPE ANY.

  IF nbrd_texts_alr_read EQ space.
    CALL &apos;C_SAPGPARAM&apos; ID &apos;NAME&apos;  FIELD &apos;transport/systemtype&apos;            &quot;#EC CI_CCALL
                       ID &apos;VALUE&apos; FIELD vim_system_type.
    PERFORM set_numbered_texts.
    length = vim_position_info_lg1 + 2 + vim_position_info_lg3.
** XB 585898B - remove the unused characters &apos;;;&apos;.
*    IF sy-langu = &apos;J&apos;.
*      REPLACE &apos;;;&apos; IN svim_text_027 WITH &apos;  &apos;.
*    ENDIF.
** XB 585898E
*   HW804856 remove disturbing &apos;;&apos;or &apos;;;..&apos; from translated texts
    REPLACE ALL OCCURRENCES OF &apos;;&apos; IN svim_text_027 WITH &apos;    &apos;.
    REPLACE ALL OCCURRENCES OF &apos;;&apos; IN svim_text_028 WITH &apos;    &apos;.
    REPLACE ALL OCCURRENCES OF &apos;;&apos; IN svim_text_029 WITH &apos;    &apos;.
    WRITE: svim_text_027 TO
             vim_position_info_mask(vim_position_info_lg1),
           svim_text_028 TO
             vim_position_info_mask+length(vim_position_info_lg2).
    vim_posi_push = &apos;@3Y@&apos;. vim_posi_push+4 = svim_text_029.
    MOVE: &apos;I&apos;   TO mark_functions-sign,
          &apos;I&apos;   TO adrnbr_domain-sign,
          &apos;I&apos;   TO exted_functions-sign,
          &apos;EQ&apos;  TO mark_functions-option,
          &apos;EQ&apos;  TO adrnbr_domain-option,
          &apos;EQ&apos;  TO exted_functions-option,
          space TO mark_functions-high,
          space TO adrnbr_domain-high,
          space TO exted_functions-high.
    MOVE &apos;ADDR&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;ALMK&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;DELE&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;DELM&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;EXPA&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;KOPE&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;MKLO&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;ORGI&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;REPL&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;TEXT&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;TREX&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;TRIN&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;UNDO&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;BCSH&apos; TO mark_functions-low. APPEND mark_functions.&quot;#EC *
    MOVE &apos;UNDO&apos; TO exted_functions-low. APPEND exted_functions.&quot;#EC *
    MOVE &apos;DELE&apos; TO exted_functions-low. APPEND exted_functions.&quot;#EC *
    MOVE &apos;TRIN&apos; TO exted_functions-low. APPEND exted_functions.&quot;#EC *
    MOVE &apos;TREX&apos; TO exted_functions-low. APPEND exted_functions.&quot;#EC *
    PERFORM vim_fill_vim_guid_domain.
    PERFORM vim_fill_date_type.
    DO.
      ASSIGN COMPONENT sy-index OF STRUCTURE vim_adrnbr_domains TO &lt;m1&gt;.
      IF sy-subrc NE 0. EXIT. ENDIF.
      MOVE &lt;m1&gt; TO adrnbr_domain-low. APPEND adrnbr_domain. &quot;#EC *
    ENDDO.
    PERFORM vim_initialize_d0100.      &quot; SW Texttransl
    MOVE &apos;X&apos; TO nbrd_texts_alr_read.
  ENDIF.
  READ TABLE x_header INDEX 1.                              &quot;#EC *
  IF x_header-existency NE &apos;R&apos;.
* SOBJ-Eintrag da?
    IF x_header-bastab EQ space OR
     ( x_header-maintview NE x_header-viewname AND          &quot;UF160998
       x_header-bastab NE space ).                          &quot;#EC BOOL_OK
      i_objtype = &apos;V&apos;.
    ELSE.
      i_objtype = &apos;S&apos;.
    ENDIF.
    SELECT SINGLE * FROM objh WHERE objectname EQ x_header-viewname
                                AND objecttype EQ i_objtype.&quot;#EC *
    IF sy-subrc NE 0.                  &quot;no obj.descr. -&gt; run RSVIM30A
      MESSAGE a138(sv) WITH x_header-viewname x_header-area.
    ENDIF.
  ENDIF.
  CLEAR: vim_nbr_of_scrfrm_pointers.
  vim_view_name = vim_addresses_to_save-viewname = x_header-viewname.
  MOVE: x_header-liste TO liste,
        x_header-detail TO detail.
  CASE x_header-type.
    WHEN &apos;1&apos;. MOVE einstufig TO status-type.
    WHEN &apos;2&apos;. MOVE zweistufig TO status-type.
  ENDCASE.
  counter = STRLEN( x_header-ddtext ).
  IF counter EQ 0. counter = 1. x_header-ddtext(1) = &apos;?&apos;. ENDIF.
  vim_title_name = x_header-ddtext.
  ASSIGN: vim_title_name(counter) TO &lt;name&gt;.
  MOVE &lt;name&gt; TO vim_frame_field.
* set up status vector
  IF x_header-bastab NE space.
    MOVE: &apos;STATUS_&apos; TO name,
          x_header-maintview TO name+7.                     &quot;Subviews
    ASSIGN (name) TO &lt;status&gt;.
    MOVE: &apos;*&apos; TO name,
          x_header-maintview TO name+1.
    ASSIGN (x_header-maintview) TO &lt;table1&gt;.
    IF sy-subrc = 4.
      MESSAGE a173(sv) WITH x_header-maintview x_header-area.  &quot;#EC *
    ENDIF.
    ASSIGN (name) TO &lt;initial&gt; CASTING TYPE (x_header-maintview).
* XB H606530B
* check if the time-field exists: Yes, then reset initial value.
    LOOP AT x_namtab WHERE datatype = &apos;TIMS&apos; AND
                       texttabfld EQ space.         &quot;HCG HW681596
      CONCATENATE &apos;&lt;initial&gt;&apos; x_namtab-viewfield INTO f_fieldname
              SEPARATED BY &apos;-&apos;.
      ASSIGN (f_fieldname) TO &lt;f_fld_value&gt;.
      CLEAR &lt;f_fld_value&gt; WITH space.
    ENDLOOP.
* XB H606530B
    IF x_header-texttbexst NE space.
      MOVE x_header-texttab TO name+1.
      ASSIGN: (x_header-texttab)  TO &lt;table1_text&gt;,
              (name)              TO &lt;text_initial&gt;,
              &lt;table1_text&gt;       TO &lt;table1_xtext&gt; CASTING,
              &lt;table1_xtext&gt;(x_header-textkeylen)  TO &lt;textkey_x&gt;,
              &lt;text_initial&gt;      TO &lt;text_initial_x&gt; CASTING,
              &lt;text_initial_x&gt;(x_header-textkeylen)
               TO &lt;initial_textkey_x&gt;.
      IF x_header-generictrp &lt;&gt; &apos;X&apos;
       AND cl_abap_char_utilities=&gt;charsize = 1.
* charlike key and non-unicode-system (FS only assigned for
* downward compatibility).
        ASSIGN: &lt;table1_text&gt;(x_header-textkeylen) TO &lt;textkey&gt;,
           &lt;text_initial&gt;(x_header-textkeylen) TO &lt;initial_textkey&gt;.
      ELSE.
        ASSIGN: &lt;table1_xtext&gt; TO &lt;textkey&gt;,
               &lt;initial_textkey_x&gt; TO &lt;initial_textkey&gt;.
      ENDIF.
    ENDIF.
    IF x_header-viewname = x_header-maintview.              &quot;Subviews
      CLEAR e071k-viewname.
      master_type = transp_object.
    ELSE.      &quot;View auf Tab.                              &quot;Subviews ..
      e071k-viewname = view_name.
      master_type = vim_view_type.
    ENDIF.                             &quot;.. Subviews
  ELSE.                                                     &quot;view
* XB H606530B
* check if the time-field exists: Yes, then reset initial value.
    LOOP AT x_namtab WHERE datatype = &apos;TIMS&apos;.               &quot;#EC *
      CONCATENATE &apos;&lt;initial&gt;&apos; x_namtab-viewfield INTO f_fieldname
              SEPARATED BY &apos;-&apos;.
      ASSIGN (f_fieldname) TO &lt;f_fld_value&gt;.
      CLEAR &lt;f_fld_value&gt; WITH space.
    ENDLOOP.
* XB H606530B
    WRITE: x_header-maintview TO compl_formname+compl_form_offs,
           x_header-maintview TO corr_formname+corr_form_offs.
    MOVE: view_name     TO e071k-viewname,
          vim_view_type TO master_type.
  ENDIF.
* set up screens
  MOVE: &apos;TCTRL_&apos; TO name,
        x_header-maintview TO name+6.
* Übergangslösung Tablecontrol Anfang
  DATA: h LIKE d020s, f LIKE d021s OCCURS 10, e LIKE d022s OCCURS 10,&quot;#EC *
        m LIKE d023s OCCURS 10, e_h LIKE d022s,             &quot;#EC NEEDED
        i_dynid(44) TYPE c.            &quot;VALUE &apos;SAPL&apos;.
  i_dynid  = x_header-fpoolname.                            &quot;4.0B
  i_dynid+40(4) = x_header-liste.
  IMPORT DYNPRO h f e m ID i_dynid.
  IF sy-subrc EQ 0.
    LOOP AT e INTO e_h WHERE LINE CS name.
      EXIT.
    ENDLOOP.
    IF sy-subrc EQ 0.
      vim_tabctrl_active = &apos;X&apos;.
    ELSE.
      CLEAR vim_tabctrl_active.
    ENDIF.
    ASSIGN h-mili TO &lt;mili&gt; CASTING TYPE x.
    IF &lt;mili&gt; O vim_template_dynpro.   &quot;SW: gen. Dynpros sind evtl.
      h-mili = h-mili - vim_template_dynpro.   &quot;fälschlicherweise als
      EXPORT DYNPRO h f e m ID i_dynid.&quot;Vorlagedynpros gekennzeichnet
      GENERATE DYNPRO h f e m ID i_dynid
                              MESSAGE h_f1 LINE h_f2 WORD h_f3.
    ENDIF.
  ELSE.
    CLEAR vim_tabctrl_active.
  ENDIF.
  IF x_header-type = &apos;2&apos;.
    i_dynid+40(4) = x_header-detail.
    IMPORT DYNPRO h f e m ID i_dynid.
    ASSIGN h-mili TO &lt;mili&gt; CASTING TYPE x.                         &quot;#EC RC_READ
    IF sy-subrc = 0
     AND &lt;mili&gt; O vim_template_dynpro. &quot;UF: Auch Einzelbilder sind
      h-mili = h-mili - vim_template_dynpro.   &quot;evtl. fälschlicherweise
      EXPORT DYNPRO h f e m ID i_dynid.&quot;als Vorlagedynpros
      GENERATE DYNPRO h f e m ID i_dynid       &quot;gekennzeichnet
       MESSAGE h_f1 LINE h_f2 WORD h_f3.
    ENDIF.
  ENDIF.
  IF vim_tabctrl_active NE space.
* Übergangslösung Tablecontrol Ende
    ASSIGN (name) TO &lt;vim_tctrl&gt;.
    IF sy-subrc EQ 0.
      vim_tabctrl_active = &apos;X&apos;.
      IF last_view_info &lt;&gt; space.      &quot;Subviews ..
        REFRESH CONTROL name FROM SCREEN x_header-liste.
      ENDIF.                           &quot;.. Subviews
      IF vim_restore_mode EQ space.
        &lt;status&gt;-l_sel_mode = &lt;vim_tctrl&gt;-line_sel_mode.
      ENDIF.
*     IF x_header-maintview &lt;&gt; x_header-viewname. &quot;Subviews or Switch-ID
      LOOP AT x_namtab WHERE readonly = vim_hidden.         &quot;#EC *
        CONCATENATE x_header-maintview &apos;-&apos; x_namtab-viewfield
                                                           INTO fname.
        LOOP AT &lt;vim_tctrl&gt;-cols INTO vim_tc_cols
                                 WHERE screen-name = fname.
          vim_tc_cols-vislength = 0.
          vim_tc_cols-invisible = &apos;1&apos;.
          MODIFY &lt;vim_tctrl&gt;-cols FROM vim_tc_cols.
          EXIT.
        ENDLOOP.
      ENDLOOP.
*     ENDIF.                                   &quot;.. Subviews or Switch-ID
    ELSE.
      CLEAR vim_tabctrl_active.
    ENDIF.
  ENDIF.
* process assigns to structure
  vim_ctabkeylen =
   x_header-after_keyc / cl_abap_char_utilities=&gt;charsize.
  IF x_header-clidep NE space.
    READ TABLE x_namtab ASSIGNING &lt;x_namtab&gt;
     WITH KEY datatype = &apos;CLNT&apos;.
    ASSIGN COMPONENT &lt;x_namtab&gt;-viewfield OF STRUCTURE &lt;table1&gt;
     TO &lt;client&gt;.
    ASSIGN COMPONENT &lt;x_namtab&gt;-viewfield OF STRUCTURE &lt;initial&gt;
     TO &lt;vim_client_initial&gt;.
    &lt;vim_client_initial&gt; = sy-mandt.
  ELSE.
    ASSIGN mandant TO &lt;vim_client_initial&gt;.
  ENDIF.
  master_name = view_name.
  ASSIGN: (x_header-maintview) TO &lt;table1_x&gt; CASTING,
          &lt;table1_x&gt;(x_header-keylen) TO &lt;f1_x&gt;,
          vim_view_wax TO &lt;table1_wa&gt;
           CASTING TYPE (x_header-maintview),
          vim_view_wax TO &lt;table1_wax&gt; CASTING,
          &lt;table1_wax&gt;(x_header-keylen) TO &lt;f1_wax&gt; CASTING.
  IF x_header-generictrp &lt;&gt; &apos;X&apos;
   AND cl_abap_char_utilities=&gt;charsize = 1.
* charlike key or non-unicode-system (&lt;f1&gt; is only assigned for
* downward compatibility).
    ASSIGN &lt;table1&gt;(vim_ctabkeylen) TO &lt;f1&gt;.
  ELSE.
    ASSIGN &lt;f1_x&gt; TO &lt;f1&gt;.
  ENDIF.
  PERFORM vim_set_init_from_sellist USING x_header-maintview
                                          x_namtab[]
                                          dba_sellist[]
                                          vim_hidden
                                    CHANGING &lt;initial&gt;.
  IF last_view_info NE space.          &quot;store old exclfldtabs
    MOVE: last_view_info TO vim_excl_xxx_tab_safe-viewname,
          excl_pos_tab[] TO vim_excl_xxx_tab_safe-excl_pos_tab,
          excl_rpl_tab[] TO vim_excl_xxx_tab_safe-excl_rpl_tab,
          excl_que_tab[] TO vim_excl_xxx_tab_safe-excl_que_tab.
    MODIFY TABLE vim_excl_xxx_tab_safe.                     &quot;#EC *
    IF sy-subrc NE 0.
      INSERT TABLE vim_excl_xxx_tab_safe.                   &quot;#EC *
    ENDIF.
  ENDIF.
  READ TABLE vim_excl_xxx_tab_safe WITH TABLE KEY
                                   viewname = x_header-viewname.&quot;#EC *
  IF sy-subrc EQ 0.
    excl_pos_tab[] = vim_excl_xxx_tab_safe-excl_pos_tab.
    excl_rpl_tab[] = vim_excl_xxx_tab_safe-excl_rpl_tab.
    excl_que_tab[] = vim_excl_xxx_tab_safe-excl_que_tab.
  ELSE.
    REFRESH: excl_rpl_tab, excl_que_tab, excl_pos_tab, exclude_tab.
    CLEAR: excl_rpl_tab, excl_que_tab, excl_pos_tab, exclude_tab.
    initexclfldtabs = &apos;X&apos;.
  ENDIF.
  IF x_header-subsetflag NE space OR x_header-adrnbrflag NE space OR
     x_header-rdonlyflag NE space OR x_header-usrexiflag NE space OR
     x_header-hiddenflag NE space OR x_header-scrfrmflag NE space OR
     x_header-guidflag NE space.
* no positioning or replacing for certain kinds of fields
    LOOP AT x_namtab WHERE readonly NE space
                        OR domname IN adrnbr_domain
                        OR domname EQ vim_scrform_domain
                        OR domname IN vim_guid_domain.      &quot;#EC *
      IF x_namtab-domname IN adrnbr_domain.
*        ASSIGN &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                    TO &lt;address_number&gt;.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
         TO &lt;address_number&gt;.
        MOVE x_namtab-readonly TO adrnbr_roflag.
        vim_addr_basetable = x_namtab-bastabname.
        vim_addr_bastab_field = x_namtab-bastabfld.
        CHECK initexclfldtabs NE space.
        MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
        MOVE x_namtab-viewfield TO excl_que_tab-fieldname.
        MOVE x_namtab-viewfield TO excl_pos_tab-fieldname.
        COLLECT excl_rpl_tab.                               &quot;#EC *
        COLLECT excl_que_tab.                               &quot;#EC *
        COLLECT excl_pos_tab.                               &quot;#EC *
        CONTINUE.
      ELSEIF x_namtab-domname EQ vim_scrform_domain.
*        ASSIGN &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                    TO &lt;vim_scrform_name&gt;.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
         TO &lt;vim_scrform_name&gt;.
        ADD 1 TO vim_nbr_of_scrfrm_pointers.
      ELSEIF x_namtab-domname IN vim_guid_domain.
        MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
        MOVE x_namtab-viewfield TO excl_que_tab-fieldname.
        MOVE x_namtab-viewfield TO excl_pos_tab-fieldname.
        COLLECT excl_rpl_tab.                               &quot;#EC *
        COLLECT excl_que_tab.                               &quot;#EC *
        COLLECT excl_pos_tab.                               &quot;#EC *
        CONTINUE.
      ENDIF.
      CHECK initexclfldtabs NE space.
      CASE x_namtab-readonly.
        WHEN subset.
          MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
          MOVE x_namtab-viewfield TO excl_que_tab-fieldname.
          APPEND excl_rpl_tab.                              &quot;#EC *
          APPEND excl_que_tab.                              &quot;#EC *
        WHEN usrexi.
*         check initexclfldtabs ne space.
          MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
          MOVE x_namtab-viewfield TO excl_que_tab-fieldname.
          MOVE x_namtab-viewfield TO excl_pos_tab-fieldname.
          APPEND excl_rpl_tab.                              &quot;#EC *
          APPEND excl_que_tab.                              &quot;#EC *
          APPEND excl_pos_tab.                              &quot;#EC *
        WHEN vim_hidden.
          MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
          MOVE x_namtab-viewfield TO excl_que_tab-fieldname.
          MOVE x_namtab-viewfield TO excl_pos_tab-fieldname.
          APPEND excl_rpl_tab.                              &quot;#EC *
          APPEND excl_que_tab.                              &quot;#EC *
          APPEND excl_pos_tab.                              &quot;#EC *
        WHEN rdonly.
          MOVE x_namtab-viewfield TO excl_rpl_tab-fieldname.
          APPEND excl_rpl_tab.                              &quot;#EC *
      ENDCASE.
    ENDLOOP.
  ENDIF.
  IF x_header-scrfrmflag NE space AND vim_nbr_of_scrfrm_pointers EQ 1.
    mark_functions-low = &apos;SCRF&apos;. APPEND mark_functions.     &quot;#EC *
  ELSE.
    DELETE mark_functions WHERE low EQ &apos;SCRF&apos;.
  ENDIF.
  IF x_header-selection NE space AND initexclfldtabs NE space.
    i_fnameln-cnt = 1.
    LOOP AT dba_sellist WHERE ddic CO ddic_marks
                        AND ( negation EQ space AND operator EQ &apos;EQ&apos; OR
                              negation EQ &apos;NOT&apos; AND operator EQ &apos;NE&apos; ).&quot;#EC *
      i_fnameln-name = dba_sellist-viewfield.
      COLLECT i_fnameln INTO i_fnametb.
    ENDLOOP.
    LOOP AT i_fnametb INTO i_fnameln WHERE cnt EQ 1.        &quot;#EC CI_SORTSEQ
      excl_rpl_tab-fieldname = i_fnameln-name.
      COLLECT excl_rpl_tab.                                 &quot;#EC *
      excl_que_tab-fieldname = i_fnameln-name.
      COLLECT excl_que_tab.                                 &quot;#EC *
    ENDLOOP.
  ENDIF.
  IF x_header-delmdtflag NE space.
    vim_tdep_title = svim_text_104.
    CLEAR: vim_old_viewkey, vim_old_st_selected.          &quot;SW wegen Vcl
    REFRESH vim_sval_tab. CLEAR vim_sval_tab.
    MOVE: x_header-viewname TO vim_sval_tab-tabname,
          x_header-maintview TO vim_begdate_name-tabname,
          x_header-maintview TO vim_enddate_name-tabname,
          &apos;X&apos; TO vim_sval_tab-field_obl,
          sy-datum TO vim_sval_tab-value.
    vim_begdate_name-dash = vim_enddate_name-dash = &apos;-&apos;.
    IF x_header-delmdtflag EQ &apos;E&apos;.
      ASSIGN d0001_field_tab-end TO &lt;key_date&gt;.
    ELSE.
      ASSIGN d0001_field_tab-begin TO &lt;key_date&gt;.
    ENDIF.
    ASSIGN: vim_mainkey TO &lt;vim_h_mkey&gt; CASTING,
            vim_old_viewkey TO &lt;vim_h_old_mkey&gt; CASTING,
            vim_collapsed_mainkeys-mainkey TO &lt;vim_h_coll_mkey&gt; CASTING,
            vim_collapsed_mainkeys-log_key TO &lt;vim_h_coll_logkey&gt;
             CASTING,
            vim_collapsed_mainkeys-mkey_bf TO &lt;vim_h_coll_bfkey&gt;
             CASTING,
            vim_merged_entries-merged_key TO &lt;vim_h_merged_key&gt; CASTING.
    LOOP AT x_namtab WHERE domname EQ vim_delim_date_domain
                       AND ( rollname IN vim_begda_types OR
                             rollname IN vim_endda_types ). &quot;#EC *
      IF x_namtab-rollname IN vim_begda_types.
* begin date
        IF x_header-delmdtflag EQ &apos;E&apos;.
* end date is key field
          IF x_namtab-texttabfld EQ space.
*            ASSIGN: &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_new_begdate&gt; TYPE &apos;D&apos;,
*                    &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_begdate_mask&gt; TYPE &apos;C&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_new_begdate&gt;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_begdate_mask&gt; CASTING TYPE c.
            MOVE: x_namtab-viewfield TO vim_sval_tab-fieldname,
                  x_namtab-viewfield TO vim_begdate_name-fieldname.
            vim_begdate_is_ro = x_namtab-readonly.
          ENDIF.
        ELSE.
* begin date is key field
          CHECK keydate_alr_assigned EQ space.
          keydate_alr_assigned = &apos;X&apos;.
          IF x_namtab-texttabfld EQ space.
*            ASSIGN: &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_enddate_mask&gt; TYPE &apos;C&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_enddate_mask&gt; CASTING TYPE c.
            IF x_namtab-position GT 0.
              IF x_header-generictrp &lt;&gt; &apos;X&apos;.
** charlike key or non-unicode-system (FS is only assigned for
** downward compatibility).
                length = x_namtab-position
                          DIV cl_abap_char_utilities=&gt;charsize.
                ASSIGN: &lt;table1&gt;(length)
                         TO &lt;vim_f1_before&gt; CASTING TYPE c,
                        vim_mainkey(length)
                          TO &lt;vim_mkey_before&gt; CASTING TYPE c,
                        vim_old_viewkey(length)
                          TO &lt;vim_old_mkey_before&gt; CASTING TYPE c.
              ENDIF.
              IF NOT ( &lt;vim_f1_before&gt; IS ASSIGNED
                       OR &lt;vim_mkey_before&gt; IS ASSIGNED
                       OR &lt;vim_old_mkey_before&gt; IS ASSIGNED ).
** could not be assigned because unicode flag is set in function
** group and key is non charlike
                ASSIGN: &lt;table1_x&gt;(x_namtab-position)
                         TO &lt;vim_f1_before&gt; CASTING TYPE x,
                        &lt;vim_h_mkey&gt;(x_namtab-position)
                          TO &lt;vim_mkey_before&gt; CASTING TYPE x,
                        &lt;vim_h_old_mkey&gt;(x_namtab-position)
                          TO &lt;vim_old_mkey_before&gt; CASTING TYPE x.
              ENDIF.
              ASSIGN: &lt;table1_x&gt;(x_namtab-position)
                       TO &lt;vim_f1_beforex&gt;,
                      &lt;vim_h_mkey&gt;(x_namtab-position)
                        TO &lt;vim_mkey_beforex&gt;,
                      &lt;vim_h_old_mkey&gt;(x_namtab-position)
                        TO &lt;vim_old_mkey_beforex&gt;,
                      &lt;vim_h_coll_bfkey&gt;(x_namtab-position)
                        TO &lt;vim_collapsed_mkey_bfx&gt;.
              CLEAR vim_no_mainkey_exists.
            ELSE.
              ASSIGN: vim_dummy_mainkey TO &lt;vim_mkey_before&gt; TYPE &apos;C&apos;,&quot;#EC *
                      &lt;vim_mkey_before&gt; TO &lt;vim_old_mkey_before&gt;,
                      &lt;vim_mkey_before&gt; TO &lt;vim_f1_before&gt;,
                      vim_dummy_mainkey TO &lt;vim_mkey_beforex&gt; CASTING,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_old_mkey_beforex&gt;,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_f1_beforex&gt;,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_collapsed_mkey_bfx&gt;.
              vim_no_mainkey_exists = &apos;X&apos;.
            ENDIF.
            MOVE x_namtab-viewfield TO vim_enddate_name-fieldname.
            PERFORM vim_assign_mainkey_after USING sy-tabix.
          ENDIF.
        ENDIF.                         &quot;x_header-delmdtflag eq &apos;E&apos;
      ELSE.
* end date
        IF x_header-delmdtflag EQ &apos;E&apos;.
* end date is key field
          CHECK keydate_alr_assigned EQ space.
          keydate_alr_assigned = &apos;X&apos;.
          IF x_namtab-texttabfld EQ space.
*            ASSIGN: &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_enddate_mask&gt; TYPE &apos;C&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_enddate_mask&gt; CASTING TYPE c.
            IF x_namtab-position GT 0.
              IF x_header-generictrp &lt;&gt; &apos;X&apos;.
** charlike key or non-unicode-system (FS is only assigned for
** downward compatibility).
                length = x_namtab-position
                          DIV cl_abap_char_utilities=&gt;charsize.
                ASSIGN: &lt;table1&gt;(length)
                         TO &lt;vim_f1_before&gt; CASTING TYPE c,
                        vim_mainkey(length)
                          TO &lt;vim_mkey_before&gt; CASTING TYPE c,
                        vim_old_viewkey(length)
                          TO &lt;vim_old_mkey_before&gt; CASTING TYPE c.
              ENDIF.
              IF NOT ( &lt;vim_f1_before&gt; IS ASSIGNED
                       OR &lt;vim_mkey_before&gt; IS ASSIGNED
                       OR &lt;vim_old_mkey_before&gt; IS ASSIGNED ).
** could not be assigned because unicode flag is set in function
** group and key is non charlike
                ASSIGN: &lt;table1_x&gt;(x_namtab-position)
                         TO &lt;vim_f1_before&gt; CASTING TYPE x,
                        vim_mainkey(x_namtab-position)
                          TO &lt;vim_mkey_before&gt; CASTING TYPE x,
                        vim_old_viewkey(x_namtab-position)
                          TO &lt;vim_old_mkey_before&gt; CASTING TYPE x.
              ENDIF.
              ASSIGN: &lt;table1_x&gt;(x_namtab-position)
                       TO &lt;vim_f1_beforex&gt;,
                      &lt;vim_h_mkey&gt;(x_namtab-position)
                        TO &lt;vim_mkey_beforex&gt;,
                      &lt;vim_h_old_mkey&gt;(x_namtab-position)
                        TO &lt;vim_old_mkey_beforex&gt;,
                      &lt;vim_h_coll_bfkey&gt;(x_namtab-position)
                        TO &lt;vim_collapsed_mkey_bfx&gt;.
*              ASSIGN: &lt;table1&gt;(x_namtab-position)
*                                     TO &lt;vim_f1_before&gt; TYPE &apos;C&apos;,
*                      vim_mainkey(x_namtab-position)
*                                     TO &lt;vim_mkey_before&gt; TYPE &apos;C&apos;,
*                      vim_old_viewkey(x_namtab-position)
*                                     TO &lt;vim_old_mkey_before&gt; TYPE &apos;C&apos;.
              CLEAR vim_no_mainkey_exists.
            ELSE.
              ASSIGN: vim_dummy_mainkey TO &lt;vim_mkey_before&gt; TYPE &apos;C&apos;,&quot;#EC *
                      &lt;vim_mkey_before&gt; TO &lt;vim_old_mkey_before&gt;,
                      &lt;vim_mkey_before&gt; TO &lt;vim_f1_before&gt;,
                      vim_dummy_mainkey TO &lt;vim_mkey_beforex&gt; CASTING,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_old_mkey_beforex&gt;,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_f1_beforex&gt;,
                      &lt;vim_mkey_beforex&gt; TO &lt;vim_collapsed_mkey_bfx&gt;.
              vim_no_mainkey_exists = &apos;X&apos;.
            ENDIF.
            MOVE x_namtab-viewfield TO vim_enddate_name-fieldname.
            PERFORM vim_assign_mainkey_after USING sy-tabix.
          ENDIF.
        ELSE.
* begin date is key field
          IF x_namtab-texttabfld EQ space.
*            ASSIGN: &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_new_begdate&gt; TYPE &apos;D&apos;,
*                    &lt;table1&gt;+x_namtab-position(x_namtab-flength)
*                                   TO &lt;vim_begdate_mask&gt; TYPE &apos;C&apos;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_new_begdate&gt;.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
             TO &lt;vim_begdate_mask&gt; CASTING TYPE c.
            MOVE: x_namtab-viewfield TO vim_sval_tab-fieldname,
                  x_namtab-viewfield TO vim_begdate_name-fieldname.
            vim_begdate_is_ro = x_namtab-readonly.
          ENDIF.
        ENDIF.                         &quot;x_header-delmdtflag eq &apos;E&apos;
      ENDIF.
    ENDLOOP.
    APPEND vim_sval_tab.                                    &quot;#EC *
    CONDENSE: vim_begdate_name NO-GAPS, vim_enddate_name NO-GAPS.
    MOVE: x_header-viewname TO vim_memory_id_1-viewname,
          sy-uname          TO vim_memory_id_1-user.
    IMPORT vim_collapsed_mainkeys FROM MEMORY ID vim_memory_id_1.&quot;#EC *
    IF sy-subrc NE 0.
      REFRESH vim_collapsed_mainkeys.
    ENDIF.
    ASSIGN: &lt;vim_h_coll_mkey&gt;(x_header-keylen)
                              TO &lt;vim_collapsed_keyx&gt;,
            &lt;vim_h_coll_logkey&gt;(x_header-keylen)
                              TO &lt;vim_collapsed_logkeyx&gt;,
            &lt;vim_h_merged_key&gt;(x_header-keylen)
                              TO &lt;vim_merged_keyx&gt;.
    IF x_header-generictrp &lt;&gt; &apos;X&apos;.
      ASSIGN: vim_collapsed_mainkeys-mainkey(x_header-keylen)
                                    TO &lt;vim_collapsed_key&gt;,
              vim_collapsed_mainkeys-log_key(x_header-keylen)
                                    TO &lt;vim_collapsed_logkey&gt;,
              vim_merged_entries-merged_key(x_header-keylen)
                                    TO &lt;vim_merged_key&gt;.
    ELSE.
      ASSIGN: &lt;vim_collapsed_keyx&gt; TO &lt;vim_collapsed_key&gt;,
              &lt;vim_collapsed_logkeyx&gt; TO &lt;vim_collapsed_logkey&gt;,
              &lt;vim_merged_keyx&gt; TO &lt;vim_merged_key&gt;.
    ENDIF.
  ENDIF.                               &quot;x_header-delmdtflag ne space
* if necessary. -&gt; how to decide this ? X_HEADER-PTFRKYEXST, later
  ASSIGN vim_mainkey(x_header-keylen) TO &lt;vim_mainkey_mask&gt;.
  CLEAR vim_prtfky_assigned.
* endif.
* consider clusters in transport defaults
  IF vim_called_by_cluster NE space.
    master_type = vim_clus_type.
    master_name = vim_calling_cluster.
  ENDIF.
* set transport defaults.....
  MOVE: transporter   TO e071-pgmid,
        master_type   TO e071-object,
        master_name   TO e071-obj_name,
        e071_objfunc  TO e071-objfunc,
        transporter   TO e071k-pgmid,
        transp_object TO e071k-object,
        space         TO e071k-as4pos,
        master_type   TO e071k-mastertype,
        master_name   TO e071k-mastername,
        space         TO e071k-objfunc,
        space         TO e071k-flag.
  PERFORM vim_get_img_activity
   CHANGING e071k-activity.           &quot;UF738595/2001
  IF x_header-existency EQ space OR x_header-existency EQ &apos;M&apos;.
    MOVE sortflag_with_existency TO e071k-sortflag.
  ELSE.
    MOVE sortflag_without_existency TO e071k-sortflag.
  ENDIF.
  REFRESH vim_corr_objtab. CLEAR vim_corr_obj_viewname.
  IF x_header-texttbexst &lt;&gt; space.     &quot;SW Texttransl
    PERFORM vim_initialize_texttab.
    vim_texttab_is_ro = &apos;X&apos;.
    LOOP AT x_namtab WHERE keyflag EQ space
                       AND bastabname EQ x_header-texttab
                       AND readonly NE rdonly.              &quot;#EC *
      CLEAR vim_texttab_is_ro.
      EXIT.
    ENDLOOP.
  ENDIF.
  CLEAR looplines.
  CLEAR old_nl.                                             &quot;PATIDARP 1475505
* possible to select profiles?
  vim_coming_from_img = &apos;N&apos;.
  IF vim_called_by_cluster = space.
*    IF x_header-adrnbrflag = space.
*      CALL FUNCTION &apos;SCPR_MEMORY_FLAG&apos;
*        IMPORTING
*          coming_from_img = vim_coming_from_img.
*    ENDIF.
  ELSE.
    CALL FUNCTION &apos;VIEWCLUSTER_PR_IMPORT_CTRL&apos;
      EXPORTING
        viewname        = x_header-viewname
        action          = &apos;P&apos;
      CHANGING
        coming_from_img = vim_coming_from_img
      EXCEPTIONS                                            &quot;#EC FB_RC
        wrong_parameter = 1
        OTHERS          = 2.
  ENDIF.
  last_view_info = view_name.
  PERFORM vim_maint_selflag USING    &apos;I&apos;
                            CHANGING x_header-selection.
ENDFORM.                    &quot;initialisieren

*---------------------------------------------------------------------*
*       FORM VIM_INITIALIZE_TEXTTAB                                   *
*---------------------------------------------------------------------*
* Initialisierung vin &lt;VIM_TEXTTAB&gt; und &lt;VIM_READ_LANGUS&gt;
*---------------------------------------------------------------------*
FORM vim_initialize_texttab.
  DATA: idx LIKE sy-tabix,
        texttab_l TYPE i.

  READ TABLE vim_texttab_container WITH KEY viewname = view_name
                                   BINARY SEARCH.           &quot;#EC *
  vim_texttab_container_index = sy-tabix.
  IF sy-subrc &lt;&gt; 0.
    CLEAR vim_texttab_container-tabdata-valid_idx.
    REFRESH vim_texttab_container-tabdata-tab_us.
    REFRESH vim_texttab_container-tabdata-tab_vs.
    REFRESH vim_texttab_container-tabdata-tab_s.
    REFRESH vim_texttab_container-tabdata-tab_m.
    REFRESH vim_texttab_container-tabdata-tab_l.
    REFRESH vim_texttab_container-tabdata-tab_vl.
    REFRESH vim_texttab_container-tabdata-tab_ul.
    REFRESH vim_texttab_container-sel_langus.
    CLEAR vim_texttab_container.

    vim_texttab_container-viewname = view_name.
*   Texttabellenbreite bestimmen
    texttab_l = ( x_header-after_keyc + x_header-aft_txttbc )
                 / cl_abap_char_utilities=&gt;charsize + 1.
*    texttab_l = x_header-keylen + x_header-texttablen + 1.
    IF texttab_l LE ultra_short_tab.
      vim_texttab_container-tabdata-valid_idx = 2.
    ELSEIF texttab_l LE very_short_tab.
      vim_texttab_container-tabdata-valid_idx = 3.
    ELSEIF texttab_l LE short_tab.
      vim_texttab_container-tabdata-valid_idx = 4.
    ELSEIF texttab_l LE middle_tab.
      vim_texttab_container-tabdata-valid_idx = 5.
    ELSEIF texttab_l LE long_tab.
      vim_texttab_container-tabdata-valid_idx = 6.
    ELSEIF texttab_l LE very_long_tab.
      vim_texttab_container-tabdata-valid_idx = 7.
    ELSEIF texttab_l LE ultra_long_tab.
      vim_texttab_container-tabdata-valid_idx = 8.
    ENDIF.
    INSERT vim_texttab_container INDEX vim_texttab_container_index.&quot;#EC *
  ENDIF.
  idx = vim_texttab_container-tabdata-valid_idx.
  ASSIGN COMPONENT idx OF STRUCTURE
         vim_texttab_container-tabdata TO &lt;vim_texttab&gt;.
  ASSIGN vim_texttab_container-sel_langus TO &lt;vim_read_langus&gt;.
ENDFORM.                               &quot;VIM_INITIALIZE_TEXTTAB
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_fill_vim_guid_domain
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_fill_vim_guid_domain.
  MOVE: &apos;I&apos;   TO vim_guid_domain-sign,
        &apos;EQ&apos;  TO vim_guid_domain-option.
  MOVE &apos;SYSUUID&apos; TO vim_guid_domain-low. APPEND vim_guid_domain.&quot;#EC *
  MOVE &apos;SYSUUID_C&apos; TO vim_guid_domain-low. APPEND vim_guid_domain.&quot;#EC *
  MOVE &apos;SYSUUID_22&apos; TO vim_guid_domain-low. APPEND vim_guid_domain.&quot;#EC *
  MOVE &apos;SYSUUID_25&apos; TO vim_guid_domain-low. APPEND vim_guid_domain.&quot;#EC *
ENDFORM.                    &quot; vim_fill_vim_guid_domain
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_set_init_from_sellist
*&amp;---------------------------------------------------------------------*
*       If sellist defines values unambiguously, set them into initial
*       WA.
*----------------------------------------------------------------------*
*      --&gt;P_TABNAME   tabname
*      --&gt;P_NAMTAB[]  nametab info
*      --&gt;P_SELLIST   selection
*      &lt;--P_INIT      initial view-wa
*----------------------------------------------------------------------*
FORM vim_set_init_from_sellist USING    p_tabname TYPE tabname
                                        p_namtab LIKE x_namtab[]
                                        p_sellist LIKE dba_sellist[]
                                        p_maintdesc TYPE vfldroflag
                               CHANGING p_init TYPE any.

  DATA: count TYPE i, h_ix TYPE i, rcode TYPE xfeld,                     &quot;#EC NEEDED
        tabfld TYPE tabfield.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab, &lt;sel_wa&gt; TYPE vimsellist,
                 &lt;value&gt; TYPE ANY.

  LOOP AT p_namtab ASSIGNING &lt;namtab&gt; WHERE readonly = p_maintdesc.
    CLEAR: rcode, count, h_ix.
    LOOP AT p_sellist ASSIGNING &lt;sel_wa&gt;
     WHERE viewfield EQ &lt;namtab&gt;-viewfield
           AND ( negation EQ space AND operator EQ &apos;EQ&apos; OR
                 negation EQ &apos;NOT&apos; AND operator EQ &apos;NE&apos; )
           AND ( ddic      CO &apos;XB&apos; OR
                 ddic      CO &apos;SB&apos; ).
      ADD 1 TO count.
      CHECK &lt;sel_wa&gt;-and_or EQ space OR &lt;sel_wa&gt;-and_or EQ &apos;AND&apos;.
      rcode = &apos;X&apos;. h_ix = sy-tabix.
    ENDLOOP.
    IF rcode = space OR count &gt; 1.
      CLEAR: rcode, count.
      LOOP AT p_sellist ASSIGNING &lt;sel_wa&gt;
       WHERE viewfield EQ &lt;namtab&gt;-viewfield
        AND ( negation EQ space AND operator EQ &apos;EQ&apos; OR
                   negation EQ &apos;NOT&apos; AND operator EQ &apos;NE&apos; )
             AND ( ddic EQ &apos;A&apos; ).
        ADD 1 TO count.
        CHECK &lt;sel_wa&gt;-and_or EQ space OR &lt;sel_wa&gt;-and_or EQ &apos;AND&apos;.
        rcode = &apos;X&apos;. h_ix = sy-tabix.
      ENDLOOP.
    ENDIF.
    IF rcode &lt;&gt; space AND count = 1.
      ASSIGN COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE p_init TO &lt;value&gt;.
      CHECK sy-subrc = 0.
      tabfld-tabname = p_tabname.
      tabfld-fieldname = tabfld-lfieldname = &lt;namtab&gt;-viewfield.
      CALL FUNCTION &apos;RS_CONV_EX_2_IN&apos;
        EXPORTING
          input_external  = &lt;sel_wa&gt;-value
          table_field     = tabfld
        IMPORTING
          output_internal = &lt;value&gt;
        EXCEPTIONS
          OTHERS          = 1.
      IF sy-subrc &lt;&gt; 0.
        CLEAR &lt;value&gt;.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                    &quot; vim_set_init_from_sellist
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_fill_date_type
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_fill_date_type.

  MOVE: &apos;I&apos;   TO vim_begda_types-sign,
        &apos;EQ&apos;  TO vim_begda_types-option.
  MOVE vim_begdate_dtel1 TO vim_begda_types-low. APPEND vim_begda_types.&quot;#EC *
  MOVE vim_begdate_dtel2 TO vim_begda_types-low. APPEND vim_begda_types.&quot;#EC *
  MOVE vim_begdate_dtel3 TO vim_begda_types-low. APPEND vim_begda_types.&quot;#EC *
  MOVE vim_begdate_dtel4 TO vim_begda_types-low. APPEND vim_begda_types.&quot;#EC *
  MOVE vim_enddate_dtel1 TO vim_begda_types-low.
  APPEND vim_begda_types TO vim_endda_types.
  MOVE vim_enddate_dtel2 TO vim_begda_types-low.
  APPEND vim_begda_types TO vim_endda_types.
  MOVE vim_enddate_dtel3 TO vim_begda_types-low.
  APPEND vim_begda_types TO vim_endda_types.
  MOVE vim_enddate_dtel4 TO vim_begda_types-low.
  APPEND vim_begda_types TO vim_endda_types.
ENDFORM.                    &quot; vim_fill_date_type</include_source>
   </include>
   <include NAME="LSVIMF46" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMF46                                                   *
*----------------------------------------------------------------------*
* &lt;Address_Number&gt; -&gt; &lt;table1&gt; = View-Workarea (= zu übernehmender
*      Eintrag, aber Adreßnummer des akt. Mandant/System;
*      Adreßnummer wurde in VIM_MODIFY_VIEW_ENTRY ausgetauscht)
* &lt;F1&gt;             -&gt; &lt;table1&gt;(keylen)
* VIM_UPGR_ADDRESS_NUMBER -&gt; Adresse des zu übernehmenden Eintrages
* Achtung: in TOTAL steht NICHT(!) mehr der Eintrag aus akt. Mandant/Sys
*          zur Verfügung wegen Zuweisung  &apos;move &lt;table1&gt; to total&apos;
*          in liste_initialisieren im &apos;Replace_mode&apos;.
*----------------------------------------------------------------------*
FORM vim_address_adjust.
  DATA: addr_comp_tab TYPE szadr_compare_addr1_tab,
        addr_comp_line TYPE szadr_compare_addr1_line,
        handle TYPE ad_handle,
        create_address(1) TYPE c,
        retcode LIKE  szad_field-returncode,
        error_info LIKE addr_error OCCURS 0 WITH HEADER LINE,
        einfo      LIKE addr_error,
        i_msgv1 LIKE sy-msgv1,
        space_msgv LIKE sy-msgv1 VALUE space,
        dum TYPE i, pos_char TYPE i,
        handle_c TYPE ad_handle.

  FIELD-SYMBOLS: &lt;handle_x&gt; TYPE x, &lt;field_loc&gt; TYPE ANY.

* nur neue Adreßpflege!
  CHECK x_header-adrnbrflag = &apos;N&apos; AND adrnbr_roflag = space.
  ASSIGN handle TO &lt;handle_x&gt; CASTING.
  IF vim_import_mode_active = space.             &quot;interaktive Übernahme
    IF vim_upgr_address_number &lt;&gt; &apos;@ADJUSTED@&apos;.   &quot;cmpwl_addr_adjusted
      EXIT.
    ENDIF.
    IF &lt;address_number&gt; = space.
      &lt;handle_x&gt; = &lt;f1_x&gt;.
*      HANDLE = &lt;F1&gt;.
      handle_c = &lt;handle_x&gt;(140).              &quot; Note 1482993 PATIDARP
      addr_comp = &apos;X&apos;.                         &quot; Note 1482993 PATIDARP
      create_address = &apos;X&apos;.
    ELSE.
      READ TABLE vim_locked_addresses FROM &lt;address_number&gt;
                                        TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.                &quot;not yet locked
        CALL FUNCTION &apos;ADDR_ENQUEUE&apos;
             EXPORTING
                  address_number    = &lt;address_number&gt;
*               MODE_ADRC         = &apos;E&apos;
             EXCEPTIONS
                  address_not_exist = 1
                  foreign_lock      = 2
                  system_failure    = 3
                  internal_error    = 4.
        CASE sy-subrc.
          WHEN 0.
            INSERT &lt;address_number&gt; INTO TABLE vim_locked_addresses.
          WHEN 1.
            &lt;handle_x&gt; = &lt;f1_x&gt;.
*            HANDLE = &lt;F1&gt;.
            create_address = &apos;X&apos;.
            CLEAR &lt;address_number&gt;.
          WHEN 2.
            PERFORM vim_process_message
                USING &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;049&apos;
                      sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          WHEN OTHERS.
*            i_msgv1 = &lt;table1&gt;.   &quot;HCG Dump when nonchar field in view
            LOOP AT x_namtab.       &quot;HCG write field by field instead
* XB H644658B
              CHECK x_namtab-keyflag NE space.
* Beim Feld f wurden Offset oder Länge angegeben und der Datentyp des
* zuzuweisenden Felds erlaubt keine Teilzugriffe. (Dies ist bei den
* Datentypen I, F und P der Fall.)
              CHECK x_namtab-inttype NE &apos;I&apos;.
              CHECK x_namtab-inttype NE &apos;P&apos;.
              CHECK x_namtab-inttype NE &apos;F&apos;.
* XB H644658E
              ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
                                              TO &lt;field_loc&gt;.
              dum = ( x_namtab-position + x_namtab-flength ) /
                            cl_abap_char_utilities=&gt;charsize.
              pos_char = x_namtab-position /
                                      cl_abap_char_utilities=&gt;charsize.
              IF dum &lt;= 50.         &quot;End of field &lt;= Length of sy-msgv1
                WRITE &lt;field_loc&gt; TO i_msgv1+pos_char.
              ELSE.
                dum = 50 - pos_char.
                IF dum GT 0. &quot;Otherwise i_msgv1 just filled up to 50
                  WRITE &lt;field_loc&gt;(dum) TO i_msgv1+pos_char.
                ENDIF.
                EXIT.                               &quot;HCG i_msgv1 filled
              ENDIF.
            ENDLOOP.
            PERFORM vim_process_message
              USING &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;050&apos;
                  i_msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDCASE.
      ENDIF.  &quot; SY-SUBRC &lt;&gt; 0.
    ENDIF.   &quot;&lt;Address_Number&gt; = SPACE

  ELSE.  &quot;automat. Übernahme
    IF vim_upgr_address_number = space.
*      i_msgv1 = &lt;table1&gt;.   &quot;HCG Dump when nonchar field in view
      LOOP AT x_namtab.       &quot;HCG write field by field instead
* XB H647964B
              CHECK x_namtab-keyflag NE space.
* Beim Feld f wurden Offset oder Länge angegeben und der Datentyp des
* zuzuweisenden Felds erlaubt keine Teilzugriffe. (Dies ist bei den
* Datentypen I, F und P der Fall.)
              CHECK x_namtab-inttype NE &apos;I&apos;.
              CHECK x_namtab-inttype NE &apos;P&apos;.
              CHECK x_namtab-inttype NE &apos;F&apos;.
* XB H647964E
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
                                        TO &lt;field_loc&gt;.
        dum = ( x_namtab-position + x_namtab-flength ) /
                      cl_abap_char_utilities=&gt;charsize.
        pos_char = x_namtab-position /
                                cl_abap_char_utilities=&gt;charsize.
        IF dum &lt;= 50.         &quot;End of field &lt;= Length of sy-msgv1
          WRITE &lt;field_loc&gt; TO i_msgv1+pos_char.
        ELSE.
          dum = 50 - pos_char.
          IF dum GT 0. &quot;Otherwise i_msgv1 just filled up to 50
            WRITE &lt;field_loc&gt;(dum) TO i_msgv1+pos_char.
          ENDIF.
          EXIT.                               &quot;HCG i_msgv1 filled
        ENDIF.
      ENDLOOP.
      PERFORM vim_process_message
                USING &apos;SV&apos; &apos;I&apos; &apos;I&apos;  &apos;165&apos;
                    i_msgv1 space_msgv space_msgv space_msgv.
      EXIT.                                          &quot;keine Löschung
    ENDIF.

    addr_comp_line-addrnumber = &lt;address_number&gt;.
    IF &lt;address_number&gt; = space.
      &lt;handle_x&gt; = &lt;f1_x&gt;.
      addr_comp_line-addrhandle = handle.
*      ADDR_COMP_LINE-ADDRHANDLE = &lt;F1&gt;.
*      HANDLE = &lt;F1&gt;.
      create_address = &apos;X&apos;.
    ENDIF.
    addr_comp_line-remote_addrnumber = vim_upgr_address_number.
    APPEND addr_comp_line TO addr_comp_tab.
    CALL FUNCTION &apos;ADDR_COMPARE&apos;
      EXPORTING
        rfc_destination = vim_default_rfc_dest-rfcdest
      TABLES
        compare_tab     = addr_comp_tab
      EXCEPTIONS
        rfc_error       = 1
        OTHERS          = 2.
    IF sy-subrc &lt;&gt; 0.
      PERFORM vim_process_message
            USING sy-msgid &apos;E&apos; &apos;E&apos;  sy-msgno
                  sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      EXIT.
    ENDIF.
    READ TABLE addr_comp_tab INDEX 1 INTO addr_comp_line.
    IF addr_comp_line-parameter_error = &apos;X&apos; OR
       addr_comp_line-internal_error = &apos;X&apos;.
      einfo = addr_comp_line-error_table.
      PERFORM vim_process_message
        USING einfo-msg_id &apos;E&apos; &apos;E&apos;  einfo-msg_number
            einfo-msg_var1 einfo-msg_var2 einfo-msg_var3 einfo-msg_var4.
*     Adresse kann nicht abgeglichen werden -&gt; Eintrag verwerfen
      EXIT.
    ENDIF.

    IF addr_comp_line-rem_address_not_exist = &apos;X&apos;.    &quot;keine Löschung!
*      i_msgv1 = &lt;table1&gt;.   &quot;HCG Dump when nonchar field in view
      LOOP AT x_namtab.       &quot;HCG write field by field instead
* XB H647964B
              CHECK x_namtab-keyflag NE space.
* Beim Feld f wurden Offset oder Länge angegeben und der Datentyp des
* zuzuweisenden Felds erlaubt keine Teilzugriffe. (Dies ist bei den
* Datentypen I, F und P der Fall.)
              CHECK x_namtab-inttype NE &apos;I&apos;.
              CHECK x_namtab-inttype NE &apos;P&apos;.
              CHECK x_namtab-inttype NE &apos;F&apos;.
* XB H647964E
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
                                        TO &lt;field_loc&gt;.
        dum = ( x_namtab-position + x_namtab-flength ) /
                      cl_abap_char_utilities=&gt;charsize.
        pos_char = x_namtab-position /
                                cl_abap_char_utilities=&gt;charsize.
        IF dum &lt;= 50.         &quot;End of field &lt;= Length of sy-msgv1
          WRITE &lt;field_loc&gt; TO i_msgv1+pos_char.
        ELSE.
          dum = 50 - pos_char.
          IF dum GT 0. &quot;Otherwise i_msgv1 just filled up to 50
            WRITE &lt;field_loc&gt;(dum) TO i_msgv1+pos_char.
          ENDIF.
          EXIT.                               &quot;HCG i_msgv1 filled
        ENDIF.
      ENDLOOP.
      PERFORM vim_process_message
              USING &apos;SV&apos; &apos;I&apos; &apos;I&apos;  &apos;165&apos;
                    i_msgv1 space_msgv space_msgv space_msgv.
      EXIT.
    ELSEIF addr_comp_line-address_not_exist = &apos;X&apos; AND
           create_address = space.
      &lt;handle_x&gt; = &lt;f1_x&gt;.
*      HANDLE = &lt;F1&gt;.
      create_address = &apos;X&apos;.
      CLEAR: &lt;address_number&gt;, &lt;vim_total_address_number&gt;.
      REFRESH addr_comp_tab. CLEAR addr_comp_line.
      addr_comp_line = handle.
*      ADDR_COMP_LINE-ADDRHANDLE = &lt;F1&gt;.
      addr_comp_line-remote_addrnumber = vim_upgr_address_number.
      APPEND addr_comp_line TO addr_comp_tab.
      CALL FUNCTION &apos;ADDR_COMPARE&apos;
        EXPORTING
          rfc_destination = vim_default_rfc_dest-rfcdest
        TABLES
          compare_tab     = addr_comp_tab
        EXCEPTIONS
          rfc_error       = 1
          OTHERS          = 2.
      IF sy-subrc &lt;&gt; 0.
        PERFORM vim_process_message
              USING sy-msgid &apos;E&apos; &apos;E&apos;  sy-msgno
                    sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        EXIT.
      ENDIF.
      READ TABLE addr_comp_tab INDEX 1 INTO addr_comp_line.
      IF addr_comp_line-parameter_error = &apos;X&apos; OR
         addr_comp_line-internal_error = &apos;X&apos;.
        einfo = addr_comp_line-error_table.
        PERFORM vim_process_message
          USING einfo-msg_id &apos;E&apos; &apos;E&apos;  einfo-msg_number
            einfo-msg_var1 einfo-msg_var2 einfo-msg_var3 einfo-msg_var4.
*       Adresse kann nicht abgeglichen werden -&gt; Eintrag verwerfen
        EXIT.
      ENDIF.
*     Überprüfung von REM_ADDRESS_NOT_EXIST, .. hier nicht nötig

    ELSEIF addr_comp_line-address_is_equal = &apos;X&apos;.
      EXIT.
    ELSEIF create_address = space.
      READ TABLE vim_locked_addresses FROM &lt;address_number&gt;
                                        TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.                &quot;not yet locked
        CALL FUNCTION &apos;ADDR_ENQUEUE&apos;
             EXPORTING
                  address_number    = &lt;address_number&gt;
*               MODE_ADRC         = &apos;E&apos;
             EXCEPTIONS
                  address_not_exist = 1
                  foreign_lock      = 2
                  system_failure    = 3
                  internal_error    = 4.
        CASE sy-subrc.
          WHEN 0.
            INSERT &lt;address_number&gt; INTO TABLE vim_locked_addresses.
          WHEN 1.  &quot; würde schon in ADDR_COMPARE auftreten
            PERFORM vim_process_message    &quot;eigentlich überflüssig
                USING &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;049&apos;
                      sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          WHEN 2.
            PERFORM vim_process_message
                USING &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;049&apos;
                      sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          WHEN OTHERS.
*            i_msgv1 = &lt;table1&gt;.   &quot;HCG Dump when nonchar field in view
            LOOP AT x_namtab.       &quot;HCG write field by field instead
* XB H647964B
              CHECK x_namtab-keyflag NE space.
* Beim Feld f wurden Offset oder Länge angegeben und der Datentyp des
* zuzuweisenden Felds erlaubt keine Teilzugriffe. (Dies ist bei den
* Datentypen I, F und P der Fall.)
              CHECK x_namtab-inttype NE &apos;I&apos;.
              CHECK x_namtab-inttype NE &apos;P&apos;.
              CHECK x_namtab-inttype NE &apos;F&apos;.
* XB H647964E
              ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1&gt;
                                              TO &lt;field_loc&gt;.
              dum = ( x_namtab-position + x_namtab-flength ) /
                            cl_abap_char_utilities=&gt;charsize.
              pos_char = x_namtab-position /
                                      cl_abap_char_utilities=&gt;charsize.
              IF dum &lt;= 50.         &quot;End of field &lt;= Length of sy-msgv1
                WRITE &lt;field_loc&gt; TO i_msgv1+pos_char.
              ELSE.
                dum = 50 - pos_char.
                IF dum GT 0. &quot;Otherwise i_msgv1 just filled up to 50
                  WRITE &lt;field_loc&gt;(dum) TO i_msgv1+pos_char.
                ENDIF.
                EXIT.                               &quot;HCG i_msgv1 filled
              ENDIF.
            ENDLOOP.
            PERFORM vim_process_message
              USING &apos;SV&apos; &apos;E&apos; &apos;E&apos; &apos;050&apos;
                  i_msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDCASE.
      ENDIF.   &quot;SY-SUBRC
    ENDIF.
  ENDIF.     &quot; vim_import_mode_active

  CALL FUNCTION &apos;ADDR_ADJUST&apos;
    EXPORTING
      addrnumber           = &lt;address_number&gt;
      addrhandle           = handle_c            &quot;Note 1482993 PATIDARP
      address_group        = &apos;CA01&apos;
    IMPORTING
      returncode           = retcode
    TABLES
      error_table          = error_info
    EXCEPTIONS
      parameter_error      = 1
      address_not_exist    = 2
      handle_exist         = 3
      internal_error       = 4
      address_not_compared = 5
      OTHERS               = 6.
  IF sy-subrc &lt;&gt; 0.
    PERFORM vim_process_message
           USING sy-msgid &apos;E&apos; &apos;E&apos; sy-msgno
                 sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ELSE.
    IF retcode = &apos;E&apos;.
      READ TABLE error_info INDEX 1.
      PERFORM vim_process_message
             USING error_info-msg_id &apos;E&apos; &apos;E&apos; error_info-msg_number
                   error_info-msg_var1 error_info-msg_var2
                   error_info-msg_var3 error_info-msg_var4.
    ELSE.    &quot;ok
      IF create_address = &apos;X&apos;.
        &lt;address_number&gt; = &apos;@NEW&apos;.
        &lt;address_number&gt;+4(6) = &lt;status&gt;-newadrcnt.
        ADD 1 TO &lt;status&gt;-newadrcnt.
        &lt;status&gt;-upd_flag = &apos;X&apos;.
      ENDIF.
      &lt;vim_total_address_number&gt; = &lt;address_number&gt;.
      READ TABLE vim_addresses_to_save
                              WITH KEY viewname = x_header-viewname
                                       addrnumber = &lt;address_number&gt;
                              BINARY SEARCH TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        vim_addresses_to_save-viewname = x_header-viewname.
        vim_addresses_to_save-addrnumber = &lt;address_number&gt;.
        &lt;vim_addr_handle_x&gt; = &lt;f1_x&gt;.
*        VIM_ADDRESSES_TO_SAVE-HANDLE = &lt;F1&gt;.
        INSERT vim_addresses_to_save INDEX sy-tabix.
      ENDIF.
      IF vim_client_state EQ vim_log AND
        x_header-flag NE vim_transport_denied and
        vim_actopts-transp_off NE bc_transport_denied.
        &lt;status&gt;-upd_flag = &apos;X&apos;. &quot;nec. for transport of master entry
      ENDIF.
    ENDIF.                                                  &quot;RETCODE
  ENDIF.            &quot;SY-SUBRC
ENDFORM.                    &quot;vim_address_adjust</include_source>
   </include>
   <include NAME="LSVIMF50" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMF50                                                   *
*----------------------------------------------------------------------*

FORM VIM_VCLDOCKING_CONTROL.
  DATA: DISABLE_NAVI(1) TYPE C.

  IF VIM_EXTERNAL_MODE = &apos;X&apos; OR VIM_SPECIAL_MODE = VIM_DIRECT_UPGRADE
     OR STATUS-ACTION = &apos;C&apos;.
    DISABLE_NAVI = &apos;X&apos;.
  ENDIF.
  IF DISABLE_NAVI IS INITIAL.             &quot;IM 3275739 2010
    CALL FUNCTION &apos;VIEWCLUSTER_NAVI_CONTROL&apos;
      EXPORTING
        OWNER_REPID        = X_HEADER-FPOOLNAME
        OWNER_DYNNR        = SY-DYNNR
        DISABLE_NAVIGATION = DISABLE_NAVI
      EXCEPTIONS
        OTHERS             = 1.
    IF SY-SUBRC = 0.
      MOVE &apos;ATAB&apos; TO EXCL_CUA_FUNCT-FUNCTION. COLLECT EXCL_CUA_FUNCT.
    ENDIF.
  ENDIF.
ENDFORM.                                  &quot; VIM_VCLDOCKING_CONTROL</include_source>
   </include>
   <include NAME="LSVIMF51" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMF51                                                   *
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_ADD_IMG_NOTICES_PBO
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_DYNPRO  Dynpro number
*----------------------------------------------------------------------*
FORM vim_add_img_notices_pbo USING    value(p_dynpro) TYPE list_scr.

  DATA: progname LIKE sy-repid, exit, dynpro TYPE sydynnr.  &quot;#EC NEEDED
                                                            &quot;#EC TYPES_MISS

  CHECK vim_special_mode &lt;&gt; vim_upgrade AND vim_import_profile = space.
  progname = sy-repid.
  dynpro = p_dynpro.
  CALL FUNCTION &apos;SPROJECT_CONTROL_PBO&apos;
       EXPORTING
            repid = progname
            dynnr = dynpro.
ENDFORM.                               &quot; VIM_ADD_IMG_NOTICES_PBO

*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_ADD_IMG_NOTICES_PAI
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_MODE   text
*      &lt;--P_EXIT_OK  text
*----------------------------------------------------------------------*
FORM vim_add_img_notices_pai USING    p_mode TYPE char1
                             CHANGING exit_ok TYPE char1.

  DATA: leave TYPE char1, save TYPE char1.

  CHECK vim_special_mode &lt;&gt; vim_upgrade AND vim_import_profile = space.
  CASE p_mode.
    WHEN &apos;S&apos;.                          &quot;Save notices
      save = &apos;X&apos;.
    WHEN &apos;E&apos;.                          &quot;Exit and eventually save changes
      leave = &apos;X&apos;.
  ENDCASE.
  CALL FUNCTION &apos;SPROJECT_CONTROL_PAI&apos;
       EXPORTING
            i_exit    = leave
            save_note = save
       IMPORTING
            e_exit    = exit_ok.
ENDFORM.                               &quot; VIM_ADD_IMG_NOTICES_PAI</include_source>
   </include>
   <include NAME="LSVIMF5A" SQLX="X" VARCL="X" SUBC="I" APPL="S" LEVL="50A" RSTAT="T" RMAND="000" RLOAD="D">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF5A .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_BC_LOGS_PUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_BC_ENTRY_LIST  text
*----------------------------------------------------------------------*
FORM vim_bc_logs_put CHANGING p_bc_entry_list LIKE
                              vim_bc_entry_list.

  DATA: corr_keytab_save LIKE TABLE OF e071k, first,        &quot;#EC TYPES_MISS
        dummy LIKE sy-subrc, transport_active LIKE t000-cccoractiv,        &quot;#EC NEEDED
        w_tabkey_value TYPE scpractr,
        tabkey_values_n TYPE vim_bc_tab_logs,
        tabkey_values_u TYPE vim_bc_tab_logs,
        tabkey_values_d TYPE vim_bc_tab_logs,
        w_bc_entry TYPE scpr_viewdata, bc_entries TYPE scpr_viewdatas,       &quot;#EC NEEDED
        w_bc_entry_list TYPE vimty_bc_entry_list_type,
        bc_keytab TYPE bc_keytab_type,
        bc_keytab_wa LIKE LINE OF bc_keytab,
        p_msgid, p_msgty, p_msgno, bc_key_needed(1) TYPE c,                    &quot;#EC NEEDED
        foreign_langu TYPE sy-langu,
        rc LIKE sy-subrc, keys_identical TYPE xfeld,
        subrc TYPE sy-subrc, tabix TYPE sy-tabix,
        same_view(1), proceed(1) TYPE c.

  DATA: same_bc_set TYPE c,
  old_bc_set TYPE scpractr-profid,
  new_bc_set TYPE scpractr-profid,
  t_bc_entry_list TYPE vimty_bc_entry_list_type.&quot;MPRE/1034145


  STATICS: viewname_old TYPE vimdesc-viewname,
           keylen_real TYPE i.

  CONSTANTS: bc_id_length TYPE i VALUE 32,               &quot;#EC NEEDED
             bc_recno_length TYPE i VALUE 10.                        &quot;#EC NEEDED

  FIELD-SYMBOLS: &lt;bc_entry_keyx&gt; TYPE x,
                 &lt;key&gt; TYPE x,                              &quot;#EC NEEDED
                 &lt;vim_bc_keyx&gt; TYPE x, &lt;w_bc_entry_x&gt; TYPE x,
                 &lt;xlangu&gt; TYPE x, &lt;namtab&gt; TYPE vimnamtab.

*-----------&quot;HCG HW686163 Option: Write no Activation links -----------*
  CHECK vim_actopts-actlinks NE &apos;N&apos;.

  ASSIGN: w_bc_entry_list-keys(x_header-keylen) TO &lt;bc_entry_keyx&gt;.
  ASSIGN: bc_keytab_wa-bc_tabkey TO &lt;vim_bc_keyx&gt; CASTING.
  ASSIGN: w_bc_entry-data TO &lt;w_bc_entry_x&gt; CASTING.

  same_bc_set = &apos;X&apos;.
  same_view = &apos;X&apos;.                                          &quot;IG 1034145
  proceed = &apos;X&apos;.                                            &quot;IG 1034145

  READ TABLE p_bc_entry_list INTO t_bc_entry_list INDEX 1. &quot;MPRE 1034145
  IF sy-subrc = 0.
    new_bc_set = t_bc_entry_list-id.

  ENDIF.
  IF new_bc_set NE old_bc_set.
     same_bc_set = space.
    old_bc_set = new_bc_set.
  ENDIF.

  IF x_header-viewname NE viewname_old. &quot;HCG: has table align gap?
    same_view = space.
    viewname_old = x_header-viewname.
    CLEAR keylen_real.
    LOOP AT x_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = &apos;X&apos; AND
                                                texttabfld IS INITIAL.
      keylen_real = keylen_real + &lt;namtab&gt;-flength.
    ENDLOOP.
  ENDIF.
  IF x_header-subsetflag EQ &apos;X&apos;.                            &quot;IG 1034145
    IF same_view EQ &apos;X&apos; AND same_bc_set = &apos;X&apos;.
      LOOP AT p_bc_entry_list INTO w_bc_entry_list WHERE
         viewname = x_header-viewname AND action &lt;&gt; original.
        EXIT.
      ENDLOOP.
      IF vim_first_recnum NE w_bc_entry_list-recnumber.
        vim_first_recnum = w_bc_entry_list-recnumber.
      ELSE.
        proceed = space.
      ENDIF.
    ELSE.
      LOOP AT p_bc_entry_list INTO w_bc_entry_list WHERE
         viewname = x_header-viewname AND action &lt;&gt; original.
        vim_first_recnum = w_bc_entry_list-recnumber.
        EXIT.
      ENDLOOP.
    ENDIF.
  ENDIF.                                                    &quot;IG 1034145
  IF proceed = &apos;X&apos;.                                         &quot;IG 1034145
    LOOP AT p_bc_entry_list INTO w_bc_entry_list WHERE
     viewname = x_header-viewname AND action &lt;&gt; original.
*    IF w_bc_entry_list-action = neuer_geloescht.   Obsolete, was only
*      DELETE p_bc_entry_list. CONTINUE.            possible at bc-set
*    ENDIF.                              activation in dialog via SM30
      IF first = space.
        first = &apos;X&apos;.
        INSERT lines of corr_keytab INTO TABLE corr_keytab_save.
        REFRESH corr_keytab.
        CLEAR &lt;table1&gt;.
        transport_active = vim_client_state.
      ENDIF.
* fill corr_keytab
      IF x_header-keylen = keylen_real.
        READ TABLE total WITH KEY &lt;bc_entry_keyx&gt; BINARY SEARCH.&quot;#EC WARNOK
      ELSE.
        PERFORM vim_read_table_with_gap
                      TABLES   total
                      USING    &lt;bc_entry_keyx&gt;
                               x_namtab[]
                      CHANGING subrc
                               tabix.
        IF subrc = 0.
          READ TABLE total INDEX tabix.
        ENDIF.
      ENDIF.
      IF x_header-bastab EQ space.                            &quot;view
        MOVE &lt;bc_entry_keyx&gt; TO &lt;f1_x&gt;.
        PERFORM (corr_formname) IN PROGRAM (sy-repid) USING
                                              vim_writing_bc_imp_log
                                              dummy.
        REFRESH bc_keytab.
        CLEAR bc_key_needed.
      IF x_header-keylen &gt; vim_max_trsp_keylength. &quot;HCG tabkey up to 255
          bc_key_needed = &apos;X&apos;.
        ENDIF.
      IF bc_key_needed NE &apos;X&apos;.           &quot;Look for non-char field in key
          LOOP AT x_namtab WHERE keyflag = &apos;X&apos;.
            IF &apos;CNDT&apos; NS x_namtab-inttype. &quot;non charlike field
              bc_key_needed = &apos;X&apos;.
              EXIT.
            ENDIF.
          ENDLOOP.
        ENDIF.
      IF bc_key_needed NE &apos;X&apos;.             &quot;Look if viewkey &gt; primtabkey
          CLEAR keys_identical.
          PERFORM vim_comp_roottabkey USING x_header
                                            x_namtab[]
                                   CHANGING keys_identical
                                            rc.
          IF keys_identical EQ space. bc_key_needed = &apos;X&apos;. ENDIF.
        ENDIF.
      IF bc_key_needed NE space.                 &quot;Tabkeys via new coding
          LOOP AT corr_keytab.
            MOVE-CORRESPONDING corr_keytab TO bc_keytab_wa.
            APPEND bc_keytab_wa TO bc_keytab.
          ENDLOOP.
          PERFORM vim_build_bc_tabkeys USING w_bc_entry_list
                                    CHANGING bc_keytab.
      ELSE.  &quot;Tabkeys as up to now via generated coding (corr_maint_...)
          LOOP AT corr_keytab.
            MOVE-CORRESPONDING corr_keytab TO bc_keytab_wa.
            MOVE corr_keytab-tabkey TO bc_keytab_wa-bc_tabkey.
            APPEND bc_keytab_wa TO bc_keytab.
          ENDLOOP.
*     Look for other languages in bc-set and append to corr_keytab too
          IF x_header-texttbexst NE space.
            READ TABLE bc_keytab INTO bc_keytab_wa
                                 WITH KEY objname = x_header-texttab.
            LOOP AT w_bc_entry_list-forlangu INTO foreign_langu.
              ASSIGN foreign_langu TO &lt;xlangu&gt; CASTING.
              MOVE &lt;xlangu&gt; TO
    &lt;vim_bc_keyx&gt;+x_header-sprasfdpos(cl_abap_char_utilities=&gt;charsize).
              APPEND bc_keytab_wa TO bc_keytab.
            ENDLOOP.
          ENDIF.
        ENDIF.
     ELSE.                                                   &quot;base table
        MOVE &lt;vim_xtotal&gt; TO &lt;table1_x&gt;.
        MOVE-CORRESPONDING e071k TO bc_keytab_wa.
        MOVE e071k-tabkey TO bc_keytab_wa-bc_tabkey.
        bc_keytab_wa-objname = x_header-maintview.
        MOVE &lt;bc_entry_keyx&gt; TO &lt;vim_bc_keyx&gt;(x_header-keylen).
        APPEND bc_keytab_wa TO bc_keytab.
        IF x_header-bastab &lt;&gt; space AND
           x_header-texttbexst NE space AND         &quot;base table with
           &lt;vim_xtotal_text&gt; NE &lt;text_initial_x&gt;.   &quot;text table
          MOVE-CORRESPONDING e071k TO bc_keytab_wa.
          MOVE e071k-tabkey TO bc_keytab_wa-bc_tabkey.
          bc_keytab_wa-objname = x_header-texttab.
          MOVE &lt;vim_xtotal_text&gt; TO &lt;vim_bc_keyx&gt;(x_header-textkeylen).
          APPEND bc_keytab_wa TO bc_keytab.
*       other languages
         READ TABLE x_namtab WITH KEY keyflag = &apos;X&apos;         &quot;langu field
                                primtabkey = &apos;0000&apos;.
          LOOP AT w_bc_entry_list-forlangu INTO foreign_langu.
            ASSIGN foreign_langu TO &lt;xlangu&gt; CASTING.
            MOVE &lt;xlangu&gt; TO
                 &lt;vim_bc_keyx&gt;+x_namtab-texttabpos(x_namtab-flength).
            APPEND bc_keytab_wa TO bc_keytab.
          ENDLOOP.
        ENDIF.
      ENDIF.                             &quot;base table or view
      CASE w_bc_entry_list-action.
        WHEN neuer_eintrag.
* bc-set imported
          PERFORM bc_entry_log_fill USING     x_header
                                              x_namtab[]
                                              bc_keytab[]
                                              w_bc_entry_list
                                        CHANGING tabkey_values_n.
          CLEAR w_bc_entry_list-action.
        WHEN aendern.
* bc-set entry modified
          PERFORM bc_entry_log_fill USING     x_header
                                              x_namtab[]
                                              bc_keytab[]
                                              w_bc_entry_list
                                        CHANGING tabkey_values_u.
          CLEAR w_bc_entry_list-action.
          MOVE: w_bc_entry_list-id TO w_bc_entry-bcset_id,
                w_bc_entry_list-recnumber TO w_bc_entry-recnumber,
                x_header-viewname TO w_bc_entry-viewname,
                &lt;vim_xtotal&gt; TO &lt;w_bc_entry_x&gt;.
          APPEND w_bc_entry TO bc_entries.
        WHEN geloescht.
* bc-set entry deleted.
          PERFORM bc_entry_log_fill USING     x_header
                                              x_namtab[]
                                              bc_keytab[]
                                              w_bc_entry_list
                                        CHANGING tabkey_values_d.
          DELETE p_bc_entry_list.
      ENDCASE.
      REFRESH corr_keytab.   &quot;weg???
      REFRESH bc_keytab.
    ENDLOOP.
    IF NOT tabkey_values_n IS INITIAL.
      DELETE ADJACENT DUPLICATES FROM tabkey_values_n COMPARING ALL
       FIELDS.
      LOOP AT tabkey_values_n INTO w_tabkey_value.
        CALL FUNCTION &apos;SCPR_EXT_SCPRACTR_FILL&apos;
          EXPORTING
            tablename         = w_tabkey_value-tablename
            profid            = w_tabkey_value-profid
            recnumber         = w_tabkey_value-recnumber
            viewname          = x_header-maintview
            viewvar           = x_header-viewname
            del_record        = &apos; &apos;
            new_record        = &apos;X&apos;
            key               = w_tabkey_value-tabkey
          EXCEPTIONS
            wrong_parameters  = 1
            internal_error    = 2
            key_not_supportet = 3
            fielddescr_error  = 4
            OTHERS            = 5.
        IF sy-subrc &lt;&gt; 0.
          p_msgid = &apos;SCPR&apos;.
          CASE sy-subrc.
            WHEN 1.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;273&apos;.
            WHEN 3.
              p_msgty = &apos;W&apos;.
              p_msgno = &apos;408&apos;.
            WHEN 4.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;395&apos;.
            WHEN OTHERS.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;320&apos;.
          ENDCASE.
          PERFORM vim_process_message USING sy-msgid sy-msgty sy-msgty
                                    sy-msgno space space space space.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF NOT tabkey_values_u IS INITIAL.
      DELETE ADJACENT DUPLICATES FROM tabkey_values_u COMPARING ALL
       FIELDS.
      LOOP AT tabkey_values_u INTO w_tabkey_value.
        CALL FUNCTION &apos;SCPR_EXT_SCPRACTR_FILL&apos;
          EXPORTING
            tablename         = w_tabkey_value-tablename
            profid            = w_tabkey_value-profid
            recnumber         = w_tabkey_value-recnumber
            viewname          = x_header-maintview
            viewvar           = x_header-viewname
            del_record        = &apos; &apos;
            new_record        = &apos; &apos;
            key               = w_tabkey_value-tabkey
          EXCEPTIONS
            wrong_parameters  = 1
            internal_error    = 2
            key_not_supportet = 3
            fielddescr_error  = 4
            OTHERS            = 5.
        IF sy-subrc &lt;&gt; 0.
          p_msgid = &apos;SCPR&apos;.
          CASE sy-subrc.
            WHEN 1.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;273&apos;.
            WHEN 3.
              p_msgty = &apos;W&apos;.
              p_msgno = &apos;408&apos;.
            WHEN 4.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;395&apos;.
            WHEN OTHERS.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;320&apos;.
          ENDCASE.
          PERFORM vim_process_message USING sy-msgid sy-msgty sy-msgty
                                    sy-msgno space space space space.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF NOT tabkey_values_d IS INITIAL.
      DELETE ADJACENT DUPLICATES FROM tabkey_values_d COMPARING ALL
       FIELDS.
      LOOP AT tabkey_values_d INTO w_tabkey_value.
        CALL FUNCTION &apos;SCPR_EXT_SCPRACTR_FILL&apos;
          EXPORTING
            tablename         = w_tabkey_value-tablename
            profid            = w_tabkey_value-profid
            recnumber         = w_tabkey_value-recnumber
            viewname          = x_header-maintview
            viewvar           = x_header-viewname
            del_record        = &apos;X&apos;
            new_record        = &apos; &apos;
            key               = w_tabkey_value-tabkey
          EXCEPTIONS
            wrong_parameters  = 1
            internal_error    = 2
            key_not_supportet = 3
            fielddescr_error  = 4
            OTHERS            = 5.
        IF sy-subrc &lt;&gt; 0.
          p_msgid = &apos;SCPR&apos;.
          CASE sy-subrc.
            WHEN 1.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;273&apos;.
            WHEN 3.
              p_msgty = &apos;W&apos;.
              p_msgno = &apos;408&apos;.
            WHEN 4.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;395&apos;.
            WHEN OTHERS.
              p_msgty = &apos;E&apos;.
              p_msgno = &apos;320&apos;.
          ENDCASE.
          PERFORM vim_process_message USING sy-msgid sy-msgty sy-msgty
                                    sy-msgno space space space space.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF NOT corr_keytab_save IS INITIAL.
      INSERT lines of corr_keytab_save INTO TABLE corr_keytab.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; VIM_BC_LOGS_PUT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  bc_entry_log_fill
*&amp;---------------------------------------------------------------------*
*       fills value table for BC-set activation log for every fix entity
*       field
*----------------------------------------------------------------------*
*      --&gt;P_HEADER  text
*      --&gt;P_NAMTAB  text
*      --&gt;P_CORR_KEYTAB  text
*      --&gt;P_BC_ENTRY  text
*      &lt;--P_TABKEY_VALUE  text
*----------------------------------------------------------------------*
FORM bc_entry_log_fill USING        p_header TYPE vimdesc
                                    p_namtab LIKE x_namtab[]
                                    p_bc_keytab TYPE bc_keytab_type
                               p_bc_entry TYPE vimty_bc_entry_list_type
                          CHANGING p_tabkey_values TYPE vim_bc_tab_logs.

  STATICS: dd28j_tab TYPE TABLE OF dd28j.
  DATA: w_dd28j TYPE dd28j, w_tabkey_value TYPE scpractr,
        w_fields TYPE vimty_fields_type.                   &quot;#EC NEEDED
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab,
                 &lt;dfies&gt; TYPE dfies,                        &quot;#EC NEEDED
                 &lt;keytab&gt; TYPE bc_key_type.

  IF p_header-bastab = space.
    READ TABLE dd28j_tab INTO w_dd28j INDEX 1.
    IF sy-subrc &lt;&gt; 0 OR p_header-viewname &lt;&gt; w_dd28j-viewname.
* get join-conditions
      REFRESH dd28j_tab.
      CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
        EXPORTING
          name          = p_header-viewname
        TABLES
          dd28j_tab     = dd28j_tab
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      ENDIF.
    ENDIF.
  ENDIF.
  w_tabkey_value-client = sy-mandt.
  w_tabkey_value-profid = p_bc_entry-id.
  w_tabkey_value-recnumber = p_bc_entry-recnumber.
  w_tabkey_value-viewname = p_header-maintview.             &quot;HCG 6.8.02
  LOOP AT p_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = space OR
   texttabfld = space.
    READ TABLE p_bc_entry-fields INTO w_fields WITH KEY fieldname =
     &lt;namtab&gt;-viewfield.
    CHECK sy-subrc = 0.
    READ TABLE p_tabkey_values WITH KEY client = sy-mandt
      tablename = &lt;namtab&gt;-bastabname profid = p_bc_entry-id
      recnumber = p_bc_entry-recnumber viewname = p_header-viewname
      TRANSPORTING NO FIELDS.
    IF sy-subrc &lt;&gt; 0.
      LOOP AT p_bc_keytab ASSIGNING &lt;keytab&gt; WHERE
                                pgmid = &apos;R3TR&apos; AND
                               object = &apos;TABU&apos; AND
                              objname = &lt;namtab&gt;-bastabname.
        w_tabkey_value-tablename = &lt;namtab&gt;-bastabname.
        w_tabkey_value-tabkey = &lt;keytab&gt;-bc_tabkey.
        APPEND w_tabkey_value TO p_tabkey_values.
      ENDLOOP.
      CHECK sy-subrc = 0.
    ENDIF.
    IF x_header-bastab = space.
* view
      LOOP AT dd28j_tab INTO w_dd28j WHERE viewname = p_header-viewname
       AND ltab = &lt;namtab&gt;-bastabname AND lfield = &lt;namtab&gt;-viewfield.
        READ TABLE p_tabkey_values WITH KEY client = sy-mandt
          tablename = w_dd28j-rtab profid = p_bc_entry-id
          recnumber = p_bc_entry-recnumber viewname = p_header-viewname
          TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          READ TABLE p_bc_keytab WITH KEY pgmid = &apos;R3TR&apos;
                            object = &apos;TABU&apos;
                           objname = w_dd28j-rtab ASSIGNING &lt;keytab&gt;.
          CHECK sy-subrc = 0.
          w_tabkey_value-tablename = w_dd28j-rtab.
          w_tabkey_value-tabkey = &lt;keytab&gt;-bc_tabkey.
          APPEND w_tabkey_value TO p_tabkey_values.
        ENDIF.
      ENDLOOP.
      LOOP AT dd28j_tab INTO w_dd28j WHERE viewname = p_header-viewname
       AND rtab = &lt;namtab&gt;-bastabname AND rfield = &lt;namtab&gt;-viewfield.
        READ TABLE p_tabkey_values WITH KEY client = sy-mandt
          tablename = w_dd28j-ltab profid = p_bc_entry-id
          recnumber = p_bc_entry-recnumber viewname = p_header-viewname
          TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
          LOOP AT p_bc_keytab ASSIGNING &lt;keytab&gt; WHERE
                                pgmid = &apos;R3TR&apos; AND
                               object = &apos;TABU&apos; AND
                              objname = w_dd28j-ltab.
            w_tabkey_value-tablename = w_dd28j-ltab.
            w_tabkey_value-tabkey = &lt;keytab&gt;-bc_tabkey.
            APPEND w_tabkey_value TO p_tabkey_values.
          ENDLOOP.
          CHECK sy-subrc = 0.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot; bc_entry_log_fill
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_BC_LOGS_GET
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_C_ENTRY_LIST  text
*      --&gt;P_VIEW_NAME  text
*      --&gt;P_HEADER  text
*      --&gt;P_NAMTAB  text
*----------------------------------------------------------------------*
FORM vim_bc_logs_get USING    p_view_name TYPE tabname             &quot;#EC NEEDED
                              p_header TYPE vimdesc
                              p_namtab LIKE x_namtab[]
                CHANGING p_bc_entry_list TYPE vimty_bc_entry_list_ttype.

  STATICS: tablist TYPE TABLE OF scprxtabl, viewname TYPE tabname.

  DATA:    tabkeys TYPE TABLE OF scpractr, w_tablist TYPE scprxtabl,
           bc_entry_list_wa TYPE vimty_bc_entry_list_type, failed(1), &quot;#EC TYPES_MISS
           rc LIKE sy-subrc, keys_identical TYPE xfeld,
           x030l_root TYPE x030l,
           x030l_bastab TYPE x030l,
           root_entry TYPE REF TO data,
           bastab_entry TYPE REF TO data,
           tabflags TYPE scpr_actfs, tabflags_wa TYPE scpr_actf,
*           tabflags_quick TYPE HASHED TABLE OF scpr_actf
*            WITH UNIQUE KEY tablename fieldname bcset_id
           tabflags_quick TYPE SORTED TABLE OF scpr_actf
            WITH NON-UNIQUE KEY tablename fieldname bcset_id
            recnumber tabkey INITIAL SIZE 100,
           fields_wa TYPE vimty_fields_type,
           bc_entry_list TYPE STANDARD TABLE OF
            vimty_bc_entry_list_type WITH KEY viewname keys,
            tabkey_wa TYPE scpractr-tabkey,
            tabkeys_wa TYPE scpractr,
            tabix TYPE sy-tabix,
            tabkey_struc(1024) TYPE c,
            flagind TYPE i, data_end TYPE i.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab, &lt;sektabkey&gt; TYPE scpractr,
                 &lt;tabkeys_main&gt; TYPE scpractr,
                 &lt;bastab&gt; TYPE ANY, &lt;bastab_x&gt; TYPE x,
                 &lt;roottab&gt; TYPE ANY, &lt;roottab_x&gt; TYPE x,
                 &lt;rootfld&gt; TYPE ANY,
                 &lt;tabkey&gt; TYPE x, &lt;viewfld&gt; TYPE ANY,
                 &lt;sektabkeyx&gt; TYPE x,
                 &lt;clnt&gt; TYPE ANY,
                 &lt;tabkey_c&gt; TYPE c.

  DELETE p_bc_entry_list WHERE viewname = p_header-maintview.&quot;HCG 6.8.02
  CHECK vim_import_profile = space.
*  CHECK &apos;TS&apos; NS maint_mode.   &quot;HCG Necessary in show and transport mode
*                    too, e.g. for selection show only data from BC-Sets
  IF viewname &lt;&gt; p_header-viewname.                  &quot;HCG 9/04 HW771997
* make table list
    viewname = p_header-maintview.
    REFRESH tablist.
    w_tablist-sign = &apos;I&apos;. w_tablist-option = &apos;EQ&apos;.
    IF p_header-bastab EQ &apos;X&apos;.                              &quot;S-table
      w_tablist-low = viewname.         &quot;HCG only roottab in tablist
      COLLECT w_tablist INTO tablist.
    ELSE.                                                      &quot;View
      w_tablist-low = p_header-roottab. &quot;HCG only roottab in tablist
      COLLECT w_tablist INTO tablist.
      LOOP AT p_namtab ASSIGNING &lt;namtab&gt;.
        IF &lt;namtab&gt;-keyflag NE space &quot;HCG Field from sektab in Viewkey
           AND &lt;namtab&gt;-bastabname NE w_tablist-low.
          w_tablist-low = &lt;namtab&gt;-bastabname.
          APPEND w_tablist TO tablist.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.
* &quot;HCG 9/04: tabkeys does only contain data to the table/view which
* needs to be regarded and tabflags-tablename contains eventually the
* name of a viewvariant, which is in the bcset but not known here.
*  For this reason the content of tabflags-tablename is not known yet.
  CALL FUNCTION &apos;SCPR_BCSET_PROT_GET_TABKEYS&apos;
    EXPORTING
      viewname = viewname
      clidep   = p_header-clidep                            &quot;824950
    IMPORTING
      actkeys  = tabkeys
      tabflags = tabflags
    TABLES
      tabnames = tablist
    EXCEPTIONS
      no_data  = 1
      OTHERS   = 2.
  CHECK sy-subrc = 0 AND NOT tabkeys IS INITIAL.
* &quot;HCG 04.01.2005 HW806401
* For Perfomance problems with very brad tables (&gt;100 fields)
* delete all lines in tabflags with flag = USE or VAR in SM30 mode
* In BC-Set activation no deletion, due to actopts-no_standrd mode
  IF vim_import_profile EQ space.
    LOOP AT tabflags INTO tabflags_wa.
      IF tabflags_wa-flag EQ vim_profile_use    or
         tabflags_wa-flag EQ vim_profile_fixkey or          &quot;824950
         tabflags_wa-flag EQ vim_profile_key    or          &quot;824950
         tabflags_wa-flag EQ vim_profile_var.               &quot;824950
        DELETE tabflags INDEX sy-tabix.
      ENDIF.
    ENDLOOP.
  ENDIF.
  LOOP AT tabkeys INTO tabkeys_wa.
    tabkey_wa = tabkeys_wa-tabkey.
    tabix = sy-tabix.
    CALL FUNCTION &apos;SCPR_EXT_ACTKEY_TO_KEY&apos;
      EXPORTING
        tablename        = tabkeys_wa-tablename  &quot;in case: Sektabname
        tablekey         = tabkey_wa
      IMPORTING
        key              = tabkey_struc
      EXCEPTIONS
        wrong_parameters = 1
        key_too_large    = 2
        fielddescr_error = 3
        internal_error   = 4
        OTHERS           = 5.
    IF sy-subrc NE 0.
      MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
       WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    ASSIGN tabkey_struc TO &lt;tabkey_c&gt; CASTING.
    tabkeys_wa-tabkey = &lt;tabkey_c&gt;.
    MODIFY tabkeys FROM tabkeys_wa INDEX tabix.
  ENDLOOP.
  bc_entry_list_wa-viewname = p_header-maintview.           &quot;HCG 6.8.02
  IF p_header-clidep &lt;&gt; space.
    READ TABLE p_namtab ASSIGNING &lt;namtab&gt;
     WITH KEY datatype = &apos;CLNT&apos;.
    ASSIGN COMPONENT &lt;namtab&gt;-viewfield
     OF STRUCTURE &lt;table1_wa&gt; TO &lt;clnt&gt;.
  ENDIF.
  SORT tabflags BY bcset_id recnumber.              &quot;HCG 1.9.03 9/04
  IF p_header-bastab = space.
* build up viewkeys and put&apos;em into entry list
***********************************************************************
* viewkey and roottabkey identical?
    PERFORM vim_comp_roottabkey USING p_header
                                      p_namtab
                                CHANGING keys_identical
                                         rc.
    CHECK rc = 0.
    IF keys_identical = space.
      PERFORM vim_get_x030l USING p_header-roottab
                            CHANGING x030l_root
                                     rc.
      CHECK rc = 0.
      CREATE DATA root_entry TYPE (p_header-roottab).
      ASSIGN: root_entry-&gt;* TO &lt;roottab&gt;,
              &lt;roottab&gt; TO &lt;roottab_x&gt; CASTING.
    ENDIF.
    INSERT lines of tabflags INTO TABLE tabflags_quick.
    LOOP AT tabkeys ASSIGNING &lt;tabkeys_main&gt;.               &quot;HCG 9/04
*     tablename = p_header-roottab.
      CLEAR: failed, &lt;table1_wa&gt;.
* get all primary table entries
      bc_entry_list_wa-id = &lt;tabkeys_main&gt;-profid.
      bc_entry_list_wa-recnumber = &lt;tabkeys_main&gt;-recnumber.
      ASSIGN &lt;tabkeys_main&gt;-tabkey TO &lt;tabkey&gt; CASTING.
      IF keys_identical &lt;&gt; space.
* move complete table key to view key
        MOVE &lt;tabkey&gt;(p_header-keylen) TO &lt;f1_wax&gt;.
      ELSE.
* fill view key field by field
        CLEAR: &lt;roottab&gt;.
        MOVE &lt;tabkey&gt;(x030l_root-keylen)
         TO &lt;roottab_x&gt;(x030l_root-keylen).
        LOOP AT p_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag &lt;&gt; space AND
         texttabfld = space.
* build viewkey...
          CHECK &lt;namtab&gt;-datatype &lt;&gt; &apos;CLNT&apos; OR p_header-clidep = space.
          ASSIGN COMPONENT &lt;namtab&gt;-viewfield
           OF STRUCTURE &lt;table1_wa&gt; TO &lt;viewfld&gt;.
          IF &lt;namtab&gt;-bastabname = p_header-roottab.
* ... from primary table
            ASSIGN COMPONENT &lt;namtab&gt;-bastabfld OF STRUCTURE &lt;roottab&gt;
             TO &lt;rootfld&gt;.
            MOVE &lt;rootfld&gt; TO &lt;viewfld&gt;.
          ELSE.
* ... from secondary table
            failed = &apos;X&apos;.
            IF NOT &lt;sektabkey&gt; IS ASSIGNED
             OR &lt;sektabkey&gt;-tablename &lt;&gt; &lt;namtab&gt;-bastabname.
              READ TABLE tabkeys ASSIGNING &lt;sektabkey&gt;
               WITH KEY tablename = &lt;namtab&gt;-bastabname
                        recnumber = &lt;tabkeys_main&gt;-recnumber
                        profid = &lt;tabkeys_main&gt;-profid.
              IF sy-subrc &lt;&gt; 0.
                UNASSIGN &lt;sektabkey&gt;.
                EXIT.
              ENDIF.
              PERFORM vim_get_x030l USING &lt;namtab&gt;-bastabname
                                    CHANGING x030l_bastab
                                             rc.
              CHECK rc = 0.
              CREATE DATA bastab_entry TYPE (&lt;namtab&gt;-bastabname).
              ASSIGN: bastab_entry-&gt;* TO &lt;bastab&gt;,
                      &lt;bastab&gt; TO &lt;bastab_x&gt; CASTING.
            ENDIF.
            ASSIGN &lt;sektabkey&gt;-tabkey TO &lt;sektabkeyx&gt; CASTING.
            MOVE &lt;sektabkeyx&gt;(x030l_bastab-keylen)
             TO &lt;bastab_x&gt;(x030l_bastab-keylen).
            ASSIGN COMPONENT &lt;namtab&gt;-bastabfld OF STRUCTURE &lt;bastab&gt;
             TO &lt;rootfld&gt;.
            MOVE &lt;rootfld&gt; TO &lt;viewfld&gt;.
            CLEAR failed.
          ENDIF.
        ENDLOOP.
        CHECK failed IS INITIAL.
      ENDIF.
      IF p_header-clidep &lt;&gt; space.
* fill client-field
        MOVE sy-mandt TO &lt;clnt&gt;.
      ENDIF.
      MOVE &lt;f1_wax&gt; TO bc_entry_list_wa-keys.
      REFRESH bc_entry_list_wa-fields.
      LOOP AT p_namtab ASSIGNING &lt;namtab&gt;.
        CHECK &lt;namtab&gt;-datatype &lt;&gt; &apos;CLNT&apos; OR p_header-clidep = space.
* get bc-set field attributes
        READ TABLE tabflags_quick INTO tabflags_wa WITH KEY                           &quot;#EC CI_SORTSEQ
*         tablename = p_header-viewname               &quot;HCG 9/04
         fieldname = &lt;namtab&gt;-viewfield &quot;HCH 8.8.2002 separat portiert
         bcset_id = bc_entry_list_wa-id
         recnumber = bc_entry_list_wa-recnumber.
        CHECK sy-subrc = 0.
        fields_wa-fieldname = &lt;namtab&gt;-viewfield.
        fields_wa-flag = tabflags_wa-flag.
        APPEND fields_wa TO bc_entry_list_wa-fields.
      ENDLOOP.
      INSERT bc_entry_list_wa INTO TABLE bc_entry_list.
      UNASSIGN &lt;sektabkey&gt;.
    ENDLOOP.
  ELSE.
* move table keys into entry list
***********************************************************************
    LOOP AT tabkeys ASSIGNING &lt;tabkeys_main&gt; WHERE
     tablename = p_header-maintview.
      bc_entry_list_wa-id = &lt;tabkeys_main&gt;-profid.
      bc_entry_list_wa-recnumber = &lt;tabkeys_main&gt;-recnumber.
      ASSIGN &lt;tabkeys_main&gt;-tabkey TO &lt;tabkey&gt; CASTING.
      MOVE &lt;tabkey&gt;(p_header-keylen) TO &lt;table1_wax&gt;(p_header-keylen).
      IF p_header-clidep &lt;&gt; space.
* fill client-field
        MOVE sy-mandt TO &lt;clnt&gt;.
      ENDIF.
      MOVE &lt;f1_wax&gt; TO bc_entry_list_wa-keys.
      REFRESH bc_entry_list_wa-fields.
* get bc-set field attributes                               &quot;HCG 1.9.03
*      LOOP AT tabflags INTO tabflags_wa WHERE ( tablename =
*       p_header-viewname OR tablename = p_header-texttab ) AND
*       bcset_id = bc_entry_list_wa-id
*       AND recnumber = bc_entry_list_wa-recnumber.
*        fields_wa-fieldname = tabflags_wa-fieldname.
*        fields_wa-flag = tabflags_wa-flag.
*        APPEND fields_wa TO bc_entry_list_wa-fields.
*      ENDLOOP.
*------------------get bc-set field attributes (New)----&quot;HCG 1.9.03----*
      READ TABLE tabflags INTO tabflags_wa WITH KEY
*         tablename = p_header-viewname          &quot;HCG 9/04
          bcset_id = bc_entry_list_wa-id
         recnumber = bc_entry_list_wa-recnumber BINARY SEARCH.
      IF sy-subrc = 0.
        flagind = sy-tabix.
        fields_wa-fieldname = tabflags_wa-fieldname.
        fields_wa-flag = tabflags_wa-flag.
        APPEND fields_wa TO bc_entry_list_wa-fields.
        CLEAR data_end.
        WHILE data_end = 0.     &quot;HCG all fields for 1 dataset in a row
          flagind = flagind + 1.
          READ TABLE tabflags INTO tabflags_wa INDEX flagind.
          IF sy-subrc = 0.            &quot;Otherwise end of table tabflags
*           IF tabflags_wa-tablename = p_header-viewname AND &quot;HCG 9/04
            IF tabflags_wa-bcset_id = bc_entry_list_wa-id AND
               tabflags_wa-recnumber = bc_entry_list_wa-recnumber.
              fields_wa-fieldname = tabflags_wa-fieldname.
              fields_wa-flag = tabflags_wa-flag.
              APPEND fields_wa TO bc_entry_list_wa-fields.
            ELSE.
              data_end = 1.
            ENDIF.
          ELSE.
            data_end = 1.               &quot;End of table tabflags reached
          ENDIF.
        ENDWHILE.
*-------------------&quot;HCG 1.9.03-----End of Performance optimization----*
        INSERT bc_entry_list_wa INTO TABLE bc_entry_list.
      ENDIF.
    ENDLOOP.
  ENDIF.
  SORT bc_entry_list.
* should normally not be necessary:
  DELETE ADJACENT DUPLICATES FROM bc_entry_list.
  DESCRIBE TABLE bc_entry_list.
* changing of fix BC-set-entries?
  CLEAR &lt;status&gt;-bcfixnochg.
  IF sy-tfill &gt; 0.
    INSERT lines of bc_entry_list INTO TABLE p_bc_entry_list.
    CALL FUNCTION &apos;SCPR_AUTHORITY_CHECK&apos;
      EXPORTING
        task             = &apos;CHGFIXVAL&apos;
      EXCEPTIONS
        wrong_parameters = 1
        no_authority     = 2
        OTHERS           = 3.
    IF sy-subrc &lt;&gt; 0.
      &lt;status&gt;-bcfixnochg = &apos;N&apos;.
    ELSE.
      &lt;status&gt;-bcfixnochg = &apos;Y&apos;.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; VIM_GET_BC_LOGS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_BC_LOGS_MAINTAIN
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_HEADER         Header info of maintenance dialog
*      --&gt;P_BACKGROUND     Flag: &apos;X&apos; means BC-set import in background
*                                running.
*      &lt;--P_BC_ENTRY_LIST  List of entries coming from BC-set
*----------------------------------------------------------------------*
FORM vim_bc_logs_maintain USING    p_header TYPE vimdesc
                                   p_background TYPE xfeld
                          CHANGING p_bc_entry_list LIKE
                                   vim_bc_entry_list.

  DATA: fields_wa TYPE vimty_fields_type,                  &quot;#EC NEEDED
        subrc TYPE sy-subrc, tabix TYPE sy-tabix.
  STATICS:       viewname_old TYPE vimdesc-viewname,
                 keylen_real TYPE i.
  FIELD-SYMBOLS: &lt;bc_entry&gt; TYPE vimty_bc_entry_list_type,
                 &lt;key&gt; TYPE x, &lt;namtab&gt; TYPE vimnamtab.

  IF p_background = space.
* bc import running in dialogue
    LOOP AT total.
      CHECK &apos; N&apos; NS &lt;action&gt;.
      READ TABLE p_bc_entry_list ASSIGNING &lt;bc_entry&gt; WITH KEY
       viewname = p_header-viewname keys = &lt;vim_xtotal_key&gt;.
      CHECK sy-subrc = 0.
      CASE &lt;action&gt;.
        WHEN aendern.
* Rel. 4.6 only: does entry contain fix values?
*          LOOP AT &lt;bc_entry&gt;-fields INTO fields_wa
*           WHERE flag = vim_profile_fix.
*            TRANSLATE &lt;bc_entry&gt;-action USING &apos; U&apos;.
*            EXIT.
*          ENDLOOP.
        WHEN geloescht.
* deleting bc-set-entry
          CASE &lt;bc_entry&gt;-action.
            WHEN neuer_eintrag.
              &lt;bc_entry&gt;-action = neuer_geloescht.
            WHEN OTHERS.
              &lt;bc_entry&gt;-action = geloescht.
          ENDCASE.
*      WHEN zurueckholen.
** undeleting BC-set-entry --&gt; maintain table of BC-Set-entries
*        CASE &lt;bc_entry&gt;-action.
*          WHEN neuer_geloescht.
*            &lt;bc_entry&gt;-action = neuer_eintrag.
*          WHEN OTHERS.
*            &lt;bc_entry&gt;-action = original.
      ENDCASE.
    ENDLOOP.
  ELSE.
* bc import running in background
    DELETE vim_bc_entry_list WHERE viewname = p_header-viewname.&quot;#EC PF_ACT_GLO
    PERFORM vim_get_global_table IN PROGRAM saplsvim
                USING &apos;VIM_BC_ENTRY_LIST&apos;
                       vim_bc_entry_list
                       sy-subrc.
    IF sy-subrc &lt;&gt; 0.
      EXIT.
    ENDIF.
    IF p_header-viewname NE viewname_old. &quot;HCG: has table align gap?
      viewname_old = p_header-viewname.
      CLEAR keylen_real.
      LOOP AT x_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = &apos;X&apos; AND
                                                texttabfld IS INITIAL.
        keylen_real = keylen_real + &lt;namtab&gt;-flength.
      ENDLOOP.
    ENDIF.
    LOOP AT vim_bc_entry_list ASSIGNING &lt;bc_entry&gt; WHERE
     viewname = p_header-viewname.
      ASSIGN &lt;bc_entry&gt;-keys(x_header-keylen) TO &lt;key&gt;.
      IF p_header-keylen = keylen_real.
        READ TABLE total WITH KEY &lt;key&gt; BINARY SEARCH.      &quot;#EC WARNOK
        subrc = sy-subrc.
      ELSE.
        PERFORM vim_read_table_with_gap
                    TABLES   total
                    USING    &lt;key&gt;
                             x_namtab[]
                    CHANGING subrc
                             tabix.
        IF subrc = 0.
          READ TABLE total INDEX tabix.
        ENDIF.
      ENDIF.
* bc-set entry really imported?
      IF subrc &lt;&gt; 0 OR &apos;NUD&apos; NS &lt;action&gt;.
        DELETE vim_bc_entry_list.
      ENDIF.
    ENDLOOP.
  ENDIF.
ENDFORM.                               &quot; VIM_BC_LOGS_MAINTAIN
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_BC_LOGS_USE
*&amp;---------------------------------------------------------------------*
*       delivers field attribute defined in BC-sets
*----------------------------------------------------------------------*
*      --&gt;P_FIELD         text
*      --&gt;P_VIM_BC_ENTRY  text
*      &lt;--P_SCREEN_INPUT  text
*      &lt;--P_MODIFY_SCREEN  text
*----------------------------------------------------------------------*
FORM vim_bc_logs_use USING p_field TYPE fieldname
                           p_vim_bc_entry TYPE vimty_bc_entry_list_type
                     CHANGING p_screen LIKE screen
                              p_modify_screen TYPE xfeld.

  DATA w_field TYPE vimty_fields_type.

  READ TABLE p_vim_bc_entry-fields INTO w_field
   WITH TABLE KEY fieldname = p_field.
  CHECK sy-subrc = 0.
  IF w_field-flag = vim_profile_fix.
    p_screen-input = 0.
    p_modify_screen = &apos;X&apos;.
  ENDIF.
ENDFORM.                               &quot; VIM_BC_LOGS_USE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_chng_fix_flds
*&amp;---------------------------------------------------------------------*
*       make fix values form bc-sets modifiable
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_chng_fix_flds.
  IF vim_actlinks NE x_header-viewname.
    PERFORM vim_bc_logs_get USING view_name x_header x_namtab[]
                          CHANGING vim_bc_entry_list.
    vim_actlinks = x_header-viewname. &quot;For which actlinks are valid
  ENDIF.
  IF &lt;status&gt;-bcfixnochg = &apos;Y&apos;.
    vim_bc_chng_allowed = &apos;X&apos;.
  ELSE.
    MESSAGE e202(sv).
*   Sie haben keine Berechtigung, Felder mit fixen BC-Set-Werten zu ände
  ENDIF.
ENDFORM.                               &quot; vim_chng_fix_flds
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_get_x030l
*&amp;---------------------------------------------------------------------*
*       Delivers X030l fron dictionary.
*----------------------------------------------------------------------*
*      --&gt;P_TABNAME     tablename
*      &lt;--P_X030L
*      &lt;--P_RC
*----------------------------------------------------------------------*
FORM vim_get_x030l  USING    p_tabname TYPE tabname
                    CHANGING p_x030l TYPE x030l
                             p_rc LIKE sy-subrc.
  CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
    EXPORTING
      tabname  = p_tabname
    IMPORTING
      x030l_wa = p_x030l
    EXCEPTIONS
      OTHERS   = 1.
  p_rc = sy-subrc.
ENDFORM.                    &quot; vim_get_x030l
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_show_fix_flds
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_bc_show_fix_flds.
  DATA: p_tabtype TYPE objh-objecttype,
        p_tabname TYPE scpr_tabl.


  IF vim_actlinks NE x_header-viewname.
    PERFORM vim_bc_logs_get USING view_name x_header x_namtab[]
                          CHANGING vim_bc_entry_list.
    vim_actlinks = x_header-viewname. &quot;For which actlinks are valid
  ENDIF.
  p_tabname = x_header-maintview. &quot;HCG 6.8.02 actlinks for maintview
  IF x_header-bastab = space.
    p_tabtype = &apos;V&apos;.
  ELSE.
    p_tabtype = &apos;S&apos;.
  ENDIF.
  LOOP AT extract.
    IF &lt;xmark&gt; NE markiert.
      CONTINUE.
    ELSE.
      MOVE &lt;vim_extract_struc&gt; TO &lt;table1&gt;.
      CALL FUNCTION &apos;SCPR_ACTIVATION_INFOS_SHOW&apos;
        EXPORTING
          tablename             = p_tabname
          tabletype             = p_tabtype
          record                = &lt;table1&gt;
        EXCEPTIONS
          fielddefinition_error = 1
          no_tvdir_entry        = 2
          table_not_found       = 3
          table_to_large        = 4
          ddif_internal_error   = 5
          wrong_parameters      = 6
          internal_error        = 7
          no_actlinks           = 8
          key_too_large         = 9
          OTHERS                = 10.
      CASE sy-subrc.
        WHEN 0.
        WHEN 1.
          MESSAGE e395(scpr) RAISING fielddefinition_error.                   &quot;#EC FB_RAIS_EX
        WHEN 2.
          MESSAGE e028(scpr) WITH p_tabname RAISING no_tvdir_entry.
        WHEN 3.
          MESSAGE e120(scpr) WITH p_tabname RAISING table_not_found.
        WHEN 4.
          MESSAGE e026(scpr) WITH p_tabname RAISING table_to_large.           &quot;#EC FB_RAIS_EX
        WHEN 5.
          MESSAGE e035(scpr) RAISING ddif_internal_error.                     &quot;#EC FB_RAIS_EX
        WHEN 6.
          MESSAGE e273(scpr) RAISING wrong_parameters.                        &quot;#EC FB_RAIS_EX
        WHEN 8.
          MESSAGE s399(scpr) RAISING no_actlinks.                             &quot;#EC FB_RAIS_EX
        WHEN 9.
          MESSAGE e408(scpr) RAISING key_too_large.                           &quot;#EC FB_RAIS_EX
        WHEN OTHERS.
          MESSAGE e320(scpr) RAISING internal_error.
      ENDCASE.
    ENDIF.
  ENDLOOP.

ENDFORM.                    &quot; vim_show_fix_flds
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_build_bc_tabkeys
*&amp;---------------------------------------------------------------------*
*   To build up table keys for views with keylen &gt; 120 up to 256
*   and / or non-character like fields.
*----------------------------------------------------------------------*
*      &lt;--P_BC_KEYTAB  text
*----------------------------------------------------------------------*
FORM vim_build_bc_tabkeys USING bc_entry_list_wa TYPE
                                       vimty_bc_entry_list_type
                       CHANGING p_bc_keytab TYPE bc_keytab_type.

  TYPES: BEGIN OF tablist_type,
           tabname TYPE objs-tabname,
         END OF tablist_type.

  STATICS: cg_dd28j_tab LIKE dd28j OCCURS 30,
           old_viewname LIKE vimdesc-viewname,
           all_dfiestab LIKE dfies OCCURS 40.

  DATA: objstablist TYPE TABLE OF tablist_type, &quot;#EC NEEDED
        namtab_wa TYPE vimnamtab, &quot;#EC NEEDED
        tabname_wa TYPE objs-tabname,
        dd28j_wa LIKE LINE OF cg_dd28j_tab,
        primtab_entry TYPE REF TO data,
        sektab_entry TYPE REF TO data,
        p_bc_keytab_wa LIKE LINE OF p_bc_keytab,
        keytab_index TYPE sy-tabix,
        bc_keylen TYPE i, flag(1) TYPE c,
        cg_langu(1) TYPE c,
        cg_dfiestab LIKE dfies OCCURS 10,
        dfies_wa LIKE LINE OF cg_dfiestab,
        piecelist TYPE TABLE OF objs-tabname,
        foreign_langu LIKE sy-langu,
        langu_fieldname TYPE dfies-fieldname,
        p_bc_keytab_langu TYPE bc_keytab_type,
        w_bc_entry_list TYPE vimty_bc_entry_list_type.  &quot;#EC NEEDED

  FIELD-SYMBOLS: &lt;primtab&gt; TYPE ANY, &lt;sektab&gt; TYPE ANY,
                 &lt;viewfld&gt; TYPE ANY,
                 &lt;primtabfld&gt; TYPE ANY, &lt;sektabfld&gt; TYPE ANY,
                 &lt;bc_tabkey&gt; TYPE bc_key_type-bc_tabkey,    &quot;#EC NEEDED
                 &lt;tabkey_x&gt; TYPE x, &lt;tabkey_struc_x&gt; TYPE x.

  IF x_header-viewname NE old_viewname.
    old_viewname = x_header-viewname.
    CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
      EXPORTING
        name          = x_header-viewname
        state         = &apos;A&apos;
        langu         = sy-langu
      IMPORTING
        gotstate      = flag
      TABLES
        dd28j_tab     = cg_dd28j_tab
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE e164(sv) WITH tabname_wa RAISING view_not_found.
    ENDIF.
    IF flag = space.
      MESSAGE e306(sv) WITH tabname_wa RAISING view_not_found.
    ENDIF.
*   Get tables from piecelist
    SELECT tabname FROM objs INTO tabname_wa
                       WHERE objectname = x_header-viewname
                         AND objecttype = &apos;V&apos;.
      APPEND tabname_wa TO piecelist.
    ENDSELECT.
    REFRESH all_dfiestab.
    LOOP AT piecelist INTO tabname_wa.
      REFRESH cg_dfiestab.
      CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
        EXPORTING
          tabname   = tabname_wa
        TABLES
          dfies_tab = cg_dfiestab[]
        EXCEPTIONS
          not_found = 1
          OTHERS    = 2.
      IF sy-subrc NE 0.
        MESSAGE e028(sv) WITH tabname_wa RAISING view_not_found.
      ENDIF.
      LOOP AT cg_dfiestab INTO dfies_wa.
        APPEND dfies_wa TO all_dfiestab.
      ENDLOOP.
    ENDLOOP.
  ENDIF.
  LOOP AT p_bc_keytab INTO p_bc_keytab_wa.
    keytab_index = sy-tabix.
    IF p_bc_keytab_wa-objname = x_header-roottab.
*-----Build tabkey for root-table from viewkey-------------------------
      CREATE DATA primtab_entry TYPE (x_header-roottab).
      ASSIGN primtab_entry-&gt;* TO &lt;primtab&gt;.
      LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
                           bastabname = x_header-roottab.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_total_struc&gt; TO &lt;viewfld&gt;.
        ASSIGN COMPONENT x_namtab-bastabfld OF STRUCTURE &lt;primtab&gt;
                   TO &lt;primtabfld&gt;.
        MOVE &lt;viewfld&gt; TO &lt;primtabfld&gt;.
      ENDLOOP.                 &quot; Primtabkey completely in &lt;primtab&gt;
      PERFORM vim_get_bc_keylen    &quot;Analog corr_maint_&gt;&gt;viewname&lt;&lt;
              USING x_header-roottab
           CHANGING bc_keylen.
      ASSIGN &lt;primtab&gt; TO &lt;tabkey_struc_x&gt; CASTING.
      ASSIGN p_bc_keytab_wa-bc_tabkey TO &lt;tabkey_x&gt; CASTING.
      MOVE &lt;tabkey_struc_x&gt;(bc_keylen) TO &lt;tabkey_x&gt;(bc_keylen).
      MODIFY p_bc_keytab INDEX keytab_index FROM p_bc_keytab_wa.
    ELSEIF p_bc_keytab_wa-objname EQ x_header-texttab.
*-----Build tabkeys for textable of view from viewkey field by field---
      REFRESH p_bc_keytab_langu.
      tabname_wa = p_bc_keytab_wa-objname.
      CREATE DATA sektab_entry TYPE (tabname_wa).
      ASSIGN sektab_entry-&gt;* TO &lt;sektab&gt;.
      PERFORM vim_get_bc_keylen    &quot;Analog corr_maint_&gt;&gt;viewname&lt;&lt;
                  USING tabname_wa
                  CHANGING bc_keylen.
      LOOP AT all_dfiestab INTO dfies_wa WHERE tabname = tabname_wa
                                          AND keyflag = &apos;X&apos;.
        CLEAR cg_langu.
        READ TABLE cg_dd28j_tab WITH KEY rtab = tabname_wa
                                       rfield = dfies_wa-fieldname
                                    INTO dd28j_wa.
        IF sy-subrc EQ 0.
          READ TABLE x_namtab WITH KEY bastabname = dd28j_wa-ltab
                                        bastabfld = dd28j_wa-lfield.
        ELSE.       &quot;Field not in join -&gt; additional keyfield in view
          READ TABLE x_namtab WITH KEY bastabname = tabname_wa
                                    bastabfld = dfies_wa-fieldname.
          IF sy-subrc NE 0.    &quot;Then it must be langu field of texttab
            cg_langu = &apos;X&apos;.
          ENDIF.
        ENDIF.
        IF cg_langu EQ space.                 &quot;Field is not langu field
          ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                     &lt;vim_total_struc&gt; TO &lt;viewfld&gt;.
          ASSIGN COMPONENT dfies_wa-fieldname OF STRUCTURE
                                           &lt;sektab&gt; TO &lt;sektabfld&gt;.
          MOVE &lt;viewfld&gt; TO &lt;sektabfld&gt;.
        ELSE.                                     &quot;Field is langu field
          langu_fieldname = dfies_wa-fieldname.
          ASSIGN COMPONENT dfies_wa-fieldname OF STRUCTURE
                                           &lt;sektab&gt; TO &lt;sektabfld&gt;.
          MOVE sy-langu TO &lt;sektabfld&gt;.
        ENDIF.
        ASSIGN &lt;sektab&gt; TO &lt;tabkey_struc_x&gt; CASTING.
        ASSIGN p_bc_keytab_wa-bc_tabkey TO &lt;tabkey_x&gt; CASTING.
        MOVE &lt;tabkey_struc_x&gt;(bc_keylen) TO &lt;tabkey_x&gt;(bc_keylen).
      ENDLOOP.
      MODIFY p_bc_keytab INDEX keytab_index FROM p_bc_keytab_wa.
*     Look for other languages in bc-set and append to p_bc_keytab too
      ASSIGN COMPONENT langu_fieldname OF STRUCTURE
                                           &lt;sektab&gt; TO &lt;sektabfld&gt;.
      LOOP AT bc_entry_list_wa-forlangu INTO foreign_langu.
        MOVE foreign_langu TO &lt;sektabfld&gt;.
        MOVE &lt;tabkey_struc_x&gt;(bc_keylen) TO &lt;tabkey_x&gt;(bc_keylen).
        APPEND p_bc_keytab_wa TO p_bc_keytab_langu.
      ENDLOOP.
    ELSE.
*-----Build tabkeys for secondary tabs from viewkey field by field-----
      tabname_wa = p_bc_keytab_wa-objname.
      CREATE DATA sektab_entry TYPE (tabname_wa).
      ASSIGN sektab_entry-&gt;* TO &lt;sektab&gt;.
      PERFORM vim_get_bc_keylen    &quot;Analog corr_maint_&gt;&gt;viewname&lt;&lt;
                  USING tabname_wa
                  CHANGING bc_keylen.
      LOOP AT all_dfiestab INTO dfies_wa WHERE tabname = tabname_wa
                                          AND keyflag = &apos;X&apos;.
        CLEAR cg_langu.
        READ TABLE cg_dd28j_tab WITH KEY rtab = tabname_wa
                                       rfield = dfies_wa-fieldname
                                    INTO dd28j_wa.
        IF sy-subrc EQ 0.
          READ TABLE x_namtab WITH KEY bastabname = dd28j_wa-ltab
                                        bastabfld = dd28j_wa-lfield.
        ELSE.       &quot;Field not in join -&gt; additional keyfield in view
          READ TABLE x_namtab WITH KEY bastabname = tabname_wa
                                    bastabfld = dfies_wa-fieldname.
          IF sy-subrc NE 0.                 &quot;Then it must be an error
*            error.!!!!
          ENDIF.
        ENDIF.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_total_struc&gt; TO &lt;viewfld&gt;.
        ASSIGN COMPONENT dfies_wa-fieldname OF STRUCTURE
                                         &lt;sektab&gt; TO &lt;sektabfld&gt;.
        MOVE &lt;viewfld&gt; TO &lt;sektabfld&gt;.
        ASSIGN &lt;sektab&gt; TO &lt;tabkey_struc_x&gt; CASTING.
        ASSIGN p_bc_keytab_wa-bc_tabkey TO &lt;tabkey_x&gt; CASTING.
        MOVE &lt;tabkey_struc_x&gt;(bc_keylen) TO &lt;tabkey_x&gt;(bc_keylen).
      ENDLOOP.
      MODIFY p_bc_keytab INDEX keytab_index FROM p_bc_keytab_wa.
    ENDIF.
  ENDLOOP.
***********************************************************************
  &quot;HCG Look for sektab, which is not in piecelist but has keyfield
  &quot;in viewkey and write actlink anyway &quot;HW664698
  LOOP AT x_namtab WHERE keyflag = &apos;X&apos;.
*   View Variant may not have all the key fields selected
    IF x_namtab-bastabname NE space.                        &quot;IG 1020971
      READ TABLE p_bc_keytab WITH KEY objname = x_namtab-bastabname
                                             TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0. &quot;bastab of keyfield not in piecelist -&gt; add
        READ TABLE p_bc_keytab INTO p_bc_keytab_wa INDEX 1.
        p_bc_keytab_wa-objname = x_namtab-bastabname.
        CLEAR p_bc_keytab_wa-bc_tabkey.
        REFRESH cg_dfiestab.
        tabname_wa = x_namtab-bastabname.
        CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
          EXPORTING
            tabname   = tabname_wa
          TABLES
            dfies_tab = cg_dfiestab[]
          EXCEPTIONS
            not_found = 1
            OTHERS    = 2.
        IF sy-subrc NE 0.
          MESSAGE e028(sv) WITH tabname_wa RAISING view_not_found.
        ENDIF.
        LOOP AT cg_dfiestab INTO dfies_wa.
          APPEND dfies_wa TO all_dfiestab.
        ENDLOOP.
*-----Build tabkeys for secondary tabs from viewkey field by field-----
        CREATE DATA sektab_entry TYPE (tabname_wa).
        ASSIGN sektab_entry-&gt;* TO &lt;sektab&gt;.
        PERFORM vim_get_bc_keylen    &quot;Analog corr_maint_&gt;&gt;viewname&lt;&lt;
                    USING tabname_wa
                    CHANGING bc_keylen.
        LOOP AT all_dfiestab INTO dfies_wa WHERE tabname = tabname_wa
                                            AND keyflag = &apos;X&apos;.
          CLEAR cg_langu.
          READ TABLE cg_dd28j_tab WITH KEY rtab = tabname_wa
                                         rfield = dfies_wa-fieldname
                                      INTO dd28j_wa.
          IF sy-subrc EQ 0.
            READ TABLE x_namtab WITH KEY bastabname = dd28j_wa-ltab
                                          bastabfld = dd28j_wa-lfield.
            IF sy-subrc NE 0.
              READ TABLE x_namtab WITH KEY bastabname = tabname_wa
                                      bastabfld = dfies_wa-fieldname.
            ENDIF.
          ELSE.       &quot;Field not in join -&gt; additional keyfield in view
            READ TABLE cg_dd28j_tab WITH KEY ltab = tabname_wa        &quot; IM 3990122/2009
                                         lfield = dfies_wa-fieldname
                                      INTO dd28j_wa.
            IF sy-subrc EQ 0.
              READ TABLE x_namtab WITH KEY bastabname = dd28j_wa-rtab
                                          bastabfld = dd28j_wa-rfield.
              IF sy-subrc NE 0.
                READ TABLE x_namtab WITH KEY bastabname = tabname_wa
                                      bastabfld = dfies_wa-fieldname.
              ENDIF.
            ENDIF.
*            READ TABLE x_namtab WITH KEY bastabname = tabname_wa
*                                      bastabfld = dfies_wa-fieldname.
          ENDIF.
          IF sy-subrc NE 0.
            IF dfies_wa-datatype = &apos;CLNT&apos;.
              ASSIGN COMPONENT dfies_wa-fieldname OF STRUCTURE
                                             &lt;sektab&gt; TO &lt;sektabfld&gt;.
             &lt;sektabfld&gt; = sy-mandt.&quot;HCG clnt in namtab with primtabname
            ELSE.
*            error. Field/SEKTAB not in join cond. and not in namtab.
            ENDIF.
          ELSE.
            ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
                       &lt;vim_total_struc&gt; TO &lt;viewfld&gt;.
            ASSIGN COMPONENT dfies_wa-fieldname OF STRUCTURE
                                             &lt;sektab&gt; TO &lt;sektabfld&gt;.
            MOVE &lt;viewfld&gt; TO &lt;sektabfld&gt;.
          ENDIF.
          ASSIGN &lt;sektab&gt; TO &lt;tabkey_struc_x&gt; CASTING.
          ASSIGN p_bc_keytab_wa-bc_tabkey TO &lt;tabkey_x&gt; CASTING.
          MOVE &lt;tabkey_struc_x&gt;(bc_keylen) TO &lt;tabkey_x&gt;(bc_keylen).
        ENDLOOP.
        APPEND p_bc_keytab_wa TO p_bc_keytab.
      ENDIF.
    ENDIF.
  ENDLOOP.
***********************************************************************
  APPEND LINES OF p_bc_keytab_langu TO p_bc_keytab.
ENDFORM.                    &quot; vim_build_bc_tabkeys
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_read_table_with_gap
*&amp;---------------------------------------------------------------------*
*       Implementierung des
*         READ TABLE &lt;it_data&gt; WITH KEY &lt;key&gt; BINARY SEARCH
*       für Tabellen mit Alignment-Lücken (Nicht-Character-Feld wie
*       z.B. ein INT4-Feld im Schlüssel)
*
*       Voraussetzung zum Aufruf: gap_table ist sortiert
*
*       Rückgabewert: SUBRC = 0    1. Datensatz passend zum KEY
*       (analog                    wurde gefunden (wichtig für
*        BINARY                    BC-Sets mit Schlüsselkonflikt)
*        SEARCH)                   Datensatznummer in TABIX
*
*                     SUBRC = 4    Eintrag wurde nicht gefunden
*                                  Datensatznummer + 1 in TABIX
*
*                     SUBRC = 8    Eintrag wurde nicht gefunden
*                                  Letzte Datensatznummer + 1 in TABIX
*----------------------------------------------------------------------*
*     To use function SCPR_CTRL_CT_COMP_TWO_RECORDS table of field
*     description in SCPR format is created and filled partly.
*----------------------------------------------------------------------*
FORM vim_read_table_with_gap TABLES   gap_table
                         USING    key   TYPE x
                                  namtab LIKE x_namtab[]
                         CHANGING subrc TYPE sy-subrc
                                  tabix TYPE sy-tabix.

  TYPES: scpr_x8192(8192) TYPE x.
  DATA: result  TYPE scpr_txt20,
        tab_i   TYPE sy-tabix,
        tab_j   TYPE sy-tabix,
        tab_k   TYPE sy-tabix,
        tab_len TYPE sy-tabix.

  DATA: align TYPE f, wa_8192 TYPE scpr_x8192,      &quot;#EC NEEDED
        it_fldnames TYPE STANDARD TABLE OF scpr_flddescr,
        fldnames_wa LIKE LINE OF it_fldnames.
*        gap_table_wa(2048) TYPE c.
  FIELD-SYMBOLS: &lt;wa_it_data&gt; TYPE x,
                 &lt;namtab&gt; TYPE vimnamtab.

* Fill necessary fields in it_fieldnames from namtab
  LOOP AT namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = &apos;X&apos;
                                    AND texttabfld = space.
    fldnames_wa-fieldname = &lt;namtab&gt;-viewfield.
    fldnames_wa-position = &lt;namtab&gt;-position.
    fldnames_wa-intlen = &lt;namtab&gt;-flength.
    fldnames_wa-keyflag = &apos;X&apos;.
    fldnames_wa-flag = &apos;FKY&apos;. &quot;KEY would do the same job...
    APPEND fldnames_wa TO it_fldnames.
  ENDLOOP.

  DESCRIBE TABLE gap_table LINES tab_len.
  tab_i = 1.
  tab_j = tab_len.
  subrc = 8.
  tabix = tab_len + 1.
  ASSIGN wa_8192 TO &lt;wa_it_data&gt;.
* sturkturierte oder non-sturkturierte sollte beobachten
  ASSIGN gap_table TO &lt;wa_it_data&gt; CASTING.                 &quot;XB H628871


  DO.
    IF tab_i &gt; tab_j.
*     Datensatz wurde nicht gefunden
      subrc = 4.
      tabix = tab_k + 1.
      EXIT.
    ENDIF.
    tab_k = ( tab_i + tab_j ) / 2.

*    READ TABLE gap_table INTO gap_table_wa INDEX tab_k.
    READ TABLE gap_table INDEX tab_k.                       &quot;XB H628871

    CALL FUNCTION &apos;SCPR_CTRL_CT_COMP_TWO_RECORDS&apos;
      EXPORTING
        cu_lines      = &lt;wa_it_data&gt;
        bc_lines      = key
        compare_key   = &apos;X&apos;
        ip_align_data = &apos;X&apos;
      IMPORTING
        RESULT        = RESULT
      TABLES
        it_fldnames   = it_fldnames.

    IF result = &apos;LT&apos;.
      tab_j = tab_k - 1.
    ELSEIF result = &apos;GT&apos;.
      tab_i = tab_k + 1.
    ELSE.
      subrc = 0.
      tabix = tab_k.
      EXIT.
    ENDIF.
  ENDDO.
ENDFORM.                    &quot; read_table_with_gap</include_source>
   </include>
   <include NAME="LSVIMF5B" SQLX="X" VARCL="X" SUBC="I" APPL="S" LEVL="50A" RSTAT="T" RMAND="000" RLOAD="D">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF5B .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CHECK_LIST_BEFORE_ALV
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM check_list_before_alv CHANGING rc LIKE sy-subrc.

  DATA:          counter TYPE i, index type i,
                 variant LIKE disvariant,
                 fcat_var TYPE slis_t_fieldcat_alv.
  FIELD-SYMBOLS: &lt;fcat&gt; TYPE slis_fieldcat_alv.
  CONSTANTS:     alv_maxcols TYPE i VALUE 99.

  CLEAR: counter, rc.
  LOOP AT vim_alv_fcat TRANSPORTING NO FIELDS WHERE no_out &lt;&gt; &apos;X&apos;.
    ADD 1 TO counter.
  ENDLOOP.
  CHECK counter &gt; alv_maxcols.
* suitable standard variant defined?
  CONCATENATE x_header-viewname sy-repid INTO variant-report.
  CALL FUNCTION &apos;REUSE_ALV_VARIANT_SELECT&apos;
       EXPORTING
            i_dialog            = space
            i_user_specific     = &apos;X&apos;
            i_default           = &apos;X&apos;  &quot;vim_var_default
*         I_TABNAME_HEADER    =
*         I_TABNAME_ITEM      =
            it_default_fieldcat = vim_alv_fcat
            i_layout            = vim_alv_layout
       IMPORTING
*         E_EXIT              =
            et_fieldcat         = fcat_var
*         ET_SORT             =
*         ET_FILTER           =
            es_layout           = vim_alv_layout
       CHANGING
            cs_variant          = variant
       EXCEPTIONS
            wrong_input         = 1
            fc_not_complete     = 2
            not_found           = 3
            program_error       = 4
            OTHERS              = 5.
  IF sy-subrc = 0 AND NOT variant-variant IS INITIAL.
    CLEAR: counter.
    LOOP AT fcat_var TRANSPORTING NO FIELDS WHERE no_out &lt;&gt; &apos;X&apos;.
      ADD 1 TO counter.
    ENDLOOP.
    CHECK counter &gt; alv_maxcols.
  ENDIF.
* no variant with less than 99 columns exists
*  WHILE counter &gt; alv_maxcols.
*    MESSAGE i807(sv) WITH counter.
**    Bitte wählen Sie max. 99 Felder für die Liste aus.
*    CALL FUNCTION &apos;REUSE_ALV_VARIANT_MAINTAIN&apos;
*         EXPORTING
**         I_TABNAME_HEADER  =
**         I_TABNAME_ITEM    =
*              i_save            = vim_var_save
**         I_POPUP           = &apos;X&apos;
*              is_layout         = vim_alv_layout
**         IT_SPECIAL_GROUPS =
**         IT_SORT           =
**    IMPORTING
**         E_SAVE            =
*         CHANGING
*              ct_fieldcat       = vim_alv_fcat
*         EXCEPTIONS
*              no_change         = 1
**         PROGRAM_ERROR     = 2
*              OTHERS            = 3.
*    rc = sy-subrc.
*    IF rc &lt;&gt; 0. EXIT. ENDIF.
*    CLEAR counter.
*    LOOP AT vim_alv_fcat TRANSPORTING NO FIELDS WHERE no_out &lt;&gt; &apos;X&apos;.
*      ADD 1 TO counter.
*    ENDLOOP.
**    check counter &lt; alv_maxcols.
** field catalogue changed =&gt; rearrange value tab
*&gt;&gt;&gt;&gt;Complete field catalogue needs to be rearranged here: too lavish
*&gt;&gt;&gt;&gt;for this rare case. Let&apos;s try an easier attempt at first.
*  ENDWHILE.
  MESSAGE i808(sv) with COUNTER.
*   Es können nicht alle Spalten der Tabelle auf der Liste angezeigt wer
  index = alv_maxcols + 1.
  LOOP AT vim_alv_fcat ASSIGNING &lt;fcat&gt; FROM index.
    &lt;fcat&gt;-no_out = &apos;X&apos;.
  ENDLOOP.
ENDFORM.                               &quot; CHECK_LIST_BEFORE_ALV</include_source>
   </include>
   <include NAME="LSVIMF5C" SQLX="X" VARCL="X" SUBC="I" APPL="S" LEVL="50A" RSTAT="T" RMAND="000" RLOAD="D">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF5C .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_SET_OC
*&amp;---------------------------------------------------------------------*
*       Called from external to create reference to organisation
*       criterion
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_set_oc USING value(p_obj)
                       TYPE REF TO cl_viewfields_org_crit.

  clear vim_oc_inst.
  check not p_obj is initial.
  vim_oc_inst = p_obj.
ENDFORM.                               &quot; VIM_SET_GLOBAL_OBJECT</include_source>
   </include>
   <include NAME="LSVIMF5D" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMF5D                                                   *
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_MAINT_SELFLAG
*&amp;---------------------------------------------------------------------*
*       Sets or resets X_HEADER-SELECTION and keeps initial value
*       Purpose: additional check vs. sellist in form
*       CHECK_DYNAMIC_SELECT_OPTIONS
*----------------------------------------------------------------------*
*      --&gt;mode   S = set flag to &apos;X&apos;, I = initialize,
*                R = get and reset to initial value
*      &lt;--p_selflag value of X_HEADER-SELECTION
*----------------------------------------------------------------------*
FORM vim_maint_selflag USING    value(p_mode) TYPE sychar01
                   CHANGING p_selflag     TYPE xfeld.

  STATICS: init_val TYPE xfeld.

  CASE p_mode.
    WHEN &apos;I&apos;.
      init_val = p_selflag.
    WHEN &apos;S&apos;.
      x_header-selection = &apos;X&apos;.                             &quot;#EC PF_ACT_GLO
    WHEN &apos;R&apos;.
      p_selflag = x_header-selection.
      x_header-selection = init_val.
  ENDCASE.
ENDFORM.                               &quot; VIM_MAINT_SELFLAG</include_source>
   </include>
   <include NAME="LSVIMF5E" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMF5E                                                   *
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_make_guid
*&amp;---------------------------------------------------------------------*
*       Sets GUID values in a dataset. Only used if a new entry is
*       created. If p_viewfield is set, only one GUID is filled.
*----------------------------------------------------------------------*
*  --&gt;  p_viewfield   Name of GUID field in table/view
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_make_guid USING p_viewfield TYPE viewfield.

  DATA: fieldname TYPE fnam_____4,
        old_guid TYPE REF TO data.
  DATA: oref TYPE REF TO cx_uuid_error.                     &quot;#EC NEEDED
  FIELD-SYMBOLS: &lt;x_namtab&gt; TYPE vimnamtab, &lt;guid&gt; TYPE ANY,
                 &lt;old_guid&gt; TYPE ANY, &lt;work_area&gt; TYPE ANY.

  IF p_viewfield = space.
* set all GUIDs in structure
    LOOP AT x_namtab ASSIGNING &lt;x_namtab&gt; WHERE keyflag = space
     AND bastabname &lt;&gt; x_header-texttab AND domname IN vim_guid_domain.
* non-key and non-textfields only
      CONCATENATE x_header-maintview &lt;x_namtab&gt;-viewfield
       INTO fieldname SEPARATED BY &apos;-&apos;.
      ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE (fieldname).
      IF &lt;status&gt;-prof_found = vim_pr_into_view
* importing BC-set manually
       OR vim_import_profile &lt;&gt; space
* importing BC-set in background
       OR vim_special_mode = vim_upgrade
* importing from remote system/client
       AND  vim_guid_copy NE &apos;X&apos;.
* ascertaining the operation is not a copy opeartion.
        CHECK &lt;guid&gt; IS INITIAL.
      ENDIF.
      CREATE DATA old_guid TYPE (fieldname).
      ASSIGN old_guid-&gt;* TO &lt;old_guid&gt;.
      CASE &lt;x_namtab&gt;-domname.
        WHEN &apos;SYSUUID&apos;.
          ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_16.
          MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
          TRY.
              &lt;guid&gt; = cl_system_uuid=&gt;create_uuid_x16_static( ).
            CATCH cx_uuid_error INTO oref.              &quot;#EC NO_HANDLER
          ENDTRY.
        WHEN &apos;SYSUUID_C&apos;.
          ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_32.
          MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
          TRY.
              &lt;guid&gt; = cl_system_uuid=&gt;create_uuid_c32_static( ).
            CATCH cx_uuid_error INTO oref.              &quot;#EC NO_HANDLER
          ENDTRY.
        WHEN &apos;SYSUUID_22&apos;.
          ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_22.
          MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
          TRY.
              &lt;guid&gt; = cl_system_uuid=&gt;create_uuid_c22_static( ).
            CATCH cx_uuid_error INTO oref.              &quot;#EC NO_HANDLER
          ENDTRY.
        WHEN &apos;SYSUUID_25&apos;.
          ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE rssguid25.
          MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
          CALL FUNCTION &apos;RSS_SYSTEM_GET_UNIQUE_ID&apos;
            IMPORTING
              e_uni_idc25 = &lt;guid&gt;.
      ENDCASE.
      IF x_header-frm_af_uid &lt;&gt; space.
        ASSIGN (x_header-maintview) TO &lt;work_area&gt;
         CASTING TYPE (x_header-maintview).
        PERFORM (x_header-frm_af_uid) IN PROGRAM (x_header-fpoolname)
                                      USING &lt;old_guid&gt;
                                      CHANGING &lt;guid&gt;
                                               &lt;work_area&gt;.
      ENDIF.
    ENDLOOP.
  ELSE.
* set GUID for p_viewfield only
    READ TABLE x_namtab ASSIGNING &lt;x_namtab&gt;
     WITH KEY viewfield = p_viewfield.
    CHECK sy-subrc = 0 AND &lt;x_namtab&gt;-domname IN vim_guid_domain.
* non-key and non-textfields only
    CONCATENATE x_header-maintview &lt;x_namtab&gt;-viewfield
     INTO fieldname SEPARATED BY &apos;-&apos;.
    ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE (fieldname).
    IF &lt;status&gt;-prof_found = vim_pr_into_view
* importing BC-set manually
     OR vim_import_profile &lt;&gt; space
* importing BC-set in background
     OR vim_special_mode = vim_upgrade.
* importing from remote system/client
      CHECK &lt;guid&gt; IS INITIAL.
    ENDIF.
    CREATE DATA old_guid TYPE (fieldname).
    ASSIGN old_guid-&gt;* TO &lt;old_guid&gt;.
    CASE &lt;x_namtab&gt;-domname.
      WHEN &apos;SYSUUID&apos;.
        ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_16.
        MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
        TRY.
            &lt;guid&gt; = cl_system_uuid=&gt;create_uuid_x16_static( ).
          CATCH cx_uuid_error INTO oref.                &quot;#EC NO_HANDLER
        ENDTRY.
      WHEN &apos;SYSUUID_C&apos;.
        ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_32.
        MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
        TRY.
            &lt;guid&gt; = cl_system_uuid=&gt;create_uuid_c32_static( ).
          CATCH cx_uuid_error INTO oref.                &quot;#EC NO_HANDLER
        ENDTRY.
      WHEN &apos;SYSUUID_22&apos;.
        ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE guid_22.
        MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
        TRY.
            &lt;guid&gt; = cl_system_uuid=&gt;create_uuid_c22_static( ).
          CATCH cx_uuid_error INTO oref.                &quot;#EC NO_HANDLER
        ENDTRY.
      WHEN &apos;SYSUUID_25&apos;.
        ASSIGN (fieldname) TO &lt;guid&gt; CASTING TYPE rssguid25.
        MOVE &lt;guid&gt; TO &lt;old_guid&gt;.
        CALL FUNCTION &apos;RSS_SYSTEM_GET_UNIQUE_ID&apos;
          IMPORTING
            e_uni_idc25 = &lt;guid&gt;.
    ENDCASE.
    IF x_header-frm_af_uid &lt;&gt; space.
      ASSIGN (x_header-maintview) TO &lt;work_area&gt;
       CASTING TYPE (x_header-maintview).
      PERFORM (x_header-frm_af_uid) IN PROGRAM (x_header-fpoolname)
                                    USING &lt;old_guid&gt;
                                    CHANGING &lt;guid&gt;
                                             &lt;work_area&gt;.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; vim_make_guid</include_source>
   </include>
   <include NAME="LSVIMF5F" SQLX="X" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF5F .
*----------------------------------------------------------------------*</include_source>
   </include>
   <include NAME="LSVIMF60" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" UCCHECK="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           LSVIMF60                                         *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_maintain_single_set
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_maintain_single_set.
  Data: msgno like sy-msgno,
        client_key_field_only(1) type c.

  IF vim_single_entry_function EQ space AND
     ( function NE &apos;DELE&apos; AND function NE &apos;SAVE&apos; ).       &quot;HWR
      IF vim_oc_inst IS INITIAL.
        msgno = &apos;005&apos;.
      ELSE.
        READ TABLE dpl_sellist WITH KEY from_auth = space
         TRANSPORTING NO FIELDS.
        IF sy-subrc = 0.
          msgno = &apos;005&apos;.
        ELSE.
          msgno = &apos;766&apos;.
*   Eingeschränkte Anzeige von Datensätzen.
        ENDIF.
      ENDIF.
    PERFORM vim_send_sv005_or_sv766 USING msgno
                                          &apos;SENDIT&apos;.
  ENDIF.                                                  &quot;HWR
  IF status-type EQ zweistufig AND function NE &apos;ABR &apos;
     AND function NE &apos;KOPF&apos;
     AND function NE &apos;IGN &apos;.&quot;SW: nicht ex. Status ZCDGM (1211787/98)
    &lt;status&gt;-firstline = &lt;status&gt;-cur_line = nextline.
    function = &apos;DETA&apos;.
    IF x_header-delmdtflag NE space.
      TRANSLATE vim_no_mainkey_exists USING
                                        vim_no_mkey_not_procsd_patt.
    ENDIF.
*   Modify EXCL_CUA_FUNCT to remove the &quot;new entries&quot; and &quot;copy entry&quot;
*   functions only in the case of a view with Client as a key field and
*   no other key fields.
    client_key_field_only = &apos;X&apos;.                          &quot;IG 953007
    LOOP AT x_namtab WHERE keyflag EQ &apos;X&apos;
                       AND datatype NE &apos;CLNT&apos;.
      client_key_field_only = &apos; &apos;.
      EXIT.
    ENDLOOP.
    IF client_key_field_only EQ &apos;X&apos;.
      IF &lt;status&gt;-st_action EQ &apos;U&apos; OR &lt;status&gt;-st_action EQ &apos;A&apos;.
        MOVE &apos;NEWL&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
        MOVE &apos;KOPE&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
        MOVE &apos;PREV&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
        MOVE &apos;NEXT&apos; TO excl_cua_funct-function. COLLECT excl_cua_funct.
      ENDIF.
    ENDIF.
    PERFORM process_detail_screen USING &apos;S&apos;.
  ENDIF.
ENDFORM.                    &quot; vim_maintain_single_set
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_send_sv005_or_sv766
*&amp;---------------------------------------------------------------------*
*       Send messages only once unless status has not been resetted
*----------------------------------------------------------------------*
*      --&gt;P_MSGNO Message number to be sent as s-message
*      --&gt;P_MODE  SENDIT: Send S-Message if it hasn&apos;t been sent before.
*                 RESET:  Reset status.
*----------------------------------------------------------------------*
FORM vim_send_sv005_or_sv766  USING p_msgno like sy-msgno
                                    p_mode TYPE char6.

  STATICS: sent_already TYPE xfeld,
           viewname TYPE viewname.

  IF viewname &lt;&gt; x_header-viewname.
    viewname = x_header-viewname.
    CLEAR sent_already.
  ENDIF.
  CASE p_mode.
    WHEN &apos;SENDIT&apos;.
      CHECK sent_already = space.
      sent_already = &apos;X&apos;.
      MESSAGE ID &apos;SV&apos; TYPE &apos;S&apos; NUMBER p_msgno.
    WHEN &apos;RESET&apos;.
      CLEAR sent_already.
  ENDCASE.
ENDFORM.                    &quot; vim_send_sv005_or_sv766</include_source>
   </include>
   <include NAME="LSVIMF61" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" UCCHECK="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           LSVIMF61
**&amp;---------------------------------------------------------------------
*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  MAP_TEXTTABKEY_TO_VIEWKEY
*&amp;---------------------------------------------------------------------*
* Texttabellen-Schlüssel aus Transportauftrag in zugehörigen
* View-/Primärtabellenschlüssel transformieren
*----------------------------------------------------------------------*
* --&gt; NAMTAB
* --&gt; HEADER
* --&gt; TEXTTABKEY     Importschlüssel der Texttabelle
*$$$ Release 5.0: included in HEADER $$$
* --&gt; SPRASFDPOS     Offset des Sprachenschlüssels
*$$$
* --&gt; TEXTTAB_KEYLEN Länge des zu berücksichtigenden Schlüsselteils
*                    (i.A. tatsächliche Schlüssellänge,
*                    bei generischem Transport: nichtgen. Schlüsselteil)
* --&gt; IS_GENERIC_KEY &apos;X&apos; =&gt; Texttabellen-Schlüssel is generisch
*
* &lt;-- VIEWKEY        View/Primärtabellenschlüssel
* &lt;-- MAP_ERROR      &apos;X&apos; -&gt; Fehler bei der Abb., VIEWKEY nicht gefüllt
*                    (nur bei GENKEY = &apos;X&apos; relevant)
*----------------------------------------------------------------------*
FORM map_texttabkey_to_viewkey TABLES namtab STRUCTURE vimnamtab
                               USING  header TYPE vimdesc
                                      texttabkey TYPE x
                                      texttab_keylen TYPE syfleng
                                      is_generic_key TYPE xfeld
                               CHANGING viewkey TYPE x
                                        map_error.
  DATA: o1 TYPE i, o2 TYPE i,
        t_keylen TYPE i, l TYPE i, h_viewkey TYPE tabl8000.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab,
                 &lt;texttab_struc&gt; TYPE ANY,
                 &lt;texttab_fld&gt; TYPE ANY,
                 &lt;txt_struc&gt; TYPE ANY,
                 &lt;viewfld&gt; TYPE ANY.

  CLEAR: map_error, viewkey.

  ASSIGN: texttabkey TO &lt;texttab_struc&gt; CASTING TYPE (header-texttab),
          h_viewkey TO &lt;txt_struc&gt; CASTING TYPE (header-maintview).
  MOVE viewkey TO h_viewkey.
  IF is_generic_key = space.
*  IF is_generic_key = space.
    LOOP AT namtab ASSIGNING &lt;namtab&gt;
      WHERE keyflag &lt;&gt; space AND txttabfldn &lt;&gt; space.
      ASSIGN: COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;txt_struc&gt;
               TO &lt;viewfld&gt;,
              COMPONENT &lt;namtab&gt;-txttabfldn
               OF STRUCTURE &lt;texttab_struc&gt; TO &lt;texttab_fld&gt;.
      &lt;viewfld&gt; = &lt;texttab_fld&gt;.
    ENDLOOP.
* &quot;HCG HW723732 fill additional view-keyfields with dataset value
* CustMSG 20963/2004 otherwise # will be stored in these view-keyfields
    IF header-bastab NE &apos;X&apos;.             &quot;Only neccessary in view case
      LOOP AT namtab ASSIGNING &lt;namtab&gt;
           WHERE keyflag &lt;&gt; space AND txttabfldn EQ space.
        ASSIGN: COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;txt_struc&gt;
                 TO &lt;viewfld&gt;.
*  value for additional view-keyfield must specified unique in sellist
*  otherwise SE11 view-definition is wrong
        READ TABLE dba_sellist WITH KEY viewfield = &lt;namtab&gt;-viewfield.
        MOVE dba_sellist-value TO &lt;viewfld&gt;.
      ENDLOOP.
    ENDIF.
  ELSE.
    IF header-sprasfdpos &lt; texttab_keylen.
* Sprache im nichtgen. Teil
      t_keylen = texttab_keylen - vim_spras_length.
    ELSE.
      t_keylen = texttab_keylen.
    ENDIF.
    LOOP AT namtab ASSIGNING &lt;namtab&gt;
*      WHERE keyflag = space AND texttabfld = &apos;X&apos;.
      WHERE keyflag &lt;&gt; space AND txttabfldn &lt;&gt; space.
      o1 = &lt;namtab&gt;-position + &lt;namtab&gt;-flength.
      o2 = &lt;namtab&gt;-texttabpos + &lt;namtab&gt;-flength.
      ASSIGN: COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;txt_struc&gt;
               TO &lt;viewfld&gt;,
              COMPONENT &lt;namtab&gt;-txttabfldn
               OF STRUCTURE &lt;texttab_struc&gt; TO &lt;texttab_fld&gt;.
      IF o1 &lt;= t_keylen AND o2 &lt;= texttab_keylen.
        &lt;viewfld&gt; = &lt;texttab_fld&gt;.
      ELSEIF o1 &gt; t_keylen AND o2 &gt; texttab_keylen. &quot;gen. Teil
        IF &lt;namtab&gt;-position &lt; t_keylen
         AND &lt;namtab&gt;-texttabpos &lt; texttab_keylen
         AND &apos;CNDT&apos; CS &lt;namtab&gt;-inttype.
          l = ( texttab_keylen - &lt;namtab&gt;-texttabpos )
              DIV cl_abap_char_utilities=&gt;charsize.
          &lt;viewfld&gt;(l) = &lt;texttab_fld&gt;(l).
        ENDIF.
      ELSE.
        map_error = &apos;X&apos;. EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.
  MOVE h_viewkey TO viewkey.
*  LOOP AT namtab WHERE keyflag = &apos;X&apos; AND txttabfldn &lt;&gt; space.
*    IF is_generic_key = space.
*      viewkey+namtab-position(namtab-flength) =
*         texttabkey+namtab-texttabpos(namtab-flength).
*    ELSE.
*      IF sprasfdpos &lt; texttab_keylen.   &quot;Sprache im nichtgen. Teil
*        t_keylen = texttab_keylen - vim_spras_length.
*      ELSE.
*        t_keylen = texttab_keylen.
*      ENDIF.
*      o1 = namtab-position + namtab-flength.
*      o2 = namtab-texttabpos + namtab-flength.
*      IF o1 &lt;= t_keylen AND o2 &lt;= texttab_keylen.
*        viewkey+namtab-position(namtab-flength) =
*          texttabkey+namtab-texttabpos(namtab-flength).
*      ELSEIF o1 &gt; t_keylen AND o2 &gt; texttab_keylen. &quot;gen. Teil
*        IF namtab-position &lt; t_keylen AND
*           namtab-texttabpos &lt; texttab_keylen.
*          l = texttab_keylen - namtab-texttabpos.
*          viewkey+namtab-position(l) = texttabkey+namtab-texttabpos(l).
*        ENDIF.
*      ELSE.
*        map_error = &apos;X&apos;. EXIT.
*      ENDIF.
*    ENDIF.
*  ENDLOOP.
ENDFORM.                    &quot; MAP_TEXTTABKEY_TO_VIEWKEY

*&amp;--------------------------------------------------------------------*
*&amp;      Form  MAP_VIEWKEY_TO_TEXTTABKEY                               *
*&amp;--------------------------------------------------------------------*
* Schlüssel von Texttabelle anhand des View-/Tabellenschlüssels und
* der Sprache zusammensetzen
*&amp;--------------------------------------------------------------------*
* --&gt; X_NAMTAB
* --&gt; VIEW_WA  WA of view                                             *
* --&gt; SPRAS    Sprachschlüssel                                        *
* &lt;-- TEXT_WA  Key of text table                                      *
*&amp;--------------------------------------------------------------------*
FORM map_viewkey_to_texttabkey TABLES namtab STRUCTURE vimnamtab
                                USING header TYPE vimdesc
                                      spras LIKE t002-spras
                                      view_wa TYPE x
                             CHANGING text_wa TYPE x.

  DATA: align TYPE f,                                          &quot;#EC NEEDED
        h_view_wa TYPE tabl8000,
        h_texttab_wa TYPE tabl8000.

  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab,
                 &lt;texttab_struc&gt; TYPE ANY,
                 &lt;texttab_fld&gt; TYPE ANY,
                 &lt;view_struc&gt; TYPE ANY,
                 &lt;viewfld&gt; TYPE ANY.

  ASSIGN h_texttab_wa TO &lt;texttab_struc&gt; CASTING TYPE (header-texttab).
  MOVE: text_wa TO h_texttab_wa,
        view_wa TO h_view_wa.
* Sprachschlüssel
  ASSIGN COMPONENT header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
   TO &lt;texttab_fld&gt;.
  &lt;texttab_fld&gt; = spras.
*  text_wa+spras_pos(vim_spras_length) = spras.
* Schlüsselfelder der Text-Tabelle
  ASSIGN: h_view_wa(header-tablen) TO &lt;view_struc&gt;
             CASTING TYPE (header-maintview).
  LOOP AT namtab ASSIGNING &lt;namtab&gt;
    WHERE txttabfldn &lt;&gt; space AND keyflag &lt;&gt; space.
    ASSIGN: COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;view_struc&gt;
             TO &lt;viewfld&gt;,
            COMPONENT &lt;namtab&gt;-txttabfldn
             OF STRUCTURE &lt;texttab_struc&gt; TO &lt;texttab_fld&gt;.
    &lt;texttab_fld&gt; = &lt;viewfld&gt;.
  ENDLOOP.
  MOVE h_texttab_wa TO text_wa.
*  LOOP AT namtab WHERE txttabfldn &lt;&gt; space AND keyflag &lt;&gt; space.
*    text_wa+namtab-texttabpos(namtab-flength) =
*         view_wa+namtab-position(namtab-flength).
*  ENDLOOP.
ENDFORM.                               &quot; MAP_VIEWKEY_TO_TEXTTABKEY</include_source>
   </include>
   <include NAME="LSVIMF62" SQLX="X" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF62 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_get_trspkeylen
*&amp;---------------------------------------------------------------------*
*       Delivers key length in bytes of tables whithin a view. Called
*       by generated forms CORR_MAINT_yxz
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_get_trspkeylen USING    p_tabname TYPE tabname
                        CHANGING p_keylength TYPE syfleng.

  TYPES: BEGIN OF tabkeylen_type,
          tabname TYPE tabname,
          keylen TYPE syfleng,
         END OF tabkeylen_type.
  STATICS: tabkeylen_tab TYPE HASHED TABLE OF tabkeylen_type
            WITH UNIQUE KEY tabname.
  DATA: w_tabkeylen TYPE tabkeylen_type,
        x030l_wa TYPE x030l.

  READ TABLE tabkeylen_tab INTO w_tabkeylen
   WITH TABLE KEY tabname = p_tabname.
  IF sy-subrc &lt;&gt; 0.
    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname  = p_tabname
      IMPORTING
        x030l_wa = x030l_wa.
    w_tabkeylen-tabname = p_tabname.
    w_tabkeylen-keylen  = x030l_wa-keylen.
    IF p_tabname = x_header-texttab AND x_header-genertxtrp &lt;&gt; space.
      w_tabkeylen-keylen = x_header-maxtrtxkln.
    ELSEIF x_header-generictrp &lt;&gt; space.
      w_tabkeylen-keylen = x_header-maxtrkeyln.
    ENDIF.
    INSERT w_tabkeylen INTO TABLE tabkeylen_tab.
  ENDIF.
  p_keylength = w_tabkeylen-keylen.
ENDFORM.                    &quot; vim_get_trspkeylen

*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_get_bc_keylen
*&amp;---------------------------------------------------------------------*
*       Delivers key length in bytes of tables whithin a view up to
*       255 char. Necessary for writing activation links
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM vim_get_bc_keylen USING    p_tabname TYPE tabname
                        CHANGING p_keylength TYPE syfleng.

  CONSTANTS max_bc_keylen TYPE i VALUE 255.

  TYPES: BEGIN OF tabkeylen_type,
          tabname TYPE tabname,
          keylen TYPE syfleng,
         END OF tabkeylen_type.
  STATICS: tabkeylen_tab TYPE HASHED TABLE OF tabkeylen_type
            WITH UNIQUE KEY tabname.
  DATA: w_tabkeylen TYPE tabkeylen_type,
        x030l_wa TYPE x030l, max_keylen_byte TYPE i.

  READ TABLE tabkeylen_tab INTO w_tabkeylen
   WITH TABLE KEY tabname = p_tabname.
  IF sy-subrc &lt;&gt; 0.
    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname  = p_tabname
      IMPORTING
        x030l_wa = x030l_wa.
    w_tabkeylen-tabname = p_tabname.
    w_tabkeylen-keylen  = x030l_wa-keylen.
    max_keylen_byte = max_bc_keylen * cl_abap_char_utilities=&gt;charsize.
    IF w_tabkeylen-keylen &gt; max_keylen_byte.
      w_tabkeylen-keylen = max_keylen_byte.
    ENDIF.
    INSERT w_tabkeylen INTO TABLE tabkeylen_tab.
  ENDIF.
  p_keylength = w_tabkeylen-keylen.
ENDFORM.                    &quot; vim_get_bc_keylen</include_source>
   </include>
   <include NAME="LSVIMF63" SQLX="X" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF63 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_comp_roottabkey
*&amp;---------------------------------------------------------------------*
*       Check if view and root table have identical keys.
*----------------------------------------------------------------------*
*      --&gt;P_HEADER  text
*      --&gt;P_NAMTAB  text
*      &lt;--P_KEYS_IDENTICAL  text
*      &lt;--P_RC  text
*----------------------------------------------------------------------*
FORM vim_comp_roottabkey  USING    p_header TYPE vimdesc
                                   p_namtab TYPE vimnamtab_type
                          CHANGING p_keys_identical TYPE xfeld
                                   p_rc TYPE sy-subrc.
  TYPES: BEGIN OF flagstruc_type,
          viewname TYPE viewname,
          keys_ident,
         END OF flagstruc_type.

  STATICS: flagtab TYPE HASHED TABLE OF flagstruc_type
           WITH UNIQUE KEY viewname.
  DATA: w_flagtab TYPE flagstruc_type,
        x031l_tab TYPE TABLE OF x031l.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab,
                 &lt;x031l&gt; TYPE x031l.

  CLEAR p_rc.
  READ TABLE flagtab WITH TABLE KEY viewname = p_header-viewname
   INTO w_flagtab.
  IF sy-subrc &lt;&gt; 0.
    w_flagtab-viewname = p_header-viewname.
    w_flagtab-keys_ident = &apos;X&apos;.
    CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
      EXPORTING
        tabname   = p_header-roottab
      TABLES
        x031l_tab = x031l_tab
      EXCEPTIONS
        OTHERS    = 2.
    IF sy-subrc &lt;&gt; 0.
      p_rc = sy-subrc.
    ENDIF.
    LOOP AT p_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = &apos;X&apos;.
      IF &lt;namtab&gt;-bastabname &lt;&gt; p_header-roottab.
        sy-subrc = 4.
      ELSE.
        READ TABLE x031l_tab INDEX sy-tabix ASSIGNING &lt;x031l&gt;.
      ENDIF.
      IF sy-subrc &lt;&gt; 0 OR &lt;x031l&gt;-fieldname &lt;&gt; &lt;namtab&gt;-bastabfld.
        clear w_flagtab-keys_ident.
        exit.
      ENDIF.
    ENDLOOP.
    INSERT w_flagtab INTO TABLE flagtab.
  ENDIF.
  p_keys_identical = w_flagtab-keys_ident.
ENDFORM.                    &quot; vim_comp_roottabkey</include_source>
   </include>
   <include NAME="LSVIMF64" SQLX="X" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" UCCHECK="X">
    <include_source>*----------------------------------------------------------------------*
***INCLUDE LSVIMF64 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_synchronizer_call
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_CU_KO200_TAB[]  text
*      --&gt;P_CORR_KEYTAB[]  text
*      --&gt;P_SPACE  text
*----------------------------------------------------------------------*
FORM vim_synchronizer_call  USING
                                 p_cu_ko200_tab TYPE vim_ko200_tab_type
                                 p_corr_keytab TYPE tr_keys
                                 p_synchronizer_flag TYPE xfeld.

  STATICS: e071k_loc TYPE TABLE OF e071k,
          e071_loc TYPE TABLE OF e071.
  STATICS: sv_trkorr     TYPE trkorr,       &quot;VG 31 Mar 2004
           sv_at_tr_change,
           sv_project_id TYPE project_id,
           sv_strkorr    TYPE trkorr.
  DATA: e071k_loc_wa TYPE e071k,
        e071_loc_wa TYPE e071.

  IF p_synchronizer_flag = space.
    CLEAR: e071k_loc, e071_loc.
    REFRESH: e071k_loc, e071_loc.
    LOOP AT p_corr_keytab INTO e071k_loc_wa.
      APPEND e071k_loc_wa TO e071k_loc.
    ENDLOOP.
    LOOP AT p_cu_ko200_tab INTO e071_loc_wa.
      APPEND e071_loc_wa TO e071_loc.
    ENDLOOP.
  ELSE.
    READ TABLE e071k_loc INDEX 1 INTO e071k_loc_wa.
*----------------------------------------------------------------------
* Signal for Wulf Kruempelmann&apos;s Synchronizer (data written)
    IF e071k_loc_wa-trkorr = space.
      READ TABLE p_corr_keytab INDEX 1 INTO e071k_loc_wa.
    ENDIF.    &quot;HCG p_corr_keytab-trkorr could be empty in VCL HW658985

    IF e071k_loc_wa-trkorr &lt;&gt; sv_trkorr.    &quot;VG 31 Mar 2004
      sv_trkorr = e071k_loc_wa-trkorr.
      CALL FUNCTION &apos;SCTM_CHECK_TRIGGER_METHOD_TRK&apos;
        EXPORTING
          iv_trkorr              = e071k_loc_wa-trkorr
        IMPORTING
*         EV_AT_TR_RELEASE       =
          ev_at_tr_change        = sv_at_tr_change
*         EV_POLLING             =
*         EV_NO_SYNC             =
*         EV_IS_TARGET           =
          ev_project_id          = sv_project_id
          ev_strkorr             = sv_strkorr.
    ENDIF.
    CHECK sv_at_tr_change = &apos;X&apos;.

    CALL FUNCTION &apos;SCDC_DISTRIBUTE_TABLE_KEYS&apos;
      EXPORTING
        project_id = sv_project_id
        trkorr     = sv_strkorr
      TABLES
        e071_tab   = e071_loc
        e071k_tab  = e071k_loc
      EXCEPTIONS
        no_project = 1
        OTHERS     = 2.
    IF sy-subrc &lt;&gt; 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*         WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.
*----------------------------------------------------------------------
  ENDIF.
ENDFORM.                    &quot; vim_synchronizer_call
*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_sync_key_lock
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_VIM_SYNC_KEY_LOCK  text
*----------------------------------------------------------------------*
FORM check_sync_key_lock USING p_check_all
                         CHANGING p_vim_sync_key_lock.

  DATA:    keytab_loc TYPE TABLE OF tbl8096,
           keytab_wa LIKE LINE OF keytab_loc,
           allowed_keys TYPE TABLE OF tbl8096,
           n TYPE i, viewtype.                              &quot;#EC TYPES_MISS
  DATA:    sctm_fill_cache TYPE oax.
  STATICS: old_viewname TYPE vimdesc-viewname.

  CHECK &lt;xact&gt; NE &apos;L&apos;. &quot;Avoids empty checks on add new entry in list
  IF x_header-bastab EQ space.
    viewtype = &apos;V&apos;.
  ELSE.
    viewtype = &apos;S&apos;.
  ENDIF.
  IF p_check_all EQ space.                           &quot;check entry
    REFRESH keytab_loc.
    REFRESH allowed_keys.
    keytab_wa-line = &lt;vim_xextract&gt;.
    CLEAR sctm_fill_cache.
    IF &lt;xact&gt; NE space.
      sctm_fill_cache = &apos;X&apos;.
    ENDIF.
    APPEND keytab_wa TO keytab_loc.          &quot;Table with 1 line only to
    CALL FUNCTION &apos;SCTM_CHECK_VIEW_KEY&apos; &quot;grey out locked data in screen
      EXPORTING
        viewname              = x_header-viewname
        viewtype              = viewtype
        bcset                 = vim_bcset_id  &quot;if NE space: BC-set act
        fill_cache            = sctm_fill_cache
*     IMPORTING               &quot;HCG: Already set in justify_action_mode
*       EDIT_FLAG           = vim_sync_edit_lock
*       KESPEC_FLAG         = vim_sync_keyspec_check
      TABLES
        query_tab             = keytab_loc
        allowed_tab           = allowed_keys
      EXCEPTIONS
        no_sync_present       = 1
        old_sync_system       = 2
        OTHERS                = 3.
    IF sy-subrc &lt;&gt; 0.     &quot;Ignore check_result but no message to user
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      CLEAR p_vim_sync_key_lock.          &quot;If no connection: open all
    ELSE.
      DESCRIBE TABLE allowed_keys LINES n.
      IF n EQ 0.
        p_vim_sync_key_lock = &apos;X&apos;.
      ELSE.
        CLEAR p_vim_sync_key_lock.
      ENDIF.
    ENDIF.
  ELSEIF old_viewname NE x_header-viewname.
    old_viewname = x_header-viewname.&quot;Just fill cache in sync, no check
    REFRESH keytab_loc.
    REFRESH allowed_keys.
    LOOP AT total.                                          &quot;#EC *
      keytab_wa-line = &lt;vim_xtotal&gt;.
      APPEND keytab_wa TO keytab_loc.                &quot;Provide all data
    ENDLOOP.
    CALL FUNCTION &apos;SCTM_CHECK_VIEW_KEY&apos;
      EXPORTING
        viewname              = x_header-viewname
        viewtype              = viewtype
        bcset                 = vim_bcset_id  &quot;if NE space: BC-set act
        fill_cache            = &apos;X&apos;    &quot;fill cache for first call
*     IMPORTING               &quot;HCG: Already set in justify_action_mode
*       EDIT_FLAG           = vim_sync_edit_lock
*       KESPEC_FLAG         = vim_sync_keyspec_check
      TABLES
        query_tab             = keytab_loc
        allowed_tab           = allowed_keys
      EXCEPTIONS
        no_sync_present       = 1
        old_sync_system       = 2
        OTHERS                = 3.
    IF sy-subrc &lt;&gt; 0.     &quot;Ignore check_result but no message to user
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*                WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot; check_sync_key_lock</include_source>
   </include>
   <include NAME="LSVIMF65" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" UCCHECK="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           LSVIMF65                                         *
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_nonkey
*&amp;---------------------------------------------------------------------*
*       to check selection condiotions for nonkey fields only
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM check_nonkey.


  FIELD-SYMBOLS: &lt;table1_txt_loc&gt; TYPE ANY.


  IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
    ASSIGN &lt;table1_text&gt; TO &lt;table1_txt_loc&gt;.
  ELSE.
    ASSIGN &lt;table1&gt; TO &lt;table1_txt_loc&gt;.
  ENDIF.
  CALL FUNCTION &apos;TABLE_RANGE_CHECK&apos;
    EXPORTING
      tabname                   = x_header-maintview
      entry                     = &lt;table1&gt;
      entry_text                = &lt;table1_txt_loc&gt;
      ddic                      = &apos;J&apos;
      key                       = &apos;F&apos;
      ignore_blank_subsetfields = &apos;N&apos;
    TABLES
      x_namtab                  = x_namtab
      x_header                  = x_header
      sellist                   = &lt;vim_ck_sellist&gt;
    EXCEPTIONS
      entry_not_fits            = 1.
  IF sy-subrc EQ 1.
*    PERFORM set_pf_status USING &apos;ERROR&apos;.
    MESSAGE w174(sv).
  ENDIF.
ENDFORM.        &quot;check_nonkey</include_source>
   </include>
   <include NAME="LSVIMFL1" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMFL1
**----------------------------------------------------------------------
*
*---------------------------------------------------------------------*
*       FORM VIM_GET_TEXTTAB_DATA                                     *
*---------------------------------------------------------------------*
* Texteinträge von der DB nachlesen für angeg. Sprachen               *
* UFProbl251070/1998: Falls X_NAMTAB-Reihenfolge nicht mit
*                     DBA-SELLIST-Reihenfolge übereinstimmt, werden
*                     ANDs oder ORs verschluckt.
*---------------------------------------------------------------------*
*  --&gt; LANGUS         ausgewählte Sprachen
* &lt;--&gt; TEXTTAB
*---------------------------------------------------------------------*
FORM vim_get_texttab_data TABLES langus STRUCTURE h_t002
                          CHANGING texttab TYPE table.
*                                  Type VIM_LINE_US/../VIM_LINE_UL
  DATA: tgd_sellist LIKE vimsellist OCCURS 10, tgd_sel LIKE vimsellist,
        wheretab_line LIKE vimwheretb,
        spras_value(3) TYPE c,
*        curr_spras(1) TYPE c,
        keylen TYPE i,
        l TYPE i, sellist_l TYPE i, tbx TYPE i,
        and_or_str(6) TYPE c, left_par(1) TYPE c,
        tmp_texttab TYPE REF TO data,
        tmp_texttab_wa TYPE REF TO data,
*        tmp_texttab TYPE vim_tab_ul WITH HEADER LINE,
        texttab_tabix LIKE sy-tabix,
        align1 type f,                                     &quot;#EC NEEDED
        texttab_wa TYPE vim_line_ul,
        align2 type f,                                   &quot;#EC NEEDED
        view_wa TYPE tabl8000, map_error TYPE xfeld.
  FIELD-SYMBOLS: &lt;tmp_texttab&gt; TYPE STANDARD TABLE,
                 &lt;tmp_texttab_wa&gt; TYPE ANY, &lt;tmp_texttab_wax&gt; TYPE x,
                 &lt;view_key&gt; TYPE x, &lt;next_spras&gt; TYPE spras,
                 &lt;curr_spras&gt; TYPE spras,
                 &lt;h_texttab&gt; TYPE x, &lt;h_texttab_wa&gt; TYPE x,
                 &lt;viewkey_in_texttab&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY.

  CREATE DATA: tmp_texttab TYPE STANDARD TABLE OF (x_header-texttab),
               tmp_texttab_wa TYPE (x_header-texttab).
  ASSIGN: tmp_texttab-&gt;* TO &lt;tmp_texttab&gt;,
          tmp_texttab_wa-&gt;* TO &lt;tmp_texttab_wa&gt;,
          &lt;tmp_texttab_wa&gt; TO &lt;tmp_texttab_wax&gt; CASTING.

  IF x_header-selection NE space.
    LOOP AT dba_sellist INTO tgd_sel       &quot;UFProbl251070/1998
     WHERE value &lt;&gt; space OR initial = &apos;X&apos;.
      LOOP AT x_namtab WHERE viewfield EQ tgd_sel-viewfield
                       AND keyflag NE space AND txttabfldn NE space.
        tgd_sel-viewfield = x_namtab-txttabfldn.
        tgd_sel-tabix     = sy-tabix.
        APPEND tgd_sel TO tgd_sellist.
        EXIT.
      ENDLOOP.
    ENDLOOP.                                &quot;UFProbl251070/1998
  ENDIF.                               &quot;X_HEADER-SELECTION

  DESCRIBE TABLE tgd_sellist LINES sellist_l.
  IF sellist_l &gt; 0.
    READ TABLE tgd_sellist INDEX sellist_l INTO tgd_sel.
    IF tgd_sel-and_or NE space.
      CLEAR tgd_sel-and_or.
      MODIFY tgd_sellist INDEX sellist_l FROM tgd_sel.
    ENDIF.
    CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
         EXPORTING
              tablename               = x_header-texttab
              only_cnds_for_keyflds   = &apos;X&apos;
              is_texttable            = &apos;X&apos;
         TABLES
              sellist                 = tgd_sellist
              wheretab                = vim_wheretab
              x_namtab                = x_namtab
         EXCEPTIONS
              no_conditions_for_table = 01.
    IF sy-subrc = 1. sellist_l = 0. ENDIF.
  ELSE.
    REFRESH vim_wheretab.
  ENDIF.

* VIM_WHERETAB um Bedingungen für ausgew. Sprachen ergänzen
  DESCRIBE TABLE langus LINES l.
  IF l &gt; 1.
    and_or_str = &apos;OR&apos;.
    IF sellist_l &gt; 0.
      left_par = &apos;(&apos;.
    ENDIF.
  ENDIF.
  tbx = 1.
  spras_value = &apos;&apos;&apos; &apos;&apos;&apos;.
  LOOP AT langus.
    spras_value+1(1) = langus-spras.
    IF tbx = l.      &quot; letzte Zeile für Sprachselektion
      IF l &gt; 1 AND sellist_l &gt; 0.
        and_or_str = &apos; ) AND&apos;.
      ELSEIF l = 1 AND sellist_l &gt; 0.
        and_or_str = &apos; AND&apos;.
      ELSE.
        CLEAR and_or_str.
      ENDIF.
    ENDIF.
* Start of note 1449599
    IF x_header-sprasfield IS INITIAL.
      SELECT SINGLE fieldname FROM dd03l INTO x_header-sprasfield  &quot;IM 3506611/2010
                              WHERE tabname  EQ x_header-texttab   &quot;PATIDARP
                                AND keyflag  EQ &apos;X&apos;
                                AND datatype EQ &apos;LANG&apos;.
*      x_header-sprasfield = &apos;SPRAS&apos;.
    ENDIF.
* End of note 1449599
   CONCATENATE left_par x_header-sprasfield &apos;EQ&apos; spras_value and_or_str
                            INTO wheretab_line SEPARATED BY space.
    INSERT wheretab_line INTO vim_wheretab INDEX tbx.
    CLEAR left_par.
    tbx = tbx + 1.
  ENDLOOP.

  SELECT * FROM (x_header-texttab) INTO TABLE &lt;tmp_texttab&gt;
                                      WHERE (vim_wheretab).

* Texttabellen-Einträge sortiert in Texttabelle einfügen
  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    keylen = x_header-after_keyc
              - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    keylen = x_header-after_keyc.
  ENDIF.
  ASSIGN: view_wa(keylen) TO &lt;view_key&gt;,
          texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(keylen) TO &lt;viewkey_in_texttab&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen) TO &lt;h_texttab&gt;,
          &lt;h_texttab&gt; TO &lt;texttab_struc&gt;
           CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
           TO &lt;next_spras&gt;,
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;tmp_texttab_wa&gt;
           TO &lt;curr_spras&gt;.
  LOOP AT &lt;tmp_texttab&gt; INTO &lt;tmp_texttab_wa&gt;.
    PERFORM map_texttabkey_to_viewkey TABLES x_namtab
                                      USING x_header
                                            &lt;tmp_texttab_wax&gt;
                                            x_header-textkeylen
                                            x_header-genertxtrp
                                      CHANGING &lt;view_key&gt;
                                               map_error.
    CHECK map_error = space.
*    PERFORM vim_fill_view_key USING tmp_texttab
*                           CHANGING &lt;view_key&gt; curr_spras.
    CLEAR texttab_wa.
    READ TABLE texttab WITH KEY &lt;view_key&gt; INTO texttab_wa  &quot;#EC WARNOK
                                                        BINARY SEARCH.
    texttab_tabix = sy-tabix.
    IF sy-subrc = 0 AND
      &lt;viewkey_in_texttab&gt; = &lt;view_key&gt; AND  &quot;Text ex. in weiteren Spr
      &lt;next_spras&gt; &lt; &lt;curr_spras&gt;. &quot;#EC PORTABLE
      LOOP AT texttab FROM texttab_tabix INTO texttab_wa.
        IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;view_key&gt; OR
           &lt;next_spras&gt; &gt;= &lt;curr_spras&gt;. &quot;#EC PORTABLE
          texttab_tabix = sy-tabix.
          EXIT.
* Condition Redundant - Internal Message 0001699060 - ACHACHADI
*        ELSEIF &lt;next_spras&gt; &lt; &lt;curr_spras&gt;.               &quot;#EC BOOL_OK
         ELSE.
          texttab_tabix = sy-tabix + 1.
        ENDIF.
      ENDLOOP.
    ENDIF.   &quot; &lt;next_spras&gt; &gt;= &lt;curr_spras&gt; oder ex. nicht
    IF &lt;next_spras&gt; &lt;&gt; &lt;curr_spras&gt; OR
       &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;view_key&gt;.  &quot;Text ex. nicht in Sprache
      CLEAR texttab_wa.
      &lt;viewkey_in_texttab&gt; = &lt;view_key&gt;.
      &lt;texttab_struc&gt; = &lt;tmp_texttab_wa&gt;.
      INSERT texttab_wa INTO texttab INDEX texttab_tabix.
    ELSE.
      &lt;texttab_struc&gt; = &lt;tmp_texttab_wa&gt;.
      MODIFY texttab FROM texttab_wa INDEX texttab_tabix.
    ENDIF.

  ENDLOOP.                             &quot; tmp_texttab
ENDFORM.                               &quot;VIM_GET_TEXTTAB_DATA

*---------------------------------------------------------------------*
*       FORM VIM_READ_TEXTTAB_ENTRY                                   *
*---------------------------------------------------------------------*
* einzelnen Texttabellen-Eintrag für alle bisher bearbeiteten         *
* Sprachen nachlesen
* Aktueller Eintrag steht in Kopfzeile von EXTRACT
*---------------------------------------------------------------------*
FORM vim_read_texttab_entry.
  DATA: texttab_wa TYPE vim_line_ul,
        texttab_tabix LIKE sy-tabix,
        keylen TYPE i,
        offset TYPE i,
        modify_texttab(1) TYPE c,
        tmp_texttab TYPE ref to data,
        w_tmp_texttab type ref to data.
  FIELD-SYMBOLS: &lt;h_texttab_wa&gt; type x,
                 &lt;viewkey_in_texttab&gt; type x,               &quot;#EC FD_ASSGN
                 &lt;texttab_key&gt; type x,
                 &lt;texttab_fields&gt;, &lt;texttab_action&gt; type c,
                 &lt;extract_key&gt; type x,
                 &lt;tmp_texttab&gt; type standard table,
                 &lt;w_tmp_texttab&gt; type any,
                 &lt;w_tmp_texttab_x&gt; type x.

  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    ASSIGN &lt;vim_ext_mkey_beforex&gt; TO &lt;extract_key&gt;.
*    ASSIGN &lt;vim_ext_mkey_before&gt; TO &lt;extract_key&gt;.
    keylen = x_header-keylen
              - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    ASSIGN &lt;vim_xextract_key&gt; TO &lt;extract_key&gt;.
     keylen = x_header-after_keyc.
*    keylen = x_header-keylen.
  ENDIF.

  READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;extract_key&gt;           &quot;#EC WARNOK
                           BINARY SEARCH TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    texttab_tabix = sy-tabix.
  ELSE.
    EXIT.     &quot;keine Texte zum Key in anderen Sprachen erfaßt
  ENDIF.

  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; casting,
          &lt;h_texttab_wa&gt;+keylen(x_header-textkeylen) TO &lt;texttab_key&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen)
           TO &lt;texttab_fields&gt;.
*  ASSIGN texttab_wa(keylen) TO &lt;viewkey_in_texttab&gt;.
*  ASSIGN texttab_wa+keylen(x_header-textkeylen) TO &lt;texttab_key&gt;.
*  ASSIGN texttab_wa+keylen(x_header-texttablen) TO &lt;texttab_fields&gt;.
  offset = ( keylen + x_header-texttablen )
           / cl_abap_char_utilities=&gt;charsize.
*  offset = keylen + x_header-texttablen.
  ASSIGN texttab_wa+offset(1) TO &lt;texttab_action&gt;.

  create data tmp_texttab type standard table of (x_header-texttab).
  create data w_tmp_texttab type (x_header-texttab).
  assign: tmp_texttab-&gt;* to &lt;tmp_texttab&gt;,
          w_tmp_texttab-&gt;* to &lt;w_tmp_texttab&gt;,
          &lt;w_tmp_texttab&gt; to &lt;w_tmp_texttab_x&gt; casting.
  LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
*    IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_key&gt;. EXIT. ENDIF. &quot;Commented ACHACHADI 1352850
    IF &lt;texttab_action&gt; = neuer_eintrag.
      DELETE &lt;vim_texttab&gt;.
      modify_texttab = &apos;X&apos;.
    ELSEIF &lt;texttab_action&gt; &lt;&gt; original.
      refresh &lt;tmp_texttab&gt;.
*      REFRESH tmp_texttab.
      CALL FUNCTION &apos;DB_SELECT_GENERIC_TABLE&apos;
           EXPORTING
                genkey      = &lt;texttab_key&gt;
                genkey_ln   = x_header-textkeylen
                tablename   = x_header-texttab
           TABLES
                inttab      = &lt;tmp_texttab&gt;
*                inttab      = tmp_texttab
           EXCEPTIONS
                db_error    = 12
                not_found   = 04
                wrong_param = 08.
      IF sy-subrc &gt; 4. RAISE get_table_error. ENDIF.        &quot;#EC FB_RAIS_EX

      READ TABLE &lt;tmp_texttab&gt; into &lt;w_tmp_texttab&gt; INDEX 1.
*      READ TABLE tmp_texttab INDEX 1.
      IF sy-subrc = 0.
        &lt;texttab_fields&gt; = &lt;w_tmp_texttab_x&gt;(x_header-texttablen).
*        &lt;texttab_fields&gt; = tmp_texttab(x_header-texttablen).
        &lt;texttab_action&gt; = original.
        MODIFY &lt;vim_texttab&gt; FROM texttab_wa.
        modify_texttab = &apos;X&apos;.
      ELSE.                            &quot;NOT_FOUND
        DELETE &lt;vim_texttab&gt;.
        modify_texttab = &apos;X&apos;.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF modify_texttab = &apos;X&apos;.
    MODIFY vim_texttab_container INDEX vim_texttab_container_index.
    CLEAR sy-subrc.
  ELSE.
    sy-subrc = 4.
  ENDIF.
ENDFORM.                               &quot;VIM_READ_TEXTTAB_ENTRY

*---------------------------------------------------------------------*
*       FORM VIM_TEXTTAB_DB_UPD                                       *
*---------------------------------------------------------------------*
* Datenbank-Änderungen für Texttabelle (für spras &lt;&gt; SY-LANGU)        *
* Action_Flag in &lt;VIM_TEXTTAB&gt; für modif. Einträge zurücksetzen
* gelöschte Einträge aus interner Text-Tabelle löschen
*---------------------------------------------------------------------*
FORM vim_texttab_db_update.
  DATA: modified_entries TYPE i,
        texttab_modified(1) TYPE c,
        keylen TYPE i,
        offset TYPE i,
        align type f, texttab_wa TYPE vim_line_ul,                   &quot;#EC NEEDED &quot;HCG never separate
        tmp_texttab TYPE REF TO data,
        w_tmp_texttab TYPE REF TO data.
*        tmp_texttab TYPE vim_tab_ul WITH HEADER LINE.
  FIELD-SYMBOLS: &lt;tmp_texttab&gt; TYPE STANDARD TABLE,
                 &lt;w_tmp_texttab&gt; TYPE ANY,
                 &lt;h_texttab_wa&gt; TYPE x, &lt;h_texttab_fields&gt; TYPE x,
                 &lt;texttab_fields&gt; TYPE ANY, &lt;texttab_action&gt;.

  CLEAR texttab_modified.
  CHECK x_header-texttbexst &lt;&gt; space.
  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    keylen = x_header-after_keyc
             - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    keylen = x_header-after_keyc.
  ENDIF.

  CREATE DATA: tmp_texttab TYPE STANDARD TABLE OF (x_header-texttab),
               w_tmp_texttab TYPE (x_header-texttab).
  ASSIGN: tmp_texttab-&gt;* TO &lt;tmp_texttab&gt;,
          w_tmp_texttab-&gt;* TO &lt;w_tmp_texttab&gt;,
          texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen)
           TO &lt;h_texttab_fields&gt;,
          &lt;h_texttab_fields&gt; TO &lt;texttab_fields&gt;
           CASTING TYPE (x_header-texttab).
  offset = ( keylen + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
  ASSIGN texttab_wa+offset(1) TO &lt;texttab_action&gt;.

* DELETE: nur in interner Texttabelle, in DB schon bisher für alle Spr.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; EQ geloescht OR
          &lt;texttab_action&gt; EQ neuer_geloescht OR
          &lt;texttab_action&gt; EQ update_geloescht.
    DELETE &lt;vim_texttab&gt;.
    texttab_modified = &apos;X&apos;.
  ENDLOOP.                             &quot;&lt;VIM_TEXTTAB&gt;

* UPDATE
  CLEAR modified_entries. REFRESH &lt;tmp_texttab&gt;.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; EQ aendern.
    APPEND &lt;texttab_fields&gt; TO &lt;tmp_texttab&gt;.
*    tmp_texttab  = &lt;texttab_fields&gt;.
*    APPEND tmp_texttab.
    modified_entries = modified_entries + 1.
    &lt;texttab_action&gt; = original.
    MODIFY &lt;vim_texttab&gt; FROM texttab_wa.
  ENDLOOP.                             &quot;&lt;VIM_TEXTTAB&gt;
  IF modified_entries &gt; 0.
    UPDATE (x_header-texttab) FROM TABLE &lt;tmp_texttab&gt;.
    texttab_modified = &apos;X&apos;.
  ENDIF.

* INSERT
  CLEAR modified_entries. REFRESH &lt;tmp_texttab&gt;.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; EQ neuer_eintrag.
    APPEND &lt;texttab_fields&gt; TO &lt;tmp_texttab&gt;.
*    tmp_texttab = &lt;texttab_fields&gt;.
*    APPEND tmp_texttab.
    modified_entries = modified_entries + 1.
    &lt;texttab_action&gt; = original.
    MODIFY &lt;vim_texttab&gt; FROM texttab_wa.
  ENDLOOP.                             &quot;&lt;VIM_TEXTTAB&gt;
  IF modified_entries &gt; 0.
    INSERT (x_header-texttab) FROM TABLE &lt;tmp_texttab&gt;
           ACCEPTING DUPLICATE KEYS. &quot;um RABAX bei unzulässigem
    &quot;Texttab-Aufbau zu vermeiden
    texttab_modified = &apos;X&apos;.
  ENDIF.

  IF texttab_modified = &apos;X&apos;.
    MODIFY vim_texttab_container INDEX vim_texttab_container_index.
  ENDIF.
ENDFORM.                               &quot;VIM_TEXTTAB_DB_UPDATE

* Import für Texte in anderen Sprachen                      &quot;Textimp ...
*---------------------------------------------------------------------*
*       FORM VIM_READ_TEXTTAB_ALL_LANGUS                              *
*---------------------------------------------------------------------*
* Texteinträge von der DB für alle Sprachen einlesen.                 *
*---------------------------------------------------------------------*
FORM vim_read_texttab_all_langus.
  DATA: langus_selected(1) TYPE c,             &quot;#EC NEEDED
        curr_sptxt LIKE t002t-sptxt,               &quot;#EC NEEDED
        sel_langus LIKE h_t002 OCCURS 0 WITH HEADER LINE.

  CALL FUNCTION &apos;VIEW_GET_LANGUAGES&apos;
       EXPORTING
            all_without_selection = &apos;X&apos;
       IMPORTING
            languages_selected    = langus_selected
            curr_sptxt            = curr_sptxt
       TABLES
            languages             = sel_langus.
  IF x_header-frm_tl_get NE space.
    PERFORM (x_header-frm_tl_get) IN PROGRAM (x_header-fpoolname)
                                  TABLES sel_langus.
  ELSE.
    PERFORM vim_read_texttab_for_langus TABLES sel_langus USING &apos; &apos;.
  ENDIF.
ENDFORM.                               &quot;VIM_READ_TEXTTAB_ALL_LANGUS

************************************************************************
* SW Langtext
*    Absprung in Langtextpflege über Userexit vom Übersetzungsscreen aus
*    ermöglichen
*---------------------------------------------------------------------*
*       FORM VIM_CALL_LTEXT_EXIT                                      *
*---------------------------------------------------------------------*
* -&gt;  MAINT_MODE      &apos;U&apos;/&apos;R&apos; (Update/Read)
* -&gt;  EXITFORM        Name der Userexit-Routine für Langtextpflege
* &lt;-&gt; TEXTTABLE_ENTRY Zeile, für die Langtextpflege aufgerufen wurde
* &lt;-  MODIFIED        &apos;X&apos; -&gt; Zeile wurde modifiziert
*---------------------------------------------------------------------*
* Aufruf des Userexits für Langtextpflege                             *
*---------------------------------------------------------------------*
FORM vim_call_ltext_exit
             USING    maint_mode TYPE c
                      exitform TYPE vimfrmname
             CHANGING texttable_entry TYPE vimty_textmaint_record
                      modified TYPE c.
  DATA: text_wa TYPE vim_line_ul,
        textmaint_field TYPE vimty_textfield,
        pgm_name LIKE sy-repid,                        &quot;#EC NEEDED
        offset LIKE sy-fdpos.                              &quot;#EC NEEDED

  FIELD-SYMBOLS: &lt;text_wa&gt; TYPE x, &lt;text_wa_struc&gt; TYPE ANY,
                 &lt;texttabkey&gt; TYPE x, &lt;txtfld&gt; TYPE ANY.

  CLEAR modified.
  IF vim_internal_ltext_call = space.
    PERFORM (exitform) IN PROGRAM (sy-repid).
  ELSE.
    READ TABLE x_header INDEX 1.
    ASSIGN: text_wa TO &lt;text_wa&gt; CASTING,
            &lt;text_wa&gt; TO &lt;text_wa_struc&gt;
             CASTING TYPE (x_header-texttab),
            texttable_entry-keys TO &lt;texttabkey&gt; CASTING.

    PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                USING x_header
                                      texttable_entry-spras
                                      &lt;texttabkey&gt;
                             CHANGING &lt;text_wa&gt;.
*    PERFORM VIM_FILL_TEXTTAB_KEY USING TEXTTABLE_ENTRY-KEYS
*                                       TEXTTABLE_ENTRY-SPRAS
*                                       X_HEADER-SPRASFDPOS
*                              CHANGING TEXT_WA.
    LOOP AT texttable_entry-texttab INTO textmaint_field.
      READ TABLE x_namtab INDEX textmaint_field-namtab_idx.
*      offset = x_namtab-texttabpos.
      IF x_namtab-lowercase = space.
        TRANSLATE textmaint_field-text TO UPPER CASE.
      ENDIF.
      IF x_namtab-txttabfldn = space.
* tab + texttab
        ASSIGN COMPONENT x_namtab-bastabfld
         OF STRUCTURE &lt;text_wa_struc&gt; TO &lt;txtfld&gt;.
      ELSE.
* view
        ASSIGN COMPONENT x_namtab-txttabfldn
         OF STRUCTURE &lt;text_wa_struc&gt; TO &lt;txtfld&gt;.
      ENDIF.
      &lt;txtfld&gt; = textmaint_field-text.
*      text_wa+offset(x_namtab-flength) =
*         textmaint_field-text(x_namtab-flength).
    ENDLOOP.
    PERFORM (exitform) IN PROGRAM (x_header-fpoolname)
                          USING maint_mode
                          CHANGING text_wa modified.
    IF modified = &apos;X&apos;.
      IF maint_mode = &apos;U&apos;.
        LOOP AT texttable_entry-texttab INTO textmaint_field.
          READ TABLE x_namtab INDEX textmaint_field-namtab_idx.
          ASSIGN COMPONENT x_namtab-txttabfldn
           OF STRUCTURE &lt;text_wa_struc&gt; TO &lt;txtfld&gt;.
          textmaint_field-text = &lt;txtfld&gt;.
*          offset = x_namtab-texttabpos.
*          textmaint_field-text(x_namtab-flength) =
*            text_wa+offset(x_namtab-flength).
          MODIFY texttable_entry-texttab FROM textmaint_field.
        ENDLOOP.
        texttable_entry-action = &apos;X&apos;.
      ELSE.
        CLEAR modified.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; VIM_CALL_LTEXT_EXIT</include_source>
   </include>
   <include NAME="LSVIMFTX" VARCL="X" SUBC="I" APPL="S" LEVL="30A" RMAND="000" RLOAD="D">
    <include_source>*-------------------------------------------------------------------
***INCLUDE LSVIMFTX .
*-------------------------------------------------------------------
*&amp;--------------------------------------------------------------------*
*&amp;      Form  TABLE_CALL_FUNCTION                                     *
*---------------------------------------------------------------------*
* call function TABLEPROC with proper parameters
*---------------------------------------------------------------------*
* TCF_FCODE    ---&gt; current function code                             *
* TCF_TABTYPE  ---&gt; type of int. table: SHORT, MIDDLE, LONG, VERY_LONG*
* TCF_UPD_fLAG &lt;--- flag: update required                             *
*---------------------------------------------------------------------*
FORM table_call_function TABLES dba_sellist dpl_sellist
                                x_header STRUCTURE vimdesc
                                x_namtab excl_cua_funct
                         USING value(tcf_fcode) value(tcf_tabtype)
                               tcf_upd_flag.

  DATA: function_name LIKE tfdir-funcname VALUE &apos;TABLEPROC_&apos;,
        prefix_len TYPE i VALUE &apos;10&apos;.                       &quot;#EC STR_NUM

  READ TABLE x_header INDEX 1.
  MOVE x_header-area TO function_name+prefix_len.
  IF function_name CA forbidden_func_name_chars.
    PERFORM replace_forbidden_chars USING forbidden_func_name_chars
                                          function_name.
  ENDIF.
  CASE tcf_tabtype.
    WHEN &apos;ULTRA_SHORT&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_us
          total                    = total_us
        EXCEPTIONS                                          &quot;#EC FB_RC
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;VERY_SHORT&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_vs
          total                    = total_vs
        EXCEPTIONS                                    &quot;#EC FB_RC
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;SHORT&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_s
          total                    = total_s
        EXCEPTIONS                                        &quot;#EC FB_RC
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;MIDDLE&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_m
          total                    = total_m
        EXCEPTIONS                                          &quot;#EC FB_RC
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;LONG&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_l
          total                    = total_l
        EXCEPTIONS                                          &quot;#EC FB_RC
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;VERY_LONG&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_vl
          total                    = total_vl
        EXCEPTIONS                                            &quot;#EC FB_RC
          missing_corr_number      = 01
          saving_correction_failed = 03.
    WHEN &apos;ULTRA_LONG&apos;.
      CALL FUNCTION function_name
        EXPORTING
          fcode                    = tcf_fcode
          view_action              = maint_mode
          view_name                = x_header-viewname
          corr_number              = corr_nbr
        IMPORTING
          ucomm                    = function
          update_required          = tcf_upd_flag
        TABLES
          dba_sellist              = dba_sellist
          dpl_sellist              = dpl_sellist
          excl_cua_funct           = excl_cua_funct
          x_header                 = x_header
          x_namtab                 = x_namtab
          corr_keytab              = e071k_tab
          extract                  = extract_ul
          total                    = total_ul
        EXCEPTIONS                                        &quot;#EC FB_RC
          missing_corr_number      = 01
          saving_correction_failed = 03.
  ENDCASE.
ENDFORM.                               &quot; TABLE_CALL_FUNCTION

*&amp;--------------------------------------------------------------------*
*&amp;      Form  TABLE_GET_DATA                                          *
*---------------------------------------------------------------------*
* get data from database
*---------------------------------------------------------------------*
FORM table_get_data.
  CONSTANTS maxsellines TYPE i VALUE 500.
  DATA: tgd_sellist LIKE vimsellist OCCURS 10, tgd_sel LIKE vimsellist,
        tgd_sellangu LIKE vimsellist,
        short_sellist LIKE vimsellist OCCURS 10,
        short_sel LIKE vimsellist,
        tgd_ind TYPE i, tgd_field LIKE vimnamtab-viewfield,  &quot;#EC NEEDED
        selnumber TYPE i, selindex TYPE i, selcut TYPE i,
        selpieces TYPE i.
  FIELD-SYMBOLS: &lt;text_key&gt;.                                &quot;#EC NEEDED
  DATA: primtab TYPE REF TO data, texttab TYPE REF TO data,
        w_texttab_save TYPE REF TO data, w_texttab TYPE REF TO data,
        text_keyflds TYPE vim_flds_tab_type.
  DATA: append_flag(1) TYPE c.

  FIELD-SYMBOLS: &lt;primtab&gt; TYPE STANDARD TABLE,
                 &lt;texttab&gt; TYPE SORTED TABLE, &lt;w_texttab&gt; TYPE ANY,
                 &lt;w_texttab_save&gt; TYPE ANY, &lt;textline_x&gt; TYPE x.

  REFRESH total. CLEAR total.
  IF x_header-selection NE space.
    DESCRIBE TABLE dba_sellist LINES selnumber.
    IF selnumber &gt; maxsellines.  &quot;fragmentation of too large sellists
      CLEAR selpieces.
      CLEAR selindex.
      CREATE DATA primtab TYPE STANDARD TABLE OF (x_header-maintview).
      ASSIGN primtab-&gt;* TO &lt;primtab&gt;.
      WHILE selindex &lt; selnumber.
        selpieces = selpieces + maxsellines.
        REFRESH short_sellist.
        CLEAR selcut.
        WHILE selcut EQ 0 AND selindex &lt; selnumber.
          selindex = selindex + 1.
          READ TABLE dba_sellist INTO short_sel INDEX selindex.
          APPEND short_sel TO short_sellist.
          IF selindex &gt; selpieces AND short_sel-and_or NE &apos;AND&apos;.
            selcut = 1.
          ENDIF.
        ENDWHILE.
        CLEAR short_sel-and_or.      &quot;last line without logic operation
        MODIFY short_sellist FROM short_sel INDEX selindex.
        CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
           EXPORTING
                tablename               = x_header-maintview
*           ONLY_CNDS_FOR_KEYFLDS   = &apos;X&apos; &quot;use default SPACE
           TABLES
                sellist                 = short_sellist
                wheretab                = vim_wheretab
                x_namtab                = x_namtab
           EXCEPTIONS                                      &quot;#EC FB_RC
                no_conditions_for_table = 01.
*       read data from database with morer wheretabs...................*
        SELECT * FROM (x_header-maintview) APPENDING TABLE &lt;primtab&gt; &quot;Note-1859065
                                          WHERE (vim_wheretab).
        CLEAR selcut.
      ENDWHILE.
    ELSE.                                  &quot;selnumber &gt; maxsellines
      CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
           EXPORTING
                tablename               = x_header-maintview
*         ONLY_CNDS_FOR_KEYFLDS   = &apos;X&apos; &quot;use default SPACE
           TABLES
                sellist                 = dba_sellist
                wheretab                = vim_wheretab
                x_namtab                = x_namtab
           EXCEPTIONS                                       &quot;#EC FB_RC
                no_conditions_for_table = 01.
*   read data from database with one wheretab..........................*
      CREATE DATA primtab TYPE STANDARD TABLE OF (x_header-maintview).&quot;UCb
      ASSIGN primtab-&gt;* TO &lt;primtab&gt;.
      SELECT * FROM (x_header-maintview) INTO TABLE &lt;primtab&gt;   &quot;Note-1859065
                                          WHERE (vim_wheretab).
    ENDIF.                                   &quot;if selnumber &gt; maxsellines
  ELSE.                                  &quot;if x_header-selection NE space
    REFRESH vim_wheretab.
*   read data from database without wheretab...........................*
    CREATE DATA primtab TYPE STANDARD TABLE OF (x_header-maintview).&quot;UCb
    ASSIGN primtab-&gt;* TO &lt;primtab&gt;.
    SELECT * FROM (x_header-maintview) INTO TABLE &lt;primtab&gt;.
  ENDIF.                                &quot;if x_header-selection NE space
  IF x_header-texttbexst EQ space.
* no texttable
    LOOP AT &lt;primtab&gt; INTO &lt;vim_total_struc&gt;.
      APPEND total.
    ENDLOOP.                                                &quot;UCe
    SORT total BY &lt;vim_xtotal_key&gt;. &lt;status&gt;-alr_sorted = &apos;R&apos;.
    IF x_header-selection EQ space AND x_header-delmdtflag NE space.
* time dependence
      PERFORM build_mainkey_tab_0.
    ENDIF.
    LOOP AT total.
      CLEAR: &lt;action&gt;, &lt;mark&gt;.
      MODIFY total.
      IF x_header-selection EQ space AND x_header-delmdtflag NE space.
        PERFORM build_mainkey_tab_1.
      ENDIF.
    ENDLOOP.
    IF x_header-selection EQ space AND x_header-delmdtflag NE space.
      PERFORM build_mainkey_tab_2.
    ENDIF.
  ELSE.
* texttable exists
    PERFORM vim_get_text_keyflds USING x_header-texttab
                                 CHANGING text_keyflds.
    CREATE DATA texttab TYPE SORTED TABLE OF (x_header-texttab)
     WITH UNIQUE KEY (text_keyflds).                        &quot;UCb
    ASSIGN texttab-&gt;* TO &lt;texttab&gt;.
    IF x_header-selection NE space.
* get selection for texttable
*      READ TABLE dba_sellist INTO dpl_sellist INDEX 1.
      DESCRIBE TABLE dba_sellist LINES selnumber.
      selindex = 0.
      WHILE selindex &lt; selnumber.
        selindex = selindex + 1.
        READ TABLE dba_sellist INTO tgd_sel INDEX selindex.
        READ TABLE x_namtab WITH KEY
          viewfield = tgd_sel-viewfield texttabfld = space. &quot;#EC *
        CHECK x_namtab-keyflag = &apos;X&apos;.        &quot; key fields for texttab only
        tgd_sel-viewfield = x_namtab-txttabfldn.
        READ TABLE x_namtab WITH KEY
          viewfield = tgd_sel-viewfield texttabfld = &apos;X&apos;.
        tgd_sel-tabix = sy-tabix.
        CLEAR append_flag.
        IF sy-subrc EQ 0.&quot;Otherwise keyfld in tab not in txttab HW696310
          append_flag = &apos;X&apos;.
        ENDIF.
        IF tgd_sel-and_or NE &apos;AND&apos; OR selindex = 1.       &quot;Langufield
          READ TABLE x_namtab WITH KEY primtabkey = 0 keyflag = &apos;X&apos;.&quot;#EC WARNOK
          tgd_sellangu-viewfield = x_namtab-viewfield.
          tgd_sellangu-tabix     = sy-tabix.
          tgd_sellangu-operator = &apos;EQ&apos;.
          tgd_sellangu-value = sy-langu.
          tgd_sellangu-and_or = &apos;AND&apos;.
          IF tgd_sellangu-value EQ space.
            tgd_sellangu-initial = &apos;X&apos;.
          ENDIF.
          tgd_sellangu-cond_kind = dpl_sellist-cond_kind.
          CLEAR tgd_sellangu-converted.
          APPEND tgd_sellangu TO tgd_sellist.
        ENDIF.
        IF append_flag EQ &apos;X&apos;.
          APPEND tgd_sel TO tgd_sellist.
        ENDIF.
*      Did not work for sellist to describe more than one dataset in
*      transport request                                          &quot;HCG
*      LOOP AT x_namtab WHERE keyflag NE space    &quot;fill sellist for
*                         AND texttabfld NE space. &quot;texttab
*        tgd_field = x_namtab-viewfield.
*        tgd_ind   = sy-tabix.
*        IF x_namtab-primtabkey EQ 0.   &quot;langufield
*          tgd_sel-viewfield = tgd_field.
*          tgd_sel-tabix     = tgd_ind.
*          tgd_sel-operator = &apos;EQ&apos;.
*          tgd_sel-value = sy-langu.
*          tgd_sel-and_or = &apos;AND&apos;.
*          IF tgd_sel-value EQ space.
*            tgd_sel-initial = &apos;X&apos;.
*          ENDIF.
*          tgd_sel-cond_kind = dpl_sellist-cond_kind.
*          clear tgd_sel-converted.
*          APPEND tgd_sel TO tgd_sellist.
*        ELSE.
*          READ TABLE x_namtab INDEX x_namtab-primtabkey.
*          LOOP AT dba_sellist WHERE viewfield EQ x_namtab-viewfield.
*            tgd_sel = dba_sellist.
*            tgd_sel-viewfield = tgd_field.
*            tgd_sel-tabix     = tgd_ind.
*            IF tgd_sel-and_or EQ space.
*              tgd_sel-and_or = &apos;AND&apos;.
*            ENDIF.
*            APPEND tgd_sel TO tgd_sellist.
*          ENDLOOP.
*        ENDIF.
*      ENDLOOP.
      ENDWHILE.
      DESCRIBE TABLE tgd_sellist.
      READ TABLE tgd_sellist INDEX sy-tfill INTO tgd_sel.
      IF tgd_sel-and_or NE space.
        CLEAR tgd_sel-and_or.
        MODIFY tgd_sellist INDEX sy-tfill FROM tgd_sel.
      ENDIF.
    ELSE.
* no selection for primary table: fill selection with langu-field only
      LOOP AT x_namtab WHERE keyflag NE space    &quot;fill sellist with
                         AND texttabfld NE space  &quot;language condition
                         AND primtabkey EQ 0.
        tgd_sel-viewfield = x_namtab-viewfield.
        tgd_sel-tabix     = sy-tabix.
        tgd_sel-operator = &apos;EQ&apos;.
        tgd_sel-value = sy-langu.
        tgd_sel-and_or = space.
        IF tgd_sel-value EQ space.
          tgd_sel-initial = &apos;X&apos;.
        ENDIF.
        APPEND tgd_sel TO tgd_sellist.
        EXIT.
      ENDLOOP.
    ENDIF.
*    CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
*      EXPORTING
*        tablename               = x_header-texttab
*        only_cnds_for_keyflds   = &apos;X&apos;
*      TABLES
*        sellist                 = tgd_sellist
*        wheretab                = vim_wheretab
*        x_namtab                = x_namtab
*      EXCEPTIONS
*        no_conditions_for_table = 01.
** read texttable from database
*    SELECT * FROM (x_header-texttab) INTO TABLE &lt;texttab&gt;
*                                      WHERE (vim_wheretab).
    DESCRIBE TABLE tgd_sellist LINES selnumber.
    IF selnumber &gt; maxsellines.  &quot;fragmentation of too large sellists
      CLEAR selpieces.
      CLEAR selindex.
      WHILE selindex &lt; selnumber.
        selpieces = selpieces + maxsellines.
        REFRESH short_sellist.
        CLEAR selcut.
        WHILE selcut EQ 0 AND selindex &lt; selnumber.
          selindex = selindex + 1.
          READ TABLE tgd_sellist INTO short_sel INDEX selindex.
          APPEND short_sel TO short_sellist.
          IF selindex &gt; selpieces AND short_sel-and_or NE &apos;AND&apos;.
            selcut = 1.
          ENDIF.
        ENDWHILE.
        CLEAR short_sel-and_or.      &quot;last line without logic operation
        MODIFY short_sellist FROM short_sel INDEX selindex.
        CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
          EXPORTING
            tablename               = x_header-texttab
            only_cnds_for_keyflds   = &apos;X&apos;
          TABLES
            sellist                 = short_sellist
            wheretab                = vim_wheretab
            x_namtab                = x_namtab
          EXCEPTIONS                                        &quot;#EC FB_RC
            no_conditions_for_table = 01.
*       read data from database with morer wheretabs...................*
        SELECT * FROM (x_header-texttab) APPENDING TABLE &lt;texttab&gt;   &quot;Note-1859065
                                          WHERE (vim_wheretab).
        CLEAR selcut.
      ENDWHILE.
    ELSE.                                  &quot;selnumber &gt; maxsellines
      CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
        EXPORTING
          tablename               = x_header-texttab
          only_cnds_for_keyflds   = &apos;X&apos;
        TABLES
          sellist                 = tgd_sellist
          wheretab                = vim_wheretab
          x_namtab                = x_namtab
        EXCEPTIONS                                          &quot;#EC FB_RC
          no_conditions_for_table = 01.
*   read data from database with one wheretab..........................*
      SELECT * FROM (x_header-texttab) INTO TABLE &lt;texttab&gt;  &quot;Note-1859065
                                        WHERE (vim_wheretab).
    ENDIF.                                   &quot;if selnumber &gt; maxsellines
    IF x_header-selection EQ space AND x_header-delmdtflag NE space.
      PERFORM build_mainkey_tab_0.
    ENDIF.
    CREATE DATA w_texttab_save TYPE (x_header-texttab).
    CREATE DATA w_texttab TYPE (x_header-texttab).
    ASSIGN: w_texttab-&gt;* TO &lt;w_texttab&gt;,
            w_texttab_save-&gt;* TO &lt;w_texttab_save&gt;,
            &lt;w_texttab_save&gt; TO &lt;textline_x&gt; CASTING.
    LOOP AT &lt;primtab&gt; INTO &lt;vim_total_struc&gt;.
*       hier aufbauen schlüssel texttabelle in feld text_key
      CLEAR &lt;w_texttab&gt;.
      PERFORM fill_texttab_key_uc USING &lt;vim_total_struc&gt;
                                  CHANGING &lt;w_texttab&gt;.
      IF &lt;w_texttab&gt; NE &lt;w_texttab_save&gt;.
        READ TABLE &lt;texttab&gt; INTO &lt;w_texttab_save&gt;
         FROM &lt;w_texttab&gt;.
        IF sy-subrc = 0.
*          MOVE &lt;w_texttab_save&gt; TO &lt;w_textline&gt;.
*          MOVE textline(x_header-texttablen) TO &lt;total_text&gt;.
        ELSE.
          MOVE &lt;text_initial&gt; TO &lt;w_texttab_save&gt;.
        ENDIF.
*      ELSE.
*        MOVE &lt;w_texttab_save&gt; TO &lt;w_textline&gt;.
*        MOVE textline(x_header-texttablen) TO &lt;total_text&gt;.
      ENDIF.
      MOVE &lt;textline_x&gt; TO &lt;vim_xtotal_text&gt;.
      CLEAR: &lt;action&gt;, &lt;mark&gt;, &lt;action_text&gt;.
      APPEND total.
      IF x_header-selection EQ space AND x_header-delmdtflag NE space.
        PERFORM build_mainkey_tab_1.
      ENDIF.
    ENDLOOP.
    SORT total BY &lt;vim_xtotal_key&gt;. &lt;status&gt;-alr_sorted = &apos;R&apos;.
    IF x_header-selection EQ space AND x_header-delmdtflag NE space.
      PERFORM build_mainkey_tab_2.
    ENDIF.
  ENDIF.
*.check dynamic selectoptions (not in DDIC)...........................*
  IF x_header-selection NE space.
    PERFORM check_dynamic_select_options.
  ENDIF.
ENDFORM.                               &quot; TABLE_GET_DATA

*&amp;--------------------------------------------------------------------*
*&amp;      Form  TABLE_DB_UPD                                            *
*---------------------------------------------------------------------*
* process data base updates/inserts/deletes
*---------------------------------------------------------------------*
FORM table_db_upd.
  DATA: modified_entries TYPE i, prt_frky_entries TYPE i, rc TYPE i,
        h_ix TYPE i,
        primtab_mod TYPE REF TO data,
        primtab_mod_wa TYPE REF TO data,
        texttab_mod TYPE REF TO data,
        w_texttab_mod TYPE REF TO data,
        e071_loctab TYPE vim_ko200_tab_type.   &quot;#EC NEEDED
  FIELD-SYMBOLS: &lt;mod_elem_tab&gt; TYPE STANDARD TABLE,
                 &lt;h_keyx&gt; TYPE x,                           &quot;#EC NEEDED
                 &lt;mod_elem_wa&gt; TYPE ANY,
                 &lt;texttab&gt; TYPE STANDARD TABLE, &lt;w_texttab&gt; TYPE ANY,
                 &lt;textline_x&gt; TYPE x.

* first of all: delete requests
  CREATE DATA primtab_mod TYPE TABLE OF (x_header-maintview).
  CREATE DATA primtab_mod_wa TYPE (x_header-maintview).
  ASSIGN: primtab_mod-&gt;* TO &lt;mod_elem_tab&gt;,
          primtab_mod_wa-&gt;* TO &lt;mod_elem_wa&gt;.
  LOOP AT total.
    CHECK ( &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ update_geloescht OR
            &lt;action&gt; EQ neuer_geloescht ).
    IF &lt;action&gt; EQ neuer_geloescht.
      IF status-delete EQ geloescht.
        READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.       &quot;#EC WARNOK
        IF sy-subrc EQ 0.
          DELETE extract INDEX sy-tabix.
        ENDIF.
      ENDIF.
      DELETE total.
    ELSE.
      APPEND &lt;vim_total_struc&gt; TO &lt;mod_elem_tab&gt;.
      ADD 1 TO modified_entries.
      IF x_header-texttbexst EQ space. &quot;no texttab
        IF status-delete EQ geloescht.
          READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.     &quot;#EC WARNOK
          IF sy-subrc EQ 0.
            DELETE extract INDEX sy-tabix.
          ENDIF.
        ENDIF.
        DELETE total.
      ENDIF.
    ENDIF.
  ENDLOOP.
  IF modified_entries NE 0.
    DELETE (x_header-maintview) FROM TABLE &lt;mod_elem_tab&gt;.
  ENDIF.
  IF x_header-texttbexst NE space.
    CLEAR modified_entries.
    CREATE DATA texttab_mod TYPE STANDARD TABLE OF (x_header-texttab).
    CREATE DATA w_texttab_mod TYPE (x_header-texttab).
    ASSIGN: texttab_mod-&gt;* TO &lt;texttab&gt;,
            w_texttab_mod-&gt;* TO &lt;w_texttab&gt;,
            &lt;w_texttab&gt; TO &lt;textline_x&gt; CASTING.
* delete texts for all deleted entities
    LOOP AT &lt;mod_elem_tab&gt; INTO &lt;table1_wa&gt;.
      READ TABLE total WITH KEY &lt;f1_wax&gt; BINARY SEARCH.     &quot;#EC WARNOK
      h_ix = sy-tabix.
      IF x_header-ptfrkyexst NE space.
* partial foreign key relation:
* Are there still any primary table entries?
        PERFORM create_wheretab_new USING x_namtab[]
                                          &lt;vim_total_struc&gt;
                                          &lt;vim_tot_txt_struc&gt;
                                          x_header-maintview
                                          &apos;X&apos; rc.
        IF rc NE 0.                    &quot;something seems to be wrong
          prt_frky_entries = 1.        &quot;don&apos;t delete
        ELSE.
          SELECT COUNT(*) FROM (x_header-maintview) UP TO 1 ROWS
                          WHERE (vim_wheretab).
          prt_frky_entries = sy-dbcnt.
        ENDIF.
      ELSE.
        CLEAR prt_frky_entries.
      ENDIF.
      IF prt_frky_entries EQ 0.
* No, there aren&apos;t.
*        MODIFY mod_elem_tab FROM &lt;total_text&gt;.
        MOVE &lt;vim_xtotal_text&gt; TO &lt;textline_x&gt;.
        APPEND &lt;w_texttab&gt; TO &lt;texttab&gt;.
        ADD 1 TO modified_entries.
      ENDIF.
      IF status-delete EQ geloescht.
        READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;        &quot;#EC WARNOK
         TRANSPORTING NO FIELDS.
        IF sy-subrc EQ 0.
          DELETE extract INDEX sy-tabix.
        ENDIF.
      ENDIF.
      DELETE total INDEX h_ix.
    ENDLOOP.
    IF modified_entries NE 0.
* delete text entries in all languages
      DO modified_entries TIMES.
*        READ TABLE mod_elem_tab INDEX 1.
*        DELETE mod_elem_tab INDEX 1.
*        READ TABLE &lt;texttab&gt; INTO &lt;w_texttab&gt; INDEX 1.
        READ TABLE &lt;texttab&gt; INTO &lt;vim_tot_txt_struc&gt; INDEX 1.&quot;IG 862951
        DELETE &lt;texttab&gt; INDEX 1.                           &quot;IG 862951
*        PERFORM create_wheretab TABLES x_namtab
*                                USING mod_elem_tab
*                                      x_header-texttab space rc.

        PERFORM create_wheretab_new USING x_namtab[]
                                          &lt;vim_total_struc&gt;
                                          &lt;vim_tot_txt_struc&gt;
                                          x_header-texttab
                                          space
                                          rc.
        SELECT * FROM (x_header-texttab) APPENDING TABLE &lt;texttab&gt; &quot;Note-1859065
                                         WHERE (vim_wheretab).
      ENDDO.
*      DELETE (x_header-texttab) FROM TABLE mod_elem_tab.
      DELETE (x_header-texttab) FROM TABLE &lt;texttab&gt;.
    ENDIF.
  ENDIF.
* now update requests
  REFRESH: &lt;mod_elem_tab&gt;.
  CLEAR modified_entries.
  LOOP AT total.
    CHECK &lt;action&gt; EQ aendern.
*    MOVE: total TO &lt;table1&gt;,
*          &lt;table1&gt; TO mod_elem_tab.
*    APPEND mod_elem_tab.
    APPEND &lt;vim_total_struc&gt; TO &lt;mod_elem_tab&gt;.
    ADD 1 TO modified_entries.
    IF x_header-texttbexst EQ space OR
       &lt;action_text&gt; EQ original.
      READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.         &quot;#EC WARNOK
      &lt;action&gt; = original.
      IF sy-subrc = 0.
        &lt;xact&gt; = original.
        MODIFY extract INDEX sy-tabix.
      ENDIF.
      MODIFY total.
    ENDIF.
  ENDLOOP.
  IF modified_entries NE 0.
*------------------*--------------------------------------------
* Changes done on 07.08/2009 to handle Checkman errors. DUTTAN.
*--------------------------------------------------------------
* Start - Handling exceptions for Unique Indexes.
*    TRY.
        UPDATE (x_header-maintview) FROM TABLE &lt;mod_elem_tab&gt;.
*      CATCH cx_sy_open_sql_db.
*        MESSAGE i862(sv).
*    ENDTRY.
* End - handling.
*---------------------------------------------------------------
* End of  Change. 07/08/2009 DUTTAN.
*---------------------------------------------------------------
  ENDIF.
  IF x_header-texttbexst NE space.
    REFRESH &lt;texttab&gt;.
    CLEAR modified_entries.
    LOOP AT total.
      CHECK &lt;action_text&gt; EQ aendern.
*      MOVE: &lt;total_text&gt; TO mod_elem_tab.
*      APPEND mod_elem_tab.
      MOVE &lt;vim_xtotal_text&gt; TO &lt;textline_x&gt;.
      APPEND &lt;w_texttab&gt; TO &lt;texttab&gt;.
      ADD 1 TO modified_entries.
      READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.         &quot;#EC WARNOK
      IF &lt;action&gt; EQ aendern.
        &lt;action&gt; = original. &lt;xact&gt; = original.
      ENDIF.
      &lt;action_text&gt; = original. &lt;xact_text&gt; = original.
      IF sy-subrc = 0.
        MODIFY extract INDEX sy-tabix.
      ENDIF.
      MODIFY total.
    ENDLOOP.
    IF modified_entries NE 0.
*      UPDATE (x_header-texttab) FROM TABLE mod_elem_tab.
      UPDATE (x_header-texttab) FROM TABLE &lt;texttab&gt;.
    ENDIF.
  ENDIF.
* last not least: insert requests
  REFRESH: &lt;mod_elem_tab&gt;. CLEAR modified_entries.
  LOOP AT total.
    CHECK &lt;action&gt; EQ neuer_eintrag.
*    MOVE: total TO &lt;table1&gt;,
*          &lt;table1&gt; TO mod_elem_tab.
*    APPEND mod_elem_tab.
    APPEND &lt;vim_total_struc&gt; TO &lt;mod_elem_tab&gt;.
    ADD 1 TO modified_entries.
    IF x_header-texttbexst EQ space OR
       &lt;action_text&gt; EQ original.
      READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.         &quot;#EC WARNOK
      &lt;action&gt; = original.
      IF sy-subrc = 0.
        &lt;xact&gt; = original.
        MODIFY extract INDEX sy-tabix.
      ENDIF.
      MODIFY total.
    ENDIF.
  ENDLOOP.
  IF modified_entries NE 0.
*------------------*--------------------------------------------
* Changes done on 07.08/2009 to handle Checkman errors. DUTTAN.
*--------------------------------------------------------------
* Start - Handling exceptions for Unique Indexes.
*    TRY.
        INSERT (x_header-maintview) FROM TABLE &lt;mod_elem_tab&gt;.
*      CATCH cx_sy_open_sql_db.
*        MESSAGE i862(sv).
*    ENDTRY.
* End - Handling.
*---------------------------------------------------------------
* End of  Change. 07/08/2009 DUTTAN.
*---------------------------------------------------------------
  ENDIF.
  IF x_header-texttbexst NE space.
    REFRESH &lt;texttab&gt;.
    CLEAR modified_entries.
    LOOP AT total.
      CHECK &lt;action_text&gt; EQ neuer_eintrag.
*      MOVE: &lt;total_text&gt; TO mod_elem_tab.
*      APPEND mod_elem_tab.
      MOVE &lt;vim_xtotal_text&gt; TO &lt;textline_x&gt;.
      APPEND &lt;w_texttab&gt; TO &lt;texttab&gt;.
      ADD 1 TO modified_entries.
      READ TABLE extract WITH KEY &lt;vim_xtotal_key&gt;.         &quot;#EC WARNOK
      IF &lt;action&gt; EQ neuer_eintrag.
        &lt;action&gt; = original. &lt;xact&gt; = original.
      ENDIF.
      &lt;action_text&gt; = original. &lt;xact_text&gt; = original.
      IF sy-subrc = 0.
        MODIFY extract INDEX sy-tabix.
      ENDIF.
      MODIFY total.
    ENDLOOP.
    IF modified_entries NE 0.
*      INSERT (x_header-texttab) FROM TABLE mod_elem_tab
*                                ACCEPTING DUPLICATE KEYS.
      INSERT (x_header-texttab) FROM TABLE &lt;texttab&gt;
                                ACCEPTING DUPLICATE KEYS.
      IF sy-subrc NE 0. &quot;duplicate keys -&gt; process additional update
*        UPDATE (x_header-texttab) FROM TABLE mod_elem_tab.
        UPDATE (x_header-texttab) FROM TABLE &lt;texttab&gt;.
      ENDIF.
    ENDIF.
  ENDIF.
*    Call synchronizer
*  REFRESH e071_loctab.
*  APPEND e071 TO e071_loctab.
*  PERFORM vim_synchronizer_call
*                USING e071_loctab[]
*                      corr_keytab[]
*                      &apos;X&apos;.

  CLEAR: &lt;status&gt;-upd_flag,
         &lt;status&gt;-upd_checkd.
  MESSAGE s018(sv).
ENDFORM.                               &quot; TABLE_DB_UPD

*&amp;--------------------------------------------------------------------*
*&amp;      Form  TABLE_READ_SINGLE_ENTRY                                 *
*---------------------------------------------------------------------*
* read single entry from data base
*---------------------------------------------------------------------*
FORM table_read_single_entry.
  DATA: tab TYPE REF TO data, texttab TYPE REF TO data,
        textline TYPE REF TO data.

  FIELD-SYMBOLS: &lt;tab&gt; TYPE STANDARD TABLE,
                 &lt;texttab&gt; TYPE STANDARD TABLE,
                 &lt;textline&gt; TYPE ANY, &lt;textline_x&gt; TYPE x.

  CREATE DATA tab TYPE STANDARD TABLE OF (x_header-maintview).
  ASSIGN tab-&gt;* TO &lt;tab&gt;.
*  REFRESH mod_elem_tab.
*  MOVE &lt;f1&gt; TO gen_key.
  CALL FUNCTION &apos;DB_SELECT_GENERIC_TABLE&apos;
       EXPORTING
            tablename   = x_header-maintview
*     genkey      = gen_key
            genkey      = &lt;f1_x&gt;
            genkey_ln   = x_header-keylen
       TABLES
*     inttab      = mod_elem_tab
            inttab      = &lt;tab&gt;
       EXCEPTIONS
            db_error    = 12
            not_found   = 04
            wrong_param = 08.
  IF sy-subrc &gt; 4. RAISE get_table_error. ENDIF.
*  READ TABLE mod_elem_tab INDEX 1.
  READ TABLE &lt;tab&gt; INTO &lt;table1&gt; INDEX 1.
  IF sy-subrc &lt;&gt; 0.
    MOVE &lt;initial&gt; TO &lt;table1&gt;.
*  ELSE.
*    &lt;table1&gt; = mod_elem_tab.
  ENDIF.
  IF x_header-texttbexst NE space.
* read text table
    CREATE DATA texttab TYPE STANDARD TABLE OF (x_header-texttab).
    CREATE DATA textline TYPE (x_header-texttab).
    ASSIGN: texttab-&gt;* TO &lt;texttab&gt;,
            textline-&gt;* TO &lt;textline&gt;,
            &lt;textline&gt; TO &lt;textline_x&gt; CASTING.
*    REFRESH mod_elem_tab.
*    CLEAR gen_key.
*    WRITE &lt;table1_text&gt; TO gen_key(x_header-textkeylen).
    CALL FUNCTION &apos;DB_SELECT_GENERIC_TABLE&apos;
         EXPORTING
              tablename   = x_header-texttab
*       genkey      = gen_key
              genkey      = &lt;textkey_x&gt;
              genkey_ln   = x_header-textkeylen
         TABLES
*       inttab      = mod_elem_tab
              inttab      = &lt;texttab&gt;
         EXCEPTIONS
              db_error    = 12
              not_found   = 04
              wrong_param = 08.
    IF sy-subrc &gt; 4. RAISE get_table_error. ENDIF.
*    READ TABLE mod_elem_tab INDEX 1.
    READ TABLE &lt;texttab&gt; INTO &lt;table1_text&gt; INDEX 1.
    IF sy-subrc &lt;&gt; 0.
      MOVE &lt;text_initial&gt; TO &lt;table1_text&gt;.
      CLEAR sy-subrc.
*    ELSE.
*      &lt;table1_text&gt; = mod_elem_tab.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; TABLE_READ_SINGLE_ENTRY

*&amp;--------------------------------------------------------------------*
*&amp;      Form  SET_TXT_UPDATE_FLAG                                     *
*---------------------------------------------------------------------*
* note, if texttab entry was modified on screen
*---------------------------------------------------------------------*
FORM set_txt_update_flag.

  DATA: lb_als TYPE REF TO IF_EX_VIM_ALS_BADI.

  IF &lt;textkey_x&gt; EQ &lt;initial_textkey_x&gt; OR &quot;textkey not filled yet OR
     status-action EQ kopieren OR      &quot;copy mode              OR
     neuer EQ &apos;J&apos; OR &lt;xact&gt; EQ leer OR &quot;real new entry         OR
     ( temporal_delimitation_happened EQ &apos;X&apos; AND &quot;temporal delimitation
        x_header-delmdtflag EQ &apos;B&apos; ).
    PERFORM fill_texttab_key_uc USING &lt;table1&gt; &lt;table1_text&gt;.&quot;#EC ..
  ENDIF.
  IF status-action EQ hinzufuegen.
    &lt;status&gt;-upd_flag = &apos;X&apos;.           &quot;always both tables must be added
  ELSE.
    TRANSLATE &lt;status&gt;-upd_flag USING &apos; TEX&apos;.
  ENDIF.

  CALL METHOD cl_exithandler=&gt;get_instance
    EXPORTING
      null_instance_accepted        = seex_false
      exit_name                     = &apos;VIM_ALS_BADI&apos;
    CHANGING
      instance                      = lb_als
    EXCEPTIONS
      no_reference                  = 1
      no_interface_reference        = 2
      no_exit_interface             = 3
      class_not_implement_interface = 4
      single_exit_multiply_active   = 5
      cast_error                    = 6
      exit_not_existing             = 7
      data_incons_in_exit_managem   = 8
      OTHERS                        = 9.
  IF sy-subrc NE 0.
    EXIT.
  ELSE.
    CALL METHOD lb_als-&gt;enable_als
      EXPORTING
        view_name   = x_header-viewname
      IMPORTING
        als_enabled = als_enabled.

    IF als_enabled = &apos;X&apos; AND
       ( &lt;status&gt;-upd_flag EQ &apos;T&apos; OR  &lt;status&gt;-upd_flag EQ &apos;X&apos; ).
      PERFORM VIM_MULTI_LANGU_TEXT_ALS.
    ENDIF.
  ENDIF.

ENDFORM.                               &quot; SET_TXT_UPDATE_FLAG

*&amp;--------------------------------------------------------------------*
*&amp;      Form  FILL_TEXTTAB_KEY                                        *
*&amp;--------------------------------------------------------------------*
*       Kept for downward compatibility only. Never use in unicode-
*       system. Use FILL_TEXTTAB_KEY instead                          *
*&amp;--------------------------------------------------------------------*
FORM fill_texttab_key USING enti_wa text_wa.
  FIELD-SYMBOLS: &lt;enti&gt;, &lt;text&gt;.
  DATA: index TYPE i.
  LOOP AT x_namtab WHERE texttabfld NE space
                     AND keyflag NE space.   &quot;all keyfields of text table
    index = x_namtab-position - x_header-tablen.
    ASSIGN text_wa+index(x_namtab-flength) TO &lt;text&gt;.
    IF x_namtab-primtabkey EQ space.   &quot;language key
      MOVE sy-langu TO &lt;text&gt;.
    ELSE.
      index = x_namtab-primtabkey.
      READ TABLE x_namtab INDEX index.   &quot;corresponding field of entity tb
      IF sy-subrc EQ 0.
        ASSIGN enti_wa+x_namtab-position(x_namtab-flength) TO &lt;enti&gt;.
        MOVE &lt;enti&gt; TO &lt;text&gt;.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;FILL_TEXTTAB_KEY

*&amp;--------------------------------------------------------------------*
*&amp;      Form  FILL_TEXTTAB_KEY_UC                                     *
*&amp;--------------------------------------------------------------------*
* ENTI_WA ---&gt; WA of entity table                                     *
* TEXT_WA &lt;--- WA of text table                                       *
*&amp;--------------------------------------------------------------------*
FORM fill_texttab_key_uc USING enti_wa
                         CHANGING text_wa.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab, &lt;namtab2&gt; TYPE vimnamtab,
                 &lt;enti&gt; TYPE ANY, &lt;text&gt; TYPE ANY.
  DATA: index TYPE i.
  LOOP AT x_namtab ASSIGNING &lt;namtab&gt; WHERE texttabfld NE space
                     AND keyflag NE space.
* keyfield of text table
    ASSIGN COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE text_wa
     TO &lt;text&gt;.
    IF &lt;namtab&gt;-primtabkey EQ space.   &quot;language key
      MOVE sy-langu TO &lt;text&gt;.
    ELSE.
      index = &lt;namtab&gt;-primtabkey.
      READ TABLE x_namtab ASSIGNING &lt;namtab2&gt; INDEX index.
* corresponding field of entity tb
      IF sy-subrc EQ 0.
        ASSIGN COMPONENT &lt;namtab2&gt;-viewfield OF STRUCTURE enti_wa
         TO &lt;enti&gt;.
        MOVE &lt;enti&gt; TO &lt;text&gt;.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;FILL_TEXTTAB_KEY_UC

*&amp;--------------------------------------------------------------------*
*&amp;      Form CREATE_WHERETAB_NEW                                      *
*&amp;--------------------------------------------------------------------*
* create where-tab for dynamic select                                 *
*&amp;--------------------------------------------------------------------*
*        --&gt; CW_TOTAL        table line
*            CW_TABLE        table the wheretab has to be filled for
*            CW_ENTI_KEY
*            CW_RC
*&amp;--------------------------------------------------------------------*
FORM create_wheretab_new USING cw_namtab LIKE x_namtab[]
                               total_struc TYPE any
                               total_txt_struc TYPE any
                               value(cw_table) LIKE vimdesc-viewname
                               value(cw_enti_key) TYPE xfeld
                               cw_rc TYPE i.

  DATA: cw_sellist LIKE vimsellist OCCURS 10,
        cw_sel LIKE vimsellist,
        first(1) TYPE c VALUE &apos;X&apos;, w_namtab TYPE vimnamtab,
        flength_in_char TYPE i.
  FIELD-SYMBOLS: &lt;cw_value&gt; TYPE ANY,
                 &lt;w_namtab2&gt; TYPE vimnamtab.

  LOOP AT cw_namtab INTO w_namtab
                    WHERE keyflag NE space    &quot;all textkeyfields
                      AND texttabfld NE space &quot;with relations to
                      AND primtabkey NE 0.    &quot;entity key fields
    CHECK w_namtab-datatype NE &apos;CLNT&apos; OR first EQ space.
    TRANSLATE first USING &apos;X &apos;.
*    IF cw_enti_key EQ space.
*      SUBTRACT x_header-tablen FROM w_namtab-position.
*    ENDIF.
*    ASSIGN cw_total+w_namtab-position(w_namtab-flength) &quot;value of
*              TO &lt;cw_value&gt;.           &quot;textkey
    IF cw_enti_key NE space.
      READ TABLE cw_namtab INDEX w_namtab-primtabkey
       ASSIGNING &lt;w_namtab2&gt;.           &quot;corresp. enti key
      ASSIGN COMPONENT &lt;w_namtab2&gt;-viewfield OF
       STRUCTURE total_struc TO &lt;cw_value&gt;.
      cw_sel-viewfield = &lt;w_namtab2&gt;-viewfield.
    ELSE.
      ASSIGN COMPONENT w_namtab-viewfield OF
       STRUCTURE total_txt_struc TO &lt;cw_value&gt;.
      cw_sel-viewfield = w_namtab-viewfield.
    ENDIF.
    cw_sel-tabix     = sy-tabix.
    cw_sel-operator = &apos;EQ&apos;.
    cw_sel-and_or = &apos;AND&apos;.
    CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
         EXPORTING
              tabname      = cw_table
              fieldname    = cw_sel-viewfield
              value_intern = &lt;cw_value&gt;
*       inttype      = w_namtab-inttype
*       datatype     = w_namtab-datatype
*       decimals     = w_namtab-decimals
*       convexit     = w_namtab-convexit
*       sign         = w_namtab-sign
              outputlen    = w_namtab-outputlen
              intlen       = w_namtab-flength
         IMPORTING
              value_extern = cw_sel-value.
    IF cw_sel-value EQ space.
      cw_sel-initial = &apos;X&apos;.
    ENDIF.
    flength_in_char =
                  w_namtab-flength / cl_abap_char_utilities=&gt;charsize.
    CASE w_namtab-inttype.
      WHEN &apos;F&apos;. cw_sel-fltp_value = &lt;cw_value&gt;.
      WHEN &apos;D&apos;. cw_sel-date_value = &lt;cw_value&gt;.
      WHEN &apos;T&apos;. cw_sel-time_value = &lt;cw_value&gt;.
*      WHEN &apos;P&apos;. cw_sel-pckd_value(w_namtab-flength) = &lt;cw_value&gt;.
      WHEN &apos;P&apos;. cw_sel-raw_value(w_namtab-flength) = &lt;cw_value&gt;.
      WHEN &apos;N&apos;. cw_sel-numc_value(flength_in_char) = &lt;cw_value&gt;.
      WHEN &apos;C&apos;. cw_sel-invd_value(flength_in_char) = &lt;cw_value&gt;.
      WHEN &apos;I&apos;. cw_sel-int4_value = &lt;cw_value&gt;.
      WHEN &apos;X&apos;.
        CASE w_namtab-datatype.
          WHEN &apos;INT1&apos;. cw_sel-int1_value = &lt;cw_value&gt;.
          WHEN &apos;INT2&apos;. cw_sel-int2_value = &lt;cw_value&gt;.
          WHEN &apos;INT4&apos;. cw_sel-int4_value = &lt;cw_value&gt;.
          WHEN &apos;RAW&apos;. cw_sel-raw_value(w_namtab-flength) = &lt;cw_value&gt;.
        ENDCASE.
    ENDCASE.
    cw_sel-converted = &apos;X&apos;.
    APPEND cw_sel TO cw_sellist.
    CLEAR cw_sel.
  ENDLOOP.
  DESCRIBE TABLE cw_sellist.
  READ TABLE cw_sellist INTO cw_sel INDEX sy-tfill.
  IF cw_sel-and_or NE space.
    CLEAR cw_sel-and_or. MODIFY cw_sellist INDEX sy-tfill FROM cw_sel.
  ENDIF.
  CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
    EXPORTING
      tablename               = cw_table
      only_cnds_for_keyflds   = &apos;X&apos;
    TABLES
      sellist                 = cw_sellist
      wheretab                = vim_wheretab
      x_namtab                = cw_namtab
    EXCEPTIONS
      no_conditions_for_table = 01.
  cw_rc = sy-subrc.
ENDFORM.                               &quot;create_wheretab_new
*&amp;--------------------------------------------------------------------*
*&amp;      Form CREATE_WHERETAB                                          *
*&amp;--------------------------------------------------------------------*
*       Kept for downward compatibility only. Never use in unicode-
*       system. Use CREATE_WHERETAB_NEW instead.
*&amp;--------------------------------------------------------------------*
*        --&gt; CW_TOTAL        table line
*            CW_TABLE        table name
*            CW_ENTI_KEY
*            CW_RC
*&amp;--------------------------------------------------------------------*
FORM create_wheretab TABLES cw_namtab STRUCTURE vimnamtab
                     USING value(cw_total)
                           value(cw_table) LIKE vimdesc-viewname
                           value(cw_enti_key) TYPE c
                           cw_rc TYPE i.
  DATA: cw_sellist LIKE vimsellist OCCURS 10, cw_sel LIKE vimsellist,
        first(1) TYPE c VALUE &apos;X&apos;.
  FIELD-SYMBOLS: &lt;cw_value&gt;.

  LOOP AT cw_namtab WHERE keyflag NE space    &quot;all textkeyfields
                      AND texttabfld NE space &quot;with relations to
                      AND primtabkey NE 0.      &quot;entity key fields
    CHECK cw_namtab-datatype NE &apos;CLNT&apos; OR first EQ space.
    TRANSLATE first USING &apos;X &apos;.
    IF cw_enti_key EQ space.
      SUBTRACT x_header-tablen FROM cw_namtab-position.
    ENDIF.
    ASSIGN cw_total+cw_namtab-position(cw_namtab-flength) &quot;value of
              TO &lt;cw_value&gt;.           &quot;textkey
    IF cw_enti_key NE space.
      READ TABLE cw_namtab INDEX cw_namtab-primtabkey.   &quot;corresp. enti key
    ENDIF.
    cw_sel-viewfield = cw_namtab-viewfield.
    cw_sel-tabix     = sy-tabix.
    cw_sel-operator = &apos;EQ&apos;.
    cw_sel-and_or = &apos;AND&apos;.
    CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
      EXPORTING
        value_intern = &lt;cw_value&gt;
        inttype      = cw_namtab-inttype
        datatype     = cw_namtab-datatype
        decimals     = cw_namtab-decimals
        convexit     = cw_namtab-convexit
        sign         = cw_namtab-sign
        outputlen    = cw_namtab-outputlen
        intlen       = cw_namtab-flength
      IMPORTING
        value_extern = cw_sel-value.
    IF cw_sel-value EQ space.
      cw_sel-initial = &apos;X&apos;.
    ENDIF.
* SW 5.8.98 ..
* folgende MOVE&apos;s führen zu unerwünschten impliziten Konvertierungen
* und damit zu Laufzeitfehler
    CLEAR cw_sel-converted.
*   case cw_namtab-inttype.
*     when &apos;F&apos;. cw_sel-fltp_value = &lt;cw_value&gt;.
*     when &apos;D&apos;. cw_sel-date_value = &lt;cw_value&gt;.
*     when &apos;T&apos;. cw_sel-time_value = &lt;cw_value&gt;.
*     when &apos;P&apos;. cw_sel-pckd_value(cw_namtab-flength) = &lt;cw_value&gt;.
*     when &apos;N&apos;. cw_sel-numc_value(cw_namtab-flength) = &lt;cw_value&gt;.
*     when &apos;C&apos;. cw_sel-invd_value(cw_namtab-flength) = &lt;cw_value&gt;.
*     when &apos;I&apos;. cw_sel-int4_value = &lt;cw_value&gt;.
*     when &apos;X&apos;.
*       case cw_namtab-datatype.
*         when &apos;INT1&apos;. cw_sel-int1_value = &lt;cw_value&gt;.
*         when &apos;INT2&apos;. cw_sel-int2_value = &lt;cw_value&gt;.
*         when &apos;INT4&apos;. cw_sel-int4_value = &lt;cw_value&gt;.
*         when &apos;RAW&apos;. cw_sel-raw_value(cw_namtab-flength) = &lt;cw_value&gt;.
*       endcase.
*   endcase.
*   cw_sel-converted = &apos;X&apos;.                                &quot;.. SW 5.8.98
    APPEND cw_sel TO cw_sellist.
  ENDLOOP.
  DESCRIBE TABLE cw_sellist.
  READ TABLE cw_sellist INTO cw_sel INDEX sy-tfill.
  IF cw_sel-and_or NE space.
    CLEAR cw_sel-and_or. MODIFY cw_sellist INDEX sy-tfill FROM cw_sel.
  ENDIF.
  CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
    EXPORTING
      tablename               = cw_table
      only_cnds_for_keyflds   = &apos;X&apos;
    TABLES
      sellist                 = cw_sellist
      wheretab                = vim_wheretab
      x_namtab                = cw_namtab
    EXCEPTIONS
      no_conditions_for_table = 01.
  cw_rc = sy-subrc.
ENDFORM.                               &quot;create_wheretab

*&amp;--------------------------------------------------------------------*
*&amp;      Form  TABLEFRAME                                              *
*&amp;--------------------------------------------------------------------*
* program for function TABLEFRAME_&lt;area&gt;                              *
*&amp;--------------------------------------------------------------------*
FORM  tableframe TABLES header STRUCTURE vimdesc
                        namtab STRUCTURE vimnamtab
                        dbasellist STRUCTURE vimsellist
                        dplsellist STRUCTURE vimsellist
                        exclcuafunct STRUCTURE vimexclfun
                 USING  corrnumber
                        viewaction
                        viewname.                                        &quot;#EC NEEDED

  DATA: enqueue_processed TYPE c, &quot;flag: view enqueued by VIEWFRAME_..
        table_type(11) TYPE c,         &quot;type of table to use
        table_length TYPE i.           &quot;length of current table

*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
* first of all: determine well-sized internal tables etc.              *
*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
  READ TABLE header INDEX 1.
  table_length = header-tablen / cl_abap_char_utilities=&gt;charsize + 2.
*  tab lg. + action + mark
  IF header-texttbexst NE space.
    table_length = table_length
     + header-texttablen / cl_abap_char_utilities=&gt;charsize + 1.
* txtb+txtact
  ENDIF.
  IF table_length LE ultra_short_tab.
    MOVE &apos;ULTRA_SHORT&apos;     TO table_type.
    FREE: extract_vs, total_vs,
          extract_s, total_s,
          extract_m, total_m,
          extract_l, total_l,
          extract_vl, total_vl,
          extract_ul, total_ul.
  ELSEIF table_length LE very_short_tab.
    MOVE &apos;VERY_SHORT&apos;     TO table_type.
    FREE: extract_us, total_us,
          extract_s, total_s,
          extract_m, total_m,
          extract_l, total_l,
          extract_vl, total_vl,
          extract_ul, total_ul.
  ELSEIF table_length LE short_tab.
    MOVE &apos;SHORT&apos;     TO table_type.
    FREE: extract_us, total_us,
          extract_vs, total_vs,
          extract_m, total_m,
          extract_l, total_l,
          extract_vl, total_vl,
          extract_ul, total_ul.
  ELSEIF table_length LE middle_tab.
    MOVE &apos;MIDDLE&apos;    TO table_type.
    FREE: extract_us, total_us,
          extract_vs, total_vs,
          extract_s, total_s,
          extract_l, total_l,
          extract_vl, total_vl,
          extract_ul, total_ul.
  ELSEIF table_length LE long_tab.
    MOVE &apos;LONG&apos;    TO table_type.
    FREE: extract_us, total_us,
          extract_vs, total_vs,
          extract_s, total_s,
          extract_m, total_m,
          extract_vl, total_vl,
          extract_ul, total_ul.
  ELSEIF table_length LE very_long_tab.
    MOVE &apos;VERY_LONG&apos;    TO table_type.
    FREE: extract_us, total_us,
          extract_vs, total_vs,
          extract_s, total_s,
          extract_m, total_m,
          extract_l, total_l,
          extract_ul, total_ul.
  ELSEIF table_length LE ultra_long_tab.
    MOVE &apos;ULTRA_LONG&apos;    TO table_type.
    FREE: extract_us, total_us,
          extract_vs, total_vs,
          extract_s, total_s,
          extract_m, total_m,
          extract_l, total_l,
          extract_vl, total_vl.
  ENDIF.
  maint_mode = viewaction.
  corr_nbr = corrnumber.
*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
* Entrypoint after changing maintenance mode (show &lt;--&gt; update)        *
*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
  DO.
*----------------------------------------------------------------------*
* Select data from database                                            *
*----------------------------------------------------------------------*
    PERFORM table_call_function TABLES dbasellist dplsellist
                                header namtab exclcuafunct
                                USING read table_type update_flag.
    CASE sy-subrc.
      WHEN 1.
        RAISE missing_corr_number.
    ENDCASE.
*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
* Entrypoint after saving data into database                           *
* Entrypoint after refreshing selected entries from database           *
*-&lt;&lt;&lt;--------------------------------------------------------------&gt;&gt;&gt;&gt;*
    DO.
*----------------------------------------------------------------------*
* Edit data                                                            *
*----------------------------------------------------------------------*
      DO.
        PERFORM table_call_function
                             TABLES dbasellist dplsellist
                                    header namtab exclcuafunct
                             USING edit table_type &lt;status&gt;-upd_flag.
        CASE sy-subrc.
          WHEN 1.
            IF maint_mode EQ transportieren AND viewaction EQ aendern.
              MOVE viewaction TO maint_mode.
            ELSE.
              RAISE missing_corr_number.
            ENDIF.
          WHEN OTHERS.
            EXIT.
        ENDCASE.
      ENDDO.
*----------------------------------------------------------------------*
*  Handle usercommands...                                              *
*  ...at first handle commands which could cause loss of data          *
*----------------------------------------------------------------------*
      IF function EQ back.
        function = end.
      ENDIF.
      IF ( function EQ switch_to_show_mode OR
           function EQ get_another_view    OR
           function EQ switch_transp_to_upd_mode OR
           function EQ end ) AND
         &lt;status&gt;-upd_flag NE space.
        PERFORM beenden.
        CASE sy-subrc.
          WHEN 0.
            PERFORM table_call_function
                         TABLES dbasellist dplsellist
                                header namtab exclcuafunct
                         USING save table_type &lt;status&gt;-upd_flag.
            CASE sy-subrc.
              WHEN 0.
                IF &lt;status&gt;-upd_flag EQ space. EXIT. ENDIF.
              WHEN 1.
                RAISE missing_corr_number.
              WHEN 3.
            ENDCASE.
          WHEN 8.
            EXIT.
          WHEN 12.
        ENDCASE.
*----------------------------------------------------------------------*
*  ...2nd: transport request                                           *
*----------------------------------------------------------------------*
      ELSEIF function EQ transport.
        IF &lt;status&gt;-upd_flag NE space.
          PERFORM transportieren.
          CASE sy-subrc.
            WHEN 0.
              PERFORM table_call_function
                              TABLES dbasellist dplsellist
                                     header namtab exclcuafunct
                              USING save table_type &lt;status&gt;-upd_flag.
              CASE sy-subrc.
                WHEN 0.
                  maint_mode = transportieren.
                WHEN 1.
                  RAISE missing_corr_number.
                WHEN 3.
              ENDCASE.
            WHEN 8.
              EXIT.
            WHEN 12.
          ENDCASE.
        ELSE.
          maint_mode = transportieren.
        ENDIF.
*----------------------------------------------------------------------*
*  ...now reset or save requests                                       *
*----------------------------------------------------------------------*
      ELSEIF function EQ reset_list  OR
             function EQ reset_entry OR
             function EQ save.
*----------------------------------------------------------------------*
*  Refresh selected entries from database or save data into database   *
*----------------------------------------------------------------------*
        PERFORM table_call_function
                          TABLES dbasellist dplsellist
                                 header namtab exclcuafunct
                          USING function table_type &lt;status&gt;-upd_flag.
        CASE sy-subrc.
          WHEN 1.
            RAISE missing_corr_number.
          WHEN 3.
        ENDCASE.
      ELSE.
        EXIT.
      ENDIF.
    ENDDO.
*----------------------------------------------------------------------*
*  ...now other commands...                                            *
*----------------------------------------------------------------------*
    CASE function.
      WHEN switch_to_show_mode.
*   change maintenance mode from update to show
        PERFORM enqueue USING &apos;D&apos; header-frm_af_enq. &quot;dequeue view
        CLEAR enqueue_processed.
        maint_mode = anzeigen.
      WHEN switch_to_update_mode.
*     change maintenance mode from show to update
        PERFORM enqueue USING &apos;E&apos; header-frm_af_enq.  &quot;enqueue view
        IF sy-subrc EQ 0.
          MOVE &apos;X&apos; TO enqueue_processed.
          maint_mode = aendern.
        ENDIF.
      WHEN switch_transp_to_upd_mode.
*     change maintenance mode from transport to update
        maint_mode = aendern.
      WHEN transport.
*     change maintenance mode from update to transport
        maint_mode = transportieren.
      WHEN OTHERS.
        IF enqueue_processed NE space.
          PERFORM enqueue USING &apos;D&apos; header-frm_af_enq.&quot;dequeue view
        ENDIF.
        PERFORM before_leaving_frame_function
                                      USING header-frm_bf_end.
        EXIT.
    ENDCASE.
  ENDDO.
ENDFORM.                                                    &quot;

*&amp;--------------------------------------------------------------------*
*&amp;      Form TABLEPROC                                                *
*&amp;--------------------------------------------------------------------*
* program for function TABLEPROC_&lt;area&gt;                               *
*&amp;--------------------------------------------------------------------*
FORM  tableproc.
*----------------------------------------------------------------------*
* Initialization: set field-symbols etc.                               *
*----------------------------------------------------------------------*
  IF last_view_info NE view_name.
    PERFORM initialisieren.
  ENDIF.
  PERFORM justify_action_mode.
  MOVE: view_action TO maint_mode,
        corr_number TO corr_nbr.

*----------------------------------------------------------------------*
* Get data from database                                               *
*----------------------------------------------------------------------*
  IF fcode EQ read OR fcode EQ read_and_edit.
    PERFORM prepare_read_request.
    IF x_header-frm_rp_get NE space.
      PERFORM (x_header-frm_rp_get) IN PROGRAM (sy-repid).
    ELSE.
      PERFORM table_get_data.
    ENDIF.
    IF fcode EQ read_and_edit. fcode = edit. ENDIF.
  ENDIF.

  CASE fcode.
    WHEN  edit.                        &quot; Edit read data
      PERFORM call_dynpro.
      PERFORM check_upd.
*....................................................................*

    WHEN save.                         &quot; Write data into database
      PERFORM prepare_saving.
      IF &lt;status&gt;-upd_flag NE space.
        IF x_header-frm_rp_upd NE space.
          PERFORM (x_header-frm_rp_upd) IN PROGRAM.
        ELSE.
          IF sy-subrc EQ 0.
            PERFORM table_db_upd.
          ENDIF.
        ENDIF.
        PERFORM after_saving.
      ENDIF.
*....................................................................*

    WHEN reset_list.     &quot; Refresh all marked entries of EXTRACT from db
      PERFORM reset_entries USING list_bild.
*....................................................................*

    WHEN reset_entry.               &quot; Refresh single entry from database
      PERFORM reset_entries USING detail_bild.
*.......................................................................
  ENDCASE.
  MOVE: &lt;status&gt;-upd_flag TO update_required,
*  IF vim_called_by_cluster NE &apos;X&apos;.   &quot; MPRE 1449801
        function TO ucomm.            &quot; PATIDARP 1496366
*  ENDIF.
ENDFORM.                               &quot;tableproc

*&amp;--------------------------------------------------------------------*
*&amp;      FORM  REPLACE_FORBIDDEN_CHARS                                 *
*&amp;--------------------------------------------------------------------*
* replace forbidden characters with internal code into NAME           *
*---------------------------------------------------------------------*
* ---&gt; NAME - name to correct                                         *
* ---&gt; FORBIDDEN_CHARS - chars which must be replaced                 *
* &lt;--- NAME - corrected name                                          *
*&amp;--------------------------------------------------------------------*
FORM  replace_forbidden_chars USING value(forbidden_chars) name.
  FIELD-SYMBOLS: &lt;code&gt;.
  DATA: suspect_char(1) TYPE c, code(2) TYPE c.

  DO.
    IF name CA forbidden_chars.
      ASSIGN name+sy-fdpos(1)  TO &lt;code&gt;.
      MOVE &lt;code&gt; TO suspect_char.
      ASSIGN &lt;code&gt; TO &lt;code&gt; TYPE &apos;X&apos;.
      MOVE &lt;code&gt; TO code.
      REPLACE suspect_char WITH code INTO name.
    ELSE.
      EXIT.
    ENDIF.
  ENDDO.
ENDFORM.                               &quot;replace_forbidden_chars
*&amp;---------------------------------------------------------------------*
*&amp;      Form  vim_get_text_keyflds
*&amp;---------------------------------------------------------------------*
*       inserts all key field names of a texttable into a table
*----------------------------------------------------------------------*
*      --&gt;P_TEXTTABNAME   text table name
*      &lt;--P_TEXT_KEYFLDS  table of keyfields
*----------------------------------------------------------------------*
FORM vim_get_text_keyflds USING p_texttabname TYPE tabname
                         CHANGING p_text_keyflds TYPE vim_flds_tab_type.

  STATICS: texttabname_save TYPE tabname,
           text_keyflds_save TYPE vim_flds_tab_type.

  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab.

  REFRESH p_text_keyflds.
  IF texttabname_save = p_texttabname.
    APPEND LINES OF text_keyflds_save TO p_text_keyflds.
  ELSE.
    texttabname_save = p_texttabname.
    REFRESH text_keyflds_save.
    LOOP AT x_namtab ASSIGNING &lt;namtab&gt; WHERE texttabfld NE space
                       AND keyflag NE space.
      APPEND &lt;namtab&gt;-viewfield TO p_text_keyflds.
    ENDLOOP.
    APPEND LINES OF p_text_keyflds TO text_keyflds_save.
  ENDIF.
ENDFORM.                               &quot; vim_get_text_keyflds</include_source>
   </include>
   <include NAME="LSVIMFX2" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMFX2                                                   *
*----------------------------------------------------------------------*
*---------------------------------------------------------------------*
*       FORM DETAILBILD                                               *
*---------------------------------------------------------------------*
*       .........                                                     *
*---------------------------------------------------------------------*
FORM detailbild.
  IF status-mode NE list_bild OR status-type NE zweistufig.
    MESSAGE i001(sv).
    EXIT.
  ENDIF.
  nextline = firstline + l - 1.
  IF l EQ 0 OR nextline GT maxlines.
    MESSAGE s032(sv).
    MOVE firstline TO nextline.
    EXIT.
  ENDIF.
  IF mark_extract &gt; 0.                 &quot;ufdetailb
    PERFORM set_mark_only USING nextline.
  ENDIF.                               &quot;ufdetaile
  IF x_header-delmdtflag NE space.
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  ENDIF.
  PERFORM process_detail_screen USING &apos;S&apos;.
ENDFORM.                    &quot;detailbild
*---------------------------------------------------------------------*
*       FORM DETAIL_ABBRECHEN
**---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_abbrechen.
  IF replace_mode EQ space AND
     ( sy-datar NE space OR
       ( x_header-bastab EQ space OR x_header-texttbexst EQ space )
       AND &lt;table1_x&gt; NE &lt;table2_x&gt;
       OR  x_header-bastab NE space AND x_header-texttbexst NE space
       AND ( &lt;table1_x&gt; NE &lt;vim_xextract_enti&gt;
             OR &lt;table1_xtext&gt; NE &lt;vim_xextract_text&gt; ) ).
    CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
      EXPORTING
        titel          = svim_text_007
        textline1      = svim_text_009
        textline2      = svim_text_006
        defaultoption  = &apos;N&apos;
        cancel_display = &apos; &apos;
      IMPORTING
        answer         = answer.                            &quot;#EC *
    IF answer NE &apos;J&apos;.
      EXIT.
    ENDIF.
  ENDIF.
  IF status-action EQ kopieren.
    SET SCREEN 0.
    LEAVE SCREEN.
  ENDIF.
  IF maxlines LE 1.
*   IF STATUS-ACTION EQ HINZUFUEGEN OR STATUS-ACTION EQ KOPIEREN.
    IF status-action EQ hinzufuegen.
      status-action = aendern.
      title-action  = aendern.
      CLEAR &lt;status&gt;-selected.
    ENDIF.
    PERFORM fill_extract.
    nextline = 1.
  ENDIF.
  neuer = &apos;N&apos;.
  IF vim_single_entry_function EQ space.
    &lt;status&gt;-upd_flag = space.
    IF replace_mode EQ space AND vim_special_mode NE vim_delete.
      l = nextline - &lt;status&gt;-firstline + 1.
      IF l LE 0 OR l GT looplines.
        l = 1.
      ENDIF.
      nextline = &lt;status&gt;-firstline.
      SET SCREEN liste.
    ELSE.
      SET SCREEN 0. CLEAR vim_act_dynp_view.
    ENDIF.
  ELSE.                                &quot;single_entry_function
    function = end. SET SCREEN 0. CLEAR vim_act_dynp_view.
    PERFORM update_status.
  ENDIF.
  LEAVE SCREEN.
ENDFORM.                    &quot;detail_abbrechen
*---------------------------------------------------------------------*
*       FORM DETAIL_BACK                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_back.

  DATA:count TYPE i.

  CASE status-action.
    WHEN aendern.
      PERFORM update_tab.
    WHEN hinzufuegen.
*      WRITE &lt;f1&gt; TO entry(x_header-keylen).
      MOVE &lt;f1_x&gt; TO &lt;f1_wax&gt;.
      PERFORM update_tab.
      neuer = &apos;N&apos;.
*      SORT extract BY &lt;vim_extract_key&gt;.
      SORT extract BY &lt;vim_xextract_key&gt;.                   &quot;#EC *
*      MOVE entry TO &lt;table1&gt;.
*      READ TABLE extract WITH KEY &lt;f1&gt; BINARY SEARCH.
      READ TABLE extract WITH KEY &lt;f1_x&gt;.                   &quot;#EC WARNOK
      firstline = 1.
      IF sy-tabix GT looplines AND looplines GT 0.
        count = ( sy-tabix - firstline ) DIV looplines + 1.
        DO count TIMES.
          firstline = firstline + looplines - 1.
        ENDDO.
        MOVE firstline TO &lt;status&gt;-firstline.
      ENDIF.
      l = sy-tabix - firstline + 1.
      MOVE l TO &lt;status&gt;-cur_line.
      MOVE &lt;initial&gt; TO &lt;table1&gt;.
      IF x_header-bastab NE space AND x_header-texttbexst NE space.
        MOVE &lt;text_initial_x&gt; TO &lt;table1_xtext&gt;.
*        MOVE &lt;text_initial&gt; TO &lt;table1_text&gt;.
      ENDIF.
  ENDCASE.
  IF status-data EQ auswahldaten AND maxlines LE 1.
    &lt;table1_wax&gt; = &lt;vim_xextract&gt;.
    IF status-delete = geloescht.
      status-delete = nicht_geloescht.
      title-action  = aendern.
      PERFORM markiere_alle USING nicht_markiert.
    ENDIF.
    IF status-action EQ hinzufuegen.
      status-action = aendern.
      title-action  = aendern.
      CLEAR &lt;status&gt;-selected.
    ENDIF.
    IF x_header-delmdtflag NE space.
      &lt;vim_h_mkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
      LOOP AT vim_collapsed_mainkeys.&quot;#EC * &quot;WHERE mkey_bf EQ &lt;vim_f1_before&gt;.
        IF vim_collapsed_mainkeys-mkey_bf EQ space. &quot;SW: wie liste_back
* change XB 11.06.02 BCEK060520/BCEK060521 ----------begin--------------
* if &lt;vim_collapsed_mkey_bfx&gt; should be changed, only when it isn&apos;t
* constant 4B00, that means data isn&apos;t at position 0.
          IF &lt;vim_collapsed_mkey_bfx&gt; NE &lt;vim_mkey_beforex&gt;.
            &lt;vim_collapsed_mkey_bfx&gt; = &lt;vim_collapsed_logkeyx&gt;.
*          vim_collapsed_mainkeys-mkey_bf =
*                                       vim_collapsed_mainkeys-log_key.
          ENDIF.
* change XB 11.06.02 BCEK060520/BCEK060521 ------------end--------------
          CLEAR vim_collapsed_mainkeys-log_key.
        ENDIF.                                              &quot;SW
        &lt;f1_x&gt; = &lt;vim_h_coll_mkey&gt;.
*        &lt;f1&gt; = vim_collapsed_mainkeys-mainkey.
        &lt;vim_enddate_mask&gt; = space.
        &lt;vim_h_coll_mkey&gt; = &lt;f1_x&gt;.
*        vim_collapsed_mainkeys-mainkey = &lt;f1&gt;.
        MODIFY vim_collapsed_mainkeys.                      &quot;#EC *
      ENDLOOP.
      IF vim_delim_expa_excluded NE space.
        DELETE excl_cua_funct WHERE function EQ &apos;EXPA&apos;.
        CLEAR vim_delim_expa_excluded.
      ENDIF.
      IF status-action = aendern AND title-action = hinzufuegen.
        title-action  = aendern.
      ENDIF.
    ENDIF.
    PERFORM fill_extract.
*    &lt;table1&gt; = entry(x_header-keylen).
*    READ TABLE extract WITH KEY &lt;f1&gt;.
    READ TABLE extract WITH KEY &lt;f1_wax&gt;.&quot;#EC WARNOK
    IF sy-subrc EQ 0.
      nextline = sy-tabix.
    ELSE.
      nextline = 1.
    ENDIF.
  ELSE.
    MOVE firstline TO nextline.
  ENDIF.
  vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
ENDFORM.                    &quot;detail_back
*&amp;--------------------------------------------------------------------*
*&amp;      Form  DETAIL_EXIT_COMMAND                                     *
*&amp;--------------------------------------------------------------------*
* handle exit commands on detail screen                               *
*&amp;--------------------------------------------------------------------*
FORM detail_exit_command.
  DATA: answer.                                            &quot;#EC NEEDED
  function = ok_code.
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  CASE ok_code.
    WHEN &apos;ABR &apos;.
      CLEAR ok_code.
      PERFORM detail_abbrechen.
    WHEN &apos;IGN &apos;.
      PERFORM ignorieren.
    WHEN &apos;UPRF&apos;.                       &quot;UFprofileB
      CHECK vim_pr_activating = space.
*      IF SY-DATAR &lt;&gt; SPACE.
*        CALL FUNCTION &apos;POPUP_TO_CONFIRM_STEP&apos;
*             EXPORTING
*                  TEXTLINE1      = SVIM_TEXT_PRF
*                  TEXTLINE2      = SVIM_TEXT_PRG
*                  TITEL          = SVIM_TEXT_PRE
*                  CANCEL_DISPLAY = &apos; &apos;
*             IMPORTING
*                  ANSWER         = ANSWER.
*        IF ANSWER &lt;&gt; &apos;J&apos;.
*          CLEAR: FUNCTION, OK_CODE.
*        ENDIF.
*      ENDIF.
      IF NOT function IS INITIAL.
        PERFORM vim_pr_mand_fields.
      ENDIF.
    WHEN &apos;GPRF&apos;.
      CHECK vim_pr_activating = space.
      PERFORM vim_pr_mand_fields         .         &quot;UFprofileE
  ENDCASE.
ENDFORM.                               &quot;detail_exit_command
*---------------------------------------------------------------------*
*       FORM DETAIL_INIT                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_init.
  CONSTANTS: forward VALUE &apos;X&apos;.                                &quot;#EC NEEDED
  IF function NE space.
    status-mode = detail_bild.
    title-mode  = detail_bild.
    IF &lt;xmark&gt; EQ markiert.
      status-mark = markiert.
    ELSE.
      status-mark = nicht_markiert.
    ENDIF.
    IF status-action NE kopieren AND neuer NE &apos;J&apos;.
      IF &lt;status&gt;-selected = by_field_contents AND nextline &gt; maxlines.
        nextline = 1.                  &quot;377434/1999 UF011299
      ENDIF.
      IF x_header-subsetflag NE space AND replace_mode EQ space.
        PERFORM fill_subsetfields.
      ENDIF.
* ========== XB int225314/03 H601454 begin ==========
* maxlines must GT nextline in EXTRACT, otherweise the
* empty entry in EXTRACT will be readed.
      IF nextline &gt; maxlines.
        PERFORM read_table USING maxlines.
      ELSE.
        PERFORM read_table USING nextline.
      ENDIF.
* ========== XB int225314/03 H601454 end   ==========
      IF x_header-subsetflag NE space.
        PERFORM complete_subsetfields.
      ENDIF.
    ENDIF.
    IF vim_special_mode EQ vim_delimit.
      MOVE vim_sval_tab-value TO &lt;vim_new_begdate&gt;.
    ENDIF.
  ENDIF.
  CLEAR: vim_key_alr_checked, vim_keyrange_alr_checked.
  vim_act_dynp_view = x_header-viewname.
  PERFORM set_title USING title &lt;name&gt;.
  CASE replace_mode.
    WHEN space.
*     SET PF-STATUS STATUS EXCLUDING EXCL_CUA_FUNCT.
      IF neuer NE &apos;X&apos;. &quot;error in CHECK_KEY for timedep. objects
        IF vim_special_mode NE vim_delete.
          PERFORM set_pf_status USING status.
        ELSE.
          PERFORM set_pf_status USING &apos;REPLACE&apos;.
        ENDIF.
      ENDIF.
    WHEN OTHERS.
*     SUPPRESS DIALOG.
*     SET PF-STATUS &apos;REPLACE&apos;.
      PERFORM set_pf_status USING &apos;REPLACE&apos;.
*     IF X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
*     IF VIM_SPECIAL_MODE NE VIM_UPGRADE AND
*        X_HEADER-BASTAB NE SPACE AND X_HEADER-TEXTTBEXST NE SPACE.
*       IF REPLACE_TEXTTABLE_FIELD NE SPACE.
*         MOVE &apos;T&apos; TO &lt;STATUS&gt;-UPD_FLAG.
*       ELSE.
*         MOVE &apos;E&apos; TO &lt;STATUS&gt;-UPD_FLAG.
*       ENDIF.
*     ELSE.
*       MOVE &apos;X&apos; TO &lt;STATUS&gt;-UPD_FLAG.
*     ENDIF.
*     EXIT.
  ENDCASE.
ENDFORM.                    &quot;detail_init
*---------------------------------------------------------------------*
*       FORM DETAIL_LOESCHE                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_loesche.
  DATA: tot_ix LIKE sy-tabix, rec LIKE sy-subrc,
        delete_fix_value(1) TYPE c,
        entry_contains_fix_val(1) TYPE c,
        w_field TYPE vimty_fields_type,
        bc_fix_del_info_sent(1) TYPE c VALUE &apos; &apos;.

*   -------Authority check before deleting fix values from BC-Sets------
  delete_fix_value = vim_bc_chng_allowed.
  IF vim_bc_chng_allowed = space.  &quot;fix field changeability forced
    READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
    WITH TABLE KEY viewname = x_header-viewname
    keys = &lt;vim_xextract_key&gt;.
    IF sy-subrc = 0.
      CLEAR entry_contains_fix_val.
      LOOP AT vim_bc_entry_list_wa-fields INTO w_field.
        IF w_field-flag = vim_profile_fix.
          entry_contains_fix_val = &apos;X&apos;.
        ENDIF.
      ENDLOOP.
      IF entry_contains_fix_val = &apos;X&apos;.
        IF bc_fix_del_info_sent EQ space AND
           &lt;status&gt;-bcfixdelinfosent NE &apos;Y&apos;.&quot;HCG: del dependent VCL
          bc_fix_del_info_sent = &apos;X&apos;.
          &lt;status&gt;-bcfixdelinfosent = &apos;X&apos;.
          MESSAGE i177(sv).
        ENDIF.
      ELSE.
        delete_fix_value = &apos;X&apos;.
      ENDIF.
    ELSE.
      delete_fix_value = &apos;X&apos;.
    ENDIF.
  ENDIF.
  CHECK delete_fix_value EQ &apos;X&apos;.
*   -------------------------------------------------------------&quot;HCG---
  IF &lt;xmark&gt; NE uebergehen.
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
    MOVE sy-tabix TO tot_ix.
    IF x_header-existency EQ &apos;M&apos;.      &quot;no mainkey delete allowed
      PERFORM check_if_entry_can_be_deleted.
      IF sy-subrc NE 0.
        &lt;xmark&gt; = uebergehen. ignored_entries_exist = &apos;X&apos;.
        MODIFY extract INDEX nextline.                      &quot;#EC *
        &lt;mark&gt; = uebergehen.
        MODIFY total INDEX tot_ix.                          &quot;#EC *
        EXIT.
      ENDIF.
    ENDIF.
    PERFORM logical_delete_from_total USING tot_ix.
    IF &lt;xmark&gt; EQ markiert.
      mark_total  = mark_total - 1.
      mark_extract = mark_extract - 1.
    ENDIF.
    IF x_header-delmdtflag NE space.
      IF vim_special_mode NE vim_upgrade.
        PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                                   space &lt;vim_begdate&gt;.
      ELSE.
        CLEAR sy-subrc.
      ENDIF.
    ENDIF.
    IF x_header-delmdtflag EQ space OR sy-subrc LT 8.
      rec = sy-subrc.
      DELETE extract INDEX nextline.
*MN 421570 2005
      DESCRIBE TABLE extract LINES maxlines.
      IF rec EQ 4.
        LOOP AT total.                                      &quot;#EC *
          PERFORM select USING &lt;status&gt;-selected.
          CHECK sy-subrc EQ 0.
          CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_old_mkey_beforex&gt; AND
                ( vim_mkey_after_exists EQ space OR
                  &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_old_mkey_afterx&gt; ).
*          CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_old_mkey_before&gt; AND
*                ( vim_mkey_after_exists EQ space OR
*                  &lt;vim_tot_mkey_after&gt; EQ &lt;vim_old_mkey_after&gt; ).
          vim_mainkey = vim_old_viewkey.
          extract = total.
          PERFORM mod_extract_and_mainkey_tab USING &apos;I&apos; nextline.
          EXIT.
        ENDLOOP.
      ENDIF.
    ENDIF.
    IF vim_special_mode EQ vim_upgrade.
      counter = 1.
      EXIT.
    ENDIF.
    IF ignored_entries_exist EQ space AND maxlines GT 1.
      MESSAGE s013(sv).
    ELSE.
      MESSAGE i013(sv).
    ENDIF.
  ENDIF.
  IF &lt;status&gt;-mark_only &lt;&gt; space.      &quot;ufdetailb
    DESCRIBE TABLE extract LINES maxlines.
    IF mark_extract = 0.
* last marked entry deleted
      nextline = 1.
      vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
    ELSE.
* search next marked entry
      nextline = nextline - 1.
      PERFORM get_marked_entry USING &apos;X&apos;
                  CHANGING nextline
                           rec.
      IF rec &lt;&gt; 0.
* search previous marked entry
        nextline = nextline + 1.
        PERFORM get_marked_entry USING space
                    CHANGING nextline
                             rec.
      ENDIF.
      IF rec &lt;&gt; 0.
        nextline = 1. vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
      ELSE.
        PERFORM get_page_and_position USING nextline
                                            looplines
                                      CHANGING firstline
                                               l.
      ENDIF.
    ENDIF.

  ELSE.                                &quot;ufdetaile
    DESCRIBE TABLE extract LINES maxlines.
    IF maxlines EQ 0.
      nextline = 1.
      IF status-action EQ hinzufuegen.
        status-action = aendern.
        title-action = aendern.
      ENDIF.
      PERFORM fill_extract.
      vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
    ENDIF.
    IF nextline GT maxlines.
      nextline = maxlines.
    ENDIF.
  ENDIF.                               &quot;ufdetail
  READ TABLE total INDEX tot_ix.                            &quot;#EC *
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
ENDFORM.                    &quot;detail_loesche
*---------------------------------------------------------------------*
*       FORM DETAIL_MARKIERE                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_markiere.
  IF neuer EQ &apos;J&apos;.
    EXIT.
  ENDIF.
  PERFORM update_tab.
* PERFORM MARKIERE USING FIRSTLINE.
  PERFORM markiere USING nextline.
  CLEAR function.
ENDFORM.                    &quot;detail_markiere


*---------------------------------------------------------------------*
*       FORM DETAIL_MARKIERTE                                         *
*---------------------------------------------------------------------*
*       UF300798 Detail-screen only with marked entries except line-
*                selection on list-screen
*---------------------------------------------------------------------*
FORM detail_markierte.

  DATA: rc LIKE sy-subrc.

  IF status-mode NE list_bild OR status-type NE zweistufig.
    MESSAGE i001(sv).
    EXIT.
  ENDIF.
  IF mark_extract = 0.
* no entries marked
    PERFORM detailbild.
    EXIT.
  ENDIF.
  &lt;status&gt;-mark_only = &apos;X&apos;.
** current entry marked?
*  nextline = firstline + l - 1.
*  PERFORM check_marked USING nextline
*                       CHANGING rc.
*  IF rc &lt;&gt; 0.
* search first marked entry
  nextline = 0.
  PERFORM get_marked_entry USING &apos;X&apos;
                           CHANGING nextline
                                    rc.
  IF rc &lt;&gt; 0. PERFORM detailbild. EXIT. ENDIF.
*  ENDIF.
  IF x_header-delmdtflag NE space.
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  ENDIF.
  PERFORM process_detail_screen USING &apos;S&apos;.
ENDFORM.                    &quot;detail_markierte

*---------------------------------------------------------------------*
*       FORM DETAIL_PAI                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
* &lt;--- NEXT_SCREEN - next screen to process                           *
* &lt;--- LEAVE_SCREEN - flag: X - leave screen necessary                *
*---------------------------------------------------------------------*
FORM detail_pai.
  CLEAR: vim_next_screen, vim_leave_screen.
  MOVE: status-data TO &lt;status&gt;-st_data,
        status-mode TO &lt;status&gt;-st_mode,
        status-delete TO &lt;status&gt;-st_delete,
        status-action TO &lt;status&gt;-st_action,
        title         TO &lt;status&gt;-title,
        maxlines      TO &lt;status&gt;-maxlines,
        mark_extract  TO &lt;status&gt;-mk_xt,
        mark_total    TO &lt;status&gt;-mk_to,
        function      TO &lt;status&gt;-fcode.
  IF x_header-ptfrkyexst NE space.
    PERFORM consistency_prt_frky_fields USING &apos;X&apos;.
  ENDIF.
* IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE AND
*    STATUS-ACTION NE KOPIEREN.
  IF &lt;status&gt;-prof_found &lt;&gt; space.
    CLEAR vim_pr_fields_wa.            &quot;UFprofiles
  ENDIF.
  IF vim_special_mode NE vim_upgrade AND
     temporal_delimitation_happened NE space AND
     status-action NE kopieren.
    PERFORM update_tab.
    PERFORM after_temporal_delimitation.
    CLEAR temporal_delimitation_happened.
    PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;f1_x&gt; space
                                               &lt;vim_begdate&gt;.
    IF status-action EQ hinzufuegen.
      IF function NE &apos;NEXT&apos;.
        CASE sy-subrc.
          WHEN 0.                      &quot;expanded mode or new entry
            PERFORM read_table USING nextline.
          WHEN 4.                      &quot;collapsed mode and actual entry
            READ TABLE extract WITH KEY &lt;f1_x&gt;.            &quot;#EC WARNOK
            nextline = sy-tabix.
            extract = total.
            CLEAR function.
          WHEN OTHERS.                 &quot;collapsed mode and other entry
            LOOP AT extract.                                &quot;#EC *
              CHECK &lt;vim_ext_mkey_beforex&gt; EQ &lt;vim_f1_beforex&gt; AND
                    ( vim_mkey_after_exists EQ space OR
                    &lt;vim_ext_mkey_afterx&gt; EQ &lt;vim_f1_afterx&gt; ).
              nextline = sy-tabix.
              EXIT.
            ENDLOOP.
            extract = total.
            CLEAR function.
        ENDCASE.
      ENDIF.
    ELSE.
      IF sy-subrc EQ 0.
        ADD 1 TO exind.
        nextline = exind.
      ENDIF.
    ENDIF.
  ENDIF.
* FUNCTION = OK_CODE.
  CLEAR ok_code.
  IF replace_mode NE space AND
     ( vim_special_mode NE vim_upgrade OR
       NOT function IN exted_functions ).
    PERFORM update_tab.
*   SET SCREEN 0.
    vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    EXIT.
  ELSEIF vim_special_mode EQ vim_delete.
    vim_next_screen = 0. vim_leave_screen = &apos;X&apos;. EXIT.
  ENDIF.
  IF vim_single_entry_function NE space AND function NE space.
    IF vim_single_entry_ins_key_input EQ space.
      TRANSLATE status-action USING &apos;AU&apos;. status-data = gesamtdaten.
    ENDIF.
    IF function EQ &apos;UEBE&apos;.
      function = &apos;ENDE&apos;.
    ENDIF.
  ENDIF.
  CASE function.
    WHEN &apos;ADDR&apos;.
      PERFORM address_maintain.
    WHEN &apos;AEND&apos;.
      PERFORM anzg_to_aend.
    WHEN &apos;ALCO&apos;.
      PERFORM selektiere USING transportieren.
    WHEN &apos;ALMK&apos;.
      PERFORM selektiere USING markiert.
    WHEN &apos;ALNC&apos;.
      PERFORM selektiere USING space.
    WHEN &apos;ALOE&apos;.
      PERFORM selektiere USING geloescht.
    WHEN &apos;ALNW&apos;.
      PERFORM selektiere USING neuer_eintrag.
    WHEN &apos;ANZG&apos;.
      PERFORM update_tab.
      IF l EQ 0. MOVE: 1 TO l, 1 TO &lt;status&gt;-cur_line. ENDIF.
*        SET SCREEN 0. LEAVE SCREEN.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;ATAB&apos;.
      PERFORM update_tab.
      IF l EQ 0. MOVE: 1 TO l, 1 TO &lt;status&gt;-cur_line. ENDIF.
*     SET SCREEN 0. LEAVE SCREEN.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;BCCH&apos;.                       &quot;change fix bc-set fields
      PERFORM vim_chng_fix_flds.
    WHEN &apos;BCSH&apos;.                        &quot; show fix bc-set fields
      PERFORM vim_bc_show_fix_flds.
    WHEN &apos;DELE&apos;.
*     PERFORM DETAIL_LOESCHE.
      PERFORM loeschen.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        EXIT.
      ENDIF.
    WHEN &apos;DELM&apos;.
      PERFORM delimitation.
    WHEN &apos;ENDE&apos;.
      PERFORM update_tab.
      IF l EQ 0. MOVE: 1 TO l, 1 TO &lt;status&gt;-cur_line. ENDIF.
*     SET SCREEN 0. LEAVE SCREEN.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;EXPA&apos;.
*     perform ........
    WHEN &apos;FDOC&apos;.                       &quot;HW Functiondocu
      PERFORM show_function_docu.
      CLEAR function.
*    WHEN &apos;GPRF&apos;.                       &quot;UF Profile
* choose profile
*      CLEAR: &lt;status&gt;-prof_found, vim_pr_records.
*      PERFORM get_profiles USING &lt;status&gt;-prof_found.
    WHEN &apos;KOPE&apos;.
      counter = 0.
      PERFORM kopiere.
    WHEN &apos;KOPF&apos;.
*       IF X_HEADER-ADRNBRFLAG NE SPACE.
*         PERFORM ADDRESS_MAINTAIN.
*       ENDIF.
      PERFORM kopiere_eintrag USING &lt;orig_key&gt;.
    WHEN &apos;LANG&apos;.                       &quot;SW Texttransl
      PERFORM vim_set_languages.
      CLEAR function.
    WHEN &apos;MKEZ&apos;.
      PERFORM detail_markiere.
    WHEN &apos;NEWL&apos;.
      PERFORM update_tab.
      CLEAR &lt;status&gt;-mark_only.        &quot;UFdetail
      PERFORM hinzufuegen.
    WHEN &apos;NEXT&apos;.
      PERFORM naechster.
    WHEN &apos;ORDR&apos;.
      PERFORM order_administration.
    WHEN &apos;ORGI&apos;.
      PERFORM original_holen.
    WHEN &apos;POSI&apos;.
      PERFORM popup_positionieren.
    WHEN &apos;PREV&apos;.
      PERFORM voriger.
    WHEN &apos;PRMO&apos;.
* 4.6A: obsolete, left only for individual status
      PERFORM update_tab.
      PERFORM list_alv.
    WHEN &apos;PROT&apos;.
      PERFORM logs_analyse.
    WHEN &apos;PRST&apos;.
      PERFORM update_tab.
      PERFORM list_alv.
    WHEN &apos;SAVE&apos;.
      PERFORM update_tab.
      IF status-action EQ hinzufuegen.
        SORT extract BY &lt;vim_xextract_key&gt;.                &quot;#EC WARNOK
*        READ TABLE extract WITH KEY extract BINARY SEARCH.
        READ TABLE extract WITH KEY &lt;vim_xextract_key&gt;.     &quot;#EC *
        &lt;status&gt;-cur_line = l = sy-tabix - firstline + 1.
      ENDIF.
*     SET SCREEN 0. LEAVE SCREEN.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;SCRF&apos;.
      PERFORM update_tab.
      PERFORM vim_sapscript_form_maint.
    WHEN &apos;SEAR&apos;.
      PERFORM update_tab.
      PERFORM suchen.
    WHEN &apos;SELU&apos;.
      PERFORM selektiere USING aendern.
    WHEN &apos;TEXT&apos;.
      PERFORM update_tab.
      PERFORM vim_multi_langu_text_maint.
    WHEN &apos;TREX&apos;.
      MOVE geloescht TO corr_action.
      PERFORM update_corr.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        EXIT.
      ENDIF.
    WHEN &apos;TRIN&apos;.
      MOVE hinzufuegen TO corr_action.
      PERFORM update_corr.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        EXIT.
      ENDIF.
    WHEN &apos;TRSP&apos;.
*     SET SCREEN 0. LEAVE SCREEN.
      IF x_header-cursetting NE space AND
         x_header-flag EQ vim_transport_denied.
        x_header-flag = x_header-cursetting.
        TRANSLATE x_header-flag USING &apos;X YX&apos;.
        MODIFY x_header INDEX 1.                            &quot;#EC *
      ENDIF.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;UEBE&apos;.
      PERFORM detail_back.
    WHEN &apos;UPRF&apos;.
* activate chosen profile
*      PERFORM activate_profile CHANGING &lt;status&gt;-prof_found.
      MESSAGE s175(sv).
    WHEN &apos;UNDO&apos;.
*     PERFORM DETAIL_ZURUECKHOLEN.
      PERFORM zurueckholen.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
        EXIT.
      ENDIF.
    WHEN &apos;    &apos;.
      IF vim_prt_fky_flds_updated NE space.
        CLEAR vim_prt_fky_flds_updated.
        PERFORM update_tab.
      ELSE.
        IF x_header-frm_h_flds NE space.
          PERFORM (x_header-frm_h_flds) IN PROGRAM.         &quot;#EC *
        ENDIF.
        IF neuer EQ &apos;J&apos; AND vim_key_alr_checked EQ space.
*          IF x_header-guidflag &lt;&gt; space.
*            PERFORM vim_make_guid.
*          ENDIF.
          IF x_header-frm_on_new NE space.
            PERFORM (x_header-frm_on_new) IN PROGRAM.       &quot;#EC *
          ENDIF.
        ENDIF.
        PERFORM check_key.
      ENDIF.
    WHEN OTHERS.
      IF vim_called_by_cluster NE space.                    &quot;SW Crtl ..
        CALL FUNCTION &apos;VIEWCLUSTER_NEXT_ACTION&apos;
          EXPORTING
            detail       = &apos;X&apos;
          IMPORTING
            leave_screen = vim_leave_screen
          CHANGING
            fcode        = function.
        IF vim_leave_screen NE space.
          PERFORM update_tab.
          vim_next_screen = 0.
        ENDIF.
      ENDIF.                           &quot;.. SW Ctrl
  ENDCASE.
ENDFORM.                    &quot;detail_pai

*---------------------------------------------------------------------*
*       FORM DETAIL_ZURUECKHOLEN                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM detail_zurueckholen.
  DATA: tot_ix LIKE sy-tabix, msg_type(1) TYPE c, msg_no LIKE sy-msgno,
        rc LIKE sy-subrc.
  IF x_header-delmdtflag NE space.
    counter = 1.
    PERFORM temporal_delimitation.
  ENDIF.
  IF &lt;xmark&gt; EQ markiert.
    mark_total  = mark_total - 1.
    mark_extract = mark_extract - 1.
  ENDIF.
  READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
  MOVE sy-tabix TO tot_ix.
  PERFORM logical_undelete_total USING sy-tabix.
  IF temporal_delimitation_happened NE space.
    CLEAR vim_delim_entries.
    PERFORM check_if_entry_is_to_display USING &apos;L&apos; &lt;vim_xtotal_key&gt;
                                               space &lt;vim_begdate&gt;.
    IF sy-subrc LT 8.
      vim_delim_entries-index3 = nextline.
      IF sy-subrc EQ 4.
        LOOP AT total.                                      &quot;#EC *
          CHECK &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ neuer_geloescht OR
                &lt;action&gt; EQ update_geloescht.
          CHECK &lt;vim_tot_mkey_beforex&gt; EQ &lt;vim_old_mkey_beforex&gt; AND
                ( vim_mkey_after_exists EQ space OR
                  &lt;vim_tot_mkey_afterx&gt; EQ &lt;vim_old_mkey_afterx&gt; ).
*          CHECK &lt;vim_tot_mkey_before&gt; EQ &lt;vim_old_mkey_before&gt; AND
*                ( vim_mkey_after_exists EQ space OR
*                  &lt;vim_tot_mkey_after&gt; EQ &lt;vim_old_mkey_after&gt; ).
          vim_delim_entries-index1 = sy-tabix.
          vim_delim_entries-index2 = vim_delim_entries-index3.
          EXIT.
        ENDLOOP.
      ENDIF.
      APPEND vim_delim_entries.                             &quot;#EC *
    ENDIF.
    PERFORM after_temporal_delimitation.
    CLEAR temporal_delimitation_happened.
  ELSE.
    IF replace_mode NE space AND vim_external_mode EQ space.
      extract = total.
      MODIFY extract INDEX nextline.&quot;#EC * &quot;no deletion in upgrade mode
    ELSE.
      DELETE extract INDEX nextline.                        &quot;#EC *
      SUBTRACT 1 FROM maxlines.
    ENDIF.
  ENDIF.
  IF replace_mode EQ space.
    IF counter GT 1. msg_no = &apos;002&apos;. ELSE. msg_no = &apos;003&apos;. ENDIF.
    IF ignored_entries_exist EQ space.
      msg_type = &apos;S&apos;.
    ELSE.
      msg_type = &apos;W&apos;.
    ENDIF.
    MESSAGE ID &apos;SV&apos; TYPE msg_type NUMBER msg_no WITH counter.
    IF nextline NE 1 AND nextline GT maxlines.
      nextline = maxlines.
    ENDIF.
    IF maxlines EQ 0.
      title-action = aendern.
      status-delete = nicht_geloescht.
      vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
    ELSEIF &lt;status&gt;-mark_only &lt;&gt; space.
      IF mark_extract = 0.
* last marked entry deleted
        nextline = 1.
        vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
      ELSE.
* search next marked entry
        nextline = nextline - 1.
        PERFORM get_marked_entry USING &apos;X&apos;
                    CHANGING nextline
                             rc.
        IF rc &lt;&gt; 0.
* search previous marked entry
          nextline = nextline + 1.
          PERFORM get_marked_entry USING space
                      CHANGING nextline
                               rc.
        ENDIF.
        IF rc &lt;&gt; 0.
          nextline = 1. vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
        ELSE.
          PERFORM get_page_and_position USING nextline
                                              looplines
                                        CHANGING firstline
                                                 l.
        ENDIF.
      ENDIF.
    ENDIF.
    READ TABLE total INDEX tot_ix.                          &quot;#EC *
  ELSE.
    counter = 1.
  ENDIF.
  CLEAR vim_old_viewkey.
  TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
ENDFORM.                    &quot;detail_zurueckholen

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_MARKED_ENTRY
*&amp;---------------------------------------------------------------------*
*       Search marked entries in EXTRACT beginning at index p_index
*----------------------------------------------------------------------*
*      --&gt;P_FORWARD  &apos;X&apos;: search forward
*                    &apos; &apos;: search backward
*      &lt;--P_index    in: start from here (including)
*                    out: index of first marked entry found
*      &lt;--P_RC       0: further marked entry found
*                    4: no further marked entry found
*----------------------------------------------------------------------*
FORM get_marked_entry USING    p_forward TYPE sychar01
                      CHANGING p_index LIKE sy-tabix
                               p_rc LIKE sy-subrc.
  DATA: bw_index LIKE sy-tabix.

  p_rc = 4.
  IF p_forward IS INITIAL.
* search backward
    bw_index = p_index - 1.
    WHILE bw_index &gt; 0.
      READ TABLE extract INDEX bw_index.                    &quot;#EC *
      IF &lt;xmark&gt; = markiert.
        p_index = bw_index.
        old_nl = p_index.                                   &quot;GKPR - 0001009660
        CLEAR p_rc.
        EXIT.
      ENDIF.
      bw_index = bw_index - 1.
    ENDWHILE.
  ELSE.
* search forward.
    p_index = p_index + 1.
    LOOP AT extract FROM p_index.                           &quot;#EC *
      CHECK &lt;xmark&gt; = markiert.
      p_index = sy-tabix.
      old_nl = p_index.                                     &quot;GKPR - 0001009660
      CLEAR p_rc.
      EXIT.
    ENDLOOP.
    IF p_rc &gt; 0.
      p_index = p_index - 1.
    ENDIF.
  ENDIF.
ENDFORM.                               &quot; GET_MARKED_ENTRY
*---------------------------------------------------------------------*
*       FORM NAECHSTER                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM naechster.
  DATA: last_list_pos LIKE sy-tabix, rc LIKE sy-subrc.
  IF status-action NE anzeigen AND status-action NE transportieren
  AND status-mode NE list_bild.
    PERFORM update_tab.
  ENDIF.
  IF &lt;status&gt;-mark_only = space.       &quot;ufdetail
* jump to next entry
    nextline = nextline + 1.
    IF nextline GT maxlines.
      IF status-action NE hinzufuegen.
        nextline = maxlines.
        MESSAGE s008(sv).
        EXIT.
      ELSE.
        IF status-type EQ zweistufig AND
           status-mode EQ detail_bild.
          neuer = &apos;J&apos;.
          MOVE &lt;initial&gt; TO &lt;table1&gt;.
          MOVE &lt;table1&gt; TO &lt;vim_extract_struc&gt;.
          IF x_header-bastab NE space AND x_header-texttbexst NE space.
            MOVE: &lt;text_initial_x&gt; TO &lt;table1_xtext&gt;,
                 &lt;table1_xtext&gt; TO &lt;vim_xextract_text&gt;.
*            MOVE: &lt;text_initial_x&gt; TO &lt;table1_text&gt;,
*                  &lt;table1_text&gt; TO &lt;extract_text&gt;.
          ENDIF.
          nextline = maxlines + 1.
        ELSE.
          nextline = nextline - 1.
          MESSAGE s008(sv).
        ENDIF.
      ENDIF.
    ENDIF.
  ELSE.                                &quot;ufdetailb
* jump to next marked entry
    PERFORM get_marked_entry USING &apos;X&apos;
                             CHANGING nextline
                                      rc.
    IF rc &lt;&gt; 0.
      MESSAGE s830(sv).
*   Letzter markierter Eintrag bereits erreicht.
      EXIT.
    ENDIF.
  ENDIF.                               &quot;ufdetaile
  IF looplines = 0.
* coming from lower viewcluster-node
    l = nextline - firstline + 1.
    MOVE l TO &lt;status&gt;-cur_line.
  ELSEIF looplines = 1.
    firstline = l = 1.
    MOVE: firstline TO &lt;status&gt;-firstline,
          l         TO &lt;status&gt;-cur_line.
  ELSEIF looplines &gt; 1.
    IF status-mode EQ detail_bild.
      last_list_pos = firstline + looplines - 1.
      IF nextline GT last_list_pos.
        IF &lt;status&gt;-mark_only = space. &quot;ufdetail
          firstline = firstline + looplines - 1.
          l = 2.
        ELSE.                          &quot;ufdetailb
          PERFORM get_page_and_position USING nextline
                                              looplines
                                        CHANGING firstline
                                                 l.
        ENDIF.                         &quot;ufdetaile
        MOVE: firstline TO &lt;status&gt;-firstline,
              l         TO &lt;status&gt;-cur_line.
      ELSE.
        IF status-mode NE list_bild.
          l = nextline - firstline + 1.
          MOVE l TO &lt;status&gt;-cur_line.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;naechster
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SET_MARK_ONLY
*&amp;---------------------------------------------------------------------*
*       Sets status flag if entry with index p_index is marked.
*----------------------------------------------------------------------*
*      --&gt;P_index  EXTRACT-index
*----------------------------------------------------------------------*
FORM set_mark_only USING    p_index LIKE sy-tabix.
  DATA: rc LIKE sy-subrc.
  PERFORM check_marked USING p_index
                       CHANGING rc.
  IF rc = 0.
    &lt;status&gt;-mark_only = &apos;X&apos;.
  ENDIF.
ENDFORM.                               &quot; SET_MARK_ONLY
*---------------------------------------------------------------------*
*       FORM PROCESS_DETAIL_SCREEN                                    *
*---------------------------------------------------------------------*
* process detail screen call                                          *
*---------------------------------------------------------------------*
* ---&gt; MODE - C -&gt; call mode (CALL SCREEN), S -&gt; set mode (SET SCREEN)*
*---------------------------------------------------------------------*
FORM process_detail_screen USING value(mode) TYPE c.
  DATA: modulpool LIKE trdir-name,                          &quot;#EC NEEDED
        no_input_happened(1) TYPE c,                       &quot;#EC NEEDED
        state_action(1) TYPE c.                                  &quot;#EC NEEDED
  IF detail NE &apos;0000&apos;.
    IF mode EQ &apos;S&apos;.
      SET SCREEN detail.
      LEAVE SCREEN.
    ELSE.
      PERFORM vim_imp_call_screen USING detail.
    ENDIF.
  ELSE.
    RAISE detail_scr_nbr_missing.                           &quot;#EC FB_RAIS_EX
  ENDIF.
ENDFORM.                    &quot;process_detail_screen
*---------------------------------------------------------------------*
*       FORM VORIGER                                                  *
*---------------------------------------------------------------------*
*       NEXTLINE:   Index of current entry in table EXTRACT
*       FIRSTLINE:  EXTRACT-index of first line shown on list screen
*       L:          Line number of list screen, where entry was chosen
*                   via F2
*       LOOPLINES:  Number of step loop lines in list screen
*---------------------------------------------------------------------*
FORM voriger.
  DATA: rc LIKE sy-subrc, n TYPE i.

  IF status-action NE anzeigen AND status-action NE transportieren
  AND status-mode NE list_bild.
    PERFORM update_tab.
  ENDIF.
  IF &lt;status&gt;-mark_only = space.       &quot;ufdetail
* jump to previous entry
    nextline = nextline - 1.
    IF nextline LE 0.
      nextline = 1.
      MESSAGE s007(sv).
    ELSEIF nextline LT firstline.
* scroll upwards
      IF looplines &gt; firstline.
* bumping into top of EXTRACT
        firstline = 1.
        l = nextline.
      ELSE.
        firstline = firstline - looplines + 1.
        l = looplines - 1.
      ENDIF.
      MOVE: firstline TO &lt;status&gt;-firstline,
           l         TO &lt;status&gt;-cur_line.
    ELSE.
      l = nextline - firstline + 1.
      MOVE l TO &lt;status&gt;-cur_line.
    ENDIF.
  ELSE.                                &quot;ufdetailb
* jump to previous marked entry
    n = nextline DIV ( looplines - 1 ).
    PERFORM get_marked_entry USING space
                             CHANGING nextline rc.
    IF rc &gt; 0.
      MESSAGE s831(sv).
*   Erster markierter Eintrag bereits erreicht.
    ELSE.
      IF nextline LT firstline.
        PERFORM get_page_and_position USING nextline
                                            looplines
                                      CHANGING firstline
                                               l.
        MOVE: firstline TO &lt;status&gt;-firstline,
              l         TO &lt;status&gt;-cur_line.
      ELSE.
        l = nextline - firstline + 1.
        MOVE l TO &lt;status&gt;-cur_line.
      ENDIF.
    ENDIF.
  ENDIF.                               &quot;ufdetaile
ENDFORM.                    &quot;voriger
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CHECK_MARKED
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_P_INDEX  text
*      &lt;--P_RC  text
*----------------------------------------------------------------------*
FORM check_marked USING    p_index LIKE sy-tabix
                  CHANGING p_rc LIKE sy-subrc.

  p_rc = 4.
  READ TABLE extract INDEX p_index.                         &quot;#EC *
  IF sy-subrc = 0 AND &lt;xmark&gt; = markiert. CLEAR p_rc. ENDIF.
ENDFORM.                               &quot; CHECK_MARKED
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PAGE_AND_POSITION
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LINE      line in EXTRACT
*      --&gt;P_LOOPLINES # lines in list screen
*      &lt;--P_FIRST     number of first line in list screen
*      &lt;--P_PAGELINE  number of line no. P_LINE in list screen
*----------------------------------------------------------------------*
FORM get_page_and_position USING    p_line LIKE sy-tabix
                                    p_looplines LIKE sy-tabix
                           CHANGING p_first LIKE sy-tabix
                                    p_pageline LIKE sy-tabix.
  DATA: m TYPE i.
  m = p_line DIV ( p_looplines - 1 ).
  p_first = m * ( p_looplines - 1 ) + 1.
  p_pageline = p_line MOD ( p_looplines - 1 ).
ENDFORM.                               &quot; GET_PAGE_AND_POSITION

*---------------------------------------------------------------------*
*       FORM  VIM_MODIFY_DETAIL_SCREEN                                *
*---------------------------------------------------------------------*
* Modifizieren der Screen-Attribute für das Detailbild                *
*---------------------------------------------------------------------*
FORM vim_modify_detail_screen.

  DATA: dummyflag TYPE xfeld.


* dataset locked by key-specific synchronizer lock?
  IF vim_sync_keyspec_check NE space.
    PERFORM check_sync_key_lock USING &apos; &apos;
                                CHANGING vim_sync_key_lock.
  ENDIF.
  CLEAR vim_set_from_bc_pbo.
* dataset from BC-set? --&gt; get field parameters
  IF replace_mode = space AND status-action = aendern
   AND vim_bc_chng_allowed = space.    &quot;force changeability
    READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
*Start of note 1452305 PATIDARP
*     WITH TABLE KEY viewname = x_header-viewname
      WITH TABLE KEY viewname = x_header-maintview
     keys = &lt;vim_xextract_key&gt;.
*End of note 1452305 PATIDARP
    IF sy-subrc = 0.
      vim_set_from_bc_pbo = &apos;X&apos;.
    ENDIF.
  ENDIF.
  LOOP AT SCREEN.
    SPLIT screen-name AT &apos;-&apos; INTO vim_object vim_objfield. &quot;Subviews ..
    IF status-action EQ anzeigen OR status-action EQ transportieren OR
       status-delete EQ geloescht.
      screen-input = &apos;0&apos;.
    ELSE.
      IF screen-group1 EQ &apos;KEY&apos; AND screen-required NE 0 AND
         screen-input NE &apos;0&apos;.
        screen-input = &apos;0&apos;.
      ENDIF.
      IF status-action EQ hinzufuegen OR
         status-action EQ kopieren.
        IF neuer CO &apos;XJ&apos; .
          IF screen-group1 EQ &apos;KEY&apos;.
            IF ( vim_single_entry_function NE &apos;INS&apos; OR
                 vim_single_entry_ins_key_input NE space ) AND
               ( x_header-existency NE &apos;M&apos; OR
                 screen-name EQ vim_enddate_name ).
              screen-input = &apos;1&apos;.
            ENDIF.
            IF vim_single_entry_function EQ &apos;INS&apos;.
              screen-request = &apos;1&apos;. sy-subrc = 8.
            ENDIF.
          ENDIF.
          IF vim_special_mode EQ vim_upgrade AND function NE &apos;DELE&apos;.
            IF &lt;status&gt;-prof_found = vim_pr_into_view &quot;UFprofiles begin
             AND screen-group1 = &apos;KEY&apos;.
              PERFORM set_profile_key_attributes USING vim_objfield
                                                 CHANGING screen-input
                                                     vim_modify_screen.
              CLEAR vim_modify_screen.
            ENDIF.                     &quot;UFprofiles end
            screen-request = &apos;1&apos;. sy-subrc = 8.
          ENDIF.
        ENDIF.
        IF vim_pr_activating &lt;&gt; space.
          IF screen-required = &apos;1&apos;.
* obligatory fields shall not stop profile import
            screen-required = &apos;0&apos;.     &quot;UFprofile
          ENDIF.
        ENDIF.
      ELSE.
        IF replace_mode NE space.
          CASE vim_special_mode.
            WHEN vim_replace.
              IF screen-name EQ sel_field_for_replace_l.
                screen-request = &apos;1&apos;. sy-subrc = 8.
                IF screen-invisible = &apos;1&apos;.
                  screen-input = &apos;1&apos;.
                ENDIF.
              ENDIF.
            WHEN vim_upgrade.
              IF NOT function IN exted_functions.
                screen-request = &apos;1&apos;. sy-subrc = 8.
              ENDIF.
*             screen-input = &apos;1&apos;.
          ENDCASE.
        ELSE.
          IF vim_special_mode EQ vim_delete.
            screen-input = &apos;0&apos;.
          ENDIF.
          IF x_header-delmdtflag NE space AND
             x_header-existency EQ &apos;U&apos; AND
             screen-name EQ vim_begdate_name.
            screen-input = &apos;0&apos;.
          ENDIF.
        ENDIF.
        IF status-action = aendern AND neuer &lt;&gt; &apos;J&apos;.
* Dataset locked by key-specific synchronizer lock?
          IF vim_sync_key_lock NE space AND screen-group1 &lt;&gt; &apos;KEY&apos; AND
                                            screen-name NE &apos;VIM_MARKED&apos;.
            screen-input = 0.
            vim_modify_screen  = &apos;X&apos;.
          ENDIF.
          IF vim_set_from_bc_pbo &lt;&gt; space.
* Dataset comes from BC-set -&gt; check field parameter
            PERFORM vim_bc_logs_use USING    vim_objfield
                                             vim_bc_entry_list_wa
                                    CHANGING screen
                                             dummyflag.
          ENDIF.
        ENDIF.
      ENDIF. &quot;status-action EQ hinzufuegen OR status-action EQ kopieren.
    ENDIF.
    IF &lt;xmark&gt; EQ markiert AND &lt;status&gt;-mark_only = space. &quot;ufdetail
      screen-intensified = &apos;1&apos;.
    ENDIF.
    IF vim_objfield &lt;&gt; space AND vim_object = x_header-maintview.
      LOOP AT x_namtab WHERE viewfield = vim_objfield AND
                             ( texttabfld = space OR keyflag = space ).&quot;#EC *
        IF x_namtab-readonly = vim_hidden.
          screen-active = &apos;0&apos;.
        ELSEIF x_namtab-readonly = rdonly.
          screen-input = &apos;0&apos;.
        ENDIF.
        EXIT.
      ENDLOOP.
    ENDIF.                                   &quot;.. Subviews
    MODIFY SCREEN.
  ENDLOOP.
ENDFORM.                               &quot;vim_modify_detail_screen</include_source>
   </include>
   <include NAME="LSVIMFX3" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMFX3                                                   *
*----------------------------------------------------------------------*
*&amp;--------------------------------------------------------------------*
*&amp;      Form LIST_ALV                                               *
*&amp;--------------------------------------------------------------------*
* D_VIA_SELECTION_SCREEN --&gt; X - mit Selektion, &apos; &apos; - Standardliste   *
*&amp;--------------------------------------------------------------------*
FORM list_alv.

*  STATICS: vim_alv_fcat TYPE slis_t_fieldcat_alv,  --&gt; global
*           alv_events TYPE slis_t_event,
*           alv_layout TYPE slis_layout_alv.
  STATICS: texttab_begin LIKE sy-tabix,
           textlen TYPE intlen, unittab TYPE tabname,
           unitname TYPE fieldname, cukytab TYPE tabname,
           cukyname TYPE fieldname,
           glob_unitvalue(3) TYPE c,    &quot;vim_unit,UF296573/2000
           glob_cukyvalue TYPE vim_cuky.
  DATA: textfld_no, textoffset TYPE intlen, rc LIKE sy-subrc,    &quot;#EC NEEDED
        progname LIKE sy-repid, value_len TYPE intlen,           &quot;#EC NEEDED
        w_alv_value_tab TYPE tabl8000.
  FIELD-SYMBOLS: &lt;alv_fcat&gt; LIKE LINE OF vim_alv_fcat,
                 &lt;textfields&gt;.                              &quot;#EC NEEDED

  IF x_header-frm_bf_prn &lt;&gt; space.
* old user exit for printing still used
    PERFORM drucken_ztp_alt.
    EXIT.
  ENDIF.
  IF NOT vim_alv_fcat[] IS INITIAL.
    READ TABLE vim_alv_fcat ASSIGNING &lt;alv_fcat&gt; INDEX 1.
    IF &lt;alv_fcat&gt;-ref_tabname &lt;&gt; view_name.
      UNASSIGN &lt;alv_fcat&gt;. FREE vim_alv_fcat.
    ENDIF.
  ENDIF.
  IF vim_alv_fcat[] IS INITIAL.
* build up field catalogue from X_NAMTAB
    PERFORM fill_alv_fieldcat CHANGING vim_alv_fcat
                                       texttab_begin
                                       vim_alv_value_length
                                       unittab
                                       unitname
                                       glob_unitvalue
                                       cukytab
                                       cukyname
                                       glob_cukyvalue.
    PERFORM define_alv_callbacks CHANGING vim_alv_events.
    PERFORM make_list_commentary USING unittab
                                       unitname
                                       glob_unitvalue
                                       cukytab
                                       cukyname
                                       glob_cukyvalue
                                 CHANGING vim_list_header.
    PERFORM make_alv_layout CHANGING vim_alv_layout
                                     vim_alv_print.
    PERFORM init_alv_variant CHANGING vim_var_save
                                      vim_var_default
                                      vim_alv_variant.
    vim_alv_called_by = &apos;VIM_CALL_ALV&apos;.
*    REFRESH: vim_alv_excluding, vim_alv_special_groups,
*             vim_alv_sort, vim_alv_event_exit.
*    CLEAR:   vim_alv_print, vim_alv_sel_hide.
  ENDIF.                               &quot;new structure table
  REFRESH alv_value_tab.
  IF status-mode = list_bild.
* Build ALV_VALUE_TAB
    LOOP AT extract.
      w_alv_value_tab = &lt;vim_xextract&gt;.
*    LOOP AT extract ASSIGNING &lt;extract_line&gt;.
*      alv_value_tab = &lt;extract_line&gt;.
      APPEND w_alv_value_tab TO alv_value_tab.
    ENDLOOP.
  ELSE.
* Build VALUE_TAB with single line
    w_alv_value_tab = &lt;vim_xextract&gt;.
*    alv_value_tab = extract.
    APPEND w_alv_value_tab TO alv_value_tab.
  ENDIF.
  IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
* table and texttable
    textlen = x_header-aft_txttbc - x_header-aft_txtkc.
*  IF x_header-bastab = space OR x_header-texttbexst = space
*   OR x_header-maintview NE x_header-viewname.
* no table &amp; texttable
*    CLEAR textlen.
*  ENDIF.
*  IF textlen &lt;&gt; 0.
* Shift fields
    PERFORM maintain_alv_value_tab_text USING    textlen.
  ELSE.
    vim_alv_value_length = x_header-tablen.
  ENDIF.
  IF x_header-frm_bf_alv &lt;&gt; space.
    PERFORM (x_header-frm_bf_alv) IN PROGRAM (sy-repid).
* Release 6.10(Unicode): alv_value_tab has got type RAW!
* useful parameters:
*   vim_alv_value_length     int. length of dataset in alv_value_tab
*   vim_alv_called_by        form routine calling FM ALV_LIST_DISPLAY
*                            preset value: &apos;VIM_CALL_ALV&apos;
*   alv_value_tab[]          internal table containing values
*   vim_alv_fcat[]     \
*   vim_alv_events[]    |
*   vim_list_header[]   &gt;    preset by view-maintenance
*   vim_alv_variant     |
*   vim_alv_layout     /
    CHECK NOT alv_value_tab[] IS INITIAL. &quot;suppress list
  ENDIF.
  PERFORM check_list_before_alv CHANGING rc.
  CHECK rc = 0.
  progname = sy-repid.
  CALL FUNCTION &apos;REUSE_ALV_TABLE_CREATE&apos;
    EXPORTING
      it_fieldcat        = vim_alv_fcat
      i_callback_program = progname
      i_formname         = vim_alv_called_by.
  FREE alv_value_tab.
ENDFORM.                               &quot; LIST_ALV

*&amp;--------------------------------------------------------------------*
*&amp;      Form DRUCKEN_ZTP_ALT                                          *
*&amp;--------------------------------------------------------------------*
* Keeps compatibility of view maintenance dialogs using old user exit
* &quot;before printing&quot;
* D_VIA_SELECTION_SCREEN --&gt; X - mit Selektion, &apos; &apos; - Standardliste   *
*&amp;--------------------------------------------------------------------*
FORM drucken_ztp_alt.
  DATA: rc_safe LIKE sy-subrc, texttab_begin LIKE sy-tabix, x TYPE i, &quot;#EC NEEDED
        entifct_begin LIKE sy-tabix, len TYPE i,
        after_text_assigned TYPE c, hname LIKE d021s-fnam. &quot;#EC NEEDED
  DATA: fcat_entry TYPE slis_fieldcat_alv, i TYPE i, &quot;#EC NEEDED
        cukytab TYPE tabname, unittab TYPE tabname, rc LIKE sy-subrc,
        cukyname TYPE fieldname, unitname TYPE fieldname,
        cukyvalue TYPE vim_cuky, unitvalue TYPE vim_unit,
        length TYPE doffset, cukylength TYPE doffset,
        fcat_entry2 TYPE slis_fieldcat_alv, progname LIKE sy-repid, &quot;#EC NEEDED
        alv_called_by TYPE char30 VALUE &apos;VIM_CALL_ALV&apos;.
  FIELD-SYMBOLS: &lt;before_text&gt;, &lt;text&gt;, &lt;after_text&gt;,       &quot;#EC NEEDED
                 &lt;cuky&gt;, &lt;unit&gt;,
                 &lt;value&gt; TYPE tabl8000, &lt;w_value_tab_x&gt; TYPE x.

  CLEAR structure_table.
  DESCRIBE TABLE structure_table.
  IF sy-tfill NE 0. READ TABLE structure_table INDEX 1. ENDIF.
  IF structure_table-tabname NE view_name.
    CALL FUNCTION &apos;VIEW_GET_FIELDTAB&apos;
      EXPORTING
        view_name = view_name
      TABLES
        fieldtab  = structure_table.
    IF x_header-bastab NE space AND x_header-texttbexst NE space
       AND x_header-maintview = x_header-viewname.           &quot;Subviews
* einfügen text-felder in structure_table hinter entity-key
      LOOP AT x_namtab WHERE texttabfld NE space
                         AND keyflag NE space.
        texttab_begin = sy-tabix.
        EXIT.
      ENDLOOP.
      LOOP AT x_namtab WHERE texttabfld EQ space
                         AND keyflag EQ space.
        entifct_begin = sy-tabix.
        EXIT.
      ENDLOOP.
      IF sy-subrc NE 0.  &quot;no entifct fields -&gt; delete text key fields
        LOOP AT structure_table FROM texttab_begin
                                WHERE keyflag NE space.
          DELETE structure_table.
        ENDLOOP.
      ELSE.
        WHILE sy-subrc EQ 0.
          LOOP AT structure_table FROM texttab_begin.
            DELETE structure_table.
            IF structure_table-keyflag EQ space.
              EXIT.
            ENDIF.
          ENDLOOP.
          IF sy-subrc EQ 0.
            INSERT structure_table INDEX entifct_begin.
            ADD: 1 TO entifct_begin, 1 TO texttab_begin.
          ENDIF.
        ENDWHILE.
      ENDIF.
* aktualisieren von offset und position in structure_table
      len = 0.
      LOOP AT structure_table.
        structure_table-offset = len.
        structure_table-position = sy-tabix.
* Alignment
        IF &apos;CNDT&apos; CS structure_table-inttype.
* Character-like datatypes
          x = ( structure_table-offset
                + cl_abap_char_utilities=&gt;charsize )
                MOD cl_abap_char_utilities=&gt;charsize.
          IF x NE 0.
            structure_table-offset = structure_table-offset
                               + cl_abap_char_utilities=&gt;charsize - x.
          ENDIF.
        ELSE.
          CASE structure_table-datatype.
            WHEN &apos;INT2&apos; OR &apos;PREC&apos;.
              x = ( structure_table-offset + 2 ) MOD 2.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 2 - x.
              ENDIF.
            WHEN &apos;INT4&apos;.
              x = ( structure_table-offset + 4 ) MOD 4.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 4 - x.
              ENDIF.
            WHEN &apos;FLTP&apos;.
              x = ( structure_table-offset + 8 ) MOD 8.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 8 - x.
              ENDIF.
          ENDCASE.
        ENDIF.
        MODIFY structure_table.
        len = structure_table-offset + structure_table-intlen.
      ENDLOOP.
    ENDIF.                             &quot;table with texttable
    IF x_header-hiddenflag NE space.   &quot;hidden fields exist
* ignore hidden fields
      LOOP AT x_namtab WHERE readonly EQ vim_hidden OR
       domname IN vim_guid_domain.
        LOOP AT structure_table WHERE fieldname EQ x_namtab-viewfield.
          DELETE structure_table.
          EXIT.
        ENDLOOP.
      ENDLOOP.
* aktualisieren von offset und position in structure_table
      len = 0.
      LOOP AT structure_table.
        structure_table-offset = len.
        structure_table-position = sy-tabix.
        IF &apos;CNDT&apos; CS structure_table-inttype.
* Character-like datatypes
          x = ( structure_table-offset
                + cl_abap_char_utilities=&gt;charsize )
                MOD cl_abap_char_utilities=&gt;charsize.
          IF x NE 0.
            structure_table-offset = structure_table-offset
                               + cl_abap_char_utilities=&gt;charsize - x.
          ENDIF.
        ELSE.
          CASE structure_table-datatype.
            WHEN &apos;INT2&apos; OR &apos;PREC&apos;.
              x = ( structure_table-offset + 2 ) MOD 2.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 2 - x.
              ENDIF.
            WHEN &apos;INT4&apos;.
              x = ( structure_table-offset + 4 ) MOD 4.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 4 - x.
              ENDIF.
            WHEN &apos;FLTP&apos;.
              x = ( structure_table-offset + 8 ) MOD 8.
              IF x NE 0.
                structure_table-offset = structure_table-offset + 8 - x.
              ENDIF.
          ENDCASE.
        ENDIF.
        MODIFY structure_table.
        len = structure_table-offset + structure_table-intlen.
      ENDLOOP.
    ENDIF.                             &quot;hidden fields exist
  ENDIF.                               &quot;new structure table
* Aufbau der Value_tab
  ASSIGN value_tab TO &lt;w_value_tab_x&gt; CASTING.
  IF x_header-bastab NE space AND x_header-texttbexst NE space
                                       &quot;base table with text table
     AND x_header-maintview = x_header-viewname.
    CLEAR value_tab.
    IF status-mode EQ list_bild.
      LOOP AT extract.
        PERFORM build_valtab_hfields.
      ENDLOOP.
    ELSE.
      PERFORM build_valtab_hfields.
    ENDIF.
*    ENDIF.
  ELSE.
* view or base table without text table and user exits exists or hidden
* fields exist
    CLEAR value_tab.
    IF x_header-hiddenflag EQ space AND&quot;no hidden fields
       x_header-fieldorder EQ space.   &quot;Subviews /untersch. Feldreihenf.
      IF status-mode EQ list_bild.
        LOOP AT extract.
          MOVE &lt;vim_xextract&gt; TO &lt;w_value_tab_x&gt;(x_header-tablen).
*          MOVE extract TO value_tab(tablen).
          APPEND value_tab.
        ENDLOOP.
      ELSE.
        MOVE &lt;vim_xextract&gt; TO &lt;w_value_tab_x&gt;(x_header-tablen).
*        MOVE extract TO value_tab(tablen).
        APPEND value_tab.
      ENDIF.
    ELSE. &quot;hidden fields exist -&gt; move field by field
      IF status-mode EQ list_bild.
        LOOP AT extract.
          PERFORM build_valtab_hfields.
        ENDLOOP.
      ELSE.
        PERFORM build_valtab_hfields.
      ENDIF.
    ENDIF.
  ENDIF.                               &quot;base table with text_table.
  IF x_header-frm_bf_prn NE space.     &quot;user exit exists
* perform user exit
    PERFORM (x_header-frm_bf_prn) IN PROGRAM (sy-repid).
  ENDIF.
  CHECK NOT value_tab[] IS INITIAL.    &quot;suppress list
************************************************************************
* Build up ALV fieldcatalogue from STRUCTURE
  REFRESH vim_alv_fcat.
  LOOP AT structure_table.
    CLEAR fcat_entry.
    PERFORM conv_dfies_fcat USING structure_table
                                  sy-tabix
                            CHANGING fcat_entry.
    APPEND fcat_entry TO vim_alv_fcat.
  ENDLOOP.
  length = structure_table-offset + structure_table-intlen.
* consider CUKY or UNIT fields.......
  DESCRIBE TABLE vim_alv_fcat LINES i.
  LOOP AT vim_alv_fcat INTO fcat_entry WHERE datatype = &apos;CURR&apos;
   OR datatype = &apos;QUAN&apos;.
    CASE fcat_entry-datatype.
      WHEN &apos;CURR&apos;.
        READ TABLE x_namtab WITH KEY viewfield = fcat_entry-cfieldname
            TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
* try to get global currency field
          READ TABLE x_namtab WITH KEY viewfield = fcat_entry-fieldname.
          cukytab = x_namtab-reftable.
          cukyname = x_namtab-reffield.
          CONCATENATE x_namtab-reftable &apos;-&apos; x_namtab-reffield
                  INTO hname.
          ASSIGN (hname) TO &lt;cuky&gt;.
          IF sy-subrc = 0.
* global currency key exists to be inserted in value table
            fcat_entry-currency = cukyvalue = &lt;cuky&gt;.
          ENDIF.
        ENDIF.
      WHEN &apos;QUAN&apos;.
        READ TABLE x_namtab WITH KEY viewfield = fcat_entry-qfieldname
            TRANSPORTING NO FIELDS.
        IF sy-subrc &lt;&gt; 0.
* try to get global quantity field
          READ TABLE x_namtab WITH KEY viewfield = fcat_entry-fieldname.
          unittab = x_namtab-reftable.
          unitname = x_namtab-reffield.
          CONCATENATE x_namtab-reftable &apos;-&apos; x_namtab-reffield
                  INTO hname.
          ASSIGN (hname) TO &lt;unit&gt;.
          IF sy-subrc = 0.
* global unit key exists to be inserted in value table
            fcat_entry-quantity = unitvalue = &lt;unit&gt;.
          ENDIF.
        ENDIF.
    ENDCASE.
    MODIFY vim_alv_fcat FROM fcat_entry.
  ENDLOOP.
  REFRESH alv_value_tab.
  LOOP AT value_tab.
    APPEND &lt;w_value_tab_x&gt; TO alv_value_tab.
  ENDLOOP.
*  APPEND LINES OF value_tab TO alv_value_tab.
  FREE value_tab.
  IF NOT cukyname IS INITIAL.
* Append global currency to value_tab
    LOOP AT alv_value_tab ASSIGNING &lt;value&gt;.
      &lt;value&gt;+length = cukyvalue.
    ENDLOOP.
    length = length + cukylength.
  ENDIF.
  IF NOT unitname IS INITIAL.
* Append global unit to value_tab
    LOOP AT alv_value_tab ASSIGNING &lt;value&gt;.
      &lt;value&gt;+length = unitvalue.
    ENDLOOP.
  ENDIF.
  PERFORM define_alv_callbacks CHANGING vim_alv_events.
  PERFORM make_list_commentary USING unittab
                                     unitname
                                     unitvalue
                                     cukytab
                                     cukyname
                                     cukyvalue
                               CHANGING vim_list_header.
  PERFORM make_alv_layout CHANGING vim_alv_layout
                                   vim_alv_print.
  PERFORM init_alv_variant CHANGING vim_var_save
                                    vim_var_default
                                    vim_alv_variant.
  progname = sy-repid.
  PERFORM check_list_before_alv CHANGING rc.
  CHECK rc = 0.
  CALL FUNCTION &apos;REUSE_ALV_TABLE_CREATE&apos;
    EXPORTING
      it_fieldcat        = vim_alv_fcat
      i_callback_program = progname
      i_formname         = alv_called_by.
  FREE alv_value_tab.
*  if sy-subrc ne 0. raise print_error. endif.
ENDFORM.                               &quot; DRUCKEN_ZTP_ALT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  MAKE_LIST_COMMENTARY
*&amp;---------------------------------------------------------------------*
*       Build up list header
*----------------------------------------------------------------------*
*      &lt;--P_LIST_COMMENTARY  text
*----------------------------------------------------------------------*
FORM make_list_commentary USING p_unittab TYPE tabname
                                p_unitname TYPE fieldname
                                p_unitvalue TYPE any
                                                &quot;vim_unitUF296573/2000
                                p_cukytab TYPE tabname
                                p_cukyname TYPE fieldname
                                p_cukyvalue TYPE vim_cuky
                       CHANGING p_list_header TYPE slis_t_listheader.
  DATA: h_header TYPE slis_listheader,
        text(40), w_dfies TYPE dfies.                        &quot;#EC NEEDED

  REFRESH p_list_header.
  h_header-typ = &apos;H&apos;.
  h_header-info = x_header-ddtext.
  APPEND h_header TO p_list_header.
  h_header-typ = &apos;S&apos;.
  IF x_header-bastab NE space AND x_header-texttbexst NE space
   AND x_header-maintview = x_header-viewname.
    h_header-key = svim_text_p01.
  ELSE.
    h_header-key = svim_text_p02.
  ENDIF.
  h_header-info = x_header-viewname.
  APPEND h_header TO p_list_header.
  IF x_header-clidep &lt;&gt; space.
    h_header-key = svim_text_p03.
    h_header-info = sy-mandt.
    APPEND h_header TO p_list_header.
  ENDIF.
  IF p_unitname &lt;&gt; space.
    CLEAR h_header.
    h_header-typ = &apos;S&apos;.
    PERFORM vim_get_reffield_alv USING p_unitname
                                       p_unittab
                                  CHANGING w_dfies.
    IF w_dfies &lt;&gt; space.
      IF w_dfies-scrtext_m &lt;&gt; space.
        h_header-key = w_dfies-scrtext_m(20).
      ELSE.
        IF w_dfies-scrtext_l &lt;&gt; space.
          h_header-key = w_dfies-scrtext_l(20).
        ELSE.
          IF w_dfies-scrtext_s &lt;&gt; space.
            h_header-key = w_dfies-scrtext_s(10).
          ELSE.
            IF w_dfies-reptext &lt;&gt; space.
              h_header-key = w_dfies-reptext(20).
            ELSE.
              h_header-key = w_dfies-fieldname.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    h_header-info = p_unitvalue.
    APPEND h_header TO p_list_header.
  ENDIF.
  IF p_cukyname &lt;&gt; space.
    CLEAR h_header.
    h_header-typ = &apos;S&apos;.
    PERFORM vim_get_reffield_alv USING p_cukyname
                                       p_cukytab
                                  CHANGING w_dfies.
    IF w_dfies &lt;&gt; space.
      IF w_dfies-scrtext_m &lt;&gt; space.
        h_header-key = w_dfies-scrtext_m(20).
      ELSE.
        IF w_dfies-scrtext_l &lt;&gt; space.
          h_header-key = w_dfies-scrtext_l(20).
        ELSE.
          IF w_dfies-scrtext_s &lt;&gt; space.
            h_header-key = w_dfies-scrtext_s(10).
          ELSE.
            IF w_dfies-reptext &lt;&gt; space.
              h_header-key = w_dfies-reptext(20).
            ELSE.
              h_header-key = w_dfies-fieldname.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    h_header-info = p_cukyvalue.
    APPEND h_header TO p_list_header.
  ENDIF.
ENDFORM.                               &quot; MAKE_LIST_COMMENTARY
*&amp;---------------------------------------------------------------------*
*&amp;      Form  DEFINE_ALV_CALLBACKS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_ALV_EVENTS  text
*----------------------------------------------------------------------*
FORM define_alv_callbacks CHANGING p_alv_events TYPE slis_t_event.
  DATA: h_event TYPE slis_alv_event.
  CONSTANTS: formname_top_of_list TYPE slis_formname
             VALUE &apos;ALV_TOP_OF_LIST&apos;,
             formname_top_of_page TYPE slis_formname
             VALUE &apos;ALV_TOP_OF_PAGE&apos;,
             formname_end_of_page TYPE slis_formname
             VALUE &apos;ALV_END_OF_PAGE&apos;,
             formname_end_of_list TYPE slis_formname
             VALUE &apos;ALV_END_OF_LIST&apos;.
  REFRESH p_alv_events.
  CALL FUNCTION &apos;REUSE_ALV_EVENTS_GET&apos;
    EXPORTING
      i_list_type = 0
    IMPORTING
      et_events   = p_alv_events.
* define TOP_OF_LIST event
  READ TABLE p_alv_events WITH KEY name = slis_ev_top_of_list
                           INTO h_event.
  IF sy-subrc = 0.
    h_event-form = formname_top_of_list.
    APPEND h_event TO p_alv_events.
  ENDIF.
* define TOP_OF_PAGE event
  READ TABLE p_alv_events WITH KEY name = slis_ev_top_of_page
                           INTO h_event.
  IF sy-subrc = 0.
    h_event-form = formname_top_of_page.
    APPEND h_event TO p_alv_events.
  ENDIF.
* define END_OF_PAGE event
  READ TABLE p_alv_events WITH KEY name = slis_ev_end_of_page
                           INTO h_event.
  IF sy-subrc = 0.
    h_event-form = formname_end_of_page.
    APPEND h_event TO p_alv_events.
  ENDIF.
* define END_OF_LIST event
  READ TABLE p_alv_events WITH KEY name = slis_ev_end_of_list
                           INTO h_event.
  IF sy-subrc = 0.
    h_event-form = formname_end_of_list.
    APPEND h_event TO p_alv_events.
  ENDIF.
ENDFORM.                    &quot;define_alv_callbacks

*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALV_TOP_OF_LIST
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM alv_top_of_list.
  CALL FUNCTION &apos;REUSE_ALV_COMMENTARY_WRITE&apos;
    EXPORTING
      it_list_commentary = vim_list_header.

ENDFORM.                               &quot; ALV_TOP_OF_LIST
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALV_TOP_OF_PAGE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM alv_top_of_page.
  WRITE AT (sy-linsz) sy-datum RIGHT-JUSTIFIED.
ENDFORM.                               &quot; ALV_TOP_OF_PAGE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALV_END_OF_PAGE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM alv_end_of_page.
  WRITE AT (sy-linsz) sy-pagno CENTERED.
ENDFORM.                               &quot; ALV_END_OF_PAGE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  MAKE_ALV_LAYOUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_ALV_LAYOUT  text
*----------------------------------------------------------------------*
FORM make_alv_layout CHANGING p_alv_layout TYPE slis_layout_alv
                              p_alv_print  TYPE slis_print_alv.
* screen layout
  CLEAR p_alv_layout.
  p_alv_layout-colwidth_optimize = &apos;X&apos;.
  p_alv_layout-f2code = &apos;&amp;ETA&apos;.
  p_alv_layout-detail_popup = &apos;X&apos;.
* print layout
  p_alv_print-reserve_lines = 2.                            &quot;GKPR/1014972
  p_alv_print-no_print_listinfos = &apos;X&apos;.
ENDFORM.                               &quot; MAKE_ALV_LAYOUT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  FILL_ALV_FIELDCAT
*&amp;---------------------------------------------------------------------*
*       Builds up ALV-fieldcatalogue from X_NAMTAB
*----------------------------------------------------------------------*
*      &lt;--P_VIM_ALV_FCAT  ALV-fieldctalogue
*----------------------------------------------------------------------*
FORM fill_alv_fieldcat CHANGING p_vim_alv_fcat TYPE slis_t_fieldcat_alv
                                texttab_begin LIKE sy-tabix
                                p_value_length TYPE intlen
*                                p_textlen TYPE intlen
                                p_unittab TYPE tabname
                                p_unitname TYPE fieldname
                                p_unitvalue TYPE any &quot;vim_unit
                                       &quot;UF296573/2000
                                p_cukytab TYPE tabname
                                p_cukyname TYPE fieldname
                                p_cukyvalue TYPE vim_cuky.

  DATA: fcat_header TYPE slis_fieldcat_alv, textfld_no TYPE i,
        fcat_reffield TYPE slis_fieldcat_alv, rc LIKE sy-subrc,  &quot;#EC NEEDED
        first TYPE xfeld VALUE &apos;X&apos;, list_width TYPE outputlen,
        i TYPE i, first_func_field TYPE i, text_outp_len TYPE outputlen,
        fldno(2) TYPE n, strln TYPE i,
        hname TYPE fnam_____4, maintview, global_unit_set,  &quot;#EC NEEDED
        global_cuky_set.                                       &quot;#EC NEEDED

  CONSTANTS: max_list_width TYPE i VALUE 250.

  FIELD-SYMBOLS: &lt;alv_fcat&gt; LIKE LINE OF p_vim_alv_fcat,
                 &lt;alv_fcat2&gt; LIKE LINE OF p_vim_alv_fcat, &quot;UF412290/2001
                 &lt;x_namt&gt; LIKE LINE OF x_namtab, &lt;cuky&gt; TYPE vim_cuky,
                 &lt;unit&gt; TYPE ANY.      &quot;vim_unit. UF296573/2000

  REFRESH p_vim_alv_fcat.
  CLEAR:  p_unitname, p_cukyname, p_unitvalue, p_cukyvalue,
          p_value_length.
  IF x_header-bastab EQ space OR x_header-texttbexst EQ space
   OR x_header-maintview NE x_header-viewname.
    maintview = &apos;X&apos;.                   &quot;It&apos;s a maintenance view!
  ENDIF.
* Build up field catalogue
  LOOP AT x_namtab ASSIGNING &lt;x_namt&gt; WHERE texttabfld = space
   OR keyflag = space.
    i = i + 1.
    fcat_header-col_pos = i.
    fcat_header-fieldname = &lt;x_namt&gt;-viewfield.
    IF maintview = space.
      fcat_header-ref_tabname = &lt;x_namt&gt;-bastabname.
    ELSE.
      fcat_header-ref_tabname = x_header-maintview.
    ENDIF.
    fcat_header-key = &lt;x_namt&gt;-keyflag.
    fcat_header-seltext_l = &lt;x_namt&gt;-scrtext_l.
    fcat_header-seltext_m = &lt;x_namt&gt;-scrtext_m.
    fcat_header-seltext_s = &lt;x_namt&gt;-scrtext_s.
    fcat_header-reptext_ddic = &lt;x_namt&gt;-reptext.
    fcat_header-datatype = &lt;x_namt&gt;-datatype.
    fcat_header-inttype = &lt;x_namt&gt;-inttype.
    fcat_header-ddic_outputlen = &lt;x_namt&gt;-outputlen.
    fcat_header-intlen = &lt;x_namt&gt;-flength.
    fcat_header-lowercase = &lt;x_namt&gt;-lowercase.
    CASE &lt;x_namt&gt;-datatype.
      WHEN &apos;CLNT&apos;.
        IF x_header-clidep &lt;&gt; space.
          fcat_header-tech = &apos;X&apos;.
        ENDIF.
      WHEN &apos;CURR&apos;.
        READ TABLE x_namtab WITH KEY viewfield = &lt;x_namt&gt;-reffield
            TRANSPORTING NO FIELDS.
        IF sy-subrc = 0 AND &lt;x_namt&gt;-reftable = x_header-maintview.
          &quot;UF163276/2001
* currency field in structure
          fcat_header-cfieldname = &lt;x_namt&gt;-reffield.
        ELSE.
          IF p_cukyvalue IS INITIAL.
* try to get global currency field
            p_cukytab = &lt;x_namt&gt;-reftable.
            p_cukyname = &lt;x_namt&gt;-reffield.
            CONCATENATE &lt;x_namt&gt;-reftable &apos;-&apos; &lt;x_namt&gt;-reffield
                    INTO hname.
            ASSIGN (hname) TO &lt;cuky&gt;.
            IF sy-subrc = 0.
* global currency key exists to be inserted in value table
              fcat_header-currency = p_cukyvalue = &lt;cuky&gt;.
            ENDIF.
          ELSE.
            fcat_header-currency = p_cukyvalue.
          ENDIF.
        ENDIF.
      WHEN &apos;QUAN&apos;.
        READ TABLE x_namtab WITH KEY viewfield = &lt;x_namt&gt;-reffield
            TRANSPORTING NO FIELDS.
        IF sy-subrc = 0 AND &lt;x_namt&gt;-reftable = x_header-maintview.
          &quot;UF163276/2001.
* quantity field in structure
          fcat_header-qfieldname = &lt;x_namt&gt;-reffield.
        ELSE.
* try to get global quantity field
          IF p_unitvalue IS INITIAL.
            p_unittab = &lt;x_namt&gt;-reftable.
            p_unitname = &lt;x_namt&gt;-reffield.
            CONCATENATE &lt;x_namt&gt;-reftable &apos;-&apos; &lt;x_namt&gt;-reffield
                    INTO hname.
            ASSIGN (hname) TO &lt;unit&gt;.
            IF sy-subrc = 0.
* global unit key exists to be inserted in value table
              fcat_header-quantity = p_unitvalue = &lt;unit&gt;.
            ENDIF.
          ELSE.
            fcat_header-quantity = p_unitvalue.
          ENDIF.
        ENDIF.
    ENDCASE.
    IF &lt;x_namt&gt;-readonly = vim_hidden
* hide hidden fields
     OR &lt;x_namt&gt;-domname IN vim_guid_domain.
* no GUID-values
      fcat_header-tech = &apos;X&apos;.
    ELSE.
      list_width = list_width + &lt;x_namt&gt;-outputlen + 1.
    ENDIF.
    p_value_length = p_value_length + fcat_header-intlen.
    APPEND fcat_header TO p_vim_alv_fcat.
    CLEAR fcat_header.
    CHECK &lt;x_namt&gt;-texttabfld &lt;&gt; space.
    textfld_no = textfld_no + 1.       &quot;get no. of text fields
*    p_textlen = p_textlen + &lt;x_namt&gt;-flength. &quot;int. length of text flds
    CHECK &lt;x_namt&gt;-readonly &lt;&gt; vim_hidden.
    IF first &lt;&gt; space.
      texttab_begin = i.               &quot;position of 1st text fld
      CLEAR first.
    ENDIF.
    text_outp_len = text_outp_len + &lt;x_namt&gt;-outputlen.
  ENDLOOP.
  first = &apos;X&apos;.
  CLEAR i.
  IF x_header-bastab NE space AND x_header-texttbexst NE space
   AND x_header-maintview = x_header-viewname.
* Place text fields behind key fields.
    LOOP AT p_vim_alv_fcat ASSIGNING &lt;alv_fcat&gt; WHERE key = space.
      IF first &lt;&gt; space.
        first_func_field = &lt;alv_fcat&gt;-col_pos.
        CLEAR first.
      ENDIF.
      IF sy-tabix &lt; texttab_begin.
        &lt;alv_fcat&gt;-col_pos = &lt;alv_fcat&gt;-col_pos + textfld_no.
      ELSE.
        i = i + 1.
        &lt;alv_fcat&gt;-col_pos = first_func_field + i - 1.
      ENDIF.
    ENDLOOP.
    first = &apos;X&apos;.
    SORT p_vim_alv_fcat BY col_pos.
  ENDIF.
  IF list_width &gt; max_list_width.
* line size to large for one line
    list_width = i = 1.
    LOOP AT p_vim_alv_fcat ASSIGNING &lt;alv_fcat&gt;.
      list_width = list_width + &lt;alv_fcat&gt;-ddic_outputlen + 1.
      IF list_width &gt; max_list_width.
        i = i + 1.
        list_width = &lt;alv_fcat&gt;-ddic_outputlen + 1.
      ENDIF.
      &lt;alv_fcat&gt;-row_pos = i.
    ENDLOOP.
  ENDIF.
  IF maintview = space.                  &quot;UF412290/2001b
*check field catalogue for doublettes and change their fieldname
    LOOP AT p_vim_alv_fcat ASSIGNING &lt;alv_fcat&gt;.
      i = sy-tabix.
      CLEAR fldno.
      LOOP AT p_vim_alv_fcat ASSIGNING &lt;alv_fcat2&gt;
       WHERE fieldname = &lt;alv_fcat&gt;-fieldname.
        CHECK sy-tabix &lt;&gt; i.
        &lt;alv_fcat2&gt;-ref_fieldname = &lt;alv_fcat2&gt;-fieldname.
        ADD 1 TO fldno.
        CONCATENATE &lt;alv_fcat2&gt;-fieldname fldno
         INTO &lt;alv_fcat2&gt;-fieldname.
        IF sy-subrc &lt;&gt; 0.
          strln = strlen( &lt;alv_fcat2&gt;-fieldname ) - 2.
          CONCATENATE &lt;alv_fcat2&gt;-fieldname(strln) fldno
          INTO &lt;alv_fcat2&gt;-fieldname.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDIF.                                 &quot;UF412290/2001e
ENDFORM.                               &quot; FILL_ALV_FIELDCAT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_CALL_ALV
*&amp;---------------------------------------------------------------------*
*       Calls ABAP List Viewer. Has to be called from Function Module
*       REUSE_ALV_TABLE_CREATE.
*----------------------------------------------------------------------*
*      --&gt;VALUE_TAB
*----------------------------------------------------------------------*
FORM vim_call_alv TABLES value_tab.

  DATA: progname LIKE sy-repid.
  FIELD-SYMBOLS: &lt;alv_value_tab_x&gt; TYPE tabl8000,
                 &lt;value_tab_x&gt; TYPE x.

  REFRESH value_tab.
  ASSIGN value_tab TO &lt;value_tab_x&gt; CASTING.
  LOOP AT alv_value_tab ASSIGNING &lt;alv_value_tab_x&gt;.
    &lt;value_tab_x&gt; = &lt;alv_value_tab_x&gt;.
    APPEND value_tab.
  ENDLOOP.
*  APPEND LINES OF alv_value_tab TO value_tab.
  progname = sy-repid.
  CALL FUNCTION &apos;REUSE_ALV_LIST_DISPLAY&apos;
      EXPORTING
           i_callback_program       = progname
           is_layout                = vim_alv_layout
           it_fieldcat              = vim_alv_fcat
*           it_excluding             = vim_alv_excluding
*           it_special_groups        = vim_alv_special_groups
*           it_sort                  = vim_alv_sort
*            IT_FILTER                =
*           is_sel_hide              = vim_alv_sel_hide
           i_default                = vim_var_default
           i_save                   = vim_var_save
           is_variant               = vim_alv_variant
           it_events                = vim_alv_events
*           it_event_exit            = vim_alv_event_exit
           is_print                 = vim_alv_print
*            IS_REPREP_ID             =
*            I_SCREEN_START_COLUMN    = 0
*            I_SCREEN_START_LINE      = 0
*            I_SCREEN_END_COLUMN      = 0
*            I_SCREEN_END_LINE        = 0
*       IMPORTING
*            E_EXIT_CAUSED_BY_CALLER  =
*            ES_EXIT_CAUSED_BY_USER   =
       TABLES
            t_outtab                 = value_tab[]
       EXCEPTIONS
            program_error            = 1
            OTHERS                   = 2.
  IF sy-subrc NE 0. RAISE print_error. ENDIF.               &quot;#EC FB_RAIS_EX
ENDFORM.                               &quot;vim_call_alv
*&amp;---------------------------------------------------------------------*
*&amp;      Form  MAINTAIN_ALV_VALUE_TAB_TEXT
*&amp;---------------------------------------------------------------------*
*       shift textfield directly behind key
*----------------------------------------------------------------------*
*      --&gt;P_TEXTLEN  text
*----------------------------------------------------------------------*
FORM maintain_alv_value_tab_text USING    p_textlen TYPE intlen.

  DATA: x TYPE i, record TYPE tabl8000, textoffset TYPE intlen,
        BEGIN OF new_offs,
          ref_tabname TYPE tabname,
          fieldname TYPE viewfield,
          ref_fieldname TYPE fieldname,
          offset TYPE tabfdpos,
        END OF new_offs.

  STATICS: t_fld_offs LIKE SORTED TABLE OF new_offs WITH UNIQUE KEY
                           ref_tabname fieldname ref_fieldname
                           INITIAL SIZE 1,
           viewname TYPE viewname.
  FIELD-SYMBOLS: &lt;x_namt&gt; LIKE LINE OF x_namtab,
                 &lt;alv_fcat&gt; TYPE slis_fieldcat_alv,
                 &lt;alv_val&gt;.

  IF viewname &lt;&gt; x_header-viewname.
    viewname = x_header-viewname.
    REFRESH t_fld_offs.
    new_offs-offset = x_header-after_keyc.
*    new_offs-offset = x_header-keylen.
* Offset aktualisieren
    LOOP AT vim_alv_fcat ASSIGNING &lt;alv_fcat&gt; WHERE key = space.
      new_offs-ref_tabname = &lt;alv_fcat&gt;-ref_tabname.
      new_offs-fieldname = &lt;alv_fcat&gt;-fieldname.
      new_offs-ref_fieldname = &lt;alv_fcat&gt;-ref_fieldname. &quot;UF412290/2001
* Alignment
      IF &apos;CNDT&apos; CS &lt;alv_fcat&gt;-inttype.
* Character-like datatypes
        x = ( new_offs-offset + cl_abap_char_utilities=&gt;charsize )
              MOD cl_abap_char_utilities=&gt;charsize.
        IF x NE 0.
          new_offs-offset = new_offs-offset
                             + cl_abap_char_utilities=&gt;charsize - x.
        ENDIF.
      ELSE.
        CASE &lt;alv_fcat&gt;-datatype.
          WHEN &apos;INT2&apos; OR &apos;PREC&apos;.
            x = ( new_offs-offset + 2 ) MOD 2.
            IF x NE 0.
              new_offs-offset = new_offs-offset + 2 - x.
            ENDIF.
          WHEN &apos;INT4&apos;.
            x = ( new_offs-offset + 4 ) MOD 4.
            IF x NE 0.
              new_offs-offset = new_offs-offset + 4 - x.
            ENDIF.
          WHEN &apos;FLTP&apos;.
            x = ( new_offs-offset + 8 ) MOD 8.
            IF x NE 0.
              new_offs-offset = new_offs-offset + 8 - x.
            ENDIF.
        ENDCASE.
      ENDIF.
      INSERT new_offs INTO TABLE t_fld_offs.
      new_offs-offset = new_offs-offset + &lt;alv_fcat&gt;-intlen.
    ENDLOOP.
  ENDIF.
  textoffset = x_header-after_tabc + x_header-aft_txtkc.
*  textoffset = x_header-tablen + x_header-textkeylen.
  LOOP AT alv_value_tab ASSIGNING &lt;alv_val&gt;.
    record(x_header-after_keyc) = &lt;alv_val&gt;(x_header-after_keyc).
*    record = &lt;alv_val&gt;(x_header-keylen).
    IF p_textlen &gt; 0.
      record+x_header-after_keyc(p_textlen) =
       &lt;alv_val&gt;+textoffset(p_textlen).
*      record+x_header-keylen(p_textlen) =
*       &lt;alv_val&gt;+textoffset(p_textlen).
    ENDIF.
    LOOP AT x_namtab ASSIGNING &lt;x_namt&gt; WHERE keyflag = space AND
                                              texttabfld = space.
      READ TABLE t_fld_offs INTO new_offs WITH TABLE KEY
                                    ref_tabname = &lt;x_namt&gt;-bastabname
                                    fieldname = &lt;x_namt&gt;-viewfield
                                    ref_fieldname = space.
      IF sy-subrc = 0.
        record+new_offs-offset(&lt;x_namt&gt;-flength) =
         &lt;alv_val&gt;+&lt;x_namt&gt;-position(&lt;x_namt&gt;-flength).
      ELSE.                                &quot;UF412290/2001b
* field had to be renamed because of doublettes
        READ TABLE t_fld_offs INTO new_offs WITH KEY
                                    ref_tabname = &lt;x_namt&gt;-bastabname
                                    ref_fieldname = &lt;x_namt&gt;-viewfield.
        IF sy-subrc = 0.
          record+new_offs-offset(&lt;x_namt&gt;-flength) =
           &lt;alv_val&gt;+&lt;x_namt&gt;-position(&lt;x_namt&gt;-flength).
        ENDIF.                             &quot;UF412290/2001e
      ENDIF.
    ENDLOOP.
    CLEAR &lt;alv_val&gt;.
    &lt;alv_val&gt; = record.
  ENDLOOP.
ENDFORM.                               &quot; MAINTAIN_ALV_VALUE_TAB_TEXT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_GET_REFFIELD_ALV
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_REFFIELD  text
*      --&gt;P_REFTABLE  text
*      &lt;--P_DFIES Entry for ALV-Fieldcatalogue
*----------------------------------------------------------------------*
FORM vim_get_reffield_alv USING value(p_reffield) TYPE fieldname
                                value(p_reftable) TYPE tabname
                      CHANGING p_dfies TYPE dfies.

  DATA: dfies_tab TYPE TABLE OF dfies.

  CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
    EXPORTING
      tabname        = p_reftable
      fieldname      = p_reffield
      langu          = sy-langu
    TABLES
      dfies_tab      = dfies_tab
    EXCEPTIONS
      not_found      = 1
      internal_error = 2
      OTHERS         = 3.
  IF sy-subrc &lt;&gt; 0.
    EXIT.
  ELSE.
    READ TABLE dfies_tab INTO p_dfies INDEX 1.
  ENDIF.
ENDFORM.                               &quot; VIM_GET_REFFIELD_ALV

*&amp;---------------------------------------------------------------------*
*&amp;      Form  CONV_DFIES_FCAT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_P_DFIES  text
*      &lt;--P_P_FCAT_REFFIELD  text
*----------------------------------------------------------------------*
FORM conv_dfies_fcat USING    p_dfies LIKE dfies
                              i TYPE i
                    CHANGING p_fcat_reffield TYPE slis_fieldcat_alv.

  p_fcat_reffield-col_pos = i.
  p_fcat_reffield-fieldname = p_dfies-fieldname.
  p_fcat_reffield-ref_tabname = p_dfies-tabname.
  p_fcat_reffield-key = p_dfies-keyflag.
  p_fcat_reffield-seltext_l = p_dfies-scrtext_l.
  p_fcat_reffield-seltext_m = p_dfies-scrtext_m.
  p_fcat_reffield-seltext_s = p_dfies-scrtext_s.
  p_fcat_reffield-reptext_ddic = p_dfies-reptext.
  p_fcat_reffield-datatype = p_dfies-datatype.
  p_fcat_reffield-inttype = p_dfies-inttype.
  p_fcat_reffield-ddic_outputlen = p_dfies-outputlen.
  p_fcat_reffield-intlen = p_dfies-intlen.
  p_fcat_reffield-lowercase = p_dfies-lowercase.
  CASE p_dfies-datatype.
    WHEN &apos;CLNT&apos;.
      CHECK x_header-clidep &lt;&gt; space AND p_fcat_reffield-key &lt;&gt; space.
      p_fcat_reffield-tech = &apos;X&apos;.
    WHEN &apos;CURR&apos;.
* currency field in structure
      p_fcat_reffield-cfieldname = p_dfies-reffield.
    WHEN &apos;QUAN&apos;.
* currency field in structure
      p_fcat_reffield-qfieldname = p_dfies-reffield.
  ENDCASE.
ENDFORM.                               &quot; CONV_DFIES_FCAT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  INIT_ALV_VARIANT
*&amp;---------------------------------------------------------------------*
*       define path for list variant names
*----------------------------------------------------------------------*
*      &lt;--P_VARIANT  text
*      &lt;--P_SAVE     text
*----------------------------------------------------------------------*
FORM init_alv_variant CHANGING p_save
                               p_default
                               p_variant STRUCTURE disvariant.

  CONCATENATE x_header-viewname sy-repid INTO p_variant-report.
  p_save = &apos;A&apos;.
  p_default = &apos;X&apos;.
ENDFORM.                               &quot; INIT_ALV_VARIANT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ALV_END_OF_LIST
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM alv_end_of_list.
  WRITE AT /(sy-linsz) sy-pagno CENTERED.
ENDFORM.                               &quot; ALV_END_OF_LIST</include_source>
   </include>
   <include NAME="LSVIMFXL" VARCL="X" SUBC="I" APPL="S" LEVL="40A" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>***INCLUDE LSVIMFXL.
* SW 25.3.1997
*    Readonly-Felder in Texttabelle berücksichtigen

* SW 14.7.1998
*    Import für Texte in anderen Sprachen    &quot;Textimp

* SW 17.9.1998
*    beim Kopieren Texte in anderen Sprachen berücksichtigen   &quot;Textcopy
* UF 19.10.1998: DB-Zugriffe in Include LSVIMFL1 verlagert
INCLUDE lsvimfl1.
*---------------------------------------------------------------------*
*       FORM VIM_SET_LANGUAGES                                        *
*---------------------------------------------------------------------*
* Sprachauswahl expl. über Menue
*---------------------------------------------------------------------*
FORM vim_set_languages.
  DATA: dummy_langus LIKE h_t002 OCCURS 0.
  CALL FUNCTION &apos;VIEW_GET_LANGUAGES&apos;
    EXPORTING
      new_selection         = &apos;X&apos;
*      called_by_viewmaint   = &apos;X&apos;
    TABLES
      languages             = dummy_langus
    EXCEPTIONS
      no_languages_possible = 1.
  IF sy-subrc = 1.
    MESSAGE s160(sv).
  ENDIF.
ENDFORM.                    &quot;vim_set_languages

*---------------------------------------------------------------------*
*       FORM VIM_RESET_TEXTTAB                                        *
*---------------------------------------------------------------------*
* Rücksetzen der internen Texttabelle
*---------------------------------------------------------------------*
* --&gt; VIEWNAME   Rücksetzen der Texttab für Tab/View VIEWNAME
*---------------------------------------------------------------------*
FORM vim_reset_texttab USING viewname LIKE tvdir-tabname.

  READ TABLE vim_texttab_container WITH KEY viewname = viewname
                         BINARY SEARCH.
  IF sy-subrc = 0.
    FREE vim_texttab_container-tabdata-tab_us.
    FREE vim_texttab_container-tabdata-tab_vs.
    FREE vim_texttab_container-tabdata-tab_s.
    FREE vim_texttab_container-tabdata-tab_m.
    FREE vim_texttab_container-tabdata-tab_l.
    FREE vim_texttab_container-tabdata-tab_vl.
    FREE vim_texttab_container-tabdata-tab_ul.
    FREE vim_texttab_container-sel_langus.
    CLEAR vim_texttab_container-all_langus.
    MODIFY vim_texttab_container INDEX sy-tabix.
*     DELETE VIM_TEXTTAB_CONTAINER INDEX SY-TABIX.
  ENDIF.
ENDFORM.                               &quot;VIM_RESET_TEXTTAB

*---------------------------------------------------------------------*
*       FORM VIM_MULTI_LANGU_TEXT_MAINT                               *
*---------------------------------------------------------------------*
* Routine zur Behandlung der Funktion:                                *
*   &quot;Texterfassung in weiteren Sprachen&quot;                              *
*---------------------------------------------------------------------*
FORM vim_multi_langu_text_maint.
  DATA: langus_selected(1) TYPE c,
        curr_sptxt LIKE t002t-sptxt,
        sel_langus LIKE h_t002 OCCURS 0 WITH HEADER LINE,
        texttab_for_output TYPE vimty_multilangu_texttab,
        maint_mode(1) TYPE c,
        textmodif(1) TYPE c,
        f_called_by_viewmaint TYPE c.  &quot;XB H611377 BCEK070683


  CALL FUNCTION &apos;VIEW_GET_LANGUAGES&apos;
    IMPORTING
      languages_selected    = langus_selected
      curr_sptxt            = curr_sptxt
    TABLES
      languages             = sel_langus
    EXCEPTIONS
      no_languages_possible = 1.
  IF sy-subrc = 1.
    MESSAGE s160(sv).
    EXIT.
  ELSEIF langus_selected = &apos; &apos;.
    MESSAGE s153(sv).
    EXIT.
  ENDIF.
  IF x_header-frm_tl_get NE space.
    PERFORM (x_header-frm_tl_get) IN PROGRAM (x_header-fpoolname)
                                  TABLES sel_langus.
  ELSE.
    PERFORM vim_read_texttab_for_langus TABLES sel_langus USING &apos; &apos;.
  ENDIF.

* Falls mehr als 8 Textfelder (noch nicht realisiert)
*    -&gt; Popup zur Feldselektion und Dynproattribute aktualisieren
* PERFORM VIM_ACTUALIZE_D0100.

  REFRESH texttab_for_output.
  PERFORM vim_fill_texttab_for_maint TABLES sel_langus
                                     USING curr_sptxt
                                     CHANGING texttab_for_output.
  IF status-action EQ anzeigen OR status-action EQ transportieren.
    maint_mode = &apos;R&apos;.
  ELSE.
    maint_mode = &apos;U&apos;.
  ENDIF.
* XB H611377B BCEK070683
* check if it is called by view maintenance.
  IF x_namtab IS NOT INITIAL AND x_header IS NOT INITIAL.
    f_called_by_viewmaint = &apos;X&apos;.
  ENDIF.
  CALL FUNCTION &apos;VIEW_MULTI_LANGU_TEXT_MAINT&apos;
    EXPORTING
      mode                   = maint_mode
      ltext_exit_form        = x_header-frm_tltext
      called_by_viewmaint    = f_called_by_viewmaint
    IMPORTING
      vim_texttable_modified = textmodif
    TABLES
      vim_d0100_fielddescr   = vim_d0100_fdescr_ini
      vim_texttable          = texttab_for_output
      x_header               = x_header
      x_namtab               = x_namtab.
* XB H611377E BCE070683
  IF maint_mode = &apos;U&apos; AND textmodif = &apos;X&apos;.
    PERFORM vim_update_texttab USING texttab_for_output.
    MODIFY vim_texttab_container INDEX vim_texttab_container_index.
  ENDIF.

  IF status-mode = list_bild.          &quot;Entmarkieren
    LOOP AT extract.
      CHECK &lt;xmark&gt; = markiert.
      CLEAR &lt;xmark&gt;.
      MODIFY extract.
      mark_extract = mark_extract - 1.
      READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.   &quot;#EC WARNOK
      IF sy-subrc = 0 AND &lt;mark&gt; = markiert.
        CLEAR &lt;mark&gt;.
        MODIFY total INDEX sy-tabix.
        mark_total = mark_total - 1.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                               &quot; VIM_MULTI_LANGU_TEXT_MAINT

*---------------------------------------------------------------------*
*       FORM VIM_SELECT_TEXTFIELDS                                    *
*---------------------------------------------------------------------*
* Falls mehr als 8 Textfelder existieren -&gt; Benutzerauswahl
*---------------------------------------------------------------------*
FORM vim_select_textfields.
  DATA: nr_of_fields TYPE i.

  nr_of_fields = 0.
  LOOP AT x_namtab WHERE keyflag &lt;&gt; &apos;X&apos; AND
                         ( texttabfld = &apos;X&apos; OR txttabfldn &lt;&gt; space ) AND
                     ( readonly = space OR readonly = &apos;R&apos; ).&quot;SW 25.3.97
    &quot;   Textfeld in Tabelle or Textfeld in View
    x_namtab-textfldsel = &apos;X&apos;.
    nr_of_fields = nr_of_fields + 1.
    MODIFY x_namtab.
    IF nr_of_fields &gt;= vim_max_textfields.   &quot; Auswahl über Popup !!!
      EXIT.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;VIM_SELECT_TEXTFIELDS

*---------------------------------------------------------------------*
*       FORM VIM_INITIALIZE_D0100                                     *
*---------------------------------------------------------------------*
* Initialierung der Attribute für Dynprofelder des Texterfassungs-    *
* Dynpros D0100 (View-unabhängig)                                     *
*---------------------------------------------------------------------*
FORM vim_initialize_d0100.
  DATA: fdescr_wa TYPE vimty_screen_fdescr.

  REFRESH vim_d0100_fdescr_ini.
* Keys
  CLEAR fdescr_wa.
  fdescr_wa-active = &apos;X&apos;.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY1&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  CLEAR fdescr_wa-active.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY2&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY3&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY4&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY5&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY6&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY7&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY8&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY9&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-KEY10&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
* Sprache
  fdescr_wa-vislength = 10.
  fdescr_wa-active = &apos;X&apos;.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-SPTXT&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
* Texte
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT1&apos;.
  fdescr_wa-textfld = &apos;X&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  CLEAR fdescr_wa-active.
  fdescr_wa-textfld = &apos;X&apos;.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT2&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT3&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT4&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT5&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT6&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT7&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
  fdescr_wa-name = &apos;VIM_D0100_WORKAREA-TEXT8&apos;.
  APPEND fdescr_wa TO vim_d0100_fdescr_ini.
ENDFORM.                               &quot; VIM_INITIALIZE_D0100

*---------------------------------------------------------------------*
*       FORM VIM_ACTUALIZE_D0100                                      *
*---------------------------------------------------------------------*
* Attribute für Dynprofelder für aktuellen View aktualisieren         *
* (bzw. der ausgewählten Textfelder, falls mehr als 8 ex.             *
*          !!! noch nicht unterstützt  !!!                )           *
*---------------------------------------------------------------------*
FORM vim_actualize_d0100.
  DATA: fdescr_wa TYPE vimty_screen_fdescr,
        next_tabix LIKE sy-tabix,
        nr_of_field TYPE i,
        tot_keylen TYPE i,
        vislen_0(1) TYPE c,
        max_textlen TYPE i,
        tmp_len TYPE i,
        nr_of_text TYPE i.
  FIELD-SYMBOLS: &lt;title&gt; LIKE vimnamtab-scrtext.            &quot;#EC *

  PERFORM vim_select_textfields.
  CLEAR: max_textlen, nr_of_text.
  LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
    nr_of_text = nr_of_text + 1.
    IF max_textlen &lt; x_namtab-outputlen.
      max_textlen = x_namtab-outputlen.
    ENDIF.
  ENDLOOP.
  IF max_textlen &gt; 30. max_textlen = 30. ENDIF.

  CLEAR: tot_keylen, nr_of_field, vislen_0.
  LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND texttabfld &lt;&gt; &apos;X&apos;.
    CHECK x_namtab-datatype &lt;&gt; &apos;CLNT&apos; OR x_namtab-position &gt; 0.
    CHECK x_namtab-readonly &lt;&gt; &apos;S&apos; AND x_namtab-readonly &lt;&gt; &apos;H&apos;.
    CHECK x_header-delmdtflag = space OR x_header-ptfrkyexst = space OR
          x_namtab-domname &lt;&gt; vim_delim_date_domain OR
          ( x_namtab-rollname NOT IN vim_begda_types AND
            x_namtab-rollname NOT IN vim_endda_types ).
    nr_of_field = nr_of_field + 1.
    tot_keylen = tot_keylen + x_namtab-outputlen.
    IF nr_of_field &lt;= vim_max_keyfields.
      READ TABLE vim_d0100_fdescr_ini INDEX nr_of_field INTO fdescr_wa.
      fdescr_wa-title = x_namtab-scrtext.
      fdescr_wa-active = &apos;X&apos;.
      fdescr_wa-fixlength = x_namtab-outputlen.
      tmp_len = tot_keylen + max_textlen.
      IF vislen_0 = &apos;X&apos;.
        fdescr_wa-vislength = 0.
      ELSEIF tmp_len  &gt; 70.            &quot;???
        fdescr_wa-vislength = 70 - max_textlen -
                                 ( tot_keylen - x_namtab-outputlen ).
        vislen_0 = &apos;X&apos;.
        IF fdescr_wa-vislength &lt; 0.
          fdescr_wa-vislength = 0.
        ENDIF.
      ELSE.
        fdescr_wa-vislength = fdescr_wa-fixlength.
      ENDIF.
      IF nr_of_field &lt; vim_max_keyfields.
        MODIFY vim_d0100_fdescr_ini FROM fdescr_wa INDEX nr_of_field.
      ENDIF.
    ELSE.
      fdescr_wa-fixlength = fdescr_wa-fixlength + x_namtab-outputlen + 1.
    ENDIF.
  ENDLOOP.
  IF nr_of_field &gt;= vim_max_keyfields.
    fdescr_wa-title = &apos;...&apos;.
    fdescr_wa-active = &apos;X&apos;.
    fdescr_wa-vislength = 0.
    MODIFY vim_d0100_fdescr_ini FROM fdescr_wa INDEX vim_max_keyfields.
  ELSE.
    next_tabix = nr_of_field + 1.
    LOOP AT vim_d0100_fdescr_ini INTO fdescr_wa
            FROM next_tabix TO vim_max_keyfields.
      CLEAR fdescr_wa-active.
      fdescr_wa-fixlength = 0.
      fdescr_wa-vislength = 0.
      CLEAR fdescr_wa-title.
      MODIFY vim_d0100_fdescr_ini FROM fdescr_wa.
    ENDLOOP.
  ENDIF.
  next_tabix = vim_max_keyfields + 1.                       &quot;Sprachfeld

  LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
    IF x_namtab-readonly = space OR x_namtab-readonly = &apos;R&apos;.&quot;SW 25.3.97
      next_tabix = next_tabix + 1.
      READ TABLE vim_d0100_fdescr_ini INDEX next_tabix INTO fdescr_wa.
      IF x_namtab-readonly = space.    &quot;SW 25.3.1997
        fdescr_wa-active = &apos;X&apos;.
      ELSEIF x_namtab-readonly = &apos;R&apos;.  &quot;SW 25.3.1997 ..
        fdescr_wa-active = &apos;R&apos;.
      ENDIF.                           &quot;.. SW 25.3.1997
      fdescr_wa-title = x_namtab-scrtext.
      fdescr_wa-fixlength = x_namtab-outputlen.
      fdescr_wa-vislength = x_namtab-outputlen.
      MODIFY vim_d0100_fdescr_ini FROM fdescr_wa INDEX next_tabix.
    ENDIF.
  ENDLOOP.

  next_tabix = next_tabix + 1.
  LOOP AT vim_d0100_fdescr_ini INTO fdescr_wa FROM next_tabix.
    CLEAR fdescr_wa-active.
    fdescr_wa-fixlength = 0.
    fdescr_wa-vislength = 0.
    CLEAR fdescr_wa-title.
    MODIFY vim_d0100_fdescr_ini FROM fdescr_wa.
  ENDLOOP.
ENDFORM.                               &quot;VIM_ACTUALIZE_D0100

*---------------------------------------------------------------------*
*       FORM VIM_READ_TEXTTAB_FOR_LANGUS                              *
*---------------------------------------------------------------------*
* Texteinträge von der DB nachlesen für alle Sprachen, für die noch   *
* nicht eingelesen wurde                                              *
*---------------------------------------------------------------------*
* --&gt; SEL_LANGUS         ausgewählte Sprachen
* --&gt; ALL_LANGUS         &apos;X&apos; alle Sprachen wurden ausgewählt
*---------------------------------------------------------------------*
FORM vim_read_texttab_for_langus TABLES sel_langus STRUCTURE h_t002
                                 USING all_langus TYPE c.
  DATA: diff_langus_exist(1) TYPE c,
        diff_langus LIKE h_t002 OCCURS 0 WITH HEADER LINE.

  IF vim_texttab_container-all_langus = &apos;X&apos;. EXIT. ENDIF. &quot;alles eingel.

  vim_texttab_container-all_langus = all_langus.
  REFRESH diff_langus. CLEAR diff_langus_exist.
  LOOP AT sel_langus.
    READ TABLE &lt;vim_read_langus&gt; WITH KEY sel_langus-spras          &quot;#EC WARNOK
                            TRANSPORTING NO FIELDS BINARY SEARCH.
    IF sy-subrc &lt;&gt; 0.
      INSERT sel_langus-spras INTO &lt;vim_read_langus&gt; INDEX sy-tabix.
      diff_langus = sel_langus-spras.
      APPEND diff_langus.
      diff_langus_exist = &apos;X&apos;.
    ENDIF.
  ENDLOOP.

  IF diff_langus_exist = &apos;X&apos; OR all_langus = &apos;X&apos;.
    IF diff_langus_exist = &apos;X&apos;.
      PERFORM vim_get_texttab_data TABLES diff_langus
                                 CHANGING &lt;vim_texttab&gt;.
    ENDIF.
    MODIFY vim_texttab_container INDEX vim_texttab_container_index.
*                        wegen &lt;vim_read_langus&gt; und &lt;vim_texttab&gt;
  ENDIF.
ENDFORM.                               &quot; VIM_READ_TEXTTAB_FOR_LANGUS

*---------------------------------------------------------------------*
*       FORM VIM_FILL_TEXTTAB_FOR_MAINT                               *
*---------------------------------------------------------------------*
* Die zur Texterfassung in anderen Sprachen ausgewählten Texte werden *
* (anhand der markierten Einträge sowie der ausgewählten Sprachen)    *
* in die Tabelle zur Verarbeitung auf dem Dynpro übernommen.          *
*---------------------------------------------------------------------*
* --&gt; SEL_LANGUS         ausgewählte Sprachen
* --&gt; CURR_SPTXT         SPTXT von Sy-Langu
* &lt;-- TEXTTAB_FOR_MAINT  Verarbeitungstabelle der ausgewählten Texte
*                        auf dem Dynpro
*---------------------------------------------------------------------*
FORM vim_fill_texttab_for_maint TABLES sel_langus STRUCTURE h_t002
               USING curr_sptxt LIKE t002t-sptxt
               CHANGING texttab_for_maint TYPE vimty_multilangu_texttab.

  DATA: textmaint_record TYPE vimty_textmaint_record,
        textmaint_field TYPE vimty_textfield,
        align1 TYPE f,                                       &quot;#EC NEEDED
        texttab_wa TYPE vim_line_ul,
        align2 TYPE f,                                       &quot;#EC NEEDED
        tmp_wa TYPE tabl8000,
        condense(1) TYPE c,
        texttab_tabix LIKE sy-tabix,
        extract_index LIKE sy-tabix,
        keylen TYPE i,
        rc LIKE sy-subrc,                                   &quot;875536
        keys_identical TYPE xfeld.
  DATA: primkeylen TYPE i.
  FIELD-SYMBOLS: &lt;extract_key&gt; TYPE x,
                 &lt;next_spras&gt; TYPE spras,
                 &lt;text_rec_key&gt; TYPE x, &lt;h_texttab_wa&gt; TYPE x,
                 &lt;viewkey_in_texttab&gt; TYPE x, &lt;txtfld&gt; TYPE ANY,
                 &lt;h_tmp&gt; TYPE x, &lt;tmp_struc&gt; TYPE ANY,
                 &lt;h_texttab&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY.
  FIELD-SYMBOLS: &lt;extract_primkey&gt; TYPE x.

  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    condense = &apos;X&apos;.
    ASSIGN &lt;vim_ext_mkey_beforex&gt; TO &lt;extract_key&gt;.
*    ASSIGN &lt;vim_ext_mkey_before&gt; TO &lt;extract_key&gt;.
    keylen = x_header-after_keyc
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
*    keylen = x_header-keylen - vim_datum_length.
    CLEAR &lt;vim_old_mkey_beforex&gt;.
  ELSE.
    ASSIGN &lt;vim_xextract_key&gt; TO &lt;extract_key&gt;.
    keylen = x_header-after_keyc.
*    keylen = x_header-keylen.
    CLEAR condense.
  ENDIF.
* In case of viewkey &gt; primtabkey -&gt; additional key fields are filled
* in &lt;extract_key&gt; but not existent in &lt;vim_texttab&gt; &quot;HCG 09/02/2005
*  primkeylen = x_header-textkeylen - cl_abap_char_utilities=&gt;charsize.
  IF x_header-bastab EQ space.                              &quot;875536
    CLEAR keys_identical.
    PERFORM vim_comp_roottabkey USING x_header
                                      x_namtab[]
                             CHANGING keys_identical
                                      rc.
* CUST. MSG.104177 2008 CHG.DT.31/07/2008.
* START OF CHANGE
*   IF keys_identical EQ SPACE.
    IF keys_identical EQ &apos;X&apos;.
* END OF CHANGE
      primkeylen = keylen.
    ELSE.
      clear primkeylen.
      LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
                           bastabname = x_header-roottab.
        IF x_namtab-DATATYPE NE &apos;DATS&apos;.
          primkeylen = primkeylen + x_namtab-FLENGTH.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ELSE.
    primkeylen = x_header-keylen.
  ENDIF.                                                    &quot;875536
  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING.
  IF keylen &lt; primkeylen.
    ASSIGN &lt;h_texttab_wa&gt;(keylen) TO &lt;viewkey_in_texttab&gt;.
  ELSE.
    ASSIGN &lt;h_texttab_wa&gt;(primkeylen) TO &lt;viewkey_in_texttab&gt;.
  ENDIF.
*          texttab_wa+keylen(x_header-textkeylen) TO &lt;texttab_key&gt;,
  ASSIGN: &lt;h_texttab_wa&gt;+keylen(x_header-texttablen) TO &lt;h_texttab&gt;,
          tmp_wa+keylen(x_header-texttablen)
           TO &lt;h_tmp&gt;,
          &lt;h_texttab&gt; TO &lt;texttab_struc&gt;
           CASTING TYPE (x_header-texttab),
          &lt;h_tmp&gt; TO &lt;tmp_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
           TO &lt;next_spras&gt;,
           textmaint_record-keys TO &lt;text_rec_key&gt; CASTING.
*  ASSIGN texttab_wa+offset(vim_spras_length) TO &lt;next_spras&gt;.
  IF status-mode = list_bild.
    extract_index = 1.
  ELSE.
    extract_index = nextline.
  ENDIF.

  LOOP AT extract FROM extract_index.  &quot;Loop für Detail nicht nötig
    CHECK status-mode = detail_bild OR &lt;xmark&gt; = markiert.
    CHECK condense = &apos; &apos; OR
          &lt;vim_old_mkey_beforex&gt; &lt;&gt; &lt;vim_ext_mkey_beforex&gt;.
    IF condense = &apos;X&apos;.
      &lt;vim_old_mkey_beforex&gt; = &lt;vim_ext_mkey_beforex&gt;.
    ENDIF.
*   Texte in Sy-Langu
    CLEAR textmaint_record.
    &lt;text_rec_key&gt; = &lt;extract_key&gt;.
*    textmaint_record-keys = &lt;extract_key&gt;.
    PERFORM vim_external_repr_for_key TABLES textmaint_record-keytab
                                      USING &lt;vim_xextract_key&gt;.
    textmaint_record-spras = sy-langu.
    textmaint_record-sptxt = curr_sptxt.
    IF x_header-bastab = space.
* view
      LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
        textmaint_field-namtab_idx = sy-tabix.
        textmaint_field-outplen = x_namtab-flength.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
         &lt;vim_extract_struc&gt; TO &lt;txtfld&gt;.
        textmaint_field-text = &lt;txtfld&gt;.
*      textmaint_field-text(x_namtab-flength) =
*                          extract+x_namtab-position(x_namtab-flength).
        APPEND textmaint_field TO textmaint_record-texttab.
      ENDLOOP.
    ELSE.
* tab + texttab
      LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
        textmaint_field-namtab_idx = sy-tabix.
        textmaint_field-outplen = x_namtab-flength.
        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
         &lt;vim_ext_txt_struc&gt; TO &lt;txtfld&gt;.
        textmaint_field-text = &lt;txtfld&gt;.
*      textmaint_field-text(x_namtab-flength) =
*                          extract+x_namtab-position(x_namtab-flength).
        APPEND textmaint_field TO textmaint_record-texttab.
      ENDLOOP.
    ENDIF.
    APPEND textmaint_record TO texttab_for_maint.

*   Texte in ausgewählten Sprachen
************************************************************************
    CLEAR: &lt;viewkey_in_texttab&gt;, &lt;texttab_struc&gt;.
*    CLEAR texttab_wa.
*   In case of viewkey &gt; primtabkey -&gt; additional key fields are filled
*   in &lt;extract_key&gt; but not existent in &lt;vim_texttab&gt;  &quot;HCG 09/02/2005
    IF keylen &lt; primkeylen.
      ASSIGN &lt;extract_key&gt;(keylen) TO &lt;extract_primkey&gt;.
    ELSE.
      ASSIGN &lt;extract_key&gt;(primkeylen) TO &lt;extract_primkey&gt;.
    ENDIF.
*    READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;extract_key&gt;
*                               INTO texttab_wa. &quot; BINARY SEARCH.
    READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;extract_primkey&gt;                   &quot;#EC WARNOK
                               INTO texttab_wa. &quot; BINARY SEARCH.
    texttab_tabix = sy-tabix.
    LOOP AT sel_langus.
      CLEAR textmaint_record.
      &lt;text_rec_key&gt; = &lt;extract_key&gt;.
*      textmaint_record-keys = &lt;extract_key&gt;.             &quot;SW Langtext
      textmaint_record-spras = sel_langus-spras.
      textmaint_record-sptxt = sel_langus-sptxt.

*      IF &lt;viewkey_in_texttab&gt; = &lt;extract_key&gt; AND             &quot;817790
      IF &lt;viewkey_in_texttab&gt; = &lt;extract_primkey&gt; AND       &quot;817790
         &lt;next_spras&gt; &lt; sel_langus-spras.                 &quot;#EC PORTABLE
        LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
*          IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_key&gt; OR         &quot;817790
          IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_primkey&gt; OR   &quot;817790
             &lt;next_spras&gt; &gt;= sel_langus-spras.            &quot;#EC PORTABLE
            texttab_tabix = sy-tabix.
            EXIT.
          ENDIF.
        ENDLOOP.
      ENDIF.   &quot; &lt;next_spras&gt; &gt;= sel_langus-spras oder ex. nicht
      IF &lt;next_spras&gt; &lt;&gt; sel_langus-spras OR
*         &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_key&gt;.    &quot;HCG 09/02/2005
          &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_primkey&gt;.&quot;langu:text not ex
        CLEAR &lt;tmp_struc&gt;.
*        CLEAR tmp_wa.
      ELSE.
        tmp_wa = &lt;h_texttab_wa&gt;.
      ENDIF.
      LOOP AT x_namtab WHERE textfldsel = &apos;X&apos;.
        textmaint_field-namtab_idx = sy-tabix.
        textmaint_field-outplen = x_namtab-flength.
*        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
        ASSIGN COMPONENT x_namtab-bastabfld OF STRUCTURE     &quot;HCG wrong
         &lt;tmp_struc&gt; TO &lt;txtfld&gt;.   &quot;HCG for txtfldname in view differs
        textmaint_field-text = &lt;txtfld&gt;.
*        offset = keylen + x_namtab-texttabpos.
*        textmaint_field-text(x_namtab-flength) =
*                   tmp_wa+offset(x_namtab-flength).
        APPEND textmaint_field TO textmaint_record-texttab.
      ENDLOOP.
      APPEND textmaint_record TO texttab_for_maint.
    ENDLOOP.                           &quot; SEL_LANGUS

    IF status-mode = detail_bild. EXIT. ENDIF.
  ENDLOOP.                                                  &quot; EXTRACT
ENDFORM.                               &quot; VIM_FILL_TEXTTAB_FOR_MAINT

*&amp;--------------------------------------------------------------------*
*&amp;      Form  VIM_EXTERNAL_REPR_FOR_KEY                               *
*&amp;--------------------------------------------------------------------*
* --&gt; INT_KEY    Interne Darstellung der Schlüsselfelder
* &lt;-- KEYTAB     Tabelle, externe      &quot;
*&amp;--------------------------------------------------------------------*
FORM vim_external_repr_for_key TABLES keytab &quot;TYPE VIMTY_TEXTFIELD
                               USING int_key TYPE x.
  DATA: keynr TYPE i,
        keyfield TYPE vimty_textfield,
        namtab_idx LIKE sy-tabix.
  FIELD-SYMBOLS: &lt;i_value&gt; TYPE ANY, &lt;e_value&gt; TYPE c.

  CLEAR: keynr, keyfield. REFRESH keytab.
  MOVE int_key TO &lt;table1_wax&gt;.
  LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND texttabfld &lt;&gt; &apos;X&apos;.
    namtab_idx = sy-tabix.
*   Mandant nicht anzeigen
    CHECK x_namtab-datatype &lt;&gt; &apos;CLNT&apos; OR x_header-clidep = space.
*   Subset- und Readonly-Felder nicht anzeigen
    CHECK x_namtab-readonly &lt;&gt; &apos;S&apos; AND x_namtab-readonly &lt;&gt; &apos;H&apos;.
*   Datum bei zeitunabh. Texttabelle nicht anzeigen
    CHECK x_header-delmdtflag = space OR x_header-ptfrkyexst = space OR
          x_namtab-domname &lt;&gt; vim_delim_date_domain OR
          ( x_namtab-rollname NOT IN vim_begda_types AND
            x_namtab-rollname NOT IN vim_endda_types ).
    keynr = keynr + 1.
    IF keynr &gt; vim_max_keyfields.
      keyfield-text+keyfield-outplen(1) = &apos;|&apos;.
      keyfield-outplen = keyfield-outplen + 1.
    ENDIF.
    ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;table1_wa&gt;
     TO &lt;i_value&gt;.
*    ASSIGN int_key+x_namtab-position(x_namtab-flength) TO &lt;i_value&gt;.
    ASSIGN keyfield-text+keyfield-outplen(x_namtab-outputlen)
                                                       TO &lt;e_value&gt;.
    CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
      EXPORTING
        value_intern = &lt;i_value&gt;
        tabname      = x_header-maintview
        fieldname    = x_namtab-viewfield
        outputlen    = x_namtab-outputlen
        intlen       = x_namtab-flength
      IMPORTING
        value_extern = &lt;e_value&gt;.

    IF keynr &lt; vim_max_keyfields.
      keyfield-namtab_idx = namtab_idx.
      keyfield-outplen = x_namtab-outputlen.
      APPEND keyfield TO keytab.
      CLEAR keyfield.
    ELSE.
      keyfield-outplen = keyfield-outplen + x_namtab-outputlen.
    ENDIF.
  ENDLOOP.

  IF keynr &gt;= vim_max_keyfields.
    APPEND keyfield TO keytab.
  ENDIF.
ENDFORM.                               &quot;VIM_EXTERNAL_REPR_FOR_KEY

*&amp;--------------------------------------------------------------------*
*&amp;      Form  VIM_FILL_TEXTTAB_KEY                                    *
*&amp;--------------------------------------------------------------------*
* UF210800: Not unicode-compatible: Please use form
* MAP_VIEWKEY_TO_TEXTTABKEY instead
*
*&amp;--------------------------------------------------------------------*
* --&gt; VIEW_WA  WA of view                                             *
* --&gt; SPRAS    Sprachschlüssel                                        *
* --&gt; SPRAS_POS Position des Sprachschlüssel in VIEW_WA
* &lt;-- TEXT_WA  Key of text table                                      *
*&amp;--------------------------------------------------------------------*
*FORM vim_fill_texttab_key USING view_wa
*                                spras LIKE t002-spras
*                                spras_pos LIKE vimdesc-sprasfdpos
*                       CHANGING text_wa.
*
** Sprachschlüssel
** TEXT_WA+X_HEADER-SPRASFDPOS(VIM_SPRAS_LENGTH) = SPRAS.
*  text_wa+spras_pos(vim_spras_length) = spras.
** Schlüsselfelder der Text-Tabelle
*  LOOP AT x_namtab WHERE txttabfldn &lt;&gt; space AND keyflag &lt;&gt; space.
*    text_wa+x_namtab-texttabpos(x_namtab-flength) =
*         view_wa+x_namtab-position(x_namtab-flength).
*  ENDLOOP.
*ENDFORM.                               &quot;VIM_FILL_TEXTTAB_KEY
*
*&amp;--------------------------------------------------------------------*
*&amp;      Form  VIM_FILL_VIEW_KEY                                       *
*&amp;--------------------------------------------------------------------*
* Not usable in unicode-systems!!!!
* Please use form MAP_TEXTTABKEY_TO_VIEWKEY instead!
*&amp;--------------------------------------------------------------------*
* --&gt; TEXTTAB_WA  WA of text table                                    *
* &lt;-- VIEW_KEY    KEY of view / table                                 *
* &lt;-- SPRAS                                                           *
*&amp;--------------------------------------------------------------------*
FORM vim_fill_view_key USING texttab_wa TYPE vim_line_ul
                   CHANGING view_key
                            spras LIKE t002-spras.

  LOOP AT x_namtab WHERE txttabfldn &lt;&gt; space AND keyflag &lt;&gt; space.
*   alle Schlüsselfelder, zu denen es Felder in der Texttabelle gibt
    view_key+x_namtab-position(x_namtab-flength) =
         texttab_wa+x_namtab-texttabpos(x_namtab-flength).
  ENDLOOP.
  spras = texttab_wa+x_header-sprasfdpos(vim_spras_length).
ENDFORM.                               &quot;VIM_FILL_VIEW_KEY

*---------------------------------------------------------------------*
*       FORM VIM_UPDATE_TEXTTAB                                       *
*---------------------------------------------------------------------*
* Die vom Benutzer erfaßten/geänderten Texte  werden in die interne   *
* Texttabelle &lt;VIM_TEXTTAB&gt; übernommen                                *
*---------------------------------------------------------------------*
FORM vim_update_texttab
                USING texttab_for_maint TYPE vimty_multilangu_texttab.
  DATA: textmaint_record TYPE vimty_textmaint_record,
        textmaint_field TYPE vimty_textfield,
        align TYPE f,                                          &quot;#EC NEEDED
        texttab_wa TYPE vim_line_ul,
        search_key TYPE tabl8000,
        offset LIKE sy-fdpos,
        keylen LIKE sy-fdpos,
        extract_index LIKE sy-tabix,
        total_index   LIKE sy-tabix,
        texttab_tabix LIKE sy-tabix,
        new_entry(1)  TYPE c,
        keylen_char TYPE i,
        primkeylen type i,                                  &quot;817790
        rc LIKE sy-subrc,                                   &quot;875536
        keys_identical TYPE xfeld.
  FIELD-SYMBOLS:
        &lt;search_key&gt; TYPE x, &lt;rec_key&gt; TYPE x, &lt;curr_spras&gt; TYPE ANY,
        &lt;h_texttab_wa&gt; TYPE x,
        &lt;viewkey_in_texttab&gt; TYPE x, &quot;Key aus View/Tab in Texttab
        &lt;texttab_key&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY,
        &lt;h_texttab&gt; TYPE x, &lt;tot_fld&gt; TYPE ANY, &lt;ext_fld&gt; TYPE ANY,
        &lt;texttab_action&gt; TYPE c,
        &lt;t_action&gt;, &lt;e_action&gt;,
        &lt;search_txtkey&gt; type x.                             &quot;817790

  IF x_header-delmdtflag &lt;&gt; space AND     &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.          &quot;      -&gt; zeitunabh. Texttab.
    keylen = x_header-after_keyc
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    keylen = x_header-after_keyc.
  ENDIF.
  keylen_char = keylen / cl_abap_char_utilities=&gt;charsize.
*  primkeylen = x_header-textkeylen - cl_abap_char_utilities=&gt;charsize.&quot;817790
  IF x_header-bastab EQ space.                              &quot;875536
    CLEAR keys_identical.
    PERFORM vim_comp_roottabkey USING x_header
                                      x_namtab[]
                             CHANGING keys_identical
                                      rc.
    IF keys_identical EQ space.
      primkeylen = keylen.
    ELSE.
      clear primkeylen.
      LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
                           bastabname = x_header-roottab.
        IF x_namtab-DATATYPE NE &apos;DATS&apos;.
          primkeylen = primkeylen + x_namtab-FLENGTH.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ELSE.
    primkeylen = x_header-keylen.
  ENDIF.                                                    &quot;875536

  ASSIGN: search_key(keylen) TO &lt;search_key&gt;,
          textmaint_record-keys(keylen_char) TO &lt;rec_key&gt; CASTING,
          texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(keylen) TO &lt;viewkey_in_texttab&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-textkeylen) TO &lt;texttab_key&gt;,
          &lt;h_texttab_wa&gt;+keylen(x_header-texttablen) TO &lt;h_texttab&gt;,
          &lt;h_texttab&gt; TO &lt;texttab_struc&gt;
           CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;texttab_struc&gt;
           TO &lt;curr_spras&gt;.
  IF keylen &lt; primkeylen.                                   &quot;875536
    ASSIGN search_key(keylen) TO &lt;search_txtkey&gt;.
  ELSE.
    ASSIGN search_key(primkeylen) TO &lt;search_txtkey&gt;.       &quot;817790
  ENDIF.

  offset = keylen + x_header-aft_txttbc.
  ASSIGN &lt;h_texttab_wa&gt;+offset(cl_abap_char_utilities=&gt;charsize)
   TO &lt;texttab_action&gt; CASTING.
  IF x_header-bastab = &apos;X&apos;.
* tab+texttab
    ASSIGN &lt;action_text&gt; TO &lt;t_action&gt;.
    ASSIGN &lt;xact_text&gt; TO &lt;e_action&gt;.
  ELSE.
    ASSIGN &lt;action&gt; TO &lt;t_action&gt;.
    ASSIGN &lt;xact&gt; TO &lt;e_action&gt;.
  ENDIF.

  LOOP AT texttab_for_maint INTO textmaint_record.
    IF textmaint_record-spras = sy-langu.
      &lt;search_key&gt; = &lt;rec_key&gt;.
      READ TABLE extract WITH KEY &lt;search_key&gt; BINARY SEARCH.                 &quot;#EC WARNOK
      extract_index = sy-tabix.
    ENDIF.
    CHECK textmaint_record-action = &apos;X&apos;.      &quot; Texte wurden modifiziert

    IF textmaint_record-spras = sy-langu.
*     Texte in Sy-Langu  =&gt; Update in Total und Extract
*      READ TABLE EXTRACT WITH KEY &lt;SEARCH_KEY&gt; BINARY SEARCH.
*      EXTRACT_INDEX = SY-TABIX.
      READ TABLE total WITH KEY &lt;search_key&gt; BINARY SEARCH.           &quot;#EC WARNOK
      total_index = sy-tabix.
      IF x_header-bastab = &apos;X&apos;
       AND &lt;vim_xextract_text&gt; = &lt;text_initial_x&gt;.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                sy-langu
                                                &lt;vim_xtotal&gt;
                                          CHANGING &lt;vim_xextract_text&gt;.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                sy-langu
                                                &lt;vim_xtotal&gt;
                                          CHANGING &lt;vim_xtotal_text&gt;.
*        PERFORM vim_fill_texttab_key USING &lt;search_key&gt; sy-langu
*                                           x_header-sprasfdpos
*                                  CHANGING &lt;extract_text&gt;.
*        PERFORM vim_fill_texttab_key USING &lt;search_key&gt; sy-langu
*                                           x_header-sprasfdpos
*                                  CHANGING &lt;total_text&gt;.
        &lt;e_action&gt; = neuer_eintrag.
        &lt;t_action&gt; = neuer_eintrag.
      ELSEIF &lt;e_action&gt; = original.
        &lt;e_action&gt; = aendern.
        &lt;t_action&gt; = aendern.
*     Else.                     &quot; neuer_eintrag / aendern =&gt; ok
      ENDIF.
      LOOP AT textmaint_record-texttab INTO textmaint_field.
        READ TABLE x_namtab INDEX textmaint_field-namtab_idx.
        IF x_namtab-lowercase = space.
          TRANSLATE textmaint_field-text TO UPPER CASE.
        ENDIF.
        IF x_header-bastab = &apos;X&apos;.
* tab + texttab
          ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_ext_txt_struc&gt; TO &lt;ext_fld&gt;,
                  COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_tot_txt_struc&gt; TO &lt;tot_fld&gt;.
        ELSE.
* view
          ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_extract_struc&gt; TO &lt;ext_fld&gt;,
                  COMPONENT x_namtab-viewfield OF STRUCTURE
                   &lt;vim_total_struc&gt; TO &lt;tot_fld&gt;.
        ENDIF.
        &lt;tot_fld&gt; = textmaint_field-text.
        &lt;ext_fld&gt; = textmaint_field-text.
*        extract+x_namtab-position(x_namtab-flength) =
*           textmaint_field-text(x_namtab-flength).
*        total+x_namtab-position(x_namtab-flength) =
*           textmaint_field-text(x_namtab-flength).
      ENDLOOP.                         &quot;TEXTMAINT_RECORD-TEXTTAB
      MODIFY extract INDEX extract_index.
      MODIFY total INDEX total_index.

    ELSE.
* different language: Update in texttable
      CLEAR: &lt;h_texttab_wa&gt;, &lt;texttab_struc&gt;.
*      READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;search_key&gt;            &quot;817790
*                               INTO texttab_wa BINARY SEARCH.   &quot;817790
      READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;search_txtkey&gt;                         &quot;#EC WARNOK   &quot;817790
                               INTO texttab_wa BINARY SEARCH.&quot;817790

      texttab_tabix = sy-tabix.
*     IF &lt;viewkey_in_texttab&gt; = &lt;search_key&gt; AND   &quot;Text ex. in and. Spr &quot;817790
      IF keylen &lt; primkeylen.                               &quot;875536
        primkeylen = keylen.                                &quot;875536
      ENDIF.                                                &quot;875536
      IF &lt;viewkey_in_texttab&gt;(primkeylen) = &lt;search_txtkey&gt; AND&quot;817790
         &lt;curr_spras&gt; &lt; textmaint_record-spras.
        LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
*          IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;search_key&gt; OR                         &quot;817790
          IF &lt;viewkey_in_texttab&gt;(primkeylen) &lt;&gt; &lt;search_txtkey&gt; OR&quot;817790
             &lt;curr_spras&gt; &gt;= textmaint_record-spras.
            texttab_tabix = sy-tabix.
            EXIT.
* Condition redundant - Internal Message 0001699060 - ACHACHADI
*          ELSEIF &lt;curr_spras&gt; &lt; textmaint_record-spras.
            ELSE.
            texttab_tabix = sy-tabix + 1.
          ENDIF.
        ENDLOOP.
      ENDIF.   &quot; &lt;next_spras&gt; &gt;= sel_langus-spras oder ex. nicht
*      IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;search_key&gt; OR                            &quot;817790
      IF &lt;viewkey_in_texttab&gt;(primkeylen) &lt;&gt; &lt;search_txtkey&gt; OR&quot;817790
        &lt;curr_spras&gt; &lt;&gt; textmaint_record-spras.
        CLEAR: &lt;texttab_struc&gt;.
*        CLEAR texttab_wa.
        new_entry = &apos;X&apos;.
        &lt;viewkey_in_texttab&gt; = &lt;search_key&gt;.
*        texttab_wa = &lt;search_key&gt;.
        &lt;texttab_action&gt; = neuer_eintrag.
        PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                          USING x_header
                                                textmaint_record-spras
                                                &lt;viewkey_in_texttab&gt;
                                          CHANGING &lt;texttab_key&gt;.
**        PERFORM vim_fill_texttab_key
*                            USING &lt;search_key&gt; textmaint_record-spras
*                                  x_header-sprasfdpos
*                            CHANGING &lt;texttab_key&gt;.
      ELSE.
        CLEAR new_entry.
      ENDIF.
*     Text-Values übernehmen
      LOOP AT textmaint_record-texttab INTO textmaint_field.
        READ TABLE x_namtab INDEX textmaint_field-namtab_idx.
*        offset = keylen + x_namtab-texttabpos.
        IF x_namtab-lowercase = space.
          TRANSLATE textmaint_field-text TO UPPER CASE.
        ENDIF.
        IF x_header-bastab = &apos;X&apos;.&quot;HCG Custmessage 282684/02------------
* tab + texttab
          ASSIGN: COMPONENT x_namtab-viewfield OF STRUCTURE
*                   &lt;vim_ext_txt_struc&gt; TO &lt;ext_fld&gt;.
                   &lt;texttab_struc&gt; TO &lt;ext_fld&gt;. &quot;XB int.40684/02
        ELSE.
* view, basis table field name.
          ASSIGN: COMPONENT x_namtab-bastabfld OF STRUCTURE
*                   &lt;vim_extract_struc&gt; TO &lt;ext_fld&gt;.
                   &lt;texttab_struc&gt; TO &lt;ext_fld&gt;. &quot;XB int.. 40684
        ENDIF.
*        ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE
*---------      &lt;texttab_struc&gt; TO &lt;ext_fld&gt;.&quot;HCG Custmessage 282684/02
        &lt;ext_fld&gt; = textmaint_field-text.
*        texttab_wa+offset(x_namtab-flength) =
*           textmaint_field-text(x_namtab-flength).
      ENDLOOP.
      IF &lt;texttab_action&gt; = original.
        &lt;texttab_action&gt; = aendern.
      ENDIF.
      IF new_entry = &apos;X&apos;.
        INSERT texttab_wa INTO &lt;vim_texttab&gt; INDEX texttab_tabix.
      ELSE.
        MODIFY &lt;vim_texttab&gt; FROM texttab_wa INDEX texttab_tabix.
      ENDIF.

    ENDIF.                             &quot; Sy-Langu
  ENDLOOP.                             &quot; TEXTTAB_FOR_MAINT

ENDFORM.                               &quot; VIM_UPDATE_TEXTTAB

*---------------------------------------------------------------------*
*       FORM VIM_TEMP_DELIM_TEXTTAB                                   *
*---------------------------------------------------------------------*
* Abgrenzen für zeitabh. Texttabelle :                                *
*    neuen Eintrag für &lt;vim_xtotal_key&gt; für alle Sprachen in
*      Texttabelle erzeugen, bzw. -falls schon ex.- Texte darin ersetzen
*      Texte werden aus Originaleintrag ORIG_KEY übernommen
*    im Eintrag ENDDATE Texte löschen;
*      falls dieser neu ist -&gt; gesammten Eintrag löschen
*---------------------------------------------------------------------*
* &lt;vim_xtotal_key&gt; = aktuell bearb. Intervall, entstanden durch
*                    Abgrenzen
* --&gt; ENDDATE   Endedatum des neuen Intervalls
* --&gt; ORIG_KEY  altes Endedatum des aktuellen Intervalls vor Abgrenzen
*---------------------------------------------------------------------*
FORM vim_temp_delim_texttab USING value(enddate)
                                  value(orig_key) TYPE x.
  DATA: texttab_orig TYPE vim_line_ul,
        texttab_new  TYPE vim_line_ul,
        align        TYPE f,                                                         &quot;#EC NEEDED
        old_key      TYPE tabl8000,
        orig_tabix LIKE sy-tabix,
        new_tabix  LIKE sy-tabix,
        len TYPE i,
        offset TYPE i,
        langus_selected(1) TYPE c,                                                   &quot;#EC NEEDED
        curr_sptxt LIKE t002t-sptxt,                                                 &quot;#EC NEEDED
        sel_langus LIKE h_t002 OCCURS 0 WITH HEADER LINE.
  FIELD-SYMBOLS: &lt;texttab_orig_x&gt; TYPE x,
                 &lt;txttb_orig_struc&gt; TYPE ANY,
                 &lt;viewkey_in_orig&gt; TYPE x,    &quot;-&gt; texttab_orig
                 &lt;texttab_new_x&gt; TYPE x,
                 &lt;txttb_new_struc&gt; TYPE ANY,
                 &lt;viewkey_in_new&gt; TYPE x,     &quot;-&gt; texttab_new
                 &lt;spras_in_orig&gt; TYPE spras,
                 &lt;spras_in_new&gt; TYPE spras,
                 &lt;date_in_textkey_new&gt; LIKE sy-datum,
                 &lt;action_in_orig&gt;,
                 &lt;action_in_new&gt;,
                 &lt;textfields_in_new&gt; TYPE x,
                 &lt;textfields_in_orig&gt; TYPE x,
                 &lt;h_old_key&gt; TYPE x, &lt;old_key_enddate&gt; LIKE sy-datum,
                 &lt;old_keyx&gt; TYPE x, &lt;old_key_struc&gt; TYPE ANY.

  CALL FUNCTION &apos;VIEW_GET_LANGUAGES&apos;
    EXPORTING
      all_without_selection = &apos;X&apos;
    IMPORTING
      languages_selected    = langus_selected
      curr_sptxt            = curr_sptxt
    TABLES
      languages             = sel_langus.
  IF x_header-frm_tl_get NE space.
    PERFORM (x_header-frm_tl_get) IN PROGRAM (x_header-fpoolname)
                                  TABLES sel_langus.
  ELSE.
    PERFORM vim_read_texttab_for_langus TABLES sel_langus USING &apos;X&apos;.
  ENDIF.

  READ TABLE &lt;vim_texttab&gt; WITH KEY orig_key                        &quot;#EC WARNOK
                           BINARY SEARCH TRANSPORTING NO FIELDS.
  CHECK sy-subrc = 0.
  orig_tabix = sy-tabix.
  ASSIGN: texttab_orig TO &lt;texttab_orig_x&gt; CASTING,
          &lt;texttab_orig_x&gt;(x_header-keylen) TO &lt;viewkey_in_orig&gt;,
          &lt;texttab_orig_x&gt;+x_header-after_keyc
           TO &lt;txttb_orig_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;txttb_orig_struc&gt;
           TO &lt;spras_in_orig&gt;.
  ASSIGN: texttab_new TO &lt;texttab_new_x&gt; CASTING,
          &lt;texttab_new_x&gt;(x_header-keylen) TO &lt;viewkey_in_new&gt;,
          &lt;texttab_new_x&gt;+x_header-after_keyc
           TO &lt;txttb_new_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;txttb_new_struc&gt;
           TO &lt;spras_in_new&gt;.
  offset = x_header-after_keyc + x_header-textkeylen.
  len = x_header-aft_txttbc - x_header-textkeylen.
  ASSIGN: &lt;texttab_new_x&gt;+offset(len) TO &lt;textfields_in_new&gt;,
          &lt;texttab_orig_x&gt;+offset(len) TO &lt;textfields_in_orig&gt;.
  ASSIGN: old_key TO &lt;h_old_key&gt; CASTING,
          &lt;h_old_key&gt;(x_header-keylen) TO &lt;old_keyx&gt;,
          old_key TO &lt;old_key_struc&gt; CASTING TYPE (x_header-maintview).
*  ASSIGN texttab_orig(x_header-keylen) TO &lt;viewkey_in_orig&gt;.
*  ASSIGN texttab_new(x_header-keylen) TO &lt;viewkey_in_new&gt;.
*  offset = x_header-keylen + x_header-sprasfdpos.
*  ASSIGN texttab_orig+offset(vim_spras_length) TO &lt;spras_in_orig&gt;.
*  ASSIGN texttab_new+offset(vim_spras_length) TO &lt;spras_in_new&gt;.
  LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
    ( texttabfld = &apos;X&apos; OR txttabfldn &lt;&gt; space ) AND
      domname EQ vim_delim_date_domain AND
    ( rollname IN vim_begda_types OR rollname IN vim_endda_types ).
*      offset = x_header-keylen + x_namtab-texttabpos.
*      len = x_namtab-flength.
    EXIT.
  ENDLOOP.
  ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;txttb_new_struc&gt;
   TO &lt;date_in_textkey_new&gt;.
*    ASSIGN texttab_new+offset(len) TO &lt;date_in_textkey_new&gt; TYPE &apos;D&apos;.
  offset = ( x_header-after_keyc + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
*  offset = x_header-keylen + x_header-texttablen.
  ASSIGN texttab_orig+offset(1) TO &lt;action_in_orig&gt;.
  ASSIGN texttab_new+offset(1) TO &lt;action_in_new&gt;.
*  ASSIGN texttab_new+offset(len) TO &lt;textfields_in_new&gt;.
*  ASSIGN texttab_orig+offset(len) TO &lt;textfields_in_orig&gt;.

  LOOP AT &lt;vim_texttab&gt; INTO texttab_orig FROM orig_tabix.
    IF &lt;viewkey_in_orig&gt; &lt;&gt; orig_key. EXIT. ENDIF.
    READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;vim_xtotal_key&gt;                &quot;#EC WARNOK
                     INTO texttab_new BINARY SEARCH.
    new_tabix = sy-tabix.
    IF &lt;viewkey_in_new&gt; = &lt;vim_xtotal_key&gt; AND
       &lt;spras_in_new&gt; &lt; &lt;spras_in_orig&gt;.                  &quot;#EC PORTABLE
      LOOP AT &lt;vim_texttab&gt; FROM new_tabix INTO texttab_new.
        IF &lt;viewkey_in_new&gt; &lt;&gt; &lt;vim_xtotal_key&gt; OR
           &lt;spras_in_new&gt; &gt;= &lt;spras_in_orig&gt;.             &quot;#EC PORTABLE
          new_tabix = sy-tabix.
          EXIT.
* Condition Redundant - Internal Message 0001699060 - ACHACHADI
*        ELSEIF &lt;spras_in_new&gt; &lt; &lt;spras_in_orig&gt;.          &quot;#EC PORTABLE
        ELSE.
          new_tabix = sy-tabix + 1.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF &lt;viewkey_in_new&gt; &lt;&gt; &lt;vim_xtotal_key&gt; OR
       &lt;spras_in_new&gt; &lt;&gt; &lt;spras_in_orig&gt;.
*    es gibt noch keinen Eintrag mit neuem Schlüssel
      texttab_new = texttab_orig.
      &lt;viewkey_in_new&gt; = &lt;vim_xtotal_key&gt;.
      &lt;date_in_textkey_new&gt; = &lt;vim_enddate&gt;.
      &lt;action_in_new&gt; = neuer_eintrag.
      INSERT texttab_new INTO &lt;vim_texttab&gt; INDEX new_tabix.
    ELSE.
      IF &lt;action_in_new&gt; = original.
        &lt;action_in_new&gt; = aendern.
      ENDIF.
      &lt;textfields_in_new&gt; = &lt;textfields_in_orig&gt;.
      MODIFY &lt;vim_texttab&gt; FROM texttab_new INDEX new_tabix.
    ENDIF.
  ENDLOOP.

* Text in neuen Eintrag löschen
  &lt;old_keyx&gt; = &lt;vim_xtotal_key&gt;.
*  ASSIGN old_key(x_header-keylen) TO &lt;old_key&gt;.
  LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND
    ( texttabfld = &apos;X&apos; OR txttabfldn &lt;&gt; space ) AND
    domname EQ vim_delim_date_domain AND
    ( rollname IN vim_begda_types OR rollname IN vim_endda_types ).
    EXIT.
  ENDLOOP.
  ASSIGN COMPONENT x_namtab-viewfield OF STRUCTURE &lt;old_key_struc&gt;
   TO &lt;old_key_enddate&gt;.
  &lt;old_key_enddate&gt; = enddate.
*  old_key+x_namtab-position(x_namtab-flength) = enddate.
  READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;old_keyx&gt;                        &quot;#EC WARNOK
                           BINARY SEARCH TRANSPORTING NO FIELDS.
*  READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;old_key&gt;
*                           BINARY SEARCH TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    LOOP AT &lt;vim_texttab&gt; INTO texttab_orig FROM sy-tabix.
      IF &lt;viewkey_in_orig&gt; &lt;&gt; &lt;old_keyx&gt;. EXIT. ENDIF.
      IF &lt;action_in_orig&gt; = neuer_eintrag.
        DELETE &lt;vim_texttab&gt;.
      ELSE.
        CLEAR &lt;textfields_in_orig&gt;.
        IF &lt;action_in_orig&gt; = original.
          &lt;action_in_orig&gt; = aendern.
        ENDIF.
        MODIFY &lt;vim_texttab&gt; FROM texttab_orig.
      ENDIF.
    ENDLOOP.
  ENDIF.
  MODIFY vim_texttab_container INDEX vim_texttab_container_index.
ENDFORM.                               &quot; VIM_TEMP_DELIM_TEXTTAB

*---------------------------------------------------------------------*
*       FORM VIM_CHECK_UPD_TEXTTAB                                    *
*---------------------------------------------------------------------*
* Setzen von &lt;STATUS&gt;-UPD_FLAG, falls Änderungen in Texttabelle       *
*---------------------------------------------------------------------*
FORM vim_check_upd_texttab.
  DATA: texttab_wa TYPE vim_line_ul,
        offset TYPE i.
  FIELD-SYMBOLS: &lt;texttab_action&gt;.

  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    offset = x_header-after_keyc
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    offset = x_header-after_keyc.
  ENDIF.
  offset = ( offset + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
  ASSIGN texttab_wa+offset(1) TO &lt;texttab_action&gt;.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; &lt;&gt; original.
    MOVE &apos;X&apos; TO &lt;status&gt;-upd_flag.
    EXIT.
  ENDLOOP.

ENDFORM.                               &quot;VIM_CHECK_UPD_TEXTTAB

*---------------------------------------------------------------------*
*       FORM VIM_SET_TEXTTAB_ACTION_DELETE                            *
*---------------------------------------------------------------------*
* Für alle als &apos;GELOESCHT&apos; gekennzeichneten Einträge in TOTAL         *
* entsprechende Einträge in der Texttabelle als &apos;GELOESCHT&apos; kennz.    *
*---------------------------------------------------------------------*
FORM vim_set_texttab_action_delete.
  DATA: texttab_tabix LIKE sy-tabix,
        offset TYPE i,
        texttab_wa TYPE vim_line_ul.
  FIELD-SYMBOLS: &lt;h_texttab_wa&gt; TYPE x,
                 &lt;texttab_action&gt; TYPE char01,
                 &lt;viewkey_in_texttab&gt; TYPE x,
                 &lt;total_key&gt; TYPE x.

  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    offset = x_header-after_keyc
             - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
    ASSIGN &lt;vim_tot_mkey_beforex&gt; TO &lt;total_key&gt;.
  ELSE.
    offset = x_header-after_keyc.
    ASSIGN &lt;vim_xtotal_key&gt; TO &lt;total_key&gt;.
  ENDIF.
  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(offset) TO &lt;viewkey_in_texttab&gt;.
  offset = ( offset + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
  ASSIGN texttab_wa+offset(1) TO &lt;texttab_action&gt;.

* Text-Einträge werden nur in dieser Routine, also in PREPARE_SAVING,
* als gelöscht gekennzeichnet, und nach dem eigentlichen Sichern,
* in AFTER_SAVING, aus der internen Texttabelle gelöscht.
* Hier sollten daher keine Einträge als gelöscht gekennzeichnet sein,
* außer wenn im User_exit vor dem Sichern das Sichern abgebrochen wurde.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; = geloescht OR
          &lt;texttab_action&gt; = update_geloescht OR
          &lt;texttab_action&gt; = neuer_geloescht.
    TRANSLATE &lt;texttab_action&gt; USING &apos;D XNYU&apos;.
    MODIFY &lt;vim_texttab&gt; FROM texttab_wa.
  ENDLOOP.

  LOOP AT total.
    CHECK &lt;action&gt; = update_geloescht OR
          &lt;action&gt; = geloescht OR
          &lt;action&gt; = neuer_geloescht.
    READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;total_key&gt;                       &quot;#EC WARNOK
                               BINARY SEARCH TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      texttab_tabix = sy-tabix.
      LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
        IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;total_key&gt;.
          EXIT.
        ENDIF.
        TRANSLATE &lt;texttab_action&gt; USING &apos; DNXUY&apos;.
        MODIFY &lt;vim_texttab&gt; FROM texttab_wa.
      ENDLOOP.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;VIM_SET_TEXTTAB_ACTION_DELETE

*---------------------------------------------------------------------*
*    VIM_TEXTTAB_MODIF_FOR_KEY
*---------------------------------------------------------------------*
* &lt;-- MODIF       &apos;X&apos; -&gt; es gibt mind. einen modifizierten Eintrag
*                        in anderer Sprache
*---------------------------------------------------------------------*
* aktueller Eintrag steht in Kopfzeile von EXTRACT
*---------------------------------------------------------------------*
FORM vim_texttab_modif_for_key CHANGING modif.
  DATA: texttab_wa TYPE vim_line_ul,
        texttab_tabix LIKE sy-tabix,
        keylen TYPE i,
        offset TYPE i.
  FIELD-SYMBOLS: &lt;h_texttab_wa&gt; TYPE x,
                 &lt;texttab_action&gt; TYPE xfeld,
                 &lt;viewkey_in_texttab&gt; TYPE x,
                 &lt;extract_key&gt; TYPE x.

  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    ASSIGN &lt;vim_ext_mkey_beforex&gt; TO &lt;extract_key&gt;.
    keylen = x_header-after_keyc
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
  ELSE.
    ASSIGN &lt;vim_xextract_key&gt; TO &lt;extract_key&gt;.
    keylen = x_header-after_keyc.
  ENDIF.

  CLEAR modif.
  READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;vim_xextract_key&gt;                        &quot;#EC WARNOK
                           BINARY SEARCH TRANSPORTING NO FIELDS.
  IF sy-subrc = 0.
    texttab_tabix = sy-tabix.
  ELSE.
    EXIT.     &quot;keine Texte zum Key in anderen Sprachen erfaßt
  ENDIF.

  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;(keylen) TO &lt;viewkey_in_texttab&gt;.
  offset = ( keylen + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
  ASSIGN texttab_wa+offset(1) TO &lt;texttab_action&gt;.
  LOOP AT &lt;vim_texttab&gt; FROM texttab_tabix INTO texttab_wa.
    IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;extract_key&gt;.
      EXIT.
    ELSEIF &lt;texttab_action&gt; &lt;&gt; original.
      modif = &apos;X&apos;.
      EXIT.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;VIM_TEXTTAB_MODIF_FOR_KEY

*---------------------------------------------------------------------*
*       FORM VIM_TEXT_KEYTAB_ENTRIES
*---------------------------------------------------------------------*
* Korrektureinträge für Texttabellenänderungen
* UF170200 Dump DATA_LENGTH_TOO_LARGE: Keylen not changed anymore in
* header line of X_HEADER but received in CORR_UPD and added to
* interface (P_KEYLEN).
*---------------------------------------------------------------------*
FORM vim_text_keytab_entries USING value(vake_action) TYPE c
                                   vake_rc TYPE i
                                   value(p_keylen) TYPE syfleng
                                   value(p_txtkeylen) TYPE syfleng.
  DATA: rc1 LIKE sy-subrc,
        offset TYPE i,
        texttab_wa TYPE vim_line_ul,
        max_trsp_keylength_in_byte TYPE i,
        text_keylen TYPE i.                                 &quot; MN 904720
  FIELD-SYMBOLS: &lt;h_texttab_wa&gt; TYPE x,
                 &lt;texttab_action&gt; TYPE c, &lt;texttab_key&gt; TYPE x,
                 &lt;x_header2&gt; TYPE vimdesc.                  &quot;#EC *

  text_keylen = x_header-keylen.                            &quot;MN 904720
  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    p_keylen = p_keylen
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize. &quot;UF170200
    text_keylen = x_header-keylen
      - vim_datum_length * cl_abap_char_utilities=&gt;charsize.&quot;MN 904720
  ENDIF.
*  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
*          &lt;h_texttab_wa&gt;+x_header-keylen(x_header-textkeylen) TO &lt;texttab_key&gt;.
  ASSIGN: texttab_wa TO &lt;h_texttab_wa&gt; CASTING,
          &lt;h_texttab_wa&gt;+text_keylen(x_header-textkeylen) TO &lt;texttab_key&gt;.&quot; MN 904720
  max_trsp_keylength_in_byte = vim_max_trsp_keylength
   * cl_abap_char_utilities=&gt;charsize.
  IF x_header-keylen GT max_trsp_keylength_in_byte.
*       &quot;HCG                  same as in corr_upd -&gt; p_keylen unchanged
  ELSE.                     &quot;HCG if keylen not an even number char must
    p_keylen = x_header-after_keyc.  &quot;begin on even memory adress in UC
  ENDIF.           &quot;e.g. int1 in key -&gt; keylen = 2n+1 aft_keyc = 2n+1+1
  offset = x_header-after_keyc + x_header-aft_txttbc.       &quot;IG 924398
  IF x_header-delmdtflag &lt;&gt; space AND  &quot;zeitabh. &amp; part. Fremdschl.
     x_header-ptfrkyexst  = &apos;X&apos;.       &quot;      -&gt; zeitunabh. Texttab.
    offset = offset
     - vim_datum_length * cl_abap_char_utilities=&gt;charsize. &quot;HCG774471
  ENDIF.
  ASSIGN &lt;h_texttab_wa&gt;+offset(cl_abap_char_utilities=&gt;charsize)
          TO &lt;texttab_action&gt; CASTING.

  corr_keytab =  e071k.
  corr_keytab-objname = x_header-texttab.

  vake_rc = 8.
  LOOP AT &lt;vim_texttab&gt; INTO texttab_wa.
    CHECK &lt;texttab_action&gt; &lt;&gt; original AND
          &lt;texttab_action&gt; &lt;&gt; neuer_geloescht.
    MOVE &lt;texttab_key&gt; TO &lt;vim_corr_keyx&gt;(p_txtkeylen).
*    MOVE &lt;texttab_key&gt; TO corr_keytab-tabkey(p_txtkeylen).
    PERFORM update_corr_keytab USING vake_action rc1.
    IF rc1 = 0.
      CLEAR vake_rc.
    ELSE.
      IF vake_action EQ pruefen. vake_rc = 8. EXIT. ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot;VIM_TEXT_KEYTAB_ENTRIES

*---------------------------------------------------------------------*
*       FORM VIM_TEXT_KEYTAB_ENTRY
*---------------------------------------------------------------------*
* Korrektureintrag für Entry in allen vorhandenen Sprachen
*---------------------------------------------------------------------*
FORM vim_text_keytab_entry USING value(viewkey) TYPE x
                                 value(vake_action) TYPE c
                                 vake_rc TYPE i.
  DATA: rc1 LIKE sy-subrc,
        sys_type(10) TYPE c,
        keylen TYPE i,
        offset TYPE i,
        tbx LIKE sy-tabix,
        align TYPE f,                                                                  &quot;#EC NEEDED
        texttab_wa TYPE vim_line_ul,
        key_wa TYPE vim_line_ul,                                                       &quot;#EC NEEDED
        wheretab LIKE vimwheretb OCCURS 0 WITH HEADER LINE,
        tmp_sellist LIKE vimsellist OCCURS 0 WITH HEADER LINE,
        tmp_texttab TYPE REF TO data, w_tmp_texttab TYPE REF TO data.
  FIELD-SYMBOLS: &lt;tmp_texttab&gt; TYPE STANDARD TABLE,
                 &lt;texttab_wax&gt; TYPE x,
                 &lt;texttab_x&gt; TYPE x, &lt;texttab_struc&gt; TYPE ANY,
                 &lt;texttab_key&gt; TYPE x, &lt;texttab_action&gt; TYPE c,
                 &lt;keyvalue&gt; TYPE ANY, &lt;lang&gt; TYPE spras,
                 &lt;viewkey_in_texttab&gt;, &lt;viewkey&gt; TYPE x.

  vake_rc = 8.
  corr_keytab =  e071k.
  corr_keytab-objname = x_header-texttab.

  IF x_header-generictrp &lt;&gt; space OR x_header-genertxtrp &lt;&gt; space.
    keylen = x_header-maxtrkeyln.
  ELSE.
    keylen = x_header-keylen.
  ENDIF.
  CALL &apos;C_SAPGPARAM&apos; ID &apos;NAME&apos;  FIELD &apos;transport/systemtype&apos;                &quot;#EC CI_CCALL
                     ID &apos;VALUE&apos; FIELD sys_type.

  ASSIGN: viewkey(keylen) TO &lt;viewkey&gt; CASTING.
  IF vim_texttab_container-all_langus = &apos;X&apos;.
* texts have already been read
    ASSIGN: texttab_wa TO &lt;texttab_wax&gt; CASTING,
            &lt;texttab_wax&gt;+keylen(x_header-texttablen) TO &lt;texttab_x&gt;,
            &lt;texttab_x&gt;(x_header-textkeylen) TO &lt;texttab_key&gt;,
            &lt;texttab_x&gt; TO &lt;texttab_struc&gt;
             CASTING TYPE (x_header-texttab),
            COMPONENT x_header-sprasfield OF STRUCTURE
             &lt;texttab_struc&gt; TO &lt;lang&gt;.
    IF x_header-delmdtflag &lt;&gt; space AND&quot;zeitabh. &amp; part. Fremdschl.
       x_header-ptfrkyexst  = &apos;X&apos;.     &quot;      -&gt; zeitunabh. Texttab.
      keylen = keylen
                - vim_datum_length * cl_abap_char_utilities=&gt;charsize.
    ENDIF.
    ASSIGN &lt;texttab_wax&gt;(keylen) TO &lt;viewkey_in_texttab&gt;.
    offset = keylen + x_header-aft_txttbc.
    ASSIGN &lt;texttab_wax&gt;+offset(cl_abap_char_utilities=&gt;charsize)
     TO &lt;texttab_action&gt; CASTING.

    READ TABLE &lt;vim_texttab&gt; WITH KEY &lt;viewkey&gt;
             BINARY SEARCH TRANSPORTING NO FIELDS.                  &quot;#EC WARNOK
    IF sy-subrc = 0.
      LOOP AT &lt;vim_texttab&gt; INTO texttab_wa FROM sy-tabix.
        CHECK &lt;texttab_action&gt; &lt;&gt; neuer_eintrag.
        IF &lt;viewkey_in_texttab&gt; &lt;&gt; &lt;viewkey&gt;. EXIT. ENDIF.
        MOVE &lt;texttab_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-textkeylen).
*        WRITE &lt;texttab_key&gt; TO corr_keytab-tabkey(x_header-textkeylen).
        PERFORM update_corr_keytab USING vake_action rc1.
        IF rc1 = 0.
          CLEAR vake_rc.
        ELSE.
          IF vake_action EQ pruefen. vake_rc = 8. EXIT. ENDIF.
        ENDIF.
      ENDLOOP.
    ELSE.
      CLEAR vake_rc.
    ENDIF.
  ELSE.
* Texte direkt von DB lesen
    REFRESH wheretab.
    tmp_sellist-operator = &apos;EQ&apos;.
    tmp_sellist-and_or = &apos;AND&apos;.
    MOVE &lt;viewkey&gt; TO &lt;f1_wax&gt;.
    LOOP AT x_namtab WHERE keyflag NE space    &quot;fill sellist for
                       AND txttabfldn &lt;&gt; space.             &quot;texttab
      tmp_sellist-tabix = sy-tabix.
*      ASSIGN viewkey+x_namtab-position(x_namtab-flength) TO &lt;keyvalue&gt;.
*      ASSIGN COMPONENT x_namtab-viewfield
*       OF STRUCTURE &lt;table1_wa&gt; TO &lt;keyvalue&gt;.
* XB 11062002, int2023251/03. choos the right key into texttabkey.
      ASSIGN COMPONENT x_namtab-viewfield
       OF STRUCTURE &lt;table1&gt; TO &lt;keyvalue&gt;.           &quot; XB H631231
      tmp_sellist-viewfield = x_namtab-txttabfldn.
      IF x_namtab-inttype = &apos;C&apos; AND x_namtab-convexit = space.
        tmp_sellist-value = &lt;keyvalue&gt;.
      ELSE.
        CALL FUNCTION &apos;VIEW_CONVERSION_OUTPUT&apos;
          EXPORTING
            value_intern = &lt;keyvalue&gt;
            tabname      = x_header-maintview
            fieldname    = x_namtab-viewfield
            inttype      = x_namtab-inttype
            datatype     = x_namtab-datatype
            decimals     = x_namtab-decimals
            convexit     = x_namtab-convexit
            sign         = x_namtab-sign
            outputlen    = x_namtab-outputlen
            intlen       = x_namtab-flength
          IMPORTING
            value_extern = tmp_sellist-value
          EXCEPTIONS                      &quot;#EC FB_RC
            OTHERS       = 1.
      ENDIF.
      APPEND tmp_sellist.
      tbx   = sy-tabix.
    ENDLOOP.
    IF tbx &gt; 0.
      CLEAR tmp_sellist-and_or.
      MODIFY tmp_sellist INDEX tbx.
      CALL FUNCTION &apos;VIEW_FILL_WHERETAB&apos;
        EXPORTING
          tablename               = x_header-texttab
          only_cnds_for_keyflds   = &apos;X&apos;
          is_texttable            = &apos;X&apos;
        TABLES
          sellist                 = tmp_sellist
          wheretab                = wheretab
          x_namtab                = x_namtab
        EXCEPTIONS                        &quot;#EC FB_RC
          no_conditions_for_table = 01.
      CREATE DATA tmp_texttab TYPE STANDARD TABLE OF (x_header-texttab).
      CREATE DATA w_tmp_texttab TYPE (x_header-texttab).
      ASSIGN: tmp_texttab-&gt;* TO &lt;tmp_texttab&gt;,
              w_tmp_texttab-&gt;* TO &lt;texttab_struc&gt;,
              &lt;texttab_struc&gt; TO &lt;texttab_wax&gt; CASTING,
              &lt;texttab_wax&gt;(x_header-textkeylen) TO &lt;texttab_key&gt;,
              COMPONENT x_header-sprasfield OF STRUCTURE
               &lt;texttab_struc&gt; TO &lt;lang&gt;.
      SELECT * FROM (x_header-texttab) INTO TABLE &lt;tmp_texttab&gt;
                                      WHERE (wheretab).
      IF sy-subrc = 0.
*        ASSIGN texttab_wa(x_header-textkeylen) TO &lt;texttab_key&gt;.
        LOOP AT &lt;tmp_texttab&gt; INTO &lt;texttab_struc&gt;.
*          MOVE &lt;texttab_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-textkeylen).
* txttabkeyLen &gt; 120, use x_hader-maxtrtxkln.
* XB H631231B
          IF x_header-textkeylen &gt; x_header-maxtrtxkln
            AND x_header-maxtrtxkln &lt;&gt; 0.
            MOVE &lt;texttab_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-maxtrtxkln).
          ELSE.
            MOVE &lt;texttab_key&gt; TO &lt;vim_corr_keyx&gt;(x_header-textkeylen).
          ENDIF.
* XB H631231E
          PERFORM update_corr_keytab USING vake_action rc1.
          IF rc1 = 0.
            CLEAR vake_rc.
          ELSE.
            IF vake_action EQ pruefen. vake_rc = 8. EXIT. ENDIF.         &quot;#EC CI_NOORDER
          ENDIF.
        ENDLOOP.
      ELSE.
        CLEAR vake_rc.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                               &quot;VIM_TEXT_KEYTAB_ENTRY

* &quot;SW Textcopy
*---------------------------------------------------------------------*
*       FORM VIM_COPY_TEXTTAB_ENTRY                                   *
*---------------------------------------------------------------------*
* Kopieren für Texttabelle :                                          *
*    neuen Eintrag für NEW_KEY für alle Sprachen in Texttabelle erzeugen
*       ?? bzw. -falls schon ex.- Texte darin ersetzen ??
*    Texte werden aus Originaleintrag ORIG_KEY übernommen
*---------------------------------------------------------------------*
* --&gt; NEW_KEY   Schlüssel des neuen Eintrags
* --&gt; ORIG_KEY  Schlüssel des zu kopierenden Eintrags
*---------------------------------------------------------------------*
FORM vim_copy_texttab_entry USING value(new_key) TYPE x
                                  value(orig_key) TYPE x.
  DATA: texttab_orig TYPE vim_line_ul,
        texttab_new  TYPE vim_line_ul,
        orig_tabix LIKE sy-tabix,
        new_tabix  LIKE sy-tabix,
        len TYPE i,
        offset TYPE i,
        langus_selected(1) TYPE c,                                                          &quot;#EC NEEDED
        curr_sptxt LIKE t002t-sptxt,                                                        &quot;#EC NEEDED
        sel_langus LIKE h_t002 OCCURS 0 WITH HEADER LINE.
  FIELD-SYMBOLS: &lt;texttab_orig_x&gt; TYPE x,
                 &lt;h_texttab_orig_x&gt; TYPE x,
                 &lt;txttb_orig_struc&gt; TYPE ANY,
                 &lt;viewkey_in_orig&gt; TYPE x,    &quot;-&gt; texttab_orig
                 &lt;texttab_new_x&gt; TYPE x,
                 &lt;h_texttab_new_x&gt; TYPE x,
                 &lt;txttb_new_struc&gt; TYPE ANY,
                 &lt;viewkey_in_new&gt; TYPE x,     &quot;-&gt; texttab_new
                 &lt;spras_in_orig&gt; TYPE spras,
                 &lt;spras_in_new&gt; TYPE spras,
                 &lt;action_in_orig&gt;,
                 &lt;action_in_new&gt;,
                 &lt;textfields_in_new&gt; TYPE x,
                 &lt;textfields_in_orig&gt; TYPE x,
                 &lt;textkey_in_new&gt; TYPE x.

  CALL FUNCTION &apos;VIEW_GET_LANGUAGES&apos;
    EXPORTING
      all_without_selection = &apos;X&apos;
    IMPORTING
      languages_selected    = langus_selected
      curr_sptxt            = curr_sptxt
    TABLES
      languages             = sel_langus.
  IF x_header-frm_tl_get NE space.
    PERFORM (x_header-frm_tl_get) IN PROGRAM (x_header-fpoolname)
                                  TABLES sel_langus.
  ELSE.
    PERFORM vim_read_texttab_for_langus TABLES sel_langus USING &apos;X&apos;.
  ENDIF.

  READ TABLE &lt;vim_texttab&gt; WITH KEY orig_key                          &quot;#EC WARNOK
                           BINARY SEARCH TRANSPORTING NO FIELDS.
  CHECK sy-subrc = 0.
  orig_tabix = sy-tabix.
  ASSIGN: texttab_orig TO &lt;texttab_orig_x&gt; CASTING,
          &lt;texttab_orig_x&gt;(x_header-keylen) TO &lt;viewkey_in_orig&gt;,
          &lt;texttab_orig_x&gt;+x_header-after_keyc(x_header-texttablen)
           TO &lt;h_texttab_orig_x&gt;,
          &lt;h_texttab_orig_x&gt;
           TO &lt;txttb_orig_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;txttb_orig_struc&gt;
           TO &lt;spras_in_orig&gt;.
  ASSIGN: texttab_new TO &lt;texttab_new_x&gt; CASTING,
          &lt;texttab_new_x&gt;(x_header-keylen) TO &lt;viewkey_in_new&gt;,
          &lt;texttab_new_x&gt;+x_header-after_keyc(x_header-textkeylen)
           TO &lt;textkey_in_new&gt;,
          &lt;texttab_new_x&gt;+x_header-after_keyc(x_header-texttablen)
           TO &lt;h_texttab_new_x&gt;,
          &lt;h_texttab_new_x&gt;
           TO &lt;txttb_new_struc&gt; CASTING TYPE (x_header-texttab),
          COMPONENT x_header-sprasfield OF STRUCTURE &lt;txttb_new_struc&gt;
           TO &lt;spras_in_new&gt;.
  offset = x_header-after_keyc + x_header-textkeylen.
  len = x_header-aft_txttbc - x_header-textkeylen.
  ASSIGN: &lt;texttab_new_x&gt;+offset(len) TO &lt;textfields_in_new&gt;,
          &lt;texttab_orig_x&gt;+offset(len) TO &lt;textfields_in_orig&gt;.
  offset = ( x_header-after_keyc + x_header-aft_txttbc )
           / cl_abap_char_utilities=&gt;charsize.
  ASSIGN texttab_orig+offset(1) TO &lt;action_in_orig&gt;.
  ASSIGN texttab_new+offset(1) TO &lt;action_in_new&gt;.
*  ASSIGN texttab_orig(x_header-keylen) TO &lt;viewkey_in_orig&gt;.
*  ASSIGN texttab_new(x_header-keylen) TO &lt;viewkey_in_new&gt;.
*  ASSIGN texttab_new+x_header-keylen(x_header-textkeylen)
*                                       TO &lt;textkey_in_new&gt;.
*  offset = x_header-keylen + x_header-sprasfdpos.
*  ASSIGN texttab_orig+offset(vim_spras_length) TO &lt;spras_in_orig&gt;.
*  ASSIGN texttab_new+offset(vim_spras_length) TO &lt;spras_in_new&gt;.
*  offset = x_header-keylen + x_header-texttablen.
*  ASSIGN texttab_new+offset(1) TO &lt;action_in_new&gt;.
*  offset = x_header-keylen + x_header-textkeylen.
*  len = x_header-texttablen - x_header-textkeylen.
*  ASSIGN texttab_new+offset(len) TO &lt;textfields_in_new&gt;.
*  ASSIGN texttab_orig+offset(len) TO &lt;textfields_in_orig&gt;.

  LOOP AT &lt;vim_texttab&gt; INTO texttab_orig FROM orig_tabix.
    IF &lt;viewkey_in_orig&gt; &lt;&gt; orig_key. EXIT. ENDIF.
    READ TABLE &lt;vim_texttab&gt; WITH KEY new_key               &quot;#EC WARNOK
                     INTO texttab_new BINARY SEARCH.
    new_tabix = sy-tabix.
    IF &lt;viewkey_in_new&gt; = new_key AND
       &lt;spras_in_new&gt; &lt; &lt;spras_in_orig&gt;.                  &quot;#EC PORTABLE
      LOOP AT &lt;vim_texttab&gt; FROM new_tabix INTO texttab_new.
        IF &lt;viewkey_in_new&gt; &lt;&gt; new_key OR                 &quot;#EC PORTABLE
           &lt;spras_in_new&gt; &gt;= &lt;spras_in_orig&gt;.
          new_tabix = sy-tabix.
          EXIT.
* Condition redundant - Internal Message 0001699060 - ACHACHADI
*        ELSEIF &lt;spras_in_new&gt; &lt; &lt;spras_in_orig&gt;.          &quot;#EC PORTABLE
         ELSE.
          new_tabix = sy-tabix + 1.
        ENDIF.
      ENDLOOP.
    ENDIF.
    IF &lt;viewkey_in_new&gt; &lt;&gt; new_key OR
       &lt;spras_in_new&gt; &lt;&gt; &lt;spras_in_orig&gt;.
*    es gibt noch keinen Eintrag mit neuem Schlüssel
      texttab_new = texttab_orig.
      &lt;viewkey_in_new&gt; = new_key.
      PERFORM map_viewkey_to_texttabkey TABLES x_namtab
                                        USING x_header
                                              &lt;spras_in_orig&gt;
                                              new_key
                                        CHANGING &lt;textkey_in_new&gt;.
*      PERFORM vim_fill_texttab_key USING new_key
*                          &lt;spras_in_orig&gt; x_header-sprasfdpos
*                                   CHANGING &lt;textkey_in_new&gt;.
      &lt;action_in_new&gt; = neuer_eintrag.
      INSERT texttab_new INTO &lt;vim_texttab&gt; INDEX new_tabix.
    ELSE.
      IF &lt;action_in_new&gt; = original.
        &lt;action_in_new&gt; = aendern.
      ENDIF.
      &lt;textfields_in_new&gt; = &lt;textfields_in_orig&gt;.
      MODIFY &lt;vim_texttab&gt; FROM texttab_new INDEX new_tabix.
    ENDIF.
  ENDLOOP.
  MODIFY vim_texttab_container INDEX vim_texttab_container_index.
ENDFORM.                               &quot; VIM_COPY_TEXTTAB_ENTRY</include_source>
   </include>
   <include NAME="LSVIMFXP" VARCL="X" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE LSVIMFXP  form routines to activate profiles               *
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PROFILES
*&amp;---------------------------------------------------------------------*
*  NOT IN USE ANYMOREW BUT STILL CALLED IN APPLICATION FUNCTION GROUPS
*       Get customizing profiles using Function
*       SCPR_SHOW_CUT_OF_VIEW
*----------------------------------------------------------------------*
*  &lt;--  p_selected  Flag X: Profil wurde bereits ausgewählt und
*                           importiert ==&gt; nur anzeigen
*----------------------------------------------------------------------*
FORM get_profiles USING p_selected TYPE c.             &quot;#EC NEEDED

*  DATA: cobj_type VALUE &apos;V&apos;.           &quot;customizing-objecttype
*
*  IF x_header-bastab NE space.               &quot;HCG FuBa gelöscht zu 700
*    cobj_type = vim_tabl.
*  ENDIF.
*  CLEAR vim_pr_activating.
*  CALL FUNCTION &apos;SCPR_SHOW_OUT_OF_VIEW&apos;
*    EXPORTING
*      tabname            = x_header-viewname
*      tabtype            = cobj_type
*      preselection       = p_selected
*      cluster            = vim_called_by_cluster
*    TABLES
*      header             = x_header
*      namtab             = x_namtab
*      sellist            = &lt;vim_ck_sellist&gt;
*    EXCEPTIONS
*      user_abort         = 1
*      no_profile_found   = 2
*      profile_dont_exist = 3
*      no_data            = 4
*      OTHERS             = 5.
*  CASE sy-subrc.
*    WHEN 2.
*      MESSAGE s820(sv).
**   Kein Profil gefunden.
*    WHEN 3.
*      IF cobj_type = &apos;S&apos;.
*        MESSAGE s822(sv) WITH x_header-viewname.
**   Zur Tabelle &amp; existiert kein Profil.
*      ELSE.
*        MESSAGE s821(sv) WITH x_header-viewname.
**   Zur View &amp; existiert kein Profil.
*      ENDIF.
*  ENDCASE.
ENDFORM.                               &quot; GET_PROFILES
*&amp;---------------------------------------------------------------------*
*&amp;      Form  IMPORT_PROFILE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*----------------------------------------------------------------------*
FORM import_profile USING actopts TYPE scpractopt.

  DATA:          ext_field(1000),                          &quot;#EC NEEDED
                 pr_field(1000),                               &quot;#EC NEEDED
                 next,                                     &quot;#EC NEEDED
                 i TYPE i VALUE 1,
                 extr_lin TYPE i,
                 len_text TYPE i, profile_used,
                 imported_to_all VALUE &apos;X&apos;.                        &quot;#EC NEEDED
  FIELD-SYMBOLS: &lt;pr_field&gt;, &lt;bc_total_key&gt;,                &quot;#EC NEEDED
                 &lt;bc_total&gt;, &lt;bc_total_action&gt;, &lt;bc_total_mark&gt;,&quot;#EC NEEDED
                 &lt;w_record&gt; TYPE vim_pr_tab_type.

  len_text = x_header-texttablen - x_header-textkeylen.
  CASE status-action.
    WHEN aendern.
* import in update mode
      IF status-mode = list_bild.
* import in list screen
        LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt;.
          IF &lt;w_record&gt;-action = aendern.
* update existing entry
            LOOP AT extract.
              CHECK &lt;w_record&gt;-keys = &lt;vim_xextract_key&gt;.
              PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                      aendern actopts.
              MODIFY extract.
              EXIT.
            ENDLOOP.
          ELSE.
* new entry
            MOVE &lt;initial_x&gt; TO &lt;vim_xextract&gt;.
            &lt;vim_xextract_key&gt; = &lt;w_record&gt;-keys.
            PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                  neuer_eintrag actopts.
            APPEND extract.
            ADD 1 TO maxlines.
          ENDIF.
        ENDLOOP.
        SORT extract BY &lt;vim_xextract_key&gt;.
      ELSE.
* import in detail mode
        LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt; WHERE
         action = neuer_eintrag.
          MOVE &lt;initial_x&gt; TO &lt;vim_xextract&gt;.
          &lt;vim_xextract_key&gt; = &lt;w_record&gt;-keys.
          PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                               neuer_eintrag actopts.
          APPEND extract.
          ADD 1 TO maxlines.
        ENDLOOP.
* update existing entries
        LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt; WHERE action = aendern.
          CLEAR profile_used.
          LOOP AT extract.
            CHECK &lt;w_record&gt;-keys = &lt;vim_xextract_key&gt;.
            PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                    aendern actopts.
            MODIFY extract.
            profile_used = &apos;X&apos;.
            EXIT.
          ENDLOOP.
          IF profile_used = space.
            LOOP AT total INTO extract.
              CHECK &lt;w_record&gt;-keys = &lt;vim_xextract_key&gt;.
              PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                      aendern actopts.
              APPEND extract.
              ADD 1 TO maxlines.
              EXIT.
            ENDLOOP.
          ENDIF.
        ENDLOOP.
        SORT extract BY &lt;vim_xextract_key&gt;.
      ENDIF.
    WHEN hinzufuegen.
* import from append status
      IF status-mode = list_bild.
* import in list mode
        DESCRIBE TABLE extract LINES extr_lin.
        LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt; WHERE
         action = neuer_eintrag.
          IF extr_lin LE i.
* add blank line to extract
            CLEAR extract. MOVE leer TO &lt;xact&gt;.
            APPEND extract.
          ENDIF.
* new entry
          LOOP AT extract FROM i.
            CHECK &lt;xact&gt; = leer.
            i = sy-tabix + 1.
            ADD 1 TO maxlines.
            &lt;vim_xextract_key&gt; = &lt;w_record&gt;-keys.
            PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                 neuer_eintrag actopts.
            MODIFY extract.
            EXIT.
          ENDLOOP.
        ENDLOOP.
      ELSE.
* import in detail mode
        MOVE &lt;initial_x&gt; TO &lt;vim_xextract&gt;.
        LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt; WHERE
         action = neuer_eintrag.
          &lt;vim_xextract_key&gt; = &lt;w_record&gt;-keys.
          PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                               neuer_eintrag actopts.
          APPEND extract.
          ADD 1 TO maxlines.
        ENDLOOP.
      ENDIF.
* update existing entries
      LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt; WHERE action = aendern.
        LOOP AT total INTO extract.
          CHECK &lt;w_record&gt;-keys = &lt;vim_xextract_key&gt;.
          PERFORM bcset_force_into_entry USING    &lt;w_record&gt;
                                                  aendern actopts.
          APPEND extract.
          EXIT.
        ENDLOOP.
      ENDLOOP.
      SORT extract BY &lt;vim_xextract_key&gt;.
  ENDCASE.
ENDFORM.                               &quot; IMPORT_PROFILE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PROFILE_STATUS
*&amp;---------------------------------------------------------------------*
*       Checks key fields of the profile whether they&apos;re fixed or not
*       and concatenates profile keys into the lines of vim_pr_tab
*       according to their nametab-position.
*       Table &amp; Texttable: Fills textfield value and initial text key
*       into VIM_PR_TAB.
*----------------------------------------------------------------------*
*  &lt;--  VIM_PR_TAB     contains for every record key status, key values
*                      and textfields
*  &lt;--  VIM_PR_FIELDS  Contains all profile fields filled with
*                      values. Used to set the request-flag in PBO.
*----------------------------------------------------------------------*
FORM get_profile_status CHANGING vim_pr_tab LIKE vim_pr_tab
                                 vim_pr_fields LIKE vim_pr_fields[].

  DATA:          w_profile TYPE scpr_vals,
                 w_vim_pr_tab TYPE vim_pr_tab_type,
                 w_vim_pr_fields TYPE vim_pr_fields_type,
                 recnumber LIKE scprvals-recnumber,
                 text(1000), value LIKE vimsellist-value,   &quot;#EC NEEDED
                 gottext, first, rc LIKE sy-subrc,           &quot;#EC NEEDED
                 fieldname TYPE fnam_____4.
  FIELD-SYMBOLS: &lt;pr_key&gt;,                                  &quot;#EC NEEDED
                 &lt;x_keys&gt; TYPE x, &lt;x_text&gt; TYPE x,
                 &lt;bc_val&gt; TYPE ANY, &lt;imp_val&gt; TYPE ANY,
                 &lt;keys_struc&gt; TYPE ANY, &lt;text_struc&gt; TYPE ANY.

  ASSIGN: w_vim_pr_tab-keys TO &lt;x_keys&gt; CASTING,
          &lt;x_keys&gt; TO &lt;keys_struc&gt; CASTING TYPE (x_header-maintview).
  IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
    ASSIGN: w_vim_pr_tab-textrecord TO &lt;x_text&gt; CASTING,
            &lt;x_text&gt; TO &lt;text_struc&gt; CASTING TYPE (x_header-texttab).
  ENDIF.
  RANGES dont_use FOR scprvals-recnumber.
  dont_use-sign = &apos;E&apos;. dont_use-option = &apos;EQ&apos;.

  LOOP AT vim_pr_tab INTO w_vim_pr_tab.
    READ TABLE vim_pr_fields INTO w_vim_pr_fields WITH KEY
     recnumber = w_vim_pr_tab-recnumber.
    &lt;x_keys&gt; = &lt;initial_x&gt;(x_header-keylen).
*    w_vim_pr_tab-keys = &lt;initial&gt;(x_header-keylen).
    IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
      &lt;x_text&gt; = &lt;initial_textkey_x&gt;.
*      w_vim_pr_tab-textrecord = &lt;initial_textkey&gt;.
    ENDIF.
* Fill key fields
    LOOP AT x_namtab WHERE keyflag = &apos;X&apos; AND texttabfld IS INITIAL.
      IF x_namtab-datatype = &apos;CLNT&apos; AND x_header-clidep &lt;&gt; space.
*        MOVE sy-mandt TO
*             w_vim_pr_tab-keys+x_namtab-position(x_namtab-flength).
        DELETE TABLE w_vim_pr_fields-fields WITH TABLE KEY
         fieldname = x_namtab-viewfield.
        MODIFY TABLE vim_pr_fields FROM w_vim_pr_fields.
*        IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
*          MOVE sy-mandt TO
*         w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength).
*        ENDIF.
      ELSE.
        CLEAR w_profile.
        READ TABLE vim_profile_values INTO w_profile WITH KEY
                   tablename = x_header-viewname
                   fieldname = x_namtab-viewfield
                   recnumber = w_vim_pr_tab-recnumber.
        IF w_profile-flag = vim_profile_fixkey.
          CASE w_vim_pr_tab-keys_fix.
            WHEN space.
              w_vim_pr_tab-keys_fix = vim_pr_all_fix.
            WHEN vim_pr_open.
              w_vim_pr_tab-keys_fix = vim_pr_some_fix.
          ENDCASE.
        ELSE.
          CASE w_vim_pr_tab-keys_fix.
            WHEN space.
              w_vim_pr_tab-keys_fix = vim_pr_open.
            WHEN vim_pr_all_fix.
              w_vim_pr_tab-keys_fix = vim_pr_some_fix.
          ENDCASE.
        ENDIF.
        IF x_namtab-readonly &lt;&gt; subset.&quot;subsetf. already in &lt;initial&gt;
* use profile keyfield
          CONCATENATE x_header-maintview x_namtab-viewfield
           INTO fieldname SEPARATED BY &apos;-&apos;.
          ASSIGN: w_profile-value TO &lt;bc_val&gt; CASTING TYPE (fieldname),
                      COMPONENT x_namtab-viewfield
                       OF STRUCTURE &lt;keys_struc&gt; TO &lt;imp_val&gt;.
          &lt;imp_val&gt; = &lt;bc_val&gt;.
*          MOVE w_profile-value(x_namtab-flength) TO
*          w_vim_pr_tab-keys+x_namtab-position(x_namtab-flength).
          IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space.
* make text table key (for finding the suitable text value only)
            ASSIGN COMPONENT x_namtab-txttabfldn
                   OF STRUCTURE &lt;text_struc&gt; TO &lt;imp_val&gt;.
            &lt;imp_val&gt; = &lt;bc_val&gt;.
*            MOVE w_profile-value(x_namtab-flength) TO
*         w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength).
          ENDIF.
        ENDIF.                         &quot;x_namtab-readonly &lt;&gt; subset
        w_vim_pr_fields-keys_fix = w_vim_pr_tab-keys_fix.
        MODIFY vim_pr_fields FROM w_vim_pr_fields TRANSPORTING keys_fix
                 WHERE recnumber = w_vim_pr_fields-recnumber.
      ENDIF.                           &quot;x_namtab-datatype = &apos;CLNT&apos;
    ENDLOOP.
    IF x_header-bastab &lt;&gt; space AND x_header-texttbexst &lt;&gt; space AND
       w_vim_pr_tab-keys_fix &lt;&gt; vim_pr_error.
* get record for text table
      CLEAR recnumber.
      IF vim_pr_records &gt; 1.
        WHILE gottext = space.
          gottext = &apos;X&apos;.
          first = &apos;X&apos;.
          LOOP AT vim_profile_values INTO w_profile WHERE
                          tablename = x_header-texttab
                          AND recnumber IN dont_use[].
            IF first = &apos;X&apos;.
              recnumber = w_profile-recnumber.
              CLEAR first.
            ELSE.
              IF recnumber &lt;&gt; w_profile-recnumber.
                IF gottext &lt;&gt; space. EXIT. ENDIF.
                recnumber = w_profile-recnumber.
              ENDIF.
            ENDIF.
            IF w_profile-flag+2 = &apos;Y&apos;. &quot;keY, ukY or fkY -&gt; Key fields!
* check key-value
              IF w_profile-fieldname = x_header-sprasfield.
                IF w_profile-value(1) &lt;&gt; sy-langu.
                  dont_use-low = recnumber.
                  APPEND dont_use.
                  CLEAR: text, gottext.
                  CONTINUE.
                ENDIF.
              ELSE.
                READ TABLE x_namtab WITH KEY
                                    viewfield = w_profile-fieldname
                                    keyflag = &apos;X&apos; texttabfld = &apos;X&apos;.
                CONCATENATE x_header-texttab x_namtab-txttabfldn
                         INTO fieldname SEPARATED BY &apos;-&apos;.
                ASSIGN: w_profile-value TO &lt;bc_val&gt;
                         CASTING TYPE (fieldname),
                        COMPONENT x_namtab-txttabfldn
                         OF STRUCTURE &lt;text_struc&gt; TO &lt;imp_val&gt;.
*                ASSIGN w_profile-value(x_namtab-flength) TO &lt;vgl1&gt;.
*   ASSIGN w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength)
*                                                          TO &lt;vgl2&gt;.
*                IF &lt;vgl1&gt; &lt;&gt; &lt;vgl2&gt;.
                IF &lt;imp_val&gt; &lt;&gt; &lt;bc_val&gt;.
                  CLEAR gottext.
                  dont_use-low = recnumber.
                  APPEND dont_use.
*                    CLEAR text.
                  CONTINUE.
                ENDIF.
              ENDIF.
*              ELSE.
** store textfield.
*                text = w_profile-value.
*                APPEND w_profile-fieldname TO w_vim_pr_fields-fields.
            ENDIF.                                          &quot;key field
          ENDLOOP.
        ENDWHILE.
        IF gottext &lt;&gt; space.
          recnumber = w_profile-recnumber.
        ENDIF.
*          IF NOT text IS INITIAL.
*            READ TABLE x_namtab WITH KEY keyflag = space
*                                         texttabfld = &apos;X&apos;.
*            MOVE text TO
*         w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength).
*            CLEAR: text, gottext.
*          ENDIF.
      ELSEIF vim_pr_records = 1.
* insert language into text table key
*           READ TABLE x_namtab WITH KEY viewfield = x_header-sprasfield
*                                        keyflag = &apos;X&apos; texttabfld = &apos;X&apos;.
        ASSIGN COMPONENT x_header-sprasfield
                      OF STRUCTURE &lt;text_struc&gt; TO &lt;imp_val&gt;.
        &lt;imp_val&gt; = sy-langu.
*            MOVE sy-langu TO
*         w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength).
        READ TABLE vim_profile_values INTO w_profile WITH KEY
                   tablename = x_header-texttab
                   fieldname = x_header-sprasfield
                   value = sy-langu.
        IF sy-subrc = 0.
* textfield value found
          recnumber = w_profile-recnumber.
        ENDIF.
      ENDIF.                                                &quot;lines = 1
      IF NOT recnumber IS INITIAL.
*textvalue in bc-set found
        LOOP AT x_namtab WHERE keyflag = space AND
                                     texttabfld = &apos;X&apos;.
          CONCATENATE x_header-texttab x_namtab-viewfield
                   INTO fieldname SEPARATED BY &apos;-&apos;.
          READ TABLE vim_profile_values INTO w_profile WITH KEY
                           tablename = x_header-texttab
                           recnumber = recnumber
                           fieldname = x_namtab-viewfield.
          ASSIGN: w_profile-value TO &lt;bc_val&gt;
                   CASTING TYPE (fieldname),
                  COMPONENT x_namtab-viewfield
                   OF STRUCTURE &lt;text_struc&gt; TO &lt;imp_val&gt;.
          &lt;imp_val&gt; = &lt;bc_val&gt;.
*                MOVE w_profile-value
*      TO w_vim_pr_tab-textrecord+x_namtab-texttabpos(x_namtab-flength).
          APPEND w_profile-fieldname TO w_vim_pr_fields-fields.
        ENDLOOP.
      ELSE.
* no text value in bc-set
        MOVE &lt;text_initial_x&gt; TO &lt;x_text&gt;.
      ENDIF.
    ENDIF.                             &quot;text table exists
    MODIFY vim_pr_tab FROM w_vim_pr_tab.
    MODIFY TABLE vim_pr_fields FROM w_vim_pr_fields.
  ENDLOOP.
ENDFORM.                    &quot;get_profile_status
*&amp;---------------------------------------------------------------------*
*&amp;      Form  ACTIVATE_PROFILE
*&amp;---------------------------------------------------------------------*
*     No longer in use: For 6.20 the funcionality of BC set activation
*     via SM30 was abolished
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM activate_profile CHANGING p_selected
TYPE c.

  DATA: pr_rc TYPE i, pr_funcsafe(4), pr_counter TYPE i,    &quot;#EC TYPES_MISS
        pr_mark_entries VALUE &apos;X&apos;, hf1  TYPE i, hf  TYPE i,  &quot;#EC NEEDED
        cobj_type VALUE &apos;V&apos;, pr_key_da, pr_recnumber TYPE scpr_recnr,&quot;#EC NEEDED
        bc_id TYPE scpr_id, bc_rec_found(1) TYPE c,
        actopts TYPE scpractopt.&quot;HCG always empty, only nec. 46C 610
  STATICS: viewname LIKE vimdesc-viewname.
  FIELD-SYMBOLS: &lt;pr_f1&gt; TYPE x, &lt;w_record&gt; TYPE vim_pr_tab_type,
                 &lt;bc_key&gt; TYPE x.

  CHECK status-action NE anzeigen AND  &quot;ignore wrong setted requestflags
        status-action NE transportieren. &quot;due to individual F4 modules
  CLEAR vim_pr_activating.
  IF p_selected IS INITIAL.
* read profile
    REFRESH: vim_profile_values, vim_pr_tab.
*    CALL FUNCTION &apos;SCPR_ACTIVATE&apos;     // Ast stillgelegt, der Baustein
*                                      // existiert nicht mehr
*        EXPORTING
*             tabname          = x_header-viewname
*             initial          = &lt;initial&gt;
*       IMPORTING
*            PROFID           =
*        TABLES
*             values           = vim_profile_values
*             sellist          = dpl_sellist
*        EXCEPTIONS
*             user_abort       = 1
*             no_profile_found = 2
*             OTHERS           = 3.
*    CASE sy-subrc.
*      WHEN 0.
*        p_selected = &apos;X&apos;. viewname = x_header-viewname.
*        SORT vim_profile_values BY id version tablename recnumber.
*        IF &apos;AU&apos; CA status-action.
* get records the profile contains
*          PERFORM get_pr_nbr_records USING vim_profile_values
*                                           x_header
*                                     CHANGING pr_rc
*                                              bc_id
*                                              vim_pr_records
*                                              vim_pr_tab
*                                              vim_pr_fields.
* check key-status
*          PERFORM get_profile_status CHANGING vim_pr_tab
*                                              vim_pr_fields.
*        ENDIF.
*      WHEN 1.
*        EXIT.
*      WHEN 2.
*        IF x_header-bastab NE space.
*          cobj_type = vim_tabl.
*        ENDIF.
*        IF cobj_type = &apos;S&apos;.
*          MESSAGE e822(sv) WITH x_header-viewname.
*   Zur Tabelle &amp; existiert kein Profil.
*        ELSE.
*          MESSAGE e821(sv) WITH x_header-viewname.
*   Zur View &amp; existiert kein Profil.
*        ENDIF.
*    ENDCASE.
  ELSE.
    IF vim_called_by_cluster &lt;&gt; space AND
     viewname &lt;&gt; x_header-viewname.
* update key values according to current view and selection
      viewname = x_header-viewname.
      IF &apos;AU&apos; CA status-action.
* get records the profile contains
        PERFORM get_pr_nbr_records USING vim_profile_values
                                         x_header
                                   CHANGING pr_rc
                                            bc_id
                                            vim_pr_records
                                            vim_pr_tab
                                            vim_pr_fields.
* check key-status
        PERFORM get_profile_status CHANGING vim_pr_tab
                                            vim_pr_fields.
      ENDIF.
    ENDIF.
  ENDIF.
* check, if bc-set-records refer to existing datasets
  PERFORM bcset_key_check_in_total.
  PERFORM markiere_alle USING nicht_markiert.
  PERFORM import_profile USING actopts.
* viewcluster: show list of views to work on
  IF vim_called_by_cluster &lt;&gt; space.
    CALL FUNCTION &apos;VIEWCLUSTER_PR_IMPORT_CTRL&apos;
      EXPORTING
        viewname        = x_header-viewname
        action          = &apos;M&apos;
      TABLES
        profile_values  = vim_profile_values
      EXCEPTIONS                                           &quot;#EC FB_RC
        wrong_parameter = 1
        OTHERS          = 2.
  ENDIF.
  replace_mode = &apos;X&apos;.
  vim_special_mode = vim_upgrade.
* handle changed entries
  ASSIGN &lt;vim_xtotal&gt;(x_header-tablen) TO &lt;pr_f1&gt; CASTING.
  LOOP AT extract.
    CHECK &lt;xact&gt; = aendern OR &lt;xact&gt; = neuer_eintrag.
    CLEAR vim_bc_entry_list_wa.
    vim_bc_entry_list_wa-id = bc_id.
    vim_bc_entry_list_wa-viewname = x_header-viewname.
    hf = sy-tabix.
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
    IF sy-subrc EQ 0.                  &quot;entry exists in current client
      hf1 = sy-tabix.
      IF &lt;xact&gt; EQ neuer_eintrag AND
      &lt;action&gt; EQ geloescht OR &lt;action&gt; EQ neuer_geloescht OR
      &lt;action&gt; EQ update_geloescht.
        status-delete = geloescht.
* entry deleted in cur clnt -&gt; first undelete it
        &lt;xact&gt; = &lt;action&gt;.
        MODIFY extract.
        pr_funcsafe = function.
        CLEAR pr_rc.
        PERFORM vim_mark_and_process USING hf &apos;UNDO&apos; hf1
                                           pr_rc.
        CLEAR status-delete. function = pr_funcsafe.
        CHECK pr_rc NE 4.
        IF pr_rc EQ 8.
          EXIT.
        ENDIF.
        READ TABLE extract INDEX hf.
        READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH.&quot;#EC WARNOK
        hf1 = sy-tabix.
        &lt;xact&gt; = aendern. MODIFY extract.
      ENDIF.
      IF &lt;vim_xtotal_key&gt; = &lt;vim_xextract_key&gt;.
* record already exists: do not import but save
        &lt;action&gt; = aendern.
        MODIFY total INDEX hf1.
        IF x_header-bastab NE space AND x_header-texttbexst NE space.
          TRANSLATE &lt;status&gt;-upd_flag USING &apos; ETX&apos;.
        ELSE.
          &lt;status&gt;-upd_flag = &apos;X&apos;.
        ENDIF.
      ENDIF.
    ENDIF.                             &quot;sy-subrc eq 0.
    CLEAR vim_pr_fields_wa.
    CLEAR bc_rec_found.
    LOOP AT vim_pr_tab ASSIGNING &lt;w_record&gt;.
      ASSIGN &lt;w_record&gt;-keys(x_header-keylen) TO &lt;bc_key&gt;.
      CHECK &lt;bc_key&gt; = &lt;vim_xextract_key&gt;.
      bc_rec_found = &apos;X&apos;.
      READ TABLE vim_pr_fields INTO vim_pr_fields_wa WITH KEY
       recnumber = &lt;w_record&gt;-recnumber.
      vim_bc_entry_list_wa-id = bc_id.
      vim_bc_entry_list_wa-recnumber = &lt;w_record&gt;-recnumber.
      vim_bc_entry_list_wa-keys = &lt;bc_key&gt;.
*      if x_header-bastab &lt;&gt; space and x_header-texttbexst &lt;&gt; space.
** table with text table
*        vim_bc_entry_list_wa-keys + x_header-keylen =
*         &lt;w_record&gt;-textrecord(x_header-textkeylen).
*      endif.
      vim_bc_entry_list_wa-action = neuer_eintrag.
      INSERT LINES OF vim_pr_fields_wa-fields INTO TABLE
       vim_bc_entry_list_wa-fields.
      EXIT.
    ENDLOOP.
    CHECK NOT bc_rec_found IS INITIAL.
    IF &lt;xact&gt; &lt;&gt; aendern OR &lt;pr_f1&gt; &lt;&gt; &lt;table2_x&gt;.
* import bc-set record
      CHECK NOT vim_pr_fields_wa IS INITIAL.
      &lt;status&gt;-prof_found = vim_pr_into_view.
      PERFORM vim_modify_view_entry USING hf pr_rc.
      &lt;status&gt;-prof_found = vim_profile_found.
      CHECK pr_rc NE 4.
      IF pr_rc EQ 8.
        EXIT.
      ENDIF.
    ENDIF.
    READ TABLE total WITH KEY &lt;vim_xtotal_key&gt; BINARY SEARCH &quot;#EC WARNOK
                     TRANSPORTING NO FIELDS.
    IF &lt;mark&gt; EQ nicht_markiert.
      &lt;mark&gt; = markiert. ADD 1 TO mark_total.
      MODIFY total INDEX sy-tabix.
    ENDIF.
    extract = total.
    MODIFY extract.
    INSERT vim_bc_entry_list_wa INTO TABLE vim_bc_entry_list.
    IF sy-subrc = 4.
      MODIFY TABLE vim_bc_entry_list FROM vim_bc_entry_list_wa.
    ENDIF.
    ADD 1 TO pr_counter.
  ENDLOOP.
  IF pr_counter &lt; vim_pr_records.
    MESSAGE s818(sv) WITH pr_counter vim_pr_records.
*   Es wurden &amp;1 von &amp;2 Einträgen des Business-Configuration-Sets import
  ELSE.
    MESSAGE s819(sv).
*   Das Business-Configuration-Set wurde vollständig importiert.
  ENDIF.
  nextline = 1.
  CLEAR: vim_special_mode, replace_mode.
  PERFORM fill_extract.
  IF status-action EQ hinzufuegen.
    status-action = aendern.
    title-action  = aendern.
    CLEAR &lt;status&gt;-selected.
  ENDIF.
  IF status-mode = detail_bild.
* return to list screen
    vim_next_screen = liste. vim_leave_screen = &apos;X&apos;.
  ENDIF.
ENDFORM.                               &quot; ACTIVATE_PROFILE
*&amp;---------------------------------------------------------------------*
*&amp;      Form  SET_PROFILE_KEY_ATTRIBUTES
*&amp;---------------------------------------------------------------------*
*       sets screen input attribute according to profile attributes
*       of key field p_name
*----------------------------------------------------------------------*
*      &lt;--P_SCREEN_INPUT  text
*      &lt;--P_VIM_MODIFY_SCREEN  text
*----------------------------------------------------------------------*
FORM set_profile_key_attributes
                    USING p_name LIKE vim_objfield
                    CHANGING p_screen_input LIKE screen-input
                             p_modify_screen LIKE vim_modify_screen.

  DATA: w_field TYPE vimty_fields_type.

  p_screen_input = &apos;0&apos;.
  CASE vim_pr_fields_wa-keys_fix.
    WHEN vim_pr_open.
      p_screen_input = &apos;1&apos;. p_modify_screen = &apos;X&apos;.
    WHEN vim_pr_all_fix.
      p_screen_input = &apos;0&apos;.
    WHEN vim_pr_some_fix.
      READ TABLE vim_pr_fields_wa-fields INTO w_field
          WITH KEY fieldname = p_name.
      IF w_field-flag &lt;&gt; vim_profile_fixkey.
        p_screen_input = &apos;1&apos;. p_modify_screen = &apos;X&apos;.
      ENDIF.
  ENDCASE.
ENDFORM.                               &quot; SET_PROFILE_KEY_ATTRIBUTES
*&amp;---------------------------------------------------------------------*
*&amp;      Form  PROFILE_PUT_INTO_WA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p_record  bc-set
*  --&gt;  p_subset  flag: put &quot;initial&quot; value into subsetfield
*  --&gt;  p_action  action-flag from EXTRACT
*  &lt;--  p_field   view-maintenance dataset
*----------------------------------------------------------------------*
FORM profile_put_into_wa USING p_bc_set LIKE vim_profile_values
                               p_record TYPE vim_pr_tab_type
                               p_header TYPE vimdesc
                               p_namtab LIKE x_namtab[]
                               p_subset TYPE xfeld
                               p_action TYPE char1
                               actopts TYPE scpractopt
                         CHANGING p_field.
  DATA:          w_profile TYPE scpr_vals,
                 fieldname TYPE fnam_____4,
                 old_guid TYPE REF TO data,
                 tabname_wa TYPE objs-tabname,
                 objecttype TYPE objs-objecttype VALUE &apos;S&apos;.
  STATICS:       loc_viewname TYPE objs-objectname,
                 piecelist TYPE TABLE OF objs-tabname.
  FIELD-SYMBOLS: &lt;namtab&gt; TYPE vimnamtab, &lt;field&gt; TYPE ANY,
                 &lt;old_guid&gt; TYPE ANY, &lt;work_area&gt; TYPE ANY,
                 &lt;bc_value&gt; TYPE ANY.

  CONSTANTS: no_standard(1) TYPE c VALUE &apos;F&apos;,
             stan(3) TYPE c VALUE &apos;USE&apos;,
             new_entry(1) TYPE c VALUE &apos;N&apos;.                 &quot;IG 1036876

  ASSIGN p_field TO &lt;work_area&gt; CASTING TYPE (p_header-maintview).
  LOOP AT p_namtab ASSIGNING &lt;namtab&gt; WHERE keyflag = space
   AND texttabfld = space.
    ASSIGN COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;work_area&gt;
     TO &lt;field&gt;.
    CONCATENATE p_header-maintview &lt;namtab&gt;-viewfield
     INTO fieldname SEPARATED BY &apos;-&apos;.
    IF &lt;namtab&gt;-domname IN vim_guid_domain.
* GUID field
      IF p_action = neuer.
*     Overtake GUID from BC-Set for new entries.
      ELSE.
        IF p_record-keys_fix = vim_pr_all_fix.
          IF p_header-frm_af_uid &lt;&gt; space.
* prepare event 27
            CREATE DATA old_guid TYPE (fieldname).
*          ASSIGN p_field+&lt;namtab&gt;-position(&lt;namtab&gt;-flength)
*           TO &lt;guid&gt; CASTING TYPE (fieldname).
            ASSIGN: old_guid-&gt;* TO &lt;old_guid&gt;.
            &lt;old_guid&gt; = &lt;field&gt;.
          ENDIF.
        ELSE.
          CONTINUE.
* Use GUID from BC-Set only if complete key is given fix
        ENDIF.
      ENDIF.
    ENDIF.
    CASE &lt;namtab&gt;-readonly.
      WHEN space.
        READ TABLE p_bc_set INTO w_profile WITH KEY
          tablename = p_header-viewname
          recnumber = p_record-recnumber
          fieldname = &lt;namtab&gt;-viewfield BINARY SEARCH
          TRANSPORTING flag value.
        CHECK sy-subrc = 0.
        ASSIGN w_profile-value TO &lt;bc_value&gt; CASTING TYPE (fieldname).
*       Do not overwrite field of existing dataset with BC-Set value
*       if standard field (flag = USE) and actopts-no_standard = Y.
        IF actopts-no_standrd NE no_standard OR w_profile-flag NE stan
           OR p_action EQ new_entry.                        &quot;IG 1036876
          &lt;field&gt; = &lt;bc_value&gt;.
        ENDIF.
*        MOVE w_profile-value(&lt;namtab&gt;-flength)
*             TO p_field+&lt;namtab&gt;-position(&lt;namtab&gt;-flength).
      WHEN rdonly OR vim_hidden.       &quot;HCG Check if table in piece list
        IF p_header-viewname NE loc_viewname.
          loc_viewname = p_header-viewname.
          REFRESH piecelist.
          IF p_header-bastab EQ space. objecttype = &apos;V&apos;. ENDIF.
          SELECT tabname FROM objs INTO tabname_wa   &quot;Get info from OBJS
                       WHERE objectname = p_header-viewname
                       AND   objecttype = objecttype.
            APPEND tabname_wa TO piecelist.
          ENDSELECT.
        ENDIF.
        READ TABLE p_bc_set INTO w_profile WITH KEY
          tablename = p_header-viewname
          recnumber = p_record-recnumber
          fieldname = &lt;namtab&gt;-viewfield BINARY SEARCH
          TRANSPORTING flag value.
        CHECK sy-subrc = 0.
        READ TABLE piecelist INTO tabname_wa WITH KEY      &quot;#EC WARNOK
                                               &lt;namtab&gt;-bastabname.
        IF sy-subrc EQ 0. &quot;HCG If table is not in piecelist: skip field
          ASSIGN w_profile-value TO &lt;bc_value&gt; CASTING TYPE (fieldname).
*         Do not overwrite field of existing dataset with BC-Set value
*         if standard field (flag = USE) and actopts-no_standard = Y.
          IF actopts-no_standrd NE no_standard OR
             w_profile-flag NE stan OR p_action EQ new_entry.&quot;IG 1036876
            &lt;field&gt; = &lt;bc_value&gt;.
          ENDIF.
        ENDIF.
      WHEN subset.
        CHECK p_subset &lt;&gt; space.
        ASSIGN COMPONENT &lt;namtab&gt;-viewfield OF STRUCTURE &lt;initial&gt;
         TO &lt;bc_value&gt;.
*        MOVE &lt;initial&gt;+&lt;namtab&gt;-position(&lt;namtab&gt;-flength)
*         TO p_field+&lt;namtab&gt;-position(&lt;namtab&gt;-flength).
    ENDCASE.
    IF &lt;namtab&gt;-domname IN vim_guid_domain
     AND p_record-keys_fix = vim_pr_all_fix
     AND  p_header-frm_af_uid &lt;&gt; space.
* event 27 for GUID field
      PERFORM (p_header-frm_af_uid) IN PROGRAM (p_header-fpoolname)
                                    USING &lt;old_guid&gt;
                                    CHANGING &lt;field&gt;
                                             &lt;work_area&gt;.
    ENDIF.
  ENDLOOP.
ENDFORM.                               &quot; PROFILE_PUT_INTO_WA
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PR_NBR_RECORDS
*&amp;---------------------------------------------------------------------*
*       Get the number of records the chosen profile contains and get
*       the fields every record contains.
*----------------------------------------------------------------------*
*      --&gt;VIM_PROFILE_VALUES  contains bc-set
*      --&gt;X_HEADER
*      --&gt;P_RC                = 4: no record found
*      &lt;--VIM_PR_RECORDS      number of records in bc-set
*      &lt;--VIM_PR_TAB          table of bc-set-records, initialized
*      &lt;--VIM_PR_FIELDS       lists of matched fields for every record
*----------------------------------------------------------------------*
FORM get_pr_nbr_records USING vim_profile_values
                               LIKE vim_profile_values
                              x_header TYPE vimdesc
                        CHANGING p_rc LIKE sy-subrc
                                 p_bc_id TYPE scpr_id
                                 vim_pr_records TYPE i
                                 vim_pr_tab LIKE vim_pr_tab
                                 vim_pr_fields LIKE vim_pr_fields.

  DATA: w_vim_pr_tab TYPE vim_pr_tab_type, first VALUE &apos;X&apos;,
        w_vim_pr_fields TYPE vim_pr_fields_type,
        w_fields TYPE vimty_fields_type, recnumber TYPE scpr_recnr.
  FIELD-SYMBOLS: &lt;profile_value&gt; LIKE LINE OF vim_profile_values.

  REFRESH: vim_pr_tab, vim_pr_fields.
  CLEAR: vim_pr_records, p_rc.

  LOOP AT vim_profile_values ASSIGNING &lt;profile_value&gt;
       WHERE tablename = x_header-viewname.
    IF &lt;profile_value&gt;-recnumber &lt;&gt; recnumber.
      recnumber = &lt;profile_value&gt;-recnumber.
      IF first = space.
        APPEND w_vim_pr_tab TO vim_pr_tab.
        APPEND w_vim_pr_fields TO vim_pr_fields. CLEAR w_vim_pr_fields.
      ENDIF.
      CLEAR first.
      w_vim_pr_fields-recnumber = w_vim_pr_tab-recnumber
       = &lt;profile_value&gt;-recnumber.
      ADD 1 TO vim_pr_records.
    ENDIF.
    w_fields-fieldname = &lt;profile_value&gt;-fieldname.
    w_fields-flag = &lt;profile_value&gt;-flag.
    APPEND w_fields TO w_vim_pr_fields-fields.
  ENDLOOP.
  p_rc = sy-subrc.
  CHECK sy-subrc = 0.
  APPEND w_vim_pr_tab TO vim_pr_tab.
  APPEND w_vim_pr_fields TO vim_pr_fields.
  p_bc_id = &lt;profile_value&gt;-id.
*  IF w_vim_pr_tab-recnumber IS INITIAL.
*    w_vim_pr_tab-recnumber = 1. APPEND w_vim_pr_tab TO vim_pr_tab.
*    ADD 1 TO vim_pr_records.
*  ENDIF.
ENDFORM.                               &quot; GET_PR_NBR_RECORDS
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PR_FIELD_FROM_SEL
*&amp;---------------------------------------------------------------------*
*       extracts value for field P_PR_NAMTAB-VIEWFIELD from P_PR_SELLIST
*       into P_VIM_SEL_VALUE.
*----------------------------------------------------------------------*
*      &lt;--P_SEL_VALUE   extracted value, P_SEL_VALUE remain sunchanged
*      &lt;--P_RC          0: o.k.  1: no selection defined, P_SEL_VALUE
*                       remains unchanged  2: no unambiguous
*                       extraction possible, P_SEL_VALUE cleared
*      --&gt;P_PR_SELLIST  text
*      --&gt;P_PR_NAMTAB   text
*      --&gt;P_PR_CLUSTER  Flag: View maintenance called by cluster
*----------------------------------------------------------------------*
FORM get_pr_field_from_sel
       USING    p_pr_sellist TYPE vimsellist_type
                p_pr_namtab LIKE vimnamtab
       CHANGING p_sel_value LIKE dpl_sellist-value
                p_rc LIKE sy-subrc.

  DATA: w_sellist LIKE vimsellist, first.                   &quot;#EC TYPES_MISS

  p_rc = 1. first = &apos;X&apos;.
  LOOP AT p_pr_sellist INTO w_sellist.
    CHECK w_sellist-viewfield = p_pr_namtab-viewfield.
    IF first = space OR w_sellist-operator &lt;&gt; &apos;EQ&apos;.
      CLEAR p_sel_value. p_rc = 2. EXIT.
    ELSE.
      MOVE w_sellist-value(p_pr_namtab-flength) TO
       p_sel_value(p_pr_namtab-flength).
      p_rc = 0.
    ENDIF.
    CLEAR first.
  ENDLOOP.
ENDFORM.                               &quot; GET_PR_FIELD_FROM_SEL
*&amp;---------------------------------------------------------------------*
*&amp;      Form  VIM_PR_mand_fields
*&amp;---------------------------------------------------------------------*
*       Appending profiles in detail mode: Leaves screen to reset
*       mandatory attribute and to process sreen in background if
*       at least one dynpro-field is mandatory.
*----------------------------------------------------------------------*
FORM vim_pr_mand_fields.
  LOOP AT SCREEN.
    CHECK screen-required &lt;&gt; &apos;0&apos;.
    vim_pr_activating = &apos;X&apos;.
    SET SCREEN detail. LEAVE SCREEN.
  ENDLOOP.
ENDFORM.                               &quot; VIM_PR_AT_EXIT_COM
*&amp;---------------------------------------------------------------------*
*&amp;      Form  bcset_key_check_in_total
*&amp;---------------------------------------------------------------------*
*       check, if bc-set-key already exists
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
FORM bcset_key_check_in_total.

  DATA: w_record TYPE vim_pr_tab_type.
  FIELD-SYMBOLS: &lt;bc_key&gt; TYPE x.

  ASSIGN w_record-keys(x_header-keylen) TO &lt;bc_key&gt;.
  LOOP AT vim_pr_tab INTO w_record.
    CLEAR w_record-action.
    READ TABLE total WITH KEY &lt;bc_key&gt; BINARY SEARCH        &quot;#EC WARNOK
     TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      w_record-action = aendern.
    ELSE.
      w_record-action = neuer_eintrag.
    ENDIF.
    MODIFY vim_pr_tab FROM w_record.
  ENDLOOP.
ENDFORM.                               &quot; bcset_key_check_in_total
*&amp;---------------------------------------------------------------------*
*&amp;      Form  bcset_force_into_entry
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_&lt;W_RECORD&gt;  text
*      &lt;--P_AENDERN  text
*----------------------------------------------------------------------*
FORM bcset_force_into_entry USING    p_record TYPE vim_pr_tab_type
                                     p_action TYPE char1
                                     actopts TYPE scpractopt.

  FIELD-SYMBOLS: &lt;textrec_x&gt; TYPE x.

  IF &lt;xmark&gt; = nicht_markiert.
    &lt;xmark&gt; = markiert. ADD 1 TO mark_extract.
  ENDIF.
  &lt;xact&gt; = p_action.
  PERFORM profile_put_into_wa USING vim_profile_values
                                    p_record
                                    x_header
                                    x_namtab[]
                                    &apos;X&apos;
                                    p_action
                                    actopts
                              CHANGING &lt;vim_xextract&gt;.
*                              CHANGING &lt;table2&gt;.
  IF x_header-texttbexst &lt;&gt; space AND x_header-bastab &lt;&gt; space.
    ASSIGN p_record-textrecord(x_header-texttablen)
     TO &lt;textrec_x&gt; CASTING.
    MOVE &lt;textrec_x&gt; TO &lt;vim_xextract_text&gt;.
*    MOVE p_record-textrecord+x_header-textkeylen(len_text)
*             TO &lt;extract_text&gt;+x_header-textkeylen(len_text).
  ENDIF.
ENDFORM.                               &quot; bcset_force_into_entry</include_source>
   </include>
   <include NAME="LSVIMFXX" SQLX="X" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>INCLUDE LSVIMFXL.     &quot; Pflege von Text-Feldern in mehreren Sprachen
INCLUDE LSVIMFXP.     &quot; Form routines to activate profiles
INCLUDE LSVIMFX2.                      &quot; continueing LSVIMFXX
INCLUDE LSVIMFX3.     &quot; Form Routines for printing data into lists

  INCLUDE LSVIMF45 .  &quot; INITIALISIEREN

  INCLUDE LSVIMF44 .  &quot; VIM_PROCESS_ASSIGNS

  INCLUDE LSVIMF43 .  &quot; VIM_ASSIGN_MKEY_AFTER_2

  INCLUDE LSVIMF42 .  &quot; VIM_ASSIGN_MAINKEY_AFTER

  INCLUDE LSVIMF41 .  &quot; SET_POSITION_INFO

  INCLUDE LSVIMF40 .  &quot; SET_NUMBERED_TEXTS

  INCLUDE LSVIMF3Z .  &quot; INIT_STATE_VECTOR

  INCLUDE LSVIMF3Y .  &quot; SET_STATUS_NOKEYSELCNDS

  INCLUDE LSVIMF3X .  &quot; EXCLUDE_CUA_FUNCTIONS

  INCLUDE LSVIMF3W .  &quot; SET_PF_STATUS

  INCLUDE LSVIMF3V .  &quot; SET_TITLE

  INCLUDE LSVIMF3U .  &quot; JUSTIFY_ACTION_MODE

  INCLUDE LSVIMF3T .  &quot; VIM_SET_ALE_EDIT_LOCK


  INCLUDE LSVIMF3S .  &quot; VIM_CHECK_ALE_EDIT_LOCK

  INCLUDE LSVIMF3R .  &quot; VIM_SAPSCRIPT_FORM_MAINT

  INCLUDE LSVIMF3Q .  &quot; AEND_TO_ANZG

  INCLUDE LSVIMF3P .  &quot; ANZG_TO_AEND

  INCLUDE LSVIMF3O .  &quot; BEENDEN

  INCLUDE LSVIMF3N .  &quot; LISTE_BACK

  INCLUDE LSVIMF3M .  &quot; LISTE_ABBRECHEN

  INCLUDE LSVIMF3L .  &quot; IGNORIEREN

  INCLUDE LSVIMF3K .  &quot; BLAETTERN

  INCLUDE LSVIMF3J .  &quot; CHECK_UPD

  INCLUDE LSVIMF3I .  &quot; POPUP_POSITIONIEREN

  INCLUDE LSVIMF3H .  &quot; F4_POSITIONIEREN

  INCLUDE LSVIMF3G .  &quot; LISTE_MARKIERE

  INCLUDE LSVIMF3F .  &quot; MARKIERE_BLOCK

  INCLUDE LSVIMF3E .  &quot; MARKIERE

  INCLUDE LSVIMF3D .  &quot; MARKIERE_ALLE

  INCLUDE LSVIMF3C .  &quot; LISTE_ZURUECKHOLEN

  INCLUDE LSVIMF3B .  &quot; LOGICAL_UNDELETE_TOTAL

  INCLUDE LSVIMF3A .  &quot; SELEKTIERE

  INCLUDE LSVIMF39 .  &quot; NORMAL_SELECT

  INCLUDE LSVIMF38 .  &quot; SELECT

  INCLUDE LSVIMF37 .  &quot; FILL_EXTRACT

  INCLUDE LSVIMF36 .  &quot; MOD_EXTRACT_AND_MAINKEY_TAB

  INCLUDE LSVIMF35 .  &quot; CHECK_AND_MODIFY_MAINKEY_TAB

*  INCLUDE LSVIMF34 .  &quot; CHECK_IF_ENTRY_IS_TO_BE_MERGED

  INCLUDE LSVIMF33 .  &quot; CHECK_IF_ENTRY_IS_TO_DISPLAY

  INCLUDE LSVIMF32 .  &quot; READ_TABLE

  INCLUDE LSVIMF31 .  &quot; UPDATE_TAB

  INCLUDE LSVIMF30 .  &quot; VORHANDEN

  INCLUDE LSVIMF2Z .  &quot; UPDATE_ENTRY

  INCLUDE LSVIMF2Y .  &quot; NICHT_VORHANDEN

  INCLUDE LSVIMF2X .  &quot; CHECK_NEW_MAINKEY

  INCLUDE LSVIMF2W .  &quot; HINZUFUEGEN

  INCLUDE LSVIMF2V .  &quot; CHECK_KEY

  INCLUDE LSVIMF2U .  &quot; VIM_CK_APPEND_WHERETAB

  INCLUDE LSVIMF2T .  &quot; LISTE_LOESCHE

  INCLUDE LSVIMF2S .  &quot; LOGICAL_DELETE_FROM_TOTAL

  INCLUDE LSVIMF2R .  &quot; CHECK_IF_ENTRY_CAN_BE_DELETED

  INCLUDE LSVIMF2Q .  &quot; SUCHEN

  INCLUDE LSVIMF2P .  &quot; CONSIDER_OLD_EXCLUDE_TAB

  INCLUDE LSVIMF2O .  &quot; REPLACE

  INCLUDE LSVIMF2N .  &quot; KOPIERE

  INCLUDE LSVIMF2M .  &quot; KOPIERE_EINTRAG

  INCLUDE LSVIMF2L .  &quot; CALL_DYNPRO

  INCLUDE LSVIMF2K .  &quot; VIM_STORE_STATE_INFO

  INCLUDE LSVIMF2J .  &quot; VIM_RESTORE_STATE_INFO

  INCLUDE LSVIMF2I .  &quot; VIM_EXTERNAL_EDIT

  INCLUDE LSVIMF2H .  &quot; VIM_MARK_AND_PROCESS

  INCLUDE LSVIMF2G .  &quot; CHECK_DYNAMIC_SELECT_OPTIONS

  INCLUDE LSVIMF2F .  &quot; MODIFY_TABLES

  INCLUDE LSVIMF2E .  &quot; INIT_SUBSET_KEYFIELDS

  INCLUDE LSVIMF2D .  &quot; INIT_SUBSET_FCTFIELDS

  INCLUDE LSVIMF2C .  &quot; FILL_SUBSETFIELDS

  INCLUDE LSVIMF2B .  &quot; COMPLETE_EXPROFIELDS

  INCLUDE LSVIMF2A .  &quot; COMPLETE_SUBSETFIELDS

  INCLUDE LSVIMF29 .  &quot; VIM_MULTI_LANGU_TEXT_ALS

  INCLUDE LSVIMF28 .  &quot; X_ENQUEUE

  INCLUDE LSVIMF27 .  &quot; ENQUEUE

  INCLUDE LSVIMF25 .  &quot; LISTE_ADDRESS_MAINTAIN

  INCLUDE LSVIMF24 .  &quot; ADDRESS_MAINTAIN

  INCLUDE LSVIMF23 .  &quot; ORIGINAL_HOLEN

  INCLUDE LSVIMF22 .  &quot; ORDER_ADMINISTRATION

  INCLUDE LSVIMF21 .  &quot; GET_TRANSP_INFO

  INCLUDE LSVIMF20 .  &quot; REQUEST_CORR_NUMBER

  INCLUDE LSVIMF1Z .  &quot; CHECK_LOCKABLE_OBJECT

  INCLUDE LSVIMF1Y .  &quot; CHECK_TRANSP_OBJS_FOR_MAINT

  INCLUDE LSVIMF1X .  &quot; PREPARE_CORR

  INCLUDE LSVIMF1W .  &quot; UPDATE_CORR

  INCLUDE LSVIMF1V .  &quot; VIM_ADDRESS_KEYTAB_ENTRIES

  INCLUDE LSVIMF1U .  &quot; VIM_ADDR_KEYTAB_ENTRIES_INTERN

  INCLUDE LSVIMF1T .  &quot; UPDATE_CORR_KEYTAB

  INCLUDE LSVIMF1S .  &quot; CORR_UPD

  INCLUDE LSVIMF1R .  &quot; TRANSPORTIEREN

  INCLUDE LSVIMF1Q .  &quot; GET_KEYTAB

  INCLUDE LSVIMF1P .  &quot; PREPARE_READ_REQUEST

  INCLUDE LSVIMF1O .  &quot; VIM_FILL_WHERETAB

  INCLUDE LSVIMF1N .  &quot; EDIT_VIEW_ENTRY

  INCLUDE LSVIMF1M .  &quot; ZURUECKHOLEN

  INCLUDE LSVIMF1L .  &quot; LOESCHEN

  INCLUDE LSVIMF1K .  &quot; DELETE_CHECK_KEYRANGE

  INCLUDE LSVIMF1J .  &quot; MARK_IGNORED_ENTRIES

  INCLUDE LSVIMF1H .  &quot; BUILD_VALTAB_HFIELDS

  INCLUDE LSVIMF1G .  &quot; CHECK_ALLOWED_KEYRANGES

  INCLUDE LSVIMF1F .  &quot; RESET_ENTRIES

  INCLUDE LSVIMF1E .  &quot; PROCESS_ENTRY_RESET

  INCLUDE LSVIMF1D .  &quot; PROCESS_AFTER_ENTRY_RESET

  INCLUDE LSVIMF1C .  &quot; UPGRADE

  INCLUDE LSVIMF1B .  &quot; VIM_RESTORE_SUBSET_CONDS

  INCLUDE LSVIMF1A .  &quot; VIM_PROCESS_VIEW_ENTRY

  INCLUDE LSVIMF19 .  &quot; VIM_MODIFY_VIEW_ENTRY

  INCLUDE LSVIMF18 .  &quot; VIM_SET_IMPRES_HEADER

  INCLUDE LSVIMF17 .  &quot; VIM_CONVERT_TABKEY

  INCLUDE LSVIMF16 .  &quot; VIM_IMP_CALL_SCREEN

  INCLUDE LSVIMF15 .  &quot; MOVE_EXTRACT_TO_VIEW_WA

  INCLUDE LSVIMF14 .  &quot; PREPARE_SAVING

  INCLUDE LSVIMF13 .  &quot; AFTER_SAVING

  INCLUDE LSVIMF12 .  &quot; BEFORE_LEAVING_EXT

  INCLUDE LSVIMF11 .  &quot; BEFORE_LEAVING_FRAME_FUNCTION

  INCLUDE LSVIMF10 .  &quot; LISTE_EXIT_COMMAND

  INCLUDE LSVIMF0Z .  &quot; VIM_GET_GLOBAL_TABLE

  INCLUDE LSVIMF0Y .  &quot; VIM_GET_GLOBAL_FIELD_VALUE

  INCLUDE LSVIMF0X .  &quot; VIM_SET_GLOBAL_FIELD_VALUE

  INCLUDE LSVIMF0W .  &quot; VIM_APPEND_GLOBAL_TABLE

  INCLUDE LSVIMF0V .  &quot; VIM_RESTORE_LOCAL_MEMORY

  INCLUDE LSVIMF0U .  &quot; X_CALL_VIEWMAINTENANCE

  INCLUDE LSVIMF0T .  &quot; X_CALL_SCREEN

  INCLUDE LSVIMF0S .  &quot; AFTER_TEMPORAL_DELIMITATION

  INCLUDE LSVIMF0R .  &quot; CHECK_DELIM_NEW_ENTRY

  INCLUDE LSVIMF0Q .  &quot; TEMP_DELIM_DEL_OVERLD_ENTRIES

  INCLUDE LSVIMF0P .  &quot; TEMP_DELIM_UNDELETE

  INCLUDE LSVIMF0O .  &quot; TEMPORAL_DELIMITATION

  INCLUDE LSVIMF0N .  &quot; TEMP_DELIM_DETERMINE_ACTION

  INCLUDE LSVIMF0M .  &quot; CONSISTENCY_PRT_FRKY_FIELDS

  INCLUDE LSVIMF0L .  &quot; DELIMITATION

  INCLUDE LSVIMF0K .  &quot; TIME_DEPENDENT_DISPLAY_MODIF

  INCLUDE LSVIMF0J .  &quot; COLLAPSE

  INCLUDE LSVIMF0I .  &quot; BUILD_MAINKEY_TAB

  INCLUDE LSVIMF0H .  &quot; BUILD_MAINKEY_TAB_0

  INCLUDE LSVIMF0G .  &quot; BUILD_MAINKEY_TAB_1

*  INCLUDE LSVIMF0E .  &quot; CHECK_IF_ENTRY_CAN_BE_MERGED

  INCLUDE LSVIMF0D .  &quot; BUILD_MAINKEY_TAB_2

  INCLUDE LSVIMF0C .  &quot; DELETE_FROM_MAINKEY_TAB

  INCLUDE LSVIMF0B .  &quot; CHECK_MODIFY_MERGED_ENTRIES

  INCLUDE LSVIMF0A .  &quot; X_REFRESH_TCTRL

  INCLUDE LSVIMF09 .  &quot; VIM_PROCESS_MESSAGE

  INCLUDE LSVIMF08 .  &quot; VIM_SET_IMP_RESULTS

  INCLUDE LSVIMF07 .  &quot; VIM_SINGLE_ENTRY_FILL_SELLIST

  INCLUDE LSVIMF06 .  &quot; UPDATE_STATUS

  INCLUDE LSVIMF05 .  &quot; SHOW_FUNCTION_DOCU

  INCLUDE LSVIMF04 .  &quot; LOGS_ANALYSE

  INCLUDE LSVIMF46.   &quot; VIM_ADDR_ADJUST  Abgleich für Adressen

  INCLUDE LSVIMF50.   &quot; Viewcluster: Navigation über Control

  INCLUDE LSVIMF51.   &quot; VIM_ADD_IMG_NOTICES  Editor-Control für Notizen
  INCLUDE LSVIMF5A.   &quot; Logging BC-set import
  INCLUDE LSVIMF5B.   &quot; Check before ALV
  include lsvimf5c.   &quot; VIM_SET_GLOBAL_OBJECTS
  include lsvimf5d.   &quot; VIM_MAINT_SELFLAG
  include lsvimf5e.   &quot; maintaining GUIDs
  INCLUDE LSVIMF5F.   &quot; vim_read_table
  include lsvimf60.   &quot; vim_maintain_single_set
  include lsvimf61.   &quot; map viewkey to texttabkey
  INCLUDE LSVIMF62.   &quot; vim_get_tabkeylen
  INCLUDE LSVIMF63.   &quot; VIM_COMP_ROOTTABKEY
  INCLUDE LSVIMF64.   &quot; VIM_Synchronizer_call
  INCLUDE LSVIMF65.   &quot; CHECK_NONKEY</include_source>
   </include>
   <include NAME="LSVIMITX" VARCL="X" SUBC="I" LEVL="21A" RSTAT="T" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>***INCLUDE LSVIMITX .
MODULE SET_TXT_UPDATE_FLAG.                                &quot;#EC CALLED
  PERFORM SET_TXT_UPDATE_FLAG.
ENDMODULE.</include_source>
   </include>
   <include NAME="LSVIMIXX" SQLX="X" VARCL="X" SUBC="I" APPL="S" LEVL="12A" RMAND="000" RLOAD="D">
    <include_source>*---------------------------------------------------------------------*
*       MODULE SET_UPDATE_FLAG                                        *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE set_update_flag.                                     &quot;#EC CALLED

  DATA: lb_als TYPE REF TO if_ex_vim_als_badi.

  CHECK status-action NE anzeigen AND  &quot;ignore wrong setted requestflags
        status-action NE transportieren. &quot;due to individual F4 modules
  IF x_header-delmdtflag NE space AND
     status-type EQ einstufig AND
     status-mode EQ list_bild.         &quot;only on list screen
* check if dates entered properly
    IF ( &lt;vim_new_begdate&gt; EQ vim_init_date OR
       &lt;vim_enddate_mask&gt; EQ vim_init_date ).
      MESSAGE e127(sv).&quot;Bitte den Gültigkeitsbereich eingrenzen
    ENDIF.
    CLEAR sy-subrc.
    IF status-action EQ kopieren AND vim_special_mode NE vim_delimit.
      READ TABLE vim_copied_indices WITH KEY level = vim_copy_call_level
                                                ex_ix = nextline. &quot;#EC *
    ENDIF.
    IF sy-subrc NE 0 OR       &quot;copy mode and entry not yet processed or
       ( status-action EQ hinzufuegen AND &lt;xact&gt; EQ leer ).  &quot;new entry
      neuer = &apos;J&apos;.
      IF x_header-guidflag &lt;&gt; space.
        PERFORM vim_make_guid USING space.
      ENDIF.
      IF x_header-frm_on_new NE space.
        PERFORM (x_header-frm_on_new) IN PROGRAM.           &quot;#EC *
      ENDIF.
      PERFORM check_key.
      neuer = &apos;N&apos;.
    ENDIF.
  ENDIF.
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    TRANSLATE &lt;status&gt;-upd_flag USING &apos; ETX&apos;.
  ELSE.
    &lt;status&gt;-upd_flag = &apos;X&apos;.
  ENDIF.
* check in non key field entries violate selection conditions
  PERFORM check_nonkey.
* perform ALS if it is enabled
  CALL METHOD cl_exithandler=&gt;get_instance
    EXPORTING
      null_instance_accepted        = seex_false
      exit_name                     = &apos;VIM_ALS_BADI&apos;
    CHANGING
      instance                      = lb_als
    EXCEPTIONS
      no_reference                  = 1
      no_interface_reference        = 2
      no_exit_interface             = 3
      class_not_implement_interface = 4
      single_exit_multiply_active   = 5
      cast_error                    = 6
      exit_not_existing             = 7
      data_incons_in_exit_managem   = 8
      OTHERS                        = 9.
  IF sy-subrc NE 0.
    EXIT.
  ELSE.
    CALL METHOD lb_als-&gt;enable_als
      EXPORTING
        view_name   = x_header-viewname
      IMPORTING
        als_enabled = als_enabled.

    IF als_enabled = &apos;X&apos; AND x_header-bastab EQ space.
      PERFORM set_als_update_flag.
    ENDIF.
  ENDIF.

ENDMODULE.                    &quot;set_update_flag

*---------------------------------------------------------------------*
*       MODULE DETAIL_EXIT_COMMAND                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE detail_exit_command.                                 &quot;#EC CALLED
  PERFORM detail_exit_command.
ENDMODULE.                    &quot;detail_exit_command

*---------------------------------------------------------------------*
*       MODULE LISTE_EXIT_COMMAND                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_exit_command.                                  &quot;#EC CALLED
  PERFORM liste_exit_command.
ENDMODULE.                    &quot;liste_exit_command

*---------------------------------------------------------------------*
*       MODULE LISTE_AFTER_LOOP                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_after_loop.                                    &quot;#EC CALLED
** Table-control !!!
  IF vim_tabctrl_active NE space.
    IF nextline NE &lt;vim_tctrl&gt;-top_line.
      nextline = &lt;vim_tctrl&gt;-top_line.
    ENDIF.
  ENDIF.
** Table-control !!!
  IF destpage NE 0.
    nextline = destpage. CLEAR destpage.
  ENDIF.
* IF TEMPORAL_DELIMITATION_HAPPENED NE SPACE.
  IF vim_special_mode NE vim_upgrade AND
     vim_special_mode NE vim_delimit AND
     temporal_delimitation_happened NE space.
    PERFORM after_temporal_delimitation.
    CLEAR: temporal_delimitation_happened, vim_old_viewkey.
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_not_procsd_patt.
  ENDIF.
  IF function IN mark_functions AND mark_extract EQ 0.
    MESSAGE s026(sv).                  &quot;Bitte vorher Einträge markieren
    LEAVE SCREEN.
  ENDIF.
  PERFORM update_status.
  IF vim_single_entry_function EQ &apos;INS&apos; AND
     vim_single_entry_ins_key_input NE space AND
     status-action EQ hinzufuegen.
    PERFORM vim_single_entry_fill_sellist.
  ENDIF.
  CLEAR: vim_next_screen, vim_leave_screen.
  CASE function.
    WHEN &apos;ADDR&apos;.
      PERFORM liste_address_maintain.
    WHEN &apos;AEND&apos;.
      PERFORM anzg_to_aend.
    WHEN &apos;ALCO&apos;.
      PERFORM selektiere USING transportieren.
    WHEN &apos;ALMK&apos;.
      PERFORM selektiere USING markiert.
    WHEN &apos;ALNC&apos;.
      PERFORM selektiere USING space.
    WHEN &apos;ALOE&apos;.
      PERFORM selektiere USING geloescht.
    WHEN &apos;ALNW&apos;.
      PERFORM selektiere USING neuer_eintrag.
    WHEN &apos;ANZG&apos;.
      PERFORM aend_to_anzg.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;ATAB&apos;.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;BACK&apos;.
      IF status-mode EQ list_bild AND status-data EQ gesamtdaten OR
        vim_single_entry_function NE space.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ELSE.
        PERFORM liste_back.
      ENDIF.
    WHEN &apos;BCCH&apos;.                       &quot;change fix bc-set fields
      PERFORM vim_chng_fix_flds.
    WHEN &apos;BCSH&apos;.                        &quot; show fix bc-set fields
      PERFORM vim_bc_show_fix_flds.
    WHEN &apos;BCON&apos;.
      PERFORM selektiere USING bcset_only. &quot;show only data from bcset
    WHEN &apos;CMPO&apos;.
      PERFORM upgrade USING &apos;O&apos;.
    WHEN &apos;CMPR&apos;.
      PERFORM upgrade USING &apos;R&apos;.
    WHEN &apos;COMP&apos;.
      PERFORM upgrade USING space.
    WHEN &apos;DELE&apos;.
      PERFORM loeschen.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    WHEN &apos;DELM&apos;.
      PERFORM delimitation.
    WHEN &apos;DETM&apos;.                       &quot;UFdetail
      PERFORM detail_markierte.
    WHEN &apos;DETA&apos;.
      PERFORM detailbild.
    WHEN &apos;ENDE&apos;.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;EXPA&apos;.
*     PERFORM TIME_DEPENDENT_DISPLAY_MODIF.
      IF x_header-delmdtflag EQ space.
        MESSAGE s001(sv). EXIT.
      ENDIF.
      PERFORM (vim_time_dep_dpl_modif_form) IN PROGRAM.     &quot;#EC *
    WHEN &apos;FDOC&apos;.                       &quot;HW Functiondocu
      PERFORM show_function_docu.
*    WHEN &apos;GPRF&apos;.                       &quot;UF Profile
* choose profile
*      CLEAR: &lt;status&gt;-prof_found, vim_pr_records.
*      PERFORM get_profiles USING &lt;status&gt;-prof_found.
    WHEN &apos;KOPE&apos;.
      counter = 0.
      vim_guid_copy = &apos;X&apos;.
      PERFORM kopiere.
    WHEN &apos;KOPF&apos;.
      SET SCREEN 0. LEAVE SCREEN.
    WHEN &apos;LANG&apos;.                       &quot;SW Texttransl
      PERFORM vim_set_languages.
    WHEN &apos;MKAL&apos;.
      PERFORM markiere_alle USING markiert.
    WHEN &apos;MKBL&apos;.
      PERFORM markiere_block.
    WHEN &apos;MKEZ&apos;.
      PERFORM liste_markiere.
    WHEN &apos;MKLO&apos;.
      PERFORM markiere_alle USING nicht_markiert.
    WHEN &apos;NEWL&apos;.
      PERFORM hinzufuegen.
    WHEN &apos;NEXT&apos;.
      PERFORM naechster.
    WHEN &apos;ORDR&apos;.
      PERFORM order_administration.
    WHEN &apos;ORGI&apos;.
      PERFORM original_holen.
    WHEN &apos;POSI&apos;.
      PERFORM popup_positionieren.
    WHEN &apos;PREV&apos;.
      PERFORM voriger.
    WHEN &apos;PRMO&apos;.
* 4.6A: obsolete, left for individual status only
      PERFORM list_alv.
    WHEN &apos;PROT&apos;.
      PERFORM logs_analyse.
    WHEN &apos;PRST&apos;.
      PERFORM list_alv.
    WHEN &apos;P+  &apos;.
      PERFORM blaettern.
    WHEN &apos;P-  &apos;.
      PERFORM blaettern.
    WHEN &apos;P++ &apos;.
      PERFORM blaettern.
    WHEN &apos;P-- &apos;.
      PERFORM blaettern.
    WHEN &apos;REPL&apos;.
      PERFORM replace.
    WHEN &apos;SAVE&apos;.
      IF status-action EQ hinzufuegen.
*       SORT EXTRACT BY &lt;VIM_EXTRACT_KEY&gt;.  &quot;not nec. anymore
        &lt;status&gt;-firstline = firstline = &lt;status&gt;-cur_line = l = 1.
      ENDIF.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;SCRF&apos;.
      PERFORM vim_sapscript_form_maint.
    WHEN &apos;SEAR&apos;.
      PERFORM suchen.
    WHEN &apos;SELU&apos;.
      PERFORM selektiere USING aendern.
*    WHEN &apos;SPRF&apos;.                       &quot;UF Profile
* show chosen profile
*      PERFORM get_profiles USING &lt;status&gt;-prof_found.
    WHEN &apos;TEXT&apos;.                       &quot;SW Texttransl
      PERFORM vim_multi_langu_text_maint.
    WHEN &apos;TREX&apos;.
      MOVE geloescht TO corr_action.
      PERFORM update_corr.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    WHEN &apos;TRIN&apos;.
      MOVE hinzufuegen TO corr_action.
      PERFORM update_corr.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    WHEN &apos;TRSP&apos;.
      IF x_header-cursetting NE space AND
         x_header-flag EQ vim_transport_denied.
        x_header-flag = x_header-cursetting.
        TRANSLATE x_header-flag USING &apos;X YX&apos;.
        MODIFY x_header INDEX 1.                            &quot;#EC *
      ENDIF.
      vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
    WHEN &apos;UNDO&apos;.
*     PERFORM LISTE_ZURUECKHOLEN.
      PERFORM zurueckholen.
      IF replace_mode NE space.
        &lt;status&gt;-mk_to = mark_total.
        &lt;status&gt;-mk_xt = mark_extract.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    WHEN &apos;UPRF&apos;.                       &quot;UF Profile
* activate chosen profile
*      PERFORM activate_profile CHANGING &lt;status&gt;-prof_found.
      MESSAGE s175(sv).
    WHEN &apos;    &apos;.
      IF vim_single_entry_function EQ &apos;INS&apos; AND
         status-action EQ hinzufuegen.
        PERFORM liste_back.
      ENDIF.
      IF replace_mode NE space.
        vim_next_screen = 0. vim_leave_screen = &apos;X&apos;.
      ENDIF.
    WHEN OTHERS.
      IF vim_called_by_cluster NE space.
        CALL FUNCTION &apos;VIEWCLUSTER_NEXT_ACTION&apos;
          IMPORTING
            leave_screen = vim_leave_screen
          CHANGING
            fcode        = function.
        IF vim_leave_screen NE space.
          vim_next_screen = 0.
        ENDIF.
      ENDIF.
  ENDCASE.
  IF vim_leave_screen NE space.
    CLEAR: vim_leave_screen, vim_act_dynp_view.
    SET SCREEN vim_next_screen. LEAVE SCREEN.
  ENDIF.
ENDMODULE.                    &quot;liste_after_loop

*---------------------------------------------------------------------*
*       MODULE LISTE_BEFORE_LOOP                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_before_loop.                                   &quot;#EC CALLED
  GET CURSOR FIELD f LINE l OFFSET o.
  function = ok_code.
  CLEAR: ok_code, &lt;status&gt;-upd_flag.
  IF vim_special_mode EQ vim_delete.
    SET SCREEN 0. LEAVE SCREEN.
  ENDIF.
* PERFORM READ_TABLE USING FIRSTLINE.
  IF replace_mode EQ space.
*   SET PF-STATUS &apos;ERRORLIS&apos;.
    PERFORM set_pf_status USING &apos;ERRORLIS&apos;.
*    CLEAR &lt;STATUS&gt;-UPD_FLAG.
    neuer = &apos;N&apos;.
    IF vim_called_by_cluster NE space.
      CALL FUNCTION &apos;VIEWCLUSTER_SET_OKCODE&apos;
        EXPORTING
          ok_code = function.
    ENDIF.
  ENDIF.
ENDMODULE.                    &quot;liste_before_loop

*---------------------------------------------------------------------*
*       MODULE DETAIL_PAI                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE detail_pai.                                          &quot;#EC CALLED
  CLEAR: vim_next_screen, vim_leave_screen.
*  IF function EQ &apos;DETA&apos;.                                    &quot;GKPR - 0001009660
  IF function EQ &apos;DETA&apos; OR function EQ &apos;DETM&apos;.             &quot;PATIDARP   1475505
    CLEAR old_nl.                                           &quot;GKPR - 0001009660
  ENDIF.                                                    &quot;GKPR - 0001009660
  function = ok_code.
  PERFORM detail_pai.
  IF vim_leave_screen NE space.
    CLEAR: vim_leave_screen, vim_act_dynp_view.
    SET SCREEN vim_next_screen. LEAVE SCREEN.
  ENDIF.
ENDMODULE.                    &quot;detail_pai

*---------------------------------------------------------------------*
*       MODULE DETAIL_SET_PFSTATUS                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE detail_set_pfstatus.                                 &quot;#EC CALLED
  IF replace_mode EQ space.
*   SET PF-STATUS &apos;ERROR&apos;.
    PERFORM set_pf_status USING &apos;ERROR&apos;.
  ENDIF.
  IF x_header-delmdtflag NE space.
    EXPORT ok_code TO MEMORY ID vim_memory_id_2.            &quot;#EC *
  ENDIF.
ENDMODULE.                    &quot;detail_set_pfstatus

*---------------------------------------------------------------------*
*       MODULE LISTE_MARK_CHECKBOX                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_mark_checkbox.                                 &quot;#EC CALLED
  CHECK &lt;xact&gt; NE leer.
  CLEAR answer.
  IF vim_marked NE space AND &lt;xmark&gt; NE markiert.
    MOVE: markiert TO &lt;xmark&gt;, markiert TO answer.
    ADD: 1 TO mark_total, 1 TO mark_extract.
  ELSEIF vim_marked EQ space AND &lt;xmark&gt; NE nicht_markiert.
    MOVE: nicht_markiert TO &lt;xmark&gt;, markiert TO answer.
    IF mark_total GT 0.             &quot;HCG must not get negative HW785631
      SUBTRACT: 1 FROM mark_total.
    ENDIF.
    IF mark_extract GT 0.           &quot;HCG Must not get negative HW785631
      SUBTRACT: 1 FROM mark_extract.
    ENDIF.
  ENDIF.
  IF &lt;status&gt;-upd_flag EQ space AND answer NE space.  &quot;only mouse mark
    MOVE nextline TO index.
    READ TABLE total WITH KEY &lt;vim_xextract_key&gt; BINARY SEARCH. &quot;#EC WARNOK
    PERFORM vorhanden.
  ENDIF.
  CLEAR answer.
ENDMODULE.                    &quot;liste_mark_checkbox

*---------------------------------------------------------------------*
*       MODULE LISTE_INIT_WORKAREA                                    *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_init_workarea.                                 &quot;#EC CALLED
  IF replace_mode NE space.
    IF vim_special_mode EQ vim_upgrade.
      &lt;table2_x&gt; = &lt;vim_xtotal&gt;.
    ELSEIF vim_special_mode EQ vim_replace.
      CLEAR &lt;replace_field&gt;.
    ENDIF.
  ENDIF.
  PERFORM move_extract_to_view_wa.
  MOVE nextline TO exind.
  CLEAR vim_pr_activating.
  IF &lt;xact&gt; = profil_hinzufuegen.      &quot;UFprofiles begin
* Set update flags
    &lt;table2_x&gt; = &lt;initial_x&gt;.
    &lt;xact&gt; = leer.
    vim_pr_activating = &apos;X&apos;.
    MODIFY extract INDEX sy-stepl.                          &quot;#EC *
    IF x_header-bastab NE space AND x_header-texttbexst NE space.
      &lt;status&gt;-upd_flag = &apos;E&apos;.
    ELSE.
      &lt;status&gt;-upd_flag = &apos;X&apos;.
    ENDIF.
  ENDIF.                               &quot;UFprofiles end
  CLEAR: vim_key_alr_checked, vim_keyrange_alr_checked.
ENDMODULE.                    &quot;liste_init_workarea

*---------------------------------------------------------------------*
*       MODULE LISTE_UPDATE_LISTE                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_update_liste.                                  &quot;#EC CALLED
  CHECK status-action NE anzeigen.
  CHECK status-action NE transportieren.
  CHECK status-delete NE geloescht.
  IF ok_code NE &apos;IGN &apos;.
    IF x_header-ptfrkyexst NE space.
      PERFORM consistency_prt_frky_fields
                                   USING vim_show_consistency_alert.
    ENDIF.
    CASE status-action.                &quot;UFprofile
      WHEN kopieren.                   &quot;UFprofile
        READ TABLE vim_copied_indices WITH KEY level = vim_copy_call_level
                                                     ex_ix = nextline. &quot;#EC *
        IF sy-subrc EQ 0.              &quot;entry alr. processed
          &lt;xact&gt; = neuer_eintrag.
          PERFORM update_tab.
        ELSE.
          PERFORM kopiere_eintrag USING &lt;orig_key&gt;.
        ENDIF.
      WHEN OTHERS.
        PERFORM update_tab.
    ENDCASE.
  ELSE.
    PERFORM set_pf_status USING &apos;ERRORLIS&apos;.
  ENDIF.
  IF replace_mode EQ space.
    CLEAR ok_code.
  ENDIF.
ENDMODULE.                    &quot;liste_update_liste

*---------------------------------------------------------------------*
*       MODULE TEMP_DELIMITATION                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE temp_delimitation.                                   &quot;#EC CALLED
  DATA: td_addr_safe LIKE adrc-addrnumber.                  &quot;#EC *
  CHECK x_header-delmdtflag NE space.
* set update flag (if begdate not in the set_update_flag-chain)
  CHECK status-action NE anzeigen AND  &quot;ignore wrong set requestflags
        status-action NE transportieren. &quot;due to individual F4 modules
  IF x_header-bastab NE space AND x_header-texttbexst NE space.
    &lt;status&gt;-upd_flag = &apos;E&apos;.
  ELSE.
    &lt;status&gt;-upd_flag = &apos;X&apos;.
  ENDIF.
* process delimitation
  vim_begdate_entered = &apos;X&apos;.
  PERFORM temporal_delimitation.
  IF temporal_delimitation_happened EQ &apos;X&apos; AND
     x_header-delmdtflag EQ &apos;B&apos;.
    IF x_header-adrnbrflag = space.
      MOVE: &lt;vim_xtotal_key&gt; TO &lt;f1_x&gt;,
            &lt;vim_begdate&gt; TO &lt;vim_new_begdate&gt;.
    ELSE.
      MOVE: &lt;address_number&gt; TO td_addr_safe,
            &lt;vim_xtotal_key&gt; TO &lt;f1_x&gt;,
            td_addr_safe TO &lt;address_number&gt;,
            &lt;vim_begdate&gt; TO &lt;vim_new_begdate&gt;.
    ENDIF.
  ENDIF.
ENDMODULE.                    &quot;temp_delimitation

*---------------------------------------------------------------------*
*       MODULE CONSISTENCY                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE consistency.                                         &quot;#EC CALLED
  EXIT.
* CHECK STATUS-MODE NE DETAIL_BILD.
* PERFORM CONSISTENCY_PRT_FRKY_FIELDS USING &apos;X&apos;.
ENDMODULE.                             &quot;consistency

*&amp;---------------------------------------------------------------------*
*&amp;      Module  VCL_HELP_VALUES  INPUT
*&amp;---------------------------------------------------------------------*
* Modul zum Ereignis &apos;Process On Value-Request&apos; innerhalb der          *
* Viewcluster-Pflege:
* Realisierung von F4 auf ein Feld, dessen Prüftabelle im selben
* Viewcluster gepflegt wird.
*----------------------------------------------------------------------*
MODULE vcl_help_values INPUT.                               &quot;#EC CALLED
  DATA: vcl_event(3) .
  CLEAR: f, vim_object, vim_objfield.
* POV-Module, die an List-Boxen hängen, werden schon zum Zeitpunkt
* CONTROL OUT gerufen. Hier kann das betroffene Feld nicht über
* die Cursor-Position ermittelt werden.
  CALL &apos;DY_GET_DYNPRO_EVENT&apos; ID &apos;EVENT&apos; FIELD vcl_event.  &quot;#EC CI_CCALL
  IF sy-subrc = 0 AND vcl_event = &apos;OUT&apos;.
*   Aufruf zum Zeitpunkt Control Output
    MESSAGE i538(sv) WITH vim_calling_cluster view_name.
    EXIT.
  ENDIF.

  IF status-mode = &apos;L&apos;.                &quot; Listbild
    GET CURSOR FIELD f LINE l.
  ELSE.                                &quot; Detailbild
    GET CURSOR FIELD f.
  ENDIF.
  SPLIT f AT &apos;-&apos; INTO vim_object vim_objfield.
  IF vim_objfield IS INITIAL.
    MESSAGE s084(sv).
  ELSE.
    CALL FUNCTION &apos;VIEWCLUSTER_HELP_VALUES_NEW&apos;
      EXPORTING
        object    = vim_object
        fieldname = vim_objfield
      EXCEPTIONS
        OTHERS    = 1.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE s084(sv).
    ENDIF.
  ENDIF.
ENDMODULE.                             &quot; VCL_HELP_VALUES  INPUT</include_source>
   </include>
   <include NAME="LSVIMOXX" SQLX="X" VARCL="X" SUBC="I" APPL="S" LEVL="12A" RMAND="000" RLOAD="D">
    <include_source>*---------------------------------------------------------------------*
*       MODULE DETAIL_INIT           OUTPUT                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE detail_init OUTPUT.                                        &quot;#EC CALLED
  IF vim_called_by_cluster &lt;&gt; space.                        &quot;SW CTRL ..
    PERFORM vim_vcldocking_control.
  ENDIF.                               &quot;.. SW CTRL
  PERFORM vim_add_img_notices_pbo USING x_header-detail.
  PERFORM detail_init.
  IF ( replace_mode NE space AND
   neuer NE &apos;X&apos; )         &quot;no error in CHECK_KEY for timedep. objects
   OR vim_pr_activating &lt;&gt; space.                           &quot;UF profile
    SUPPRESS DIALOG.
  ENDIF.
  PERFORM vim_modify_detail_screen.
ENDMODULE.                    &quot;detail_init OUTPUT

*---------------------------------------------------------------------*
*       MODULE VIM_MODIF_DETAIL         OUTPUT                        *
*---------------------------------------------------------------------*
* Modifikation der Screen-Attribute für Tabstrip-Screens              *
*---------------------------------------------------------------------*
MODULE vim_modif_detail OUTPUT.                               &quot;#EC CALLED
  PERFORM vim_modify_detail_screen.
ENDMODULE.                    &quot;vim_modif_detail OUTPUT

*---------------------------------------------------------------------*
*       MODULE LISTE_SHOW_LISTE OUTPUT                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_show_liste OUTPUT.                                   &quot;#EC CALLED

** Table-control !!!   &quot;bis der Fehler behoben ist
  IF vim_tabctrl_active NE space.
    IF &lt;vim_tctrl&gt;-current_line GT maxlines AND  &quot;no more entries
       &lt;xact&gt; NE leer.                 &quot;in EXTRACT and no new entry
      EXIT FROM STEP-LOOP.
    ENDIF.
  ENDIF.
** Table-control !!!
  looplines = sy-loopc.
  IF l GT looplines.
    counter = ( l - firstline ) DIV looplines + 1.
    DO counter TIMES.
      firstline = firstline + looplines - 1.
    ENDDO.
    MOVE firstline TO &lt;status&gt;-firstline.
    &lt;status&gt;-cur_line = l = l - firstline + 1.
    SET CURSOR FIELD f LINE l OFFSET o.
  ENDIF.
  IF vim_special_mode NE vim_upgrade AND
     status-action EQ hinzufuegen AND maxlines EQ 0 AND sy-stepl EQ 1.
    DESCRIBE TABLE extract.
    IF sy-tfill GT looplines.
      sy-tfill = looplines + 1.
      LOOP AT extract FROM sy-tfill.
        DELETE extract.
      ENDLOOP.
      nbr_of_added_dummy_entries = looplines.
    ENDIF.
  ENDIF.
* dataset locked by key-specific synchronizer lock?
  IF vim_sync_keyspec_check NE space.
    perform check_sync_key_lock using &apos; &apos;
                                changing vim_sync_key_lock.
  ENDIF.
* dataset from BC-set? --&gt; get field parameters
  CLEAR vim_set_from_bc_pbo.
  IF replace_mode = space AND status-action = aendern
   AND vim_bc_chng_allowed = space.  &quot;fix field changeability forced
    READ TABLE vim_bc_entry_list INTO vim_bc_entry_list_wa
     WITH TABLE KEY viewname = x_header-maintview           &quot;HCG 9/04
     keys = &lt;vim_xextract_key&gt;.
    IF sy-subrc = 0.
      vim_set_from_bc_pbo = &apos;X&apos;.
    ENDIF.
  ENDIF.
  IF replace_mode NE space OR vim_special_mode EQ vim_delete.&quot;aro
    IF sy-stepl GT 1.
      EXIT FROM STEP-LOOP.
    ELSE.
      MOVE &lt;vim_xtotal&gt; TO &lt;table2_x&gt;.
    ENDIF.
  ENDIF.                                                    &quot;aro
  index = exind = nextline.
  IF status-action EQ kopieren AND status-type EQ einstufig.
    READ TABLE vim_copied_indices WITH KEY level = vim_copy_call_level
                                           ex_ix = nextline.
    IF sy-subrc EQ 0.                  &quot;entry already copied
      READ TABLE total INDEX vim_copied_indices-ix.
      extract = total. neuer = &apos;N&apos;.
    ELSE.
      neuer = &apos;J&apos;.
    ENDIF.
  ENDIF.
  PERFORM move_extract_to_view_wa.
  IF vim_special_mode EQ vim_delimit.
    MOVE vim_sval_tab-value TO &lt;vim_new_begdate&gt;.
  ENDIF.
  IF status-action EQ hinzufuegen AND status-type EQ einstufig AND
     neuer NE &apos;J&apos; AND &lt;xact&gt; EQ leer.
    neuer = &apos;J&apos;.
  ENDIF.
  IF &lt;xmark&gt; EQ markiert.
    MOVE &apos;X&apos; TO vim_marked.
  ENDIF.
  LOOP AT SCREEN.
    CLEAR vim_modify_screen.
    SPLIT screen-name AT &apos;-&apos; INTO vim_object vim_objfield.
    IF ( status-action EQ anzeigen OR status-action EQ transportieren OR
            status-delete EQ geloescht ) AND screen-name NE &apos;VIM_MARKED&apos;.
      screen-input = &apos;0&apos;.
* Accessibility fix
      SET CURSOR 1 1.
      vim_modify_screen = &apos;X&apos;.
    ELSEIF status-action EQ kopieren AND screen-name NE &apos;VIM_MARKED&apos; AND
           screen-group1 NE &apos;KEY&apos; AND function NE &apos;DELM&apos;.   &quot;864431
      screen-request = 1. vim_modify_screen = &apos;X&apos;.
    ELSE.
      IF screen-group1 EQ &apos;KEY&apos;.
        IF vim_tabctrl_active NE space AND screen-input EQ &apos;0&apos;.
          READ TABLE &lt;vim_tctrl&gt;-cols INTO vim_tc_cols
                                       WITH KEY
                                            screen-name = screen-name
                                       TRANSPORTING screen-required.
          IF sy-subrc EQ 0 AND
             screen-required NE vim_tc_cols-screen-required.
            screen-required = vim_tc_cols-screen-required.
            vim_modify_screen = &apos;X&apos;.
          ENDIF.
        ENDIF.
        IF screen-required NE 0 AND screen-input NE &apos;0&apos;.
          screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
        ENDIF.
        IF vim_single_entry_function EQ &apos;INS&apos;.
          screen-request = 1. vim_modify_screen = &apos;X&apos;.
        ENDIF.
* int. mess. 1757218/1999: no foreign-key check with copy
        IF status-action = kopieren.
          screen-request = 1. vim_modify_screen = &apos;X&apos;.
        ENDIF.
* int. mess. 1757218/1999: no foreign-key check with copy: end
      ENDIF.
*     IF NEUER EQ &apos;J&apos; OR STATUS-ACTION EQ KOPIEREN.
      IF neuer EQ &apos;J&apos;.
        IF vim_special_mode NE vim_delimit AND
           screen-group1 EQ &apos;KEY&apos; AND
           ( vim_single_entry_function NE &apos;INS&apos; OR
               vim_single_entry_ins_key_input NE space ) AND
           ( x_header-existency NE &apos;M&apos; OR
             screen-name EQ vim_enddate_name ).
          ADD 1 TO pos.
          IF pos EQ 1.
            SET CURSOR FIELD screen-name LINE sy-stepl.
          ENDIF.
          screen-input = &apos;1&apos;. vim_modify_screen = &apos;X&apos;.
        ENDIF.
        IF screen-name EQ &apos;VIM_MARKED&apos;.
          screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
        ELSE.
          IF &lt;xact&gt; = profil_hinzufuegen.
            READ TABLE vim_pr_fields_wa-fields WITH TABLE KEY
             fieldname = vim_objfield TRANSPORTING NO FIELDS.
            IF sy-subrc = 0.
              screen-request = 1. vim_modify_screen = &apos;X&apos;.
            ENDIF.
          ENDIF.
          IF vim_special_mode EQ vim_upgrade AND function NE &apos;DELE&apos;.
            IF &lt;status&gt;-prof_found = vim_pr_into_view &quot;UFprofiles begin
             AND status-action = hinzufuegen AND screen-group1 = &apos;KEY&apos;.
              PERFORM set_profile_key_attributes USING vim_objfield
                                                 CHANGING screen-input
                                                      vim_modify_screen.
            ENDIF.                     &quot;UFprofiles end
            screen-request = 1. vim_modify_screen = &apos;X&apos;.
          ENDIF.
        ENDIF.
      ELSE.
        IF x_header-delmdtflag NE space AND
           x_header-existency EQ &apos;U&apos; AND
           screen-name EQ vim_begdate_name.
          screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
        ENDIF.
        IF f EQ space AND screen-name NE &apos;VIM_MARKED&apos; AND
           screen-input EQ &apos;1&apos;.
          SET CURSOR FIELD screen-name LINE l.
          f = screen-name.
        ENDIF.
        IF replace_mode NE space.
          CASE vim_special_mode.
            WHEN vim_replace.
              IF screen-name EQ sel_field_for_replace_l.
                screen-request = 1. vim_modify_screen = &apos;X&apos;.
              ENDIF.
            WHEN vim_upgrade.
              IF NOT function IN exted_functions AND
                 screen-name NE &apos;VIM_MARKED&apos;.
                screen-request = 1. vim_modify_screen = &apos;X&apos;.
              ENDIF.
              screen-input = &apos;1&apos;. vim_modify_screen = &apos;X&apos;.
          ENDCASE.
        ELSE.
          IF vim_special_mode EQ vim_delete.
            screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
          ENDIF.
* Dataset locked by key-specific synchronizer lock?
          IF vim_sync_key_lock NE space AND screen-group1 &lt;&gt; &apos;KEY&apos; AND
                                            screen-name NE &apos;VIM_MARKED&apos;.
            screen-input = 0.
            vim_modify_screen  = &apos;X&apos;.
          ENDIF.
          IF vim_set_from_bc_pbo &lt;&gt; space AND screen-group1 &lt;&gt; &apos;KEY&apos;.
* Dataset comes from BC-set -&gt; check field parameter
            PERFORM vim_bc_logs_use USING    vim_objfield
                                             vim_bc_entry_list_wa
                                    CHANGING screen
                                             vim_modify_screen.
          ENDIF.
        ENDIF.                         &quot;replace_mode &lt;&gt; space
      ENDIF.                           &quot;neuer = &apos;J&apos;
    ENDIF.                             &quot;update mode
    IF &lt;xmark&gt; EQ markiert AND screen-name NE &apos;VIM_MARKED&apos;.
      screen-intensified = 1. vim_modify_screen = &apos;X&apos;.
    ENDIF.
    IF vim_special_mode EQ vim_delimit AND
       screen-name EQ vim_begdate_name.
      screen-request = 1. vim_modify_screen = &apos;X&apos;.
    ENDIF.
*   IF X_HEADER-RDONLYFLAG = &apos;X&apos; AND                      &quot;Subviews ..
*      X_HEADER-MAINTVIEW &lt;&gt; X_HEADER-VIEWNAME.
    IF vim_objfield &lt;&gt; space AND vim_object = x_header-maintview.
      LOOP AT x_namtab WHERE viewfield = vim_objfield AND
                          ( texttabfld = space OR keyflag = space ).
        IF x_namtab-readonly = vim_hidden.
          screen-active = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
        ELSEIF x_namtab-readonly = rdonly.
          screen-input = &apos;0&apos;. vim_modify_screen = &apos;X&apos;.
        ENDIF.
        EXIT.
      ENDLOOP.
    ENDIF.
*   ENDIF.                                                  &quot;.. Subviews
    IF vim_modify_screen = &apos;X&apos;.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
  IF vim_special_mode EQ vim_delete.
    SET CURSOR FIELD f LINE 1 OFFSET o. &quot;Always just 1 line in TC
  ENDIF.
  IF status-action EQ kopieren.
    neuer = &apos;N&apos;.
  ENDIF.
ENDMODULE.                    &quot;liste_show_liste OUTPUT

*---------------------------------------------------------------------*
*       MODULE LISTE_INITIALISIEREN OUTPUT                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_initialisieren OUTPUT.                               &quot;#EC CALLED
  IF vim_called_by_cluster &lt;&gt; space.                        &quot;SW CTRL ..
    PERFORM vim_vcldocking_control.
  ENDIF.                               &quot;.. SW CTRL
  status-mode = list_bild.
  title-mode  = list_bild.
  firstline = nextline.
  aktuell = firstline.
  vim_act_dynp_view = x_header-viewname.
  PERFORM vim_add_img_notices_pbo USING x_header-liste.
  IF vim_special_mode EQ vim_direct_upgrade.
    SUPPRESS DIALOG.
    ok_code = function = &apos;CMPR&apos;.
    EXIT.
  ENDIF.
  CLEAR &lt;status&gt;-mark_only.                                 &quot;ufdetail
  IF replace_mode NE space OR vim_special_mode EQ vim_delete.
    PERFORM set_title USING title &lt;name&gt;.
    IF vim_special_mode NE vim_delete. SUPPRESS DIALOG. ENDIF.
    PERFORM set_pf_status USING &apos;REPLACE&apos;.
    MOVE &lt;table1&gt; TO &lt;vim_total_struc&gt;.
*    MOVE &lt;table1&gt; TO total.
    IF x_header-bastab NE space AND x_header-texttbexst NE space.
      MOVE &lt;table1_text&gt; TO &lt;vim_tot_txt_struc&gt;.
    ENDIF.
** Table-control !!!
    IF vim_tabctrl_active NE space.
      IF status-action EQ hinzufuegen.
        &lt;vim_tctrl&gt;-lines = maxlines + nbr_of_added_dummy_entries.
      ELSE.
        &lt;vim_tctrl&gt;-lines = maxlines.
      ENDIF.
      &lt;vim_tctrl&gt;-top_line = firstline.
      LOOP AT &lt;vim_tctrl&gt;-cols INTO vim_tc_cols
                               WHERE screen-active EQ 0.
        vim_tc_cols-vislength = 0.
        MODIFY &lt;vim_tctrl&gt;-cols FROM vim_tc_cols.
      ENDLOOP.
    ENDIF.
    EXIT.
  ENDIF.
  IF mark_extract GT 0.
    status-mark = markiert.
  ELSE.
    status-mark = nicht_markiert.
  ENDIF.
  IF maxlines EQ 0.
    IF status-action NE hinzufuegen
    OR status-type NE einstufig.
      PERFORM fill_extract.
    ELSE.                                                   &quot;aro
      title-data = auswahldaten.                            &quot;aro
    ENDIF.                                                  &quot;aro
    status-delete = nicht_geloescht.
    PERFORM vim_send_sv005_or_sv766 USING &apos;766&apos;
                                          &apos;RESET&apos;.
  ELSEIF maxlines = 1 AND function &lt;&gt; &apos;UEBE&apos;.
* Viewcluster: jump into single screen also if view is chosen for
* the 2nd time
    PERFORM vim_maintain_single_set.         &quot;UFint2329966/2000
* Notlösung Sortproblem Hinzufügen Anfang
  ELSE.
    PERFORM vim_send_sv005_or_sv766 USING &apos;766&apos;
                                          &apos;RESET&apos;.
    IF status-action EQ hinzufuegen.
      pos = 1.
      LOOP AT extract.
        CHECK &lt;xact&gt; NE leer.
        IF sy-tabix NE pos.
          DELETE extract.
          INSERT extract INDEX pos.
        ENDIF.
        ADD 1 TO pos.
      ENDLOOP.
    ENDIF.
* Notlösung Sortproblem Hinzufügen Ende
  ENDIF.
  maximal = maxlines.
** Table-control !!!
  IF vim_tabctrl_active NE space.
    IF status-action EQ hinzufuegen.
      &lt;vim_tctrl&gt;-lines = maxlines + nbr_of_added_dummy_entries.
    ELSE.
      &lt;vim_tctrl&gt;-lines = maxlines.
    ENDIF.
    &lt;vim_tctrl&gt;-top_line = firstline.
    LOOP AT &lt;vim_tctrl&gt;-cols INTO vim_tc_cols
*                            WHERE SCREEN-INVISIBLE EQ 1
*                              OR  SCREEN-ACTIVE EQ 0.
                             WHERE screen-active EQ 0.
      vim_tc_cols-vislength = 0.
      MODIFY &lt;vim_tctrl&gt;-cols FROM vim_tc_cols.
    ENDLOOP.
* Notlösung Markierbarkeit beim Hinzufügen bzw. Kopieren
*   IF STATUS-ACTION EQ HINZUFUEGEN OR STATUS-ACTION EQ KOPIEREN.
*     &lt;VIM_TCTRL&gt;-LINE_SEL_MODE = 0.
*   ELSE.
**    &lt;VIM_TCTRL&gt;-LINE_SEL_MODE = 2.
*     &lt;VIM_TCTRL&gt;-LINE_SEL_MODE = &lt;STATUS&gt;-L_SEL_MODE.
*   ENDIF.
  ELSE.                                &quot;Subviews ..
    LOOP AT SCREEN.
      SPLIT screen-name AT &apos;-&apos; INTO vim_object vim_objfield.
      IF vim_objfield &lt;&gt; space AND vim_object = x_header-maintview.
        LOOP AT x_namtab WHERE viewfield = vim_objfield AND
                            ( texttabfld = space OR keyflag = space ).
          IF x_namtab-readonly = vim_hidden.
            screen-active = &apos;0&apos;. MODIFY SCREEN.
          ELSEIF x_namtab-readonly = rdonly.
            screen-input = &apos;0&apos;. MODIFY SCREEN.
          ENDIF.
          EXIT.
        ENDLOOP.
      ENDIF.
    ENDLOOP.                           &quot;.. Subviews
  ENDIF.
** Table-control !!!
  PERFORM set_position_info USING firstline maxlines.
  pos = maxlines - firstline + 1.
  IF l GT pos.
    l = 1.
  ENDIF.
  pos = 0.                                                  &quot;aro
* Change for Cust. Msg.620095 2008 DUTTAN/24.09.2008
  IF f EQ space AND fcode EQ edit AND x_header-subsetflag EQ space.
    LOOP AT SCREEN.
      SPLIT screen-name AT &apos;-&apos; INTO vim_object vim_objfield.
      READ TABLE x_namtab WITH KEY viewfield = vim_objfield.
      IF x_namtab-keyflag = &apos;X&apos; OR x_namtab-readonly = &apos;X&apos;.
        CONTINUE.
      ELSE.
      IF vim_object = x_header-viewname.
        f = screen-name.
        EXIT.
      ENDIF.
      ENDIF.
* END OF CHANGE.
    ENDLOOP.
  ENDIF.
  SET CURSOR FIELD f LINE l OFFSET o.
  PERFORM set_pf_status USING status.
  PERFORM set_title USING title &lt;name&gt;.
* Notlösung Batch-Input Anfang
  IF maxlines EQ 0.
    LOOP AT SCREEN.
      CHECK screen-name EQ &apos;VIM_POSI_PUSH&apos;.
      screen-input = 0.
      MODIFY SCREEN.
      EXIT.
    ENDLOOP.
  ENDIF.
* Notlösung Batch-Input Ende
  IF status-action EQ kopieren OR vim_single_entry_function NE space.
    LOOP AT SCREEN.
      CHECK screen-name EQ &apos;VIM_POSI_PUSH&apos;.
      screen-active = 0.
      MODIFY SCREEN.
      EXIT.
    ENDLOOP.
  ENDIF.
* Fill cache in sync function for key-specific synchronizer locks?
  IF vim_sync_keyspec_check NE space.
    perform check_sync_key_lock using &apos;X&apos;
                                changing vim_sync_key_lock.
  ENDIF.
ENDMODULE.                    &quot;liste_initialisieren OUTPUT

*---------------------------------------------------------------------*
*       MODULE FILL_SUBSTFLDS OUTPUT                                  *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE fill_substflds OUTPUT.                                         &quot;#EC CALLED
  CHECK x_header-subsetflag NE space.
  PERFORM fill_subsetfields.
ENDMODULE.                    &quot;fill_substflds OUTPUT

*---------------------------------------------------------------------*
*       MODULE LISTE_DEACTIVATE OUTPUT                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE liste_deactivate OUTPUT.                                   &quot;#EC CALLED
  CHECK &lt;xact&gt; NE leer AND status-action NE kopieren.
  LOOP AT SCREEN.
    CHECK screen-group2 EQ &apos;EZN&apos; .
    IF x_header-ptfrkyexst EQ space.
      MOVE screen-name TO f.
      SHIFT f UP TO &apos;-&apos;. SHIFT f.
      LOOP AT x_namtab WHERE keyflag EQ space  &quot;ignore keyfields
                         AND viewfield EQ f.
        MOVE &apos;X&apos; TO x_namtab-prtfrkyfld.
        MOVE &apos;X&apos; TO x_header-ptfrkyexst.
        MODIFY x_namtab.
      ENDLOOP.
    ENDIF.
    CHECK sy-stepl NE 1 AND
    &lt;vim_f1_beforex&gt; EQ &lt;vim_mkey_beforex&gt; AND
    ( vim_mkey_after_exists EQ space OR
      &lt;vim_f1_afterx&gt; EQ &lt;vim_mkey_afterx&gt; ).
*    &lt;vim_f1_before&gt; eq &lt;vim_mkey_before&gt; and
*    ( vim_mkey_after_exists eq space or
*      &lt;vim_f1_after&gt; eq &lt;vim_mkey_after&gt; ).
    screen-active = 0.
    MODIFY SCREEN.
  ENDLOOP.
  MODIFY x_header INDEX 1.
  IF vim_no_mainkey_exists EQ vim_no_mkey_not_procsd OR
    &lt;vim_f1_beforex&gt; NE &lt;vim_mkey_beforex&gt; OR
    ( vim_mkey_after_exists NE space AND
      &lt;vim_f1_afterx&gt; NE &lt;vim_mkey_afterx&gt; ).
*     &lt;vim_f1_before&gt; ne &lt;vim_mkey_before&gt; or
*     ( vim_mkey_after_exists ne space and
*       &lt;vim_f1_after&gt; ne &lt;vim_mkey_after&gt; ).
    &lt;vim_h_mkey&gt;(x_header-keylen) = &lt;f1_x&gt;.
*    vim_mainkey = &lt;f1&gt;.
    TRANSLATE vim_no_mainkey_exists USING vim_no_mkey_procsd_patt.
  ENDIF.
ENDMODULE.                             &quot;liste_deactivate.

*---------------------------------------------------------------------*
*       MODULE VIM_SUPPRESS_LISTE OUTPUT                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
MODULE vim_suppress_liste OUTPUT.                                                 &quot;#EC CALLED
  CHECK vim_special_mode &lt;&gt; vim_direct_upgrade AND
        function NE space AND function NE &apos;ANZG&apos; AND
        function NE &apos;AEND&apos; AND &quot;function NE &apos;ABR &apos; AND
        NOT ( vim_called_by_cluster NE space AND
             ( function CP &apos;DET*&apos; OR  function CP &apos;%_*&apos; ) ).
  SUPPRESS DIALOG.
  ok_code = back.
ENDMODULE.                             &quot;vim_suppres_liste</include_source>
   </include>
   <include NAME="LSVIMTDT" VARCL="X" SUBC="I" APPL="S" LEVL="21A" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>***INCLUDE LSVIMTDT .
DATA:
* Tabelle für die DB-Zeilen, Ultra Long
  BEGIN OF EXTRACT_UL OCCURS 0,
        LINE(4096),
      END OF EXTRACT_UL,
* Tabelle für die DB-Zeilen, Very Long
  BEGIN OF EXTRACT_VL OCCURS 0,
        LINE(512),
      END OF EXTRACT_VL,
* Tabelle für die DB-Zeilen, Long
  BEGIN OF EXTRACT_L OCCURS 0,
        LINE(256),
      END OF EXTRACT_L,
* Tabelle für die DB-Zeilen, Middle
  BEGIN OF EXTRACT_M OCCURS 0,
        LINE(128),
      END OF EXTRACT_M,
* Tabelle für die DB-Zeilen, Short
  BEGIN OF EXTRACT_S OCCURS 0,
        LINE(64),
      END OF EXTRACT_S,
* Tabelle für die DB-Zeilen, Very Short
  BEGIN OF EXTRACT_VS OCCURS 0,
        LINE(48),
      END OF EXTRACT_VS,
* Tabelle für die DB-Zeilen, Ultra Short
  BEGIN OF EXTRACT_US OCCURS 0,
        LINE(32),
      END OF EXTRACT_US.

* Table for all entries loaded from database
DATA:
* Tabelle für die DB-Zeilen, Ultra Long
  BEGIN OF TOTAL_UL OCCURS 0,
        LINE(4096),
      END OF TOTAL_UL,
* Tabelle für die DB-Zeilen, Very Long
  BEGIN OF TOTAL_VL OCCURS 0,
        LINE(512),
      END OF TOTAL_VL,
* Tabelle für die DB-Zeilen, Long
  BEGIN OF TOTAL_L OCCURS 0,
        LINE(256),
      END OF TOTAL_L,
* Tabelle für die DB-Zeilen, Middle
  BEGIN OF TOTAL_M OCCURS 0,
        LINE(128),
      END OF TOTAL_M,
* Tabelle für die DB-Zeilen, Short
  BEGIN OF TOTAL_S OCCURS 0,
        LINE(64),
      END OF TOTAL_S,
* Tabelle für die DB-Zeilen, Very Short
  BEGIN OF TOTAL_VS OCCURS 0,
        LINE(48),
      END OF TOTAL_VS,
* Tabelle für die DB-Zeilen, Ultra Short
  BEGIN OF TOTAL_US OCCURS 0,
        LINE(32),
      END OF TOTAL_US.

* Tabelle mit den modifizierten Elementen

DATA: BEGIN OF MOD_ELEM_TAB OCCURS 100,
        LINES(4096),
      END OF MOD_ELEM_TAB.

*ATA: FORBIDDEN_FUNC_NAME_CHARS(10) VALUE &apos;/\$!§%&amp;&apos;&apos;##&apos;,   &quot;#EC *
*     FORBIDDEN_AREA_NAME_CHARS(10) VALUE &apos;/\$!§%&amp;&apos;&apos;##&apos;.   &quot;#EC *
DATA: FORBIDDEN_FUNC_NAME_CHARS(9) VALUE &apos;\$!§%&amp;&apos;&apos;##&apos;,   &quot;#EC STRING_OK
      FORBIDDEN_AREA_NAME_CHARS(9) VALUE &apos;\$!§%&amp;&apos;&apos;##&apos;.   &quot;#EC STRING_OK</include_source>
   </include>
   <include NAME="LZBH1F00" SQLX="X" EDTX="X" SUBC="I" LEVL="740" RLOAD="E">
    <include_source>*---------------------------------------------------------------------*
*    view related FORM routines
*   generation date: 29.02.2016 at 11:23:56 by user CC615761
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

* base table related FORM-routines.............
INCLUDE LSVIMFTX .</include_source>
   </include>
   <include NAME="LZBH1I00" SQLX="X" EDTX="X" SUBC="I" LEVL="740" RLOAD="E">
    <include_source>*---------------------------------------------------------------------*
*    view related PAI modules
*   generation date: 29.02.2016 at 11:18:00 by user CC615761
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

INCLUDE LSVIMITX . &quot;base table related PAI modules</include_source>
   </include>
   <include NAME="LZBH1TOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="210" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>* regenerated at 29.02.2016 11:18:00 by  CC615761
FUNCTION-POOL ZBH1                       MESSAGE-ID SV.

* INCLUDE LZBH1D...                          &quot; Local class definition
  INCLUDE LSVIMDAT                                . &quot;general data decl.
  INCLUDE LZBH1T00                                . &quot;view rel. data dcl.</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="Z_EMPLOC_DROPDOWN" REMOTE="R" STEXT="Table to Hierarchy itab &amp; Search Function">
    <importing PARAMETER="SEARCH_STRING" OPTIONAL="X" TYP="STRING"/>
    <importing PARAMETER="FROM" DEFAULT="SY-DATUM" OPTIONAL="X" TYP="DATUM"/>
    <importing PARAMETER="TO" DEFAULT="SY-DATUM" OPTIONAL="X" TYP="DATUM"/>
    <exporting PARAMETER="HIERARCHY" TYP="ZBUI_HIER_T"/>
    <exporting PARAMETER="RETURN" TYP="STRING"/>
    <documentation PARAMETER="SEARCH_STRING" KIND="P" STEXT="Search String" INDEX=" 001"/>
    <documentation PARAMETER="FROM" KIND="P" STEXT="Date" INDEX=" 002"/>
    <documentation PARAMETER="TO" KIND="P" STEXT="Date" INDEX=" 003"/>
    <documentation PARAMETER="HIERARCHY" KIND="P" STEXT="Buildings" INDEX=" 004"/>
    <documentation PARAMETER="RETURN" KIND="P" INDEX=" 005"/>
    <fm_source_new>** Table to Hierarchy itab &amp; Search Function

  DATA: it_re       TYPE TABLE OF zrehierarchy,
        it_res      TYPE TABLE OF zrehierarchy,
        wa_re       LIKE LINE OF it_re,
        wa_loc      LIKE LINE OF hierarchy,
        it_com      TYPE TABLE OF zloc_hier,
        wa_com      LIKE LINE OF it_com,
        it_build    TYPE TABLE OF zbui_hier,
        wa_build    LIKE LINE OF it_build,
        it_floor    TYPE TABLE OF zflo_hier,
        wa_floor    LIKE LINE OF it_floor,
        it_room     TYPE TABLE OF zroo_hier,
        wa_room     LIKE LINE OF it_room,
        lv_capacity TYPE rebdmeasvaluecmpl,
        lv_objnr    TYPE recaobjnr,
        lv_from     TYPE reorpovalidfrom,
        lv_to       TYPE reorpovalidto.

  DATA: io_offered_obj TYPE bapi_re_offered_obj,
        it_perm_bapi   TYPE TABLE OF bapi_re_perm_occ,
        wa_perm        LIKE LINE OF it_perm_bapi,
        it_perm_occ    TYPE TABLE OF bapi_re_perm_occ,
        lv_space       TYPE reormsvalue,
        lv_oo          TYPE reorooid.
  DATA: lv_sinstbez TYPE sinstbez.

  SELECT * FROM zrehierarchy INTO TABLE it_re.
  IF search_string IS NOT INITIAL.
    DATA: lv_count TYPE num03.

    CONCATENATE &apos;*&apos; search_string &apos;*&apos; INTO search_string.
    LOOP AT it_re INTO wa_re WHERE xao CP search_string.
      ADD 1 TO lv_count.
      APPEND wa_re TO it_res.
    ENDLOOP.

    &quot;Grab the lower levels if there are any.
    LOOP AT it_res INTO wa_re.
      LOOP AT it_re INTO wa_re WHERE parent = wa_re-intreno.
        APPEND wa_re TO it_res.
      ENDLOOP.
    ENDLOOP.

    &quot;Grab the upper levels.
    LOOP AT it_res INTO wa_re.
      READ TABLE it_re WITH KEY intreno = wa_re-parent INTO wa_re.
      IF sy-subrc = 0.
        APPEND wa_re TO it_res.
      ENDIF.
    ENDLOOP.

    SORT it_res BY intreno.
    DELETE ADJACENT DUPLICATES FROM it_res.

    it_re = it_res.

    MOVE lv_count TO return.
  ENDIF.

* Requirement changed to look from Building Level based on Country &amp; Region. Exporting table and dynpro table changed to building level.

*  LOOP AT it_re INTO wa_re WHERE aotype CP &apos;01*&apos;. &quot;Location
*    wa_loc-locid = wa_re-intreno.
*    wa_loc-locality = wa_re-xao.
*    LOOP AT it_re INTO wa_re WHERE aotype CP &apos;02*&apos; AND parent = wa_re-intreno. &quot;Building Complex (Optional)
*      wa_com-compid = wa_re-intreno.
*      wa_com-complex = wa_re-xao.
  LOOP AT it_re INTO wa_re WHERE aotype CP &apos;03*&apos;. &quot;AND parent = wa_re-intreno. &quot;Building
    wa_build-buildid  = wa_re-intreno.
    wa_build-building = wa_re-xao.
    wa_build-country = wa_re-country.
    wa_build-region = wa_re-region.

    &quot;ToDo - Grab Address &amp; Municipality Data (Probably should go on the building level)
    SELECT SINGLE sinstbez FROM vibdao
    INTO lv_sinstbez
    WHERE intreno = wa_build-buildid.
    IF sy-subrc = 0.
      SELECT SINGLE xmbez FROM tiv16 INTO wa_build-municipality
        WHERE sinstbez = lv_sinstbez.
    ENDIF.

    SELECT SINGLE ad~house_num2 ad~str_suppl1
                  ad~str_suppl2 ad~house_num1
                  ad~street ad~city2 ad~city1
                  ad~post_code1 FROM vzobject AS vz
      INNER JOIN adrc AS ad ON ad~addrnumber = vz~adrnr
      INTO (wa_build-mounties_code, wa_build-ad_unit,
            wa_build-ad_complex, wa_build-ad_street_no,
            wa_build-ad_street, wa_build-ad_suburb,
            wa_build-ad_city, wa_build-ad_post_code)
      WHERE adrobjnr = wa_build-buildid.

    LOOP AT it_re INTO wa_re WHERE aotype CP &apos;04*&apos; AND parent = wa_re-intreno. &quot;Floor
      wa_floor-floid = wa_re-intreno.
      wa_floor-floor = wa_re-xao.
      LOOP AT it_re INTO wa_re WHERE aotype CP &apos;05*&apos; AND parent = wa_re-intreno. &quot;Rooms - Will only show available rooms except if From and To are empty.
        &quot;We want to check the availability of the room here.
        &quot;First check whether it&apos;s a common space and if there is currently capacity.
*        SELECT SINGLE measvaluecmpl FROM vibdmeas INTO lv_capacity
*          WHERE intreno = wa_re-intreno AND
*                meas    = &apos;M001&apos;.

        SELECT SINGLE roo~ooid FROM vibdao AS dao &quot;Grab OOID
          INNER JOIN vioroo AS roo ON dao~objnr = roo~objnrref
          INTO lv_oo
          WHERE dao~intreno = wa_re-intreno.

        CALL FUNCTION &apos;BAPI_RE_OO_GET_DETAIL&apos;
          EXPORTING
            offeredobjectid  = lv_oo
            detail_data_from = from
            detail_data_to   = to
          IMPORTING
            offered_obj      = io_offered_obj
          TABLES
            perm_occ         = it_perm_bapi.

        lv_space = io_offered_obj-meas_value_01. &quot;Capacity - Can also be retrieved from VIBDMEAS

        &quot;Subtracting all
        LOOP AT it_perm_bapi INTO wa_perm WHERE plan_status = &apos;A&apos; AND occupant IS NOT INITIAL AND valid_to &lt; sy-datum.
          APPEND wa_perm TO it_perm_occ.
          SUBTRACT wa_perm-degree_occ_numerator FROM lv_space.
        ENDLOOP.
        IF it_perm_occ IS INITIAL AND io_offered_obj IS NOT INITIAL. &quot;No occupants but object exists.
          sy-subrc = 0.
        ELSEIF lv_oo IS INITIAL. &quot;No offered object attached to Architectural Object. Don&apos;t list.
          sy-subrc = 4.
        ENDIF.

        IF sy-subrc = 0 AND lv_oo &gt; 0.
          &quot;Data found, capacity available.
          wa_room-roomid = wa_re-intreno.
          wa_room-room = wa_re-xao.
          wa_room-function = wa_re-xmaofunction.
          APPEND wa_room TO it_room.
        ELSEIF sy-subrc = 4.
          &quot;No measurement for object. Check whether space is occupied within requested dates.
          IF sy-subrc = 0.
*            SELECT rpo~validfrom rpo~validto FROM vioroo AS roo
*              INNER JOIN viorpo AS rpo ON roo~objnr = rpo~objnroo
*              INTO ( lv_from, lv_to )
*              WHERE roo~objnrref = lv_objnr AND
*                    rpo~planstatus = &apos;A&apos; AND &quot;Activated move
*                    rpo~occupant IS NOT NULL AND &quot;Move for occupant
*                    rpo~occupantrole = &apos;BUP003&apos;. &quot;Employees
            LOOP AT it_perm_occ INTO wa_perm.
              &quot; Check whether our from/to dates fall within an occpied space.
              IF to BETWEEN wa_perm-valid_from AND wa_perm-valid_to.
                sy-subrc = 4.
              ELSEIF from BETWEEN wa_perm-valid_from AND wa_perm-valid_to.
                sy-subrc = 4.
                &quot;Cater for indefinite times as well because apparently a from and to date is not required... Apparently...
              ELSEIF wa_perm-valid_to IS NOT INITIAL AND wa_perm-valid_from IS INITIAL AND from &lt; wa_perm-valid_to. &quot;Occupied until a date, no start date. (Historical move not possible).
                sy-subrc = 4.
              ELSEIF lv_to IS INITIAL AND wa_perm-valid_from IS NOT INITIAL AND to &lt; wa_perm-valid_from. &quot;Occupied till the end of time. (Historical move possible).
                sy-subrc = 4. &quot;Occupied in selected dates.
              ENDIF.

              IF from IS INITIAL AND to IS INITIAL. &quot;From and To are optional fields. Supply everything if empty. For HCM so they can pull everything.
                sy-subrc = 0.
              ENDIF.
            ENDLOOP.

            IF sy-subrc = 0. &quot;Not occupied
              wa_room-roomid = wa_re-intreno.
              wa_room-room = wa_re-xao.
              wa_room-function = wa_re-xmaofunction.
              APPEND wa_room TO it_room.
            ENDIF.
          ENDIF.
        ENDIF.

      ENDLOOP.
      wa_floor-rooms = it_room.
      REFRESH it_room.
      IF wa_floor-rooms IS NOT INITIAL.
        APPEND wa_floor TO it_floor.
      ENDIF.
    ENDLOOP.
    wa_build-floors = it_floor.
    REFRESH it_floor.
*        APPEND wa_build TO it_build.
    IF wa_build-floors IS NOT INITIAL.
      APPEND wa_build TO hierarchy.
    ENDIF.
  ENDLOOP.
*      wa_com-buildings = it_build.
*      REFRESH it_build.
*      APPEND wa_com TO it_com.
*    ENDLOOP.
  &quot;No Building Complex... Set Not Applicable
  &quot;&quot; =====================================================================================
*    wa_com-compid = &apos;0000000000000&apos;.
*    wa_com-complex = &apos;Not applicable&apos;.
*    LOOP AT it_re INTO wa_re WHERE aotype CP &apos;03*&apos; AND parent = wa_loc-locid. &quot;Building with only location
*      wa_build-buildid  = wa_re-intreno.
*      wa_build-building = wa_re-xao.
*      LOOP AT it_re INTO wa_re WHERE aotype CP &apos;04*&apos; AND parent = wa_re-intreno. &quot;Floor
*        wa_floor-floid = wa_re-intreno.
*        wa_floor-floor = wa_re-xao.
*        LOOP AT it_re INTO wa_re WHERE aotype CP &apos;05*&apos; AND parent = wa_re-intreno. &quot;Room
*          wa_room-roomid = wa_re-intreno.
*          wa_room-room = wa_re-xao.
*          wa_room-function = wa_re-xmaofunction.
*          APPEND wa_room TO it_room.
*        ENDLOOP.
*        wa_floor-rooms = it_room.
*        REFRESH it_room.
*        APPEND wa_floor TO it_floor.
*      ENDLOOP.
*      wa_build-floors = it_floor.
*      REFRESH it_floor.
*      APPEND wa_build TO it_build.
*    ENDLOOP.
*    IF it_build IS NOT INITIAL.
*      wa_com-buildings = it_build. &quot;Not applicable complex.
*      REFRESH it_build.
*      APPEND wa_com TO it_com.
*    ENDIF.
*    wa_loc-complexes = it_com.
*    REFRESH it_com.
*    APPEND wa_loc TO hierarchy.
*  ENDLOOP.</fm_source_new>
   </functionmodule>
   <functionmodule NAME="Z_BETTER_DROPDOWN" REMOTE="R" STEXT="Table to Hierarchy itab &amp; Search Function">
    <importing PARAMETER="SEARCH_STRING" OPTIONAL="X" TYP="STRING"/>
    <importing PARAMETER="FROM" DEFAULT="SY-DATUM" OPTIONAL="X" TYP="DATUM"/>
    <importing PARAMETER="COUNTRY" OPTIONAL="X" TYP="LAND1"/>
    <importing PARAMETER="REGION" OPTIONAL="X" TYP="REGIO"/>
    <importing PARAMETER="PARENT" OPTIONAL="X" TYP="REBDINTRENOAO"/>
    <importing PARAMETER="SHOWALL" OPTIONAL="X" TYP="CHAR1"/>
    <exporting PARAMETER="RETURN" TYP="STRING"/>
    <tables PARAMETER="HIERARCHY" DBSTRUCT="ZREHIERARCHY"/>
    <documentation PARAMETER="SEARCH_STRING" KIND="P" STEXT="Search String" INDEX=" 001"/>
    <documentation PARAMETER="FROM" KIND="P" STEXT="From Date" INDEX=" 002"/>
    <documentation PARAMETER="COUNTRY" KIND="P" STEXT="BSI: Country indicator" INDEX=" 003"/>
    <documentation PARAMETER="REGION" KIND="P" STEXT="Region (State, Province, County)" INDEX=" 004"/>
    <documentation PARAMETER="PARENT" KIND="P" STEXT="Internal Object Number for Architecture Objects (INTRENO)" INDEX=" 005"/>
    <documentation PARAMETER="SHOWALL" KIND="P" STEXT="Show All" INDEX=" 006"/>
    <documentation PARAMETER="RETURN" KIND="P" INDEX=" 007"/>
    <documentation PARAMETER="HIERARCHY" KIND="P" STEXT="Hierarchy Table - For use in iView" INDEX=" 008"/>
    <fm_source/>
   </functionmodule>
   <functionmodule NAME="Z_BETTER_DROPDOWN_LAND" REMOTE="R" STEXT="Get Country &amp; Region">
    <importing PARAMETER="LAND1" OPTIONAL="X" TYP="STRING"/>
    <exporting PARAMETER="VALUE_SET" TYP="WDR_CONTEXT_ATTR_VALUE_LIST"/>
    <documentation PARAMETER="LAND1" KIND="P" STEXT="Country Key" INDEX=" 001"/>
    <documentation PARAMETER="VALUE_SET" KIND="P" STEXT="All Fixed Values of an Attribute with Texts" INDEX=" 002"/>
    <fm_source/>
   </functionmodule>
   <functionmodule NAME="Z_RH_GET_STRUCTURE" REMOTE="R">
    <importing PARAMETER="ACT_WEGID" DBFIELD="T778A-WEGID" OPTIONAL="X"/>
    <tables PARAMETER="ACTOR_TAB" DBSTRUCT="SWHACTOR"/>
    <tables PARAMETER="AC_CONTAINER" DBSTRUCT="SWCONT"/>
    <exceptions EXCEPTION="NOBODY_FOUND"/>
    <exceptions EXCEPTION="NO_ACTIVE_PLVAR"/>
    <documentation PARAMETER="ACT_WEGID" KIND="P" STEXT="Evaluation Path" INDEX=" 001"/>
    <documentation PARAMETER="ACTOR_TAB" KIND="P" INDEX=" 002"/>
    <documentation PARAMETER="AC_CONTAINER" KIND="P" STEXT="Container" INDEX=" 003"/>
    <documentation PARAMETER="NOBODY_FOUND" KIND="X" STEXT="No agent found" INDEX=" 004"/>
    <documentation PARAMETER="NO_ACTIVE_PLVAR" KIND="X" STEXT="No active plan version exists" INDEX=" 005"/>
    <fm_source>DATA: lv_rfc TYPE string.
  DATA: lf_key2(30).
  IF sy-sysid(2) = &apos;D0&apos;.
    lf_key2 = &apos;SYSTEM D0&apos;.
  ELSEIF sy-sysid(2) = &apos;Q0&apos;.
    lf_key2 = &apos;SYSTEM Q0&apos;.
  ELSEIF sy-sysid(2) = &apos;P0&apos;.
    lf_key2 = &apos;SYSTEM P0&apos;.
  ENDIF.

  SELECT SINGLE zvalue FROM zconfig INTO lv_rfc
    WHERE zkeyfield1 = &apos;ZP000600&apos; AND
          zkeyfield2 = lf_key2.

  CALL FUNCTION &apos;Z_RH_GET_STRUCTURE&apos; DESTINATION lv_rfc
    EXPORTING
      act_wegid    = act_wegid
    TABLES
      actor_tab    = actor_tab
      ac_container = ac_container.</fm_source>
   </functionmodule>
   <functionmodule NAME="Z_RE_CL_TRIGGER" REMOTE="R" STEXT="Trigger Workflow">
    <importing PARAMETER="MPID" TYP="REORPOMPID"/>
    <documentation PARAMETER="MPID" KIND="P" STEXT="Move Plan ID" INDEX=" 001"/>
    <fm_source>DATA: zcl TYPE REF TO zcl_move_plan.

  DATA: l_event_container TYPE REF TO if_swf_ifs_parameter_container,
        l_event_ref       TYPE REF TO if_swf_evt_event.


  CALL METHOD cl_swf_evt_event=&gt;get_instance
    EXPORTING
      im_objcateg        = &apos;CL&apos;
      im_objtype         = &apos;ZCL_MOVE_PLAN&apos;
      im_event           = &apos;CREATED&apos;
      im_objkey          = mpid &quot;MPID
      im_event_container = l_event_container
    RECEIVING
      re_event           = l_event_ref.

  cl_swf_evt_services=&gt;reset_buffers( ).

  CALL METHOD l_event_ref-&gt;raise.

  COMMIT WORK.</fm_source>
   </functionmodule>
   <functionmodule NAME="Z_GET_EMPL_DETAIL" REMOTE="R" STEXT="Get detail for QMuzik extract">
    <exporting PARAMETER="GT_EXTRACT" TYP="ZTQMUZIK"/>
    <documentation PARAMETER="GT_EXTRACT" KIND="P" STEXT="QMuzik Extract - Infotypes" INDEX=" 001"/>
    <fm_source_new>DATA: lv_prefix TYPE string,
        wa_extract TYPE zsqmuzik.
  DATA: wa_pa0001  TYPE pa0001,
        wa_hrp1001 TYPE hrp1001,
        wa_pa0041 TYPE pa0041.

  DATA: wa_excl TYPE zexcl_pers.
  DATA: so_excl TYPE TABLE OF selopt,
        sa_excl LIKE LINE OF so_excl.

  sa_excl-option = &apos;EQ&apos;.
  sa_excl-sign = &apos;I&apos;.

  SELECT * FROM zexcl_pers INTO wa_excl.
    sa_excl-low = wa_excl-persk.
    APPEND sa_excl TO so_excl.
  ENDSELECT.


  SELECT pa0000~pernr pa0002~vorna pa0002~nachn pa0002~rufnm pa0001~bukrs
         pa0000~begda pa0000~endda pa0001~kostl FROM pa0000
    INNER JOIN pa0001 ON pa0001~pernr = pa0000~pernr
    INNER JOIN pa0002 ON pa0002~pernr = pa0000~pernr
    INTO CORRESPONDING FIELDS OF wa_extract
    WHERE pa0000~endda &gt;= sy-datum AND
          pa0000~begda &lt;= sy-datum AND
          pa0001~endda &gt;= sy-datum AND
          pa0001~begda &lt;= sy-datum AND
          pa0001~persk NOT IN so_excl AND
          pa0002~endda &gt;= sy-datum AND
          pa0002~begda &lt;= sy-datum AND
          pa0000~stat2 = 3 AND
          pa0001~persg &lt;&gt; &apos;A&apos; AND
          pa0001~persg &lt;&gt; &apos;D&apos; AND
          pa0001~persg &lt;&gt; &apos;F&apos; AND
          pa0001~persg &lt;&gt; &apos;T&apos; AND
          pa0001~persg &lt;&gt; &apos;X&apos;.

    SELECT SINGLE * FROM pa0041 INTO wa_pa0041
      WHERE pernr = wa_extract-pernr AND
            endda &gt;= sy-datum AND
            begda &lt;= sy-datum.

    DATA: lv_month(2) TYPE n,
          lv_field TYPE string.
    FIELD-SYMBOLS &lt;field&gt; TYPE any.

    wa_extract-begda = wa_pa0041-dat01.
    CLEAR lv_month.
    DO 12 TIMES.
      ADD 1 TO lv_month.
      CONCATENATE &apos;DAR&apos; lv_month INTO lv_field.
      ASSIGN COMPONENT lv_field OF STRUCTURE wa_pa0041 TO &lt;field&gt;.
      IF &lt;field&gt; = &apos;ZZ&apos;.
        CONCATENATE &apos;DAT&apos; lv_month INTO lv_field.
        ASSIGN COMPONENT lv_field OF STRUCTURE wa_pa0041 TO &lt;field&gt;.
        wa_extract-endda = &lt;field&gt;.
        EXIT.
      ENDIF.
    ENDDO.

    SELECT SINGLE usrid FROM pa0105
        INTO lv_prefix
          WHERE pernr = wa_extract-pernr AND
                subty = &apos;0001&apos; AND
                begda &lt;= sy-datum AND
                endda &gt;= sy-datum.

    IF sy-subrc = 0 AND strlen( lv_prefix ) &gt;= 2.
      wa_extract-pernrpf = lv_prefix+0(2).
    ENDIF.

    &quot;Line Manager
    SELECT SINGLE * FROM pa0001 INTO wa_pa0001 &quot;Org Unit
        WHERE pernr = wa_extract-pernr AND
              endda &gt;= sy-datum AND
              begda &lt;= sy-datum.

    SELECT SINGLE * FROM hrp1001 INTO wa_hrp1001 &quot;Position controlling Org Unit
    WHERE otype = &apos;O&apos; AND
          objid = wa_pa0001-orgeh AND
          relat = &apos;012&apos; AND
          rsign = &apos;B&apos; AND
          endda &gt;= sy-datum AND
          begda &lt;= sy-datum.

    SELECT SINGLE * FROM hrp1001 INTO wa_hrp1001 &quot;Person in Position
     WHERE otype = &apos;S&apos; AND
           objid = wa_hrp1001-sobid AND
           relat = &apos;008&apos; AND
           rsign = &apos;A&apos; AND
           endda &gt;= sy-datum AND
           begda &lt;= sy-datum.

* @(｡◕ ‿ ◕｡)@ - Loop until line manager is found.

    IF wa_hrp1001-sobid = wa_extract-pernr OR sy-subrc &lt;&gt; 0.

      DATA(lv_orgeh) = wa_pa0001-orgeh.

      WHILE sy-subrc &lt;&gt; 0 OR wa_hrp1001-sobid = wa_extract-pernr.
        SELECT SINGLE * FROM hrp1001 INTO wa_hrp1001 &quot;Org Unit above current
          WHERE otype = &apos;O&apos; AND
                objid = lv_orgeh AND
                relat = &apos;002&apos; AND
                rsign = &apos;A&apos; AND
                endda &gt;= sy-datum AND
                begda &lt;= sy-datum.
        IF sy-subrc = 4.
          EXIT. &quot;Exit loop if no more org units are found.
        ENDIF.
        lv_orgeh = wa_hrp1001-sobid. &quot;Move new org unit into variable.

        SELECT SINGLE * FROM hrp1001 INTO wa_hrp1001 &quot;Position Above Org Unit
         WHERE objid = wa_hrp1001-sobid AND
               relat = &apos;012&apos; AND
               rsign = &apos;B&apos; AND
               endda &gt;= sy-datum AND
               begda &lt;= sy-datum.

        SELECT SINGLE * FROM hrp1001 INTO wa_hrp1001 &quot;Person in Position
          WHERE objid = wa_hrp1001-sobid AND
                relat = &apos;008&apos; AND
                rsign = &apos;A&apos; AND
                endda &gt;= sy-datum AND
                begda &lt;= sy-datum.
      ENDWHILE.
    ENDIF.

    wa_extract-mpernr = COND #( WHEN sy-subrc = 0 AND wa_pa0001-orgeh IS NOT INITIAL THEN wa_hrp1001-sobid ).

    &quot;Email
    SELECT SINGLE usrid_long FROM pa0105
      INTO wa_extract-smtp_addr
      WHERE pernr = wa_extract-pernr AND
            subty = &apos;0010&apos; AND
            begda &lt;= sy-datum AND
            endda &gt;= sy-datum.

    &quot;Tel - Office
    SELECT SINGLE usrid_long FROM pa0105
      INTO wa_extract-tel_office
      WHERE pernr = wa_extract-pernr AND
            subty = &apos;0020&apos; AND
            begda &lt;= sy-datum AND
            endda &gt;= sy-datum.

    &quot;Tel - Mobile
    SELECT SINGLE usrid_long FROM pa0105
      INTO wa_extract-tel_mobile
      WHERE pernr = wa_extract-pernr AND
            subty = &apos;0111&apos; AND
            begda &lt;= sy-datum AND
            endda &gt;= sy-datum.

    &quot;Use manager email if email is empty.
    IF wa_extract-smtp_addr IS INITIAL AND wa_extract-mpernr IS NOT INITIAL.
      SELECT SINGLE usrid_long FROM pa0105
       INTO wa_extract-smtp_addr
       WHERE pernr = wa_extract-mpernr AND
             subty = &apos;0010&apos; AND
             begda &lt;= sy-datum AND
             endda &gt;= sy-datum.
    ENDIF.

    APPEND wa_extract TO gt_extract.
    CLEAR wa_extract.
  ENDSELECT.</fm_source_new>
   </functionmodule>
   <functionmodule NAME="TABLEFRAME_ZBH1" STEXT="Extended Table Maintenance: Upper Level">
    <importing PARAMETER="VIEW_ACTION" DEFAULT="&apos;S&apos;"/>
    <importing PARAMETER="VIEW_NAME" DBFIELD="DD02V-TABNAME"/>
    <importing PARAMETER="CORR_NUMBER" DBFIELD="E070-TRKORR" DEFAULT="&apos; &apos;"/>
    <tables PARAMETER="DBA_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="DPL_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="EXCL_CUA_FUNCT" DBSTRUCT="VIMEXCLFUN"/>
    <tables PARAMETER="X_HEADER" DBSTRUCT="VIMDESC"/>
    <tables PARAMETER="X_NAMTAB" DBSTRUCT="VIMNAMTAB"/>
    <exceptions EXCEPTION="MISSING_CORR_NUMBER"/>
    <documentation PARAMETER="VIEW_ACTION" KIND="P" STEXT="Aktion mit Tabelle: anz./änd./transp. (S/U/T)" INDEX=" 001"/>
    <documentation PARAMETER="VIEW_NAME" KIND="P" STEXT="Name der Tabelle" INDEX=" 002"/>
    <documentation PARAMETER="CORR_NUMBER" KIND="P" STEXT="Korrekturnummer für durchgeführte Änderungen" INDEX=" 003"/>
    <documentation PARAMETER="DBA_SELLIST" KIND="P" STEXT="Selektionsbedingungen für den DB-Zugriff" INDEX=" 004"/>
    <documentation PARAMETER="DPL_SELLIST" KIND="P" STEXT="Selektionsbedingungen für die Anzeige" INDEX=" 005"/>
    <documentation PARAMETER="EXCL_CUA_FUNCT" KIND="P" STEXT="Tabelle mit dynam. zu deaktivierenden CUA-Funkt." INDEX=" 006"/>
    <documentation PARAMETER="X_HEADER" KIND="P" STEXT="Kontrollblocktabelle für die Tabelle" INDEX=" 007"/>
    <documentation PARAMETER="X_NAMTAB" KIND="P" STEXT="Kontrollblocktabelle für die Tabellen-Felder" INDEX=" 008"/>
    <documentation PARAMETER="MISSING_CORR_NUMBER" KIND="X" STEXT="Korrekturnummer fehlt" INDEX=" 009"/>
    <fm_source>*---------------------------------------------------------------------*
*    program for:   TABLEFRAME_ZBH1
*   generation date: 29.02.2016 at 11:17:59 by user CC615761
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

  PERFORM TABLEFRAME TABLES X_HEADER X_NAMTAB DBA_SELLIST DPL_SELLIST
                            EXCL_CUA_FUNCT
                     USING  CORR_NUMBER VIEW_ACTION VIEW_NAME.</fm_source>
   </functionmodule>
   <functionmodule NAME="TABLEPROC_ZBH1" GLOBAL="X" STEXT="Lower-level extended table maintenance">
    <importing PARAMETER="FCODE" DEFAULT="&apos;RDED&apos;"/>
    <importing PARAMETER="VIEW_ACTION" DEFAULT="&apos;S&apos;"/>
    <importing PARAMETER="VIEW_NAME" DBFIELD="DD02V-TABNAME"/>
    <importing PARAMETER="CORR_NUMBER" DBFIELD="E070-TRKORR" DEFAULT="&apos; &apos;"/>
    <exporting PARAMETER="LAST_ACT_ENTRY"/>
    <exporting PARAMETER="UCOMM"/>
    <exporting PARAMETER="UPDATE_REQUIRED"/>
    <tables PARAMETER="CORR_KEYTAB" DBSTRUCT="E071K"/>
    <tables PARAMETER="DBA_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="DPL_SELLIST" DBSTRUCT="VIMSELLIST"/>
    <tables PARAMETER="EXCL_CUA_FUNCT" DBSTRUCT="VIMEXCLFUN"/>
    <tables PARAMETER="EXTRACT"/>
    <tables PARAMETER="TOTAL"/>
    <tables PARAMETER="X_HEADER" DBSTRUCT="VIMDESC"/>
    <tables PARAMETER="X_NAMTAB" DBSTRUCT="VIMNAMTAB"/>
    <exceptions EXCEPTION="MISSING_CORR_NUMBER"/>
    <exceptions EXCEPTION="SAVING_CORRECTION_FAILED"/>
    <documentation PARAMETER="FCODE" KIND="P" STEXT="gewünschte Funktion des Bausteins" INDEX=" 001"/>
    <documentation PARAMETER="VIEW_ACTION" KIND="P" STEXT="Aktion mit Tabelle: anz./änd./transp. (S/U/T)" INDEX=" 002"/>
    <documentation PARAMETER="VIEW_NAME" KIND="P" STEXT="Name der Tabelle" INDEX=" 003"/>
    <documentation PARAMETER="CORR_NUMBER" KIND="P" STEXT="Korrekturnummer für durchgeführte Änderungen" INDEX=" 004"/>
    <documentation PARAMETER="LAST_ACT_ENTRY" KIND="P" STEXT="Index der Cursorposition in der Anzeigetabelle" INDEX=" 005"/>
    <documentation PARAMETER="UCOMM" KIND="P" STEXT="letztes User-command innerhalb der Viewpflege" INDEX=" 006"/>
    <documentation PARAMETER="UPDATE_REQUIRED" KIND="P" STEXT="Flag: Einträge verändert, Sichern erforderlich" INDEX=" 007"/>
    <documentation PARAMETER="CORR_KEYTAB" KIND="P" STEXT="Tabelle mit den Keys der zu transport. Einträge" INDEX=" 008"/>
    <documentation PARAMETER="DBA_SELLIST" KIND="P" STEXT="Selektionsbedingungen für den DB-Zugriff" INDEX=" 009"/>
    <documentation PARAMETER="DPL_SELLIST" KIND="P" STEXT="Selektionsbedingungen für die Anzeige" INDEX=" 010"/>
    <documentation PARAMETER="EXCL_CUA_FUNCT" KIND="P" STEXT="Tab. der nicht zu aktivierenden CUA-Funktionen" INDEX=" 011"/>
    <documentation PARAMETER="EXTRACT" KIND="P" STEXT="Tab. der gerade sichtbaren Daten (Anzeigetabelle" INDEX=" 012"/>
    <documentation PARAMETER="TOTAL" KIND="P" STEXT="Tabelle, mit allen von der DB gelesenen Daten" INDEX=" 013"/>
    <documentation PARAMETER="X_HEADER" KIND="P" STEXT="Kontrollblocktabelle für die Tabelle" INDEX=" 014"/>
    <documentation PARAMETER="X_NAMTAB" KIND="P" STEXT="Kontrollblocktabelle für die Tabellen-Felder" INDEX=" 015"/>
    <documentation PARAMETER="MISSING_CORR_NUMBER" KIND="X" STEXT="Korrekturnummer fehlt" INDEX=" 016"/>
    <documentation PARAMETER="SAVING_CORRECTION_FAILED" KIND="X" STEXT="Fehler beim Sichern der Korrektureinträge" INDEX=" 017"/>
    <fm_source>*---------------------------------------------------------------------*
*    program for:   TABLEPROC_ZBH1
*   generation date: 29.02.2016 at 11:17:59 by user CC615761
*   view maintenance generator version: #001407#
*---------------------------------------------------------------------*

  PERFORM TABLEPROC.</fm_source>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <FUGR SPRAS="E" AREA="Z001" AREAT="RFC for BAPI Get Line Manager">
  <mainprogram NAME="SAPLZ001" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="210" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <source>*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************

INCLUDE lz001top.                          &quot; Global Data
INCLUDE lz001uxx.                          &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZ001F...                          &quot; Subroutines
* INCLUDE LZ001O...                          &quot; PBO-Modules
* INCLUDE LZ001I...                          &quot; PAI-Modules
* INCLUDE LZ001E...                          &quot; Events
* INCLUDE LZ001P...                          &quot; Local class implement.
* INCLUDE LZ001T99.                          &quot; ABAP Unit tests</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZ001TOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="210" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL z001.                         &quot;MESSAGE-ID ..

INCLUDE z_1bcdwb_iq000000000003dat.

SELECTION-SCREEN BEGIN OF SCREEN 2000.
INCLUDE z_1bcdwb_iq000000000003sscr.
SELECTION-SCREEN END OF SCREEN 2000.

INCLUDE z_1bcdwb_iq000000000003sscrat.

DATA: dbcursor  TYPE cursor,
      auth_tabs TYPE aqttabname.
* INCLUDE LZ001D...                          &quot; Local class definition</include_source>
   </include>
   <include NAME="LZ001TOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="210" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL z001.                         &quot;MESSAGE-ID ..

INCLUDE z_1bcdwb_iq000000000003dat.

SELECTION-SCREEN BEGIN OF SCREEN 2000.
INCLUDE z_1bcdwb_iq000000000003sscr.
SELECTION-SCREEN END OF SCREEN 2000.

INCLUDE z_1bcdwb_iq000000000003sscrat.

DATA: dbcursor  TYPE cursor,
      auth_tabs TYPE aqttabname.
* INCLUDE LZ001D...                          &quot; Local class definition</include_source>
   </include>
   <include NAME="LZ001TOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="210" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL z001.                         &quot;MESSAGE-ID ..

INCLUDE z_1bcdwb_iq000000000003dat.

SELECTION-SCREEN BEGIN OF SCREEN 2000.
INCLUDE z_1bcdwb_iq000000000003sscr.
SELECTION-SCREEN END OF SCREEN 2000.

INCLUDE z_1bcdwb_iq000000000003sscrat.

DATA: dbcursor  TYPE cursor,
      auth_tabs TYPE aqttabname.
* INCLUDE LZ001D...                          &quot; Local class definition</include_source>
   </include>
   <include NAME="LZ001TOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="210" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL z001.                         &quot;MESSAGE-ID ..

INCLUDE z_1bcdwb_iq000000000003dat.

SELECTION-SCREEN BEGIN OF SCREEN 2000.
INCLUDE z_1bcdwb_iq000000000003sscr.
SELECTION-SCREEN END OF SCREEN 2000.

INCLUDE z_1bcdwb_iq000000000003sscrat.

DATA: dbcursor  TYPE cursor,
      auth_tabs TYPE aqttabname.
* INCLUDE LZ001D...                          &quot; Local class definition</include_source>
   </include>
   <include NAME="Z_1BCDWB_IQ000000000003DAT" VARCL="X" SUBC="I" APPL="S" RMAND="210" RLOAD="E" UCCHECK="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           Z_1BCDWB_IQ000000000003DAT
*&amp;---------------------------------------------------------------------*

include &lt;symbol&gt;.
include &lt;icon&gt;.

constants:
  begin of iqid,&quot;type aqliqid
    workspace type aql_wsid   value &apos; &apos;,
    usergroup type aql_ugroup value &apos;ZHR&apos;,
    query     type aql_query  value &apos;ACTIVEUSER9999&apos;,
    lid       type aql_lid    value &apos;G00&apos;,
    struct    type aql_tname  value &apos;Z1BCDWB_IQ000000000003&apos;,
    infoset   type aql_iset   value &apos;ZHR1&apos;,
  end of iqid.

data runmode type aqlimode.

data seloptions type table of rsparams with header line.

field-symbols &lt;selopt&gt; type rsparams_tt.

tables PA0000.
tables PA0001.
tables PA0105.
tables HRP1000.
tables HRP1001.
tables pa0041.

data: begin of joinwa,
        PA0000 like PA0000,
        PA0001 like PA0001,
        PA0105 like PA0105,
        HRP1000 like HRP1000,
        HRP1001 like HRP1001,
      end of joinwa.</include_source>
   </include>
   <include NAME="Z_1BCDWB_IQ000000000003SSCR" VARCL="X" SUBC="I" APPL="S" RMAND="210" RLOAD="E" UCCHECK="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           Z_1BCDWB_IQ000000000003SSCR
*&amp;---------------------------------------------------------------------*

SELECTION-SCREEN BEGIN OF BLOCK qsel
                          WITH FRAME TITLE text-s02.
*SELECT-OPTIONS sp$00001 FOR pa0000-pernr MEMORY ID per.
*SELECT-OPTIONS sp$00002 FOR pa0000-endda.
*SELECT-OPTIONS sp$00003 FOR pa0000-begda.
*SELECT-OPTIONS sp$00004 FOR pa0001-endda.
*SELECT-OPTIONS sp$00005 FOR pa0001-begda.
*SELECT-OPTIONS sp$00006 FOR pa0000-stat2.
*SELECT-OPTIONS sp$00007 FOR pa0001-plans.
*select-options SP$00008 for PA0105-ENDDA.
*select-options SP$00009 for PA0105-BEGDA.
*select-options SP$00010 for PA0105-USRTY.
*select-options SP$00011 for HRP1000-OTYPE memory id POT.
*select-options SP$00012 for HRP1000-BEGDA memory id BEG.
*select-options SP$00013 for HRP1000-ENDDA memory id BEG.
*select-options SP$00014 for HRP1001-BEGDA memory id BEG.
*select-options SP$00015 for HRP1001-ENDDA memory id END.
*SELECTION-SCREEN END OF BLOCK qsel.

select-options SP$00001 for PA0000-PERNR.
select-options SP$00003 for PA0000-BEGDA.
select-options SP$00002 for PA0000-ENDDA.
select-options SP$00006 for PA0001-BEGDA.
select-options SP$00005 for PA0001-ENDDA.
select-options SP$00004 for PA0000-STAT2.
select-options SP$00007 for PA0001-PLANS.
select-options SP$00008 for HRP1001-ENDDA.
select-options SP$00009 for HRP1001-BEGDA.
select-options SP$00010 for HRP1001-ENDDA.
select-options SP$00011 for HRP1000-OTYPE memory id POT.
select-options SP$00016 for HRP1001-SUBTY.
select-options SP$00017 for HRP1001-SCLAS.
select-options SP$00012 for HRP1000-BEGDA memory id BEG.
select-options SP$00013 for HRP1000-ENDDA memory id END.
select-options SP$00014 for HRP1001-BEGDA memory id BEG.
select-options SP$00015 for HRP1001-ENDDA memory id END.
selection-screen end of block qsel.
SELECTION-SCREEN BEGIN OF BLOCK stdsel WITH FRAME TITLE text-s03.
PARAMETERS layout TYPE slis_vari MODIF ID lay.
SELECTION-SCREEN END OF BLOCK stdsel.</include_source>
   </include>
   <include NAME="Z_1BCDWB_IQ000000000003SSCRAT" VARCL="X" SUBC="I" APPL="S" RMAND="210" RLOAD="E" UCCHECK="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           Z_1BCDWB_IQ000000000003SSCRAT
*&amp;---------------------------------------------------------------------*

AT SELECTION-SCREEN.
  tables sscrfields.
  call function &apos;RSAQRT_LAYOUT_CHECK&apos;
       exporting variant = layout
       changing  rtmode  = runmode.
  call function &apos;RSAQRT_SSCR_TEST&apos;
       exporting  sscruc = sscrfields-ucomm
       tables     selopt = &lt;selopt&gt;
       changing   rtmode = runmode
       exceptions others = 1.
  if sy-subrc &lt;&gt; 0.
    runmode-extr_on = space.
    runmode-show_on = space.
  endif.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR LAYOUT.
  call function &apos;RSAQRT_LAYOUT_VALUE_REQUEST&apos;
       changing rtmode  = runmode
                variant = layout.

AT SELECTION-SCREEN OUTPUT.
  call function &apos;RSAQRT_SSCR_OUTPUT&apos;
       changing rtmode = runmode.

INITIALIZATION.
  assign seloptions[] to &lt;selopt&gt;.
  call function &apos;RSAQRT_INITIALIZATION&apos;
       exporting iqid   = iqid
       importing rtmode = runmode.
  perform initialization.

*---------------------------------------------------------------*
*       FORM initialization                                    *
*---------------------------------------------------------------*

form initialization.


endform.</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="Z_BAPI_GET_LINE_MANAGER" REMOTE="R" STEXT="Get Line Manager">
    <importing PARAMETER="IM_OBJID" OPTIONAL="X" TYP="OBJEKTID"/>
    <exporting PARAMETER="ES_APPROVER" TYP="PTREQ_APPROVER_STRUC"/>
    <exporting PARAMETER="EV_HAS_MANAGER" TYP="BOOLEAN"/>
    <exporting PARAMETER="INSTANCE_ID" TYP="TIM_REQ_ACTOR_ID"/>
    <exporting PARAMETER="SEQNR" TYP="TIM_REQ_ACTOR_SEQNR"/>
    <exporting PARAMETER="STATUS" TYP="TIM_REQ_ACTOR_STATUS"/>
    <exporting PARAMETER="PERNR" TYP="P_PERNR"/>
    <exporting PARAMETER="NAME" TYP="EMNAM"/>
    <exporting PARAMETER="APPROVER_POSITION" TYP="PLSTX"/>
    <exporting PARAMETER="ORG_UNIT" TYP="ORGTX"/>
    <exporting PARAMETER="SYS_USER" TYP="SYSID"/>
    <exporting PARAMETER="DEFAULT_FLAG" TYP="BOOLEAN"/>
    <documentation PARAMETER="IM_OBJID" KIND="P" STEXT="Object ID" INDEX=" 001"/>
    <documentation PARAMETER="ES_APPROVER" KIND="P" STEXT="List of Approvers for Leave Request" INDEX=" 002"/>
    <documentation PARAMETER="EV_HAS_MANAGER" KIND="P" STEXT="Approver Level for Leave Request" INDEX=" 003"/>
    <documentation PARAMETER="INSTANCE_ID" KIND="P" STEXT="Actor Identification" INDEX=" 004"/>
    <documentation PARAMETER="SEQNR" KIND="P" STEXT="Approver Sequence Number" INDEX=" 005"/>
    <documentation PARAMETER="STATUS" KIND="P" STEXT="Approver Status" INDEX=" 006"/>
    <documentation PARAMETER="PERNR" KIND="P" STEXT="Personnel Number" INDEX=" 007"/>
    <documentation PARAMETER="NAME" KIND="P" STEXT="Formatted Name of Employee or Applicant" INDEX=" 008"/>
    <documentation PARAMETER="APPROVER_POSITION" KIND="P" STEXT="Position (Short Text)" INDEX=" 009"/>
    <documentation PARAMETER="ORG_UNIT" KIND="P" STEXT="Short Text of Organizational Unit" INDEX=" 010"/>
    <documentation PARAMETER="SYS_USER" KIND="P" STEXT="Communication Identification/Number" INDEX=" 011"/>
    <documentation PARAMETER="DEFAULT_FLAG" KIND="P" STEXT="Boolean Variable (X=True, -=False, Space=Unknown)" INDEX=" 012"/>
    <fm_source_new>&quot; Choose Direct Line Manager
  DATA: lv_approver_pernr       TYPE objektid,
        ls_ac_container_wa TYPE swcont,
        lt_ac_container    TYPE TABLE OF swcont INITIAL SIZE 0,
        ls_actor_wa        TYPE swhactor,
        lo_actor_agent          TYPE REF TO ca_pt_req_actor,
        lo_approver             TYPE REF TO if_pt_req_a_wf,
        ls_approver             TYPE ptreq_approver_struc,
        lt_actor_tab       TYPE TABLE OF swhactor INITIAL SIZE 0.

  &quot;Initialzie Data
  CLEAR: es_approver,ev_has_manager.
  CLASS ca_pt_req_actor DEFINITION LOAD.
  lo_actor_agent = ca_pt_req_actor=&gt;agent.

  &quot;Get Line Manager
  ls_ac_container_wa-element    = &apos;ORG_OBJECT&apos;.
  ls_ac_container_wa-elemlength = &apos;025&apos;.
  ls_ac_container_wa-type       = &apos;C&apos;.
  CONCATENATE &apos;P&apos; im_objid INTO ls_ac_container_wa-value SEPARATED BY space.
  APPEND ls_ac_container_wa TO lt_ac_container.
  CALL FUNCTION &apos;PT_ARQ_GET_APPROVER_FROM_ORG&apos;
    EXPORTING
      authority_check = &apos; &apos;
      pernr           = im_objid
    TABLES
      actor_tab       = lt_actor_tab
      ac_container    = lt_ac_container
    EXCEPTIONS
      nobody_found    = 1
      OTHERS          = 2.

  LOOP AT lt_actor_tab INTO ls_actor_wa.
    IF ls_actor_wa-otype EQ &apos;P &apos;.
      lv_approver_pernr = ls_actor_wa-objid.
      CALL METHOD lo_actor_agent-&gt;create_actor
        EXPORTING
          im_actor_type      = &apos;P&apos;
          im_otype           = &apos;P&apos;
          im_objid           = lv_approver_pernr
        IMPORTING
          ex_actor           = lo_approver
        EXCEPTIONS
          missing_parameter  = 1
          pernr_not_existing = 2
          application_error  = 3
          OTHERS             = 4.

      IF sy-subrc &lt;&gt; 0.
        ev_has_manager = abap_false.
      ELSE.
        ls_approver-default_flag = abap_true.
        ls_approver-status = &apos;T&apos;.
        ls_approver-pernr  = lo_approver-&gt;pernr.
        ls_approver-sys_user   = lo_approver-&gt;user.
        ls_approver-name      = lo_approver-&gt;name.
        es_approver = ls_approver.

        instance_id = es_approver-instance_id.
        seqnr = es_approver-seqnr.
        status = es_approver-status.
        pernr = es_approver-pernr.
        name = es_approver-name.
        approver_position = es_approver-approver_position.
        org_unit = es_approver-org_unit.
        sys_user = es_approver-sys_user.
        default_flag = es_approver-default_flag.

        ev_has_manager = abap_true.
        RETURN.
      ENDIF.
    ENDIF.
  ENDLOOP.</fm_source_new>
   </functionmodule>
   <functionmodule NAME="Z_1BCDWB_IQ000000000003SHOW" STEXT="Module for displaying data">
    <changing PARAMETER="RTMODE" TYP="AQLIMODE"/>
    <tables PARAMETER="DTAB" DBSTRUCT="Z1BCDWB_IQ000000000003"/>
    <documentation PARAMETER="DTAB" KIND="P" STEXT="Query ACTIVEUSER9999/SYSTQV000007(210)" INDEX=" 001"/>
    <documentation PARAMETER="RTMODE" KIND="P" INDEX=" 002"/>
    <fm_source>*  call function &apos;RSAQRT_SET_IDENTIFICATION&apos;
*       exporting iqid        = iqid
*                 sscr_report = &apos;ZACTIVEUSER9999&apos;
*       changing  rtmode      = rtmode.
*  call function &apos;RSAQRT_ALV_DISPLAY&apos;
*       tables     dtab         = dtab[]
*       changing   rtmode       = rtmode.

  DATA: fieldcatalog TYPE slis_t_fieldcat_alv WITH HEADER LINE,
        gd_layout    TYPE slis_layout_alv,
        gd_repid     LIKE sy-repid,
        g_save TYPE c VALUE &apos;X&apos;,
        g_variant TYPE disvariant,
        gx_variant TYPE disvariant,
        g_exit TYPE c,
        ispfli TYPE TABLE OF spfli.

  fieldcatalog-fieldname   = &apos;PERNR&apos;.
  fieldcatalog-seltext_m   = &apos;Personnel Number&apos;.
  fieldcatalog-col_pos     = 1.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.

  fieldcatalog-fieldname   = &apos;ENDDA&apos;.
  fieldcatalog-seltext_m   = &apos;End Date&apos;.
  fieldcatalog-col_pos     = 2.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.
  fieldcatalog-fieldname   = &apos;BEGDA&apos;.
  fieldcatalog-seltext_m   = &apos;Start Date&apos;.
  fieldcatalog-col_pos     = 3.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.

  fieldcatalog-fieldname   = &apos;STAT2&apos;.
  fieldcatalog-seltext_m   = &apos;Employement Status&apos;.
  fieldcatalog-col_pos     = 4.
  fieldcatalog-outputlen   = 1.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.

  fieldcatalog-fieldname   = &apos;MASSN&apos;.
  fieldcatalog-seltext_m   = &apos;Action Type&apos;.
  fieldcatalog-col_pos     = 5.
*  fieldcatalog-outputlen   = 2.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.

  fieldcatalog-fieldname   = &apos;PERSG&apos;.
  fieldcatalog-seltext_m   = &apos;Employee Group&apos;.
  fieldcatalog-col_pos     = 6.
*  fieldcatalog-outputlen   = 1.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.

  fieldcatalog-fieldname   = &apos;PERSK&apos;.
  fieldcatalog-seltext_m   = &apos;Employee Subgroup&apos;.
  fieldcatalog-col_pos     = 7.
*  fieldcatalog-outputlen   = 2.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.

  fieldcatalog-fieldname   = &apos;KOSTL&apos;.
  fieldcatalog-seltext_m   = &apos;Cost Center&apos;.
  fieldcatalog-col_pos     = 8.
*  fieldcatalog-outputlen   = 10.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.

  fieldcatalog-fieldname   = &apos;ORGEH&apos;.
  fieldcatalog-seltext_m   = &apos;Organizational Unit&apos;.
  fieldcatalog-col_pos     = 9.
*  fieldcatalog-outputlen   = 8.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.

  fieldcatalog-fieldname   = &apos;PLANS&apos;.
  fieldcatalog-seltext_m   = &apos;Position&apos;.
  fieldcatalog-col_pos     = 10.
*  fieldcatalog-outputlen   = 8.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.

  fieldcatalog-fieldname   = &apos;DAT01&apos;.
*  fieldcatalog-seltext_m   = &apos;InfType 0041 - Termination Date&apos;.
  fieldcatalog-seltext_l   = &apos;InfType 0041 - Termination Date&apos;.
  fieldcatalog-col_pos     = 11.
  fieldcatalog-outputlen   = 31.
  APPEND fieldcatalog TO fieldcatalog.
  CLEAR  fieldcatalog.


  CALL FUNCTION &apos;REUSE_ALV_GRID_DISPLAY&apos;
    EXPORTING
      i_callback_program      = gd_repid
      i_callback_top_of_page  = &apos;TOP-OF-PAGE&apos;  &quot;see FORM
      i_callback_user_command = &apos;USER_COMMAND&apos;
      it_fieldcat             = fieldcatalog[]
      i_save                  = &apos;X&apos;
      is_variant              = g_variant
    TABLES
      t_outtab                = dtab[].</fm_source>
   </functionmodule>
   <functionmodule NAME="Z_1BCDWB_IQ000000000003EXTR" STEXT="Module for selecting data">
    <changing PARAMETER="RTMODE" TYP="AQLIMODE"/>
    <tables PARAMETER="SELOPT" DBSTRUCT="RSPARAMS"/>
    <tables PARAMETER="DTAB" DBSTRUCT="Z1BCDWB_IQ000000000003"/>
    <exceptions EXCEPTION="NO_DATA"/>
    <exceptions EXCEPTION="NO_AUTHORIZATION"/>
    <exceptions EXCEPTION="ILLEGAL_PACKAGE"/>
    <exceptions EXCEPTION="CURSOR_NOT_OPEN"/>
    <documentation PARAMETER="SELOPT" KIND="P" INDEX=" 001"/>
    <documentation PARAMETER="DTAB" KIND="P" STEXT="Query ACTIVEUSER9999/SYSTQV000007(210)" INDEX=" 002"/>
    <documentation PARAMETER="RTMODE" KIND="P" INDEX=" 003"/>
    <documentation PARAMETER="NO_DATA" KIND="X" INDEX=" 004"/>
    <documentation PARAMETER="NO_AUTHORIZATION" KIND="X" INDEX=" 005"/>
    <documentation PARAMETER="ILLEGAL_PACKAGE" KIND="X" INDEX=" 006"/>
    <documentation PARAMETER="CURSOR_NOT_OPEN" KIND="X" INDEX=" 007"/>
    <fm_source_new>CALL FUNCTION &apos;RSAQRT_SET_IDENTIFICATION&apos;
    EXPORTING
      iqid        = iqid
      sscr_report = sy-repid
    CHANGING
      rtmode      = rtmode.

  IF rtmode-pack_on = space OR rtmode-first_call = &apos;X&apos;.
    CALL FUNCTION &apos;RSAQRT_FILL_SELECTIONS&apos;
      TABLES
        selopt = selopt
      CHANGING
        rtmode = rtmode.
  ENDIF.

  CALL FUNCTION &apos;RSAQRT_INIT_TEXTHANDLING&apos;
    EXPORTING
      class   = &apos;CL_TEXT_IDENTIFIER&apos;
      wsid    = &apos; &apos;
      infoset = &apos;ZHR1&apos;.

  IF rtmode-no_authchk = space
     AND ( rtmode-pack_on = space OR rtmode-first_call = &apos;X&apos; ).
    REFRESH auth_tabs.
    APPEND &apos;PA0000&apos; TO auth_tabs.
    APPEND &apos;PA0001&apos; TO auth_tabs.
    CALL FUNCTION &apos;RSAQRT_AUTHORITY_CHECK&apos;
      EXPORTING
        auth_tabs        = auth_tabs
        auth_clas        = &apos;CL_QUERY_TAB_ACCESS_AUTHORITY&apos;
      CHANGING
        rtmode           = rtmode
      EXCEPTIONS
        no_authorization = 1.
    IF sy-subrc = 1.
      RAISE no_authorization.
    ENDIF.
  ENDIF.

  DATA: l_no_further_fetch TYPE flag, &quot; stop fetching
        l_hits_cnt         TYPE i.    &quot; cnt for dbtab entries

  IF rtmode-pack_abort = &apos;X&apos;.
    IF NOT dbcursor IS INITIAL.
      CLOSE CURSOR dbcursor.
    ENDIF.
    EXIT.
  ENDIF.


  IF rtmode-pack_on = space OR rtmode-first_call = &apos;X&apos;.
    IF NOT dbcursor IS INITIAL.
      CLOSE CURSOR dbcursor.
    ENDIF.

    OPEN CURSOR WITH HOLD dbcursor FOR
    SELECT pa0000~pernr pa0000~endda pa0000~begda pa0000~stat2 pa0000~massn pa0001~persg pa0001~persk pa0001~kostl pa0001~orgeh
           pa0001~plans pa0001~endda pa0001~begda pa0001~pernr
    FROM ( pa0000
           INNER JOIN pa0001
           ON  pa0001~pernr = pa0000~pernr )
         WHERE pa0000~pernr IN sp$00001
           AND pa0000~endda &gt;= sp$00008
           AND pa0000~begda &lt;= sp$00008
           AND pa0000~stat2 IN sp$00004
           AND pa0001~endda &gt;= sp$00008
           AND pa0001~begda &lt;= sp$00008
           AND pa0001~plans IN sp$00007.
  ENDIF.

  IF dbcursor IS INITIAL.
    RAISE cursor_not_open.
  ENDIF.

  WHILE l_no_further_fetch = space.
    FETCH NEXT CURSOR dbcursor
    INTO (PA0000-PERNR , PA0000-ENDDA , PA0000-BEGDA , PA0000-STAT2 , PA0000-MASSN , PA0001-PERSG , PA0001-PERSK , PA0001-KOSTL
        , PA0001-ORGEH , PA0001-PLANS , PA0001-ENDDA , PA0001-BEGDA , PA0001-PERNR ).
    IF ( ( rtmode-acc_check = &apos;X&apos; AND
           sy-dbcnt &gt; rtmode-acc_number )
        OR sy-subrc &lt;&gt; 0 ).
      l_no_further_fetch = &apos;X&apos;.
    ELSE.
      CHECK sp$00001.
*      CHECK sp$00002.
*      CHECK sp$00003.
      CHECK sp$00004.
*      CHECK sp$00005.
*      CHECK sp$00006.
      CHECK sp$00007.
      CALL FUNCTION &apos;RSAQRT_TEXTFIELD_REFRESH&apos;.
      dtab-pernr = pa0000-pernr .
      dtab-endda = pa0000-endda .
      dtab-begda = pa0000-begda .
      dtab-stat2 = pa0000-stat2 .
      dtab-massn = pa0000-massn .
      dtab-persg = pa0001-persg .
      dtab-persk = pa0001-persk .
      dtab-kostl = pa0001-kostl .
      dtab-orgeh = pa0001-orgeh .
      dtab-plans = pa0001-plans .

      DATA: wa_pa0041 TYPE pa0041.
      DATA: lv_month(2) TYPE n.
      DATA: lv_field TYPE string.
      DATA: lv_term TYPE sy-datum.

      FIELD-SYMBOLS: &lt;field&gt; TYPE any.


      SELECT SINGLE * FROM pa0041
        INTO wa_pa0041
        WHERE pernr = pa0000-pernr AND
              begda &lt;= sp$00008 AND
              endda &gt;= sp$00008.

      DO 12 TIMES.
        ADD 1 TO lv_month.
        CONCATENATE &apos;DAR&apos; lv_month INTO lv_field.
        ASSIGN COMPONENT lv_field OF STRUCTURE wa_pa0041 TO &lt;field&gt;.
        IF &lt;field&gt; = &apos;ZZ&apos;.
          CONCATENATE &apos;DAT&apos; lv_month INTO lv_field.
          ASSIGN COMPONENT lv_field OF STRUCTURE wa_pa0041 TO &lt;field&gt;.
          lv_term = &lt;field&gt;.
          EXIT.
        ENDIF.
      ENDDO.

      dtab-dat01 = lv_term.

      IF lv_term &gt; sy-datum OR lv_term IS INITIAL.
        APPEND dtab.
        l_hits_cnt = l_hits_cnt + 1.
      ENDIF.
      IF rtmode-pack_on = &apos;X&apos;
         AND l_hits_cnt &gt;= rtmode-pack_size.
        l_no_further_fetch = &apos;X&apos;.
      ENDIF.
    ENDIF.
  ENDWHILE.

  IF l_hits_cnt = 0.
    IF NOT dbcursor IS INITIAL.
      CLOSE CURSOR dbcursor.
    ENDIF.
    RAISE no_data.
  ENDIF.

  IF rtmode-pack_on &lt;&gt; &apos;X&apos;.
    CLOSE CURSOR dbcursor.
  ENDIF.
  READ TABLE dtab INDEX 1 TRANSPORTING NO FIELDS.
  IF sy-subrc NE 0.
    RAISE no_data.
  ENDIF.</fm_source_new>
   </functionmodule>
   <functionmodule NAME="Z_1BCDWB_IQ000000000003SSCR" STEXT="Module for generating selections">
    <changing PARAMETER="RTMODE" TYP="AQLIMODE"/>
    <tables PARAMETER="SELOPT" DBSTRUCT="RSPARAMS"/>
    <exceptions EXCEPTION="CANCELED"/>
    <documentation PARAMETER="SELOPT" KIND="P" INDEX=" 001"/>
    <documentation PARAMETER="RTMODE" KIND="P" INDEX=" 002"/>
    <documentation PARAMETER="CANCELED" KIND="X" INDEX=" 003"/>
    <fm_source>call function &apos;RSAQRT_SET_IDENTIFICATION&apos;
       exporting iqid        = iqid
                 sscr_report = sy-repid
       changing  rtmode      = rtmode.
  rtmode-sscr_fm    = &apos;X&apos;.
  rtmode-no_variant = &apos;X&apos;.
  runmode = rtmode.
  assign selopt[] to &lt;selopt&gt;.
  perform initialization.
  call function &apos;RSAQRT_FILL_SELECTIONS&apos;
       tables   selopt = selopt
       changing rtmode = rtmode.
  if rtmode-sscr_popup &lt;&gt; space.
    call selection-screen 2000
         starting at rtmode-sscr_col1 rtmode-sscr_row1.
  else.
    call selection-screen 2000.
  endif.
  if sy-subrc &lt;&gt; 0.
    raise canceled.
  endif.
  rtmode = runmode.</fm_source>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <FUGR SPRAS="E" AREA="ZBH2" AREAT="Britehouse Functions">
  <mainprogram NAME="SAPLZBH2" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="210" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <source>*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZBH2TOP.                          &quot; Global Data
  INCLUDE LZBH2UXX.                          &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZBH2F...                          &quot; Subroutines
* INCLUDE LZBH2O...                          &quot; PBO-Modules
* INCLUDE LZBH2I...                          &quot; PAI-Modules
* INCLUDE LZBH2E...                          &quot; Events
* INCLUDE LZBH2P...                          &quot; Local class implement.
* INCLUDE LZBH2T99.                          &quot; ABAP Unit tests</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZBH2TOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="210" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL ZBH2.                         &quot;MESSAGE-ID ..

* INCLUDE LZBH2D...                          &quot; Local class definition</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="ZHCM_UPDATE_0006_BATCH" REMOTE="R" STEXT="Batch Load">
    <importing PARAMETER="IT0006" OPTIONAL="X" TYP="P0006_TAB"/>
    <exporting PARAMETER="RETURN" TYP="ISI_BAPIRETURN1_TT"/>
    <documentation PARAMETER="IT0006" KIND="P" STEXT="HR Master Record: Infotype 0006 (Addresses)" INDEX=" 001"/>
    <documentation PARAMETER="RETURN" KIND="P" STEXT="Return Parameter" INDEX=" 002"/>
    <fm_source>DATA: wa_0006 LIKE LINE OF it0006.
  DATA: wa_return TYPE BAPIRETURN1.

  LOOP AT it0006 INTO wa_0006.
    CALL FUNCTION &apos;ZHCM_UPDATE_0006&apos;
      EXPORTING
        it0006 = wa_0006
    IMPORTING
        RETURN = wa_return.

    APPEND wa_return TO return.
  ENDLOOP.</fm_source>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <FUGR SPRAS="E" AREA="ZBH3" AREAT="Britehouse Functions">
  <mainprogram NAME="SAPLZBH3" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="210" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <source>*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZBH3TOP.                          &quot; Global Data
  INCLUDE LZBH3UXX.                          &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZBH3F...                          &quot; Subroutines
* INCLUDE LZBH3O...                          &quot; PBO-Modules
* INCLUDE LZBH3I...                          &quot; PAI-Modules
* INCLUDE LZBH3E...                          &quot; Events
* INCLUDE LZBH3P...                          &quot; Local class implement.
* INCLUDE LZBH3T99.                          &quot; ABAP Unit tests</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZBH3TOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="210" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL ZBH3.                         &quot;MESSAGE-ID ..

* INCLUDE LZBH3D...                          &quot; Local class definition</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="Z_GRC_BATCH_INFOTYPE_0105" REMOTE="R" STEXT="Batch Email">
    <importing PARAMETER="IP_INFOTYPE_0105" TYP="ZTINFOTYPE_0105"/>
    <documentation PARAMETER="IP_INFOTYPE_0105" KIND="P" STEXT="Batch Email Update" INDEX=" 001"/>
    <fm_source>DATA: wa_inftp TYPE zsinfotype_0105.

  LOOP AT ip_infotype_0105 INTO wa_inftp WHERE pernr IS NOT INITIAL.
    CALL FUNCTION &apos;ZGRC_UPDATE_INFOTYPE_0105&apos;
     EXPORTING
       IP_PERNR       = wa_inftp-pernr
       IP_EMAIL       = wa_inftp-email
       IP_UNAME       = wa_inftp-uname.
  ENDLOOP.</fm_source>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <FUGR SPRAS="E" AREA="ZBH4" AREAT="ALV Reporting">
  <mainprogram NAME="SAPLZBH4" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="210" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <source>*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZBH4TOP.                          &quot; Global Data
  INCLUDE LZBH4UXX.                          &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZBH4F...                          &quot; Subroutines
* INCLUDE LZBH4O...                          &quot; PBO-Modules
* INCLUDE LZBH4I...                          &quot; PAI-Modules
* INCLUDE LZBH4E...                          &quot; Events
* INCLUDE LZBH4P...                          &quot; Local class implement.
* INCLUDE LZBH4T99.                          &quot; ABAP Unit tests

  INCLUDE LZBH4001.</source>
  </mainprogram>
  <includeprograms>
   <include NAME="LZBH4001" VARCL="X" SUBC="I" APPL="S" RMAND="210" RLOAD="E" UCCHECK="X">
    <include_source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           LZBH4001
*&amp;---------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Module  D_0100_PBO  OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
module pbo output.
  perform pbo.
endmodule.

form pbo.

  set pf-status &apos;D0100&apos;.

  if gr_container is initial.
    if cl_salv_table=&gt;is_offline( ) eq if_salv_c_bool_sap=&gt;false.
      create object gr_container
        exporting
          container_name = &apos;CONTAINER&apos;.
    endif.

    set titlebar &apos;STANDARD&apos; with g_title.

    gr_content_manager-&gt;fill_container_content(
        r_container = gr_container ).
  endif.

endform.


module pai input.
  perform pai.
endmodule.


form pai.

  data: l_okcode like sy-ucomm.

  l_okcode = okcode.
  clear okcode.

  case l_okcode.
    when &apos;EXIT&apos; or &apos;CANC&apos; or &apos;BACK&apos;.
      call method gr_container-&gt;free.
      call method cl_gui_cfw=&gt;flush.

      clear gr_container.

      set screen 0.
      leave screen.
  endcase.

endform.</include_source>
   </include>
   <include NAME="LZBH4TOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="210" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL ZBH4.                         &quot;MESSAGE-ID ..

*function-pool salv_csqt_screen_manager.     &quot;MESSAGE-ID ..

data: okcode type sy-ucomm.
data: gr_content_manager type ref to if_salv_csqt_content_manager.
data: g_title type string.
data: gr_container type ref to cl_gui_custom_container.</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="Z_SALV_CSQT_CREATE_CONTAINER" STEXT="Creation of container">
    <importing PARAMETER="R_CONTENT_MANAGER" REFERENCE="X" TYP="REF TO IF_SALV_CSQT_CONTENT_MANAGER" REF_CLASS="X"/>
    <importing PARAMETER="TITLE" REFERENCE="X" TYP="STRING"/>
    <documentation PARAMETER="R_CONTENT_MANAGER" KIND="P" STEXT="Parameter display" INDEX=" 001"/>
    <documentation PARAMETER="TITLE" KIND="P" INDEX=" 002"/>
    <fm_source>DATA: okcode TYPE sy-ucomm.
  DATA: gr_content_manager TYPE REF TO if_salv_csqt_content_manager.
  DATA: g_title TYPE string.
  DATA: gr_container TYPE REF TO cl_gui_custom_container.

  gr_content_manager = r_content_manager.
  g_title = title.

  CALL SCREEN 100.</fm_source>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <FUGR SPRAS="E" AREA="ZBH5" AREAT="Payroll Functions">
  <mainprogram NAME="SAPLZBH5" VARCL="X" DBAPL="S" DBNA="D$" SUBC="F" APPL="S" RMAND="210" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
   <textPool/>
   <source>*******************************************************************
*   System-defined Include-files.                                 *
*******************************************************************
  INCLUDE LZBH5TOP.                          &quot; Global Data
  INCLUDE LZBH5UXX.                          &quot; Function Modules

*******************************************************************
*   User-defined Include-files (if necessary).                    *
*******************************************************************
* INCLUDE LZBH5F...                          &quot; Subroutines
* INCLUDE LZBH5O...                          &quot; PBO-Modules
* INCLUDE LZBH5I...                          &quot; PAI-Modules
* INCLUDE LZBH5E...                          &quot; Events
* INCLUDE LZBH5P...                          &quot; Local class implement.
* INCLUDE LZBH5T99.                          &quot; ABAP Unit tests</source>
  </mainprogram>
  <includeprograms>
   <include NAME="H99PAYDATA" VARCL="X" SUBC="I" APPL="P" RMAND="000" RLOAD="D">
    <include_source>********************************************************************
* H99PAYDATA Data definitions for payroll cluster RX Other Countries
********************************************************************
* THIS INCLUDE WAS GENERATED
* BY REPORT:___H99UMACROGENERATOR
* USER:________SCHLINKT
* ON:__________01.04.2008
* DO NOT CHANGE MANUALLY!!!!!!!!!!!!!!!!!!
********************************************************************
*Statusinformationen der Abrechnung
DATA: BEGIN OF VERSC .
INCLUDE STRUCTURE PC202 .
DATA: END OF VERSC .
*-------------
*Kumulation Abwesenheitsklassen
DATA: BEGIN OF ABC OCCURS 0.
INCLUDE STRUCTURE PC206 .
DATA: END OF ABC .
*-------------
*Abrechnungsergebnis: Ergebnistabelle
DATA: BEGIN OF RT OCCURS 0.
INCLUDE STRUCTURE PC207 .
DATA: END OF RT .
*-------------
*Abrechnungsergebnis: kumulierte Ergebnistabelle
DATA: BEGIN OF CRT OCCURS 0.
INCLUDE STRUCTURE PC208 .
DATA: END OF CRT .
*-------------
*Kostenverteilung
DATA: BEGIN OF C0 OCCURS 0.
INCLUDE STRUCTURE PC20A .
DATA: END OF C0 .
*-------------
*Variable Zuordnung
DATA: BEGIN OF V0 OCCURS 0.
INCLUDE STRUCTURE PC20C .
DATA: END OF V0 .
*-------------
*Abrechnungsergebnis: Urlaubsabtragung
DATA: BEGIN OF VCP OCCURS 0.
INCLUDE STRUCTURE PC20D .
DATA: END OF VCP .
*-------------
*Abrechnungsergebnis: Differenzen für Brutto/Netto
DATA: BEGIN OF DFT OCCURS 0.
INCLUDE STRUCTURE PC20F .
DATA: END OF DFT .
*-------------
*Abrechnungsergebnis: Ergebnistabelle
DATA: BEGIN OF GRT OCCURS 0.
INCLUDE STRUCTURE PC207 .
DATA: END OF GRT .
*-------------
*Abrechnungsergebnis: Folgelohnscheine
DATA: BEGIN OF LS OCCURS 0.
INCLUDE STRUCTURE PC20G .
DATA: END OF LS .
*-------------
*Statuskennzeichen
DATA: BEGIN OF STATUS .
INCLUDE STRUCTURE PC20J .
DATA: END OF STATUS .
*-------------
*Abrechnungsergebnis: Tabelle Arrears
DATA: BEGIN OF ARRRS OCCURS 0.
INCLUDE STRUCTURE PC22Z .
DATA: END OF ARRRS .
*-------------
*Abrechnungsergebnis: Nicht getätigte Abzüge (Deductions)
DATA: BEGIN OF DDNTK OCCURS 0.
INCLUDE STRUCTURE PC23E .
DATA: END OF DDNTK .
*-------------
*Abrechnungsergebnis: Month End Accruals
DATA: BEGIN OF ACCR OCCURS 0.
INCLUDE STRUCTURE PC23G .
DATA: END OF ACCR .
*-------------
*Benefits Abrechnungsergebnis International
DATA: BEGIN OF BENTAB OCCURS 0.
INCLUDE STRUCTURE PC27S .
DATA: END OF BENTAB .
*-------------
*Abrechnungsstruktur Fundsmanagement
DATA: BEGIN OF FUND OCCURS 0.
INCLUDE STRUCTURE PC2FUND .
DATA: END OF FUND .
*-------------
*Eingefrorene Durchschnittswerte im Abrechnungsergebnis
DATA: BEGIN OF AVERAGE OCCURS 0.
INCLUDE STRUCTURE PC2AVERA .
DATA: END OF AVERAGE .
*-------------
*HR-PAY: Modifikatoren
DATA: BEGIN OF MODIF OCCURS 0.
INCLUDE STRUCTURE PC214 .
DATA: END OF MODIF .
*-------------
*Verteilung von Verbindlichkeiten
DATA: BEGIN OF CODIST OCCURS 0.
INCLUDE STRUCTURE PC2CODIST .
DATA: END OF CODIST .
*-------------
*Abfluss/Zufluss in eine bzw. aus einer Abrechnungsperiode
DATA: BEGIN OF LIFL OCCURS 0.
INCLUDE STRUCTURE PC2LIFL .
DATA: END OF LIFL .
*-------------
*Kostenverteilte Verbindlichkeiten
DATA: BEGIN OF LIDI OCCURS 0.
INCLUDE STRUCTURE PC2LIDI .
DATA: END OF LIDI .
*-------------</include_source>
   </include>
   <include NAME="HZAPAYDATA" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="P" RMAND="000" FIXPT="X" LDBNAME="D$S">
    <include_source>********************************************************************
* HZAPAYDATA Data definitions for payroll cluster RW South Africa
********************************************************************
* THIS INCLUDE WAS GENERATED
* BY REPORT:___H99UMACROGENERATOR
* USER:________BOEHLERA
* ON:__________20.04.2009
* DO NOT CHANGE MANUALLY!!!!!!!!!!!!!!!!!!
********************************************************************
*Payroll Result: SI Data for South Africa
DATA: BEGIN OF SV OCCURS 0.
INCLUDE STRUCTURE PC235 .
DATA: END OF SV .
*-------------
*Payroll Result: Tax Data for South Africa.
DATA: BEGIN OF ST OCCURS 0.
INCLUDE STRUCTURE PC236 .
DATA: END OF ST .
*-------------
*Payroll Result: Cumulated Tax Data for South Africa.
DATA: BEGIN OF CST OCCURS 0.
INCLUDE STRUCTURE PC237 .
DATA: END OF CST .
*-------------
*Payroll Result: Cumulated Tax Results for South Africa
DATA: BEGIN OF SCRT OCCURS 0.
INCLUDE STRUCTURE PC238 .
DATA: END OF SCRT .
*-------------
*Payroll Result: Cumulated Directives (South Africa)
DATA: BEGIN OF CDT OCCURS 0.
INCLUDE STRUCTURE PC238_D .
DATA: END OF CDT .
*-------------
*Payroll Result: Cumulated SI Data for South Africa
DATA: BEGIN OF CSV OCCURS 0.
INCLUDE STRUCTURE PC235_C .
DATA: END OF CSV .
*-------------
*Payroll Result: Bursaries
DATA: BEGIN OF BRS OCCURS 0.
INCLUDE STRUCTURE PC2BU .
DATA: END OF BRS .
*-------------
*Payroll Result: Bursaries
DATA: BEGIN OF CBRS OCCURS 0.
INCLUDE STRUCTURE PC2BU .
DATA: END OF CBRS .
*-------------
DATA: cumul_tab_filter TYPE PAYZA_RESULT .
DATA: cumul_tab_all TYPE PAYZA_RESULT .
DATA: payresult_addcu TYPE PAYZA_RESULT .</include_source>
   </include>
   <include NAME="HZAPAYMACRO" VARCL="X" SUBC="I" APPL="P" LEVL="46A" RLOAD="D">
    <include_source>********************************************************************
* HZAPAYMACRO Macro definitions for payroll cluster RW South Africa
********************************************************************
* THIS INCLUDE WAS GENERATED
* BY REPORT:___H99UMACROGENERATOR
* USER:________BOEHLERA
* ON:__________20.04.2009
* DO NOT CHANGE MANUALLY!!!!!!!!!!!!!!!!!!
********************************************************************
 &quot;**********************************************************************
 &quot; import definition for cluster RW South Africa
 &quot;**********************************************************************
 define RP-IMP-C2-RW.
   clear:
     ORW-VERSION,                                                    &quot;OBJECTS_FOR_CLEAR
     VERSC,
     WPBP, WPBP[],
     ABC, ABC[],
     RT, RT[],
     CRT, CRT[],
     BT, BT[],
     C0, C0[],
     C1, C1[],
     V0, V0[],
     VCP, VCP[],
     ALP, ALP[],
     DFT, DFT[],
     GRT, GRT[],
     LS, LS[],
     STATUS,
     ARRRS, ARRRS[],
     DDNTK, DDNTK[],
     ACCR, ACCR[],
     BENTAB, BENTAB[],
     AB, AB[],
     FUND, FUND[],
     AVERAGE, AVERAGE[],
     MODIF, MODIF[],
     CODIST, CODIST[],
     LIFL, LIFL[],
     LIDI, LIDI[],
     SV, SV[],
     ST, ST[],
     CST, CST[],
     SCRT, SCRT[],
     CDT, CDT[],
     CSV, CSV[],
     BRS, BRS[],
     CBRS, CBRS[].
   import
     RW-VERSION TO ORW-VERSION                                       &quot;OBJECTS_FOR_IMPORT
     VERSC
     WPBP
     ABC
     RT
     CRT
     BT
     C0
     C1
     V0
     VCP
     ALP
     DFT
     GRT
     LS
     STATUS
     ARRRS
     DDNTK
     ACCR
     BENTAB
     AB
     FUND
     AVERAGE
     MODIF
     CODIST
     LIFL
     LIDI
     SV
     ST
     CST
     SCRT
     CDT
     CSV
     BRS
     CBRS
   from database PCL2(RW) id rx-key using pcl2_exp_imp
   IGNORING STRUCTURE BOUNDARIES.
   rp-imp-RW-subrc = sy-subrc.
   RW-VERSION-number = &apos;02&apos;.
   if sy-subrc eq 0 and
      ORW-VERSION-number ne RW-VERSION-number.
      rp-imp-RW-subrc = 8.
   endif.
 &quot; move regno (NUMC) to new regnc (CHAR)                             &quot;RW_REGNO_CONV
   if sy-subrc eq 0.                                                 &quot;RW_REGNO_CONV
     loop at st.                                                     &quot;RW_REGNO_CONV
       check st-regnc is initial and                                 &quot;RW_REGNO_CONV
         not st-regno is initial.                                    &quot;RW_REGNO_CONV
       move st-regno to st-regnc.                                    &quot;RW_REGNO_CONV
       modify st.                                                    &quot;RW_REGNO_CONV
     endloop.                                                        &quot;RW_REGNO_CONV
     loop at cst.                                                    &quot;RW_REGNO_CONV
       check cst-regnc is initial and                                &quot;RW_REGNO_CONV
         not cst-regno is initial.                                   &quot;RW_REGNO_CONV
       move cst-regno to cst-regnc.                                  &quot;RW_REGNO_CONV
       modify cst.                                                   &quot;RW_REGNO_CONV
     endloop.                                                        &quot;RW_REGNO_CONV
   endif.                                                            &quot;RW_REGNO_CONV
 &quot;-----------------------------------------------                    &quot;RW_REGNO_CONV
 &quot; move MAPAC (length 5) to new MAPAN (length 8)                     &quot;RW_REGNO_CONV
   if sy-subrc eq 0.                                                 &quot;RW_REGNO_CONV
     loop at sv.                                                     &quot;RW_REGNO_CONV
       check sv-mapan is initial and                                 &quot;RW_REGNO_CONV
         not sv-mapac is initial.                                    &quot;RW_REGNO_CONV
       move sv-mapac to sv-mapan.                                    &quot;RW_REGNO_CONV
       modify sv.                                                    &quot;RW_REGNO_CONV
     endloop.                                                        &quot;RW_REGNO_CONV
   endif.                                                            &quot;RW_REGNO_CONV
 &quot;-----------------------------------------------                    &quot;RW_REGNO_CONV

 end-of-definition.

 &quot;**********************************************************************
 &quot; export definition for cluster RW South Africa
 &quot;**********************************************************************
 define RP-EXP-C2-RW.

 &quot; move regno (NUMC) to new regnc (CHAR)                             &quot;RW_REGNO_CONV
     loop at st.                                                     &quot;RW_REGNO_CONV
       check st-regnc is initial and                                 &quot;RW_REGNO_CONV
         not st-regno is initial.                                    &quot;RW_REGNO_CONV
       move st-regno to st-regnc.                                    &quot;RW_REGNO_CONV
       modify st.                                                    &quot;RW_REGNO_CONV
     endloop.                                                        &quot;RW_REGNO_CONV
     loop at cst.                                                    &quot;RW_REGNO_CONV
       check cst-regnc is initial and                                &quot;RW_REGNO_CONV
         not cst-regno is initial.                                   &quot;RW_REGNO_CONV
       move cst-regno to cst-regnc.                                  &quot;RW_REGNO_CONV
       modify cst.                                                   &quot;RW_REGNO_CONV
     endloop.                                                        &quot;RW_REGNO_CONV
 &quot;-----------------------------------------------                    &quot;RW_REGNO_CONV
   RW-VERSION-number = &apos;02&apos;.
   pcl2-versn = &apos;02&apos;.
   export
     RW-VERSION                                                      &quot;OBJECTS_FOR_EXPORT
     VERSC
     WPBP
     ABC
     RT
     CRT
     BT
     C0
     C1
     V0
     VCP
     ALP
     DFT
     GRT
     LS
     STATUS
     ARRRS
     DDNTK
     ACCR
     BENTAB
     AB
     FUND
     AVERAGE
     MODIF
     CODIST
     LIFL
     LIDI
     SV
     ST
     CST
     SCRT
     CDT
     CSV
     BRS
     CBRS
   to database PCL2(RW) id rx-key using pcl2_exp_imp.
   rp-imp-RW-subrc = sy-subrc.
 end-of-definition.

 &quot;**********************************************************************
 &quot; import definition -&apos;O&apos; tables- for cluster RW South Africa
 &quot;**********************************************************************
 define RP-IMP-C2-RW-O.
   clear:
     ORW-VERSION,                                                    &quot;OBJECTS_FOR_CLEAR_O
     OVERSC,
     OWPBP, OWPBP[],
     OABC, OABC[],
     ORT, ORT[],
     OCRT, OCRT[],
     OBT, OBT[],
     OC0, OC0[],
     OC1, OC1[],
     OV0, OV0[],
     OVCP, OVCP[],
     OALP, OALP[],
     ODFT, ODFT[],
     OGRT, OGRT[],
     OLS, OLS[],
     OSTATUS,
     OARRRS, OARRRS[],
     ODDNTK, ODDNTK[],
     OACCR, OACCR[],
     OBENTAB, OBENTAB[],
     OAB, OAB[],
     OFUND, OFUND[],
     OAVERAGE, OAVERAGE[],
     OMODIF, OMODIF[],
     OCODIST, OCODIST[],
     OLIFL, OLIFL[],
     OLIDI, OLIDI[],
     OSV, OSV[],
     OST, OST[],
     OCST, OCST[],
     OSCRT, OSCRT[],
     OCDT, OCDT[],
     OCSV, OCSV[],
     OBRS, OBRS[],
     OCBRS, OCBRS[].
   import
     RW-VERSION TO ORW-VERSION                                       &quot;OBJECTS_FOR_IMPORT_O
     VERSC TO OVERSC
     WPBP TO OWPBP
     ABC TO OABC
     RT TO ORT
     CRT TO OCRT
     BT TO OBT
     C0 TO OC0
     C1 TO OC1
     V0 TO OV0
     VCP TO OVCP
     ALP TO OALP
     DFT TO ODFT
     GRT TO OGRT
     LS TO OLS
     STATUS TO OSTATUS
     ARRRS TO OARRRS
     DDNTK TO ODDNTK
     ACCR TO OACCR
     BENTAB TO OBENTAB
     AB TO OAB
     FUND TO OFUND
     AVERAGE TO OAVERAGE
     MODIF TO OMODIF
     CODIST TO OCODIST
     LIFL TO OLIFL
     LIDI TO OLIDI
     SV TO OSV
     ST TO OST
     CST TO OCST
     SCRT TO OSCRT
     CDT TO OCDT
     CSV TO OCSV
     BRS TO OBRS
     CBRS TO OCBRS
   from database PCL2(RW) id orx-key using pcl2_exp_imp
   IGNORING STRUCTURE BOUNDARIES.
   rp-imp-RW-subrc = sy-subrc.
   RW-VERSION-number = &apos;02&apos;.
   if sy-subrc eq 0 and
      ORW-VERSION-number ne RW-VERSION-number.
      rp-imp-RW-subrc = 8.
   endif.
 &quot; move regno (NUMC) to new regnc (CHAR)                             &quot;RW_REGNO_CONV
   if sy-subrc eq 0.                                                 &quot;RW_REGNO_CONV
     loop at ost.                                                    &quot;RW_REGNO_CONV
       check ost-regnc is initial and                                &quot;RW_REGNO_CONV
         not ost-regno is initial.                                   &quot;RW_REGNO_CONV
       move ost-regno to ost-regnc.                                  &quot;RW_REGNO_CONV
       modify ost.                                                   &quot;RW_REGNO_CONV
     endloop.                                                        &quot;RW_REGNO_CONV
     loop at ocst.                                                   &quot;RW_REGNO_CONV
       check ocst-regnc is initial and                               &quot;RW_REGNO_CONV
         not ocst-regno is initial.                                  &quot;RW_REGNO_CONV
       move ocst-regno to ocst-regnc.                                &quot;RW_REGNO_CONV
       modify ocst.                                                  &quot;RW_REGNO_CONV
     endloop.                                                        &quot;RW_REGNO_CONV
   endif.                                                            &quot;RW_REGNO_CONV
 &quot;-----------------------------------------------                    &quot;RW_REGNO_CONV
 &quot; move MAPAC (length 5) to new MAPAN (length 8)                     &quot;RW_REGNO_CONV
   if sy-subrc eq 0.                                                 &quot;RW_REGNO_CONV
     loop at osv.                                                    &quot;RW_REGNO_CONV
       check osv-mapan is initial and                                &quot;RW_REGNO_CONV
         not osv-mapac is initial.                                   &quot;RW_REGNO_CONV
       move osv-mapac to osv-mapan.                                  &quot;RW_REGNO_CONV
       modify osv.                                                   &quot;RW_REGNO_CONV
     endloop.                                                        &quot;RW_REGNO_CONV
   endif.                                                            &quot;RW_REGNO_CONV
 &quot;-----------------------------------------------                    &quot;RW_REGNO_CONV

 end-of-definition.

 &quot;**********************************************************************
 &quot; refresh definition for cluster RW South Africa
 &quot;**********************************************************************
 define RP-REF-C2-RW.
   clear:
     RX-KEY,
     ORW-VERSION,                                                    &quot;OBJECTS_FOR_CLEAR
     VERSC,
     WPBP, WPBP[],
     ABC, ABC[],
     RT, RT[],
     CRT, CRT[],
     BT, BT[],
     C0, C0[],
     C1, C1[],
     V0, V0[],
     VCP, VCP[],
     ALP, ALP[],
     DFT, DFT[],
     GRT, GRT[],
     LS, LS[],
     STATUS,
     ARRRS, ARRRS[],
     DDNTK, DDNTK[],
     ACCR, ACCR[],
     BENTAB, BENTAB[],
     AB, AB[],
     FUND, FUND[],
     AVERAGE, AVERAGE[],
     MODIF, MODIF[],
     CODIST, CODIST[],
     LIFL, LIFL[],
     LIDI, LIDI[],
     SV, SV[],
     ST, ST[],
     CST, CST[],
     SCRT, SCRT[],
     CDT, CDT[],
     CSV, CSV[],
     BRS, BRS[],
     CBRS, CBRS[].
 end-of-definition.

 &quot;**********************************************************************
 &quot; refresh definition-&apos;O&apos; tables-for cluster RW South Africa
 &quot;**********************************************************************
 define RP-REF-C2-RW-O.
   clear:
     ORX-KEY,
     ORW-VERSION,                                                    &quot;OBJECTS_FOR_CLEAR_O
     OVERSC,
     OWPBP, OWPBP[],
     OABC, OABC[],
     ORT, ORT[],
     OCRT, OCRT[],
     OBT, OBT[],
     OC0, OC0[],
     OC1, OC1[],
     OV0, OV0[],
     OVCP, OVCP[],
     OALP, OALP[],
     ODFT, ODFT[],
     OGRT, OGRT[],
     OLS, OLS[],
     OSTATUS,
     OARRRS, OARRRS[],
     ODDNTK, ODDNTK[],
     OACCR, OACCR[],
     OBENTAB, OBENTAB[],
     OAB, OAB[],
     OFUND, OFUND[],
     OAVERAGE, OAVERAGE[],
     OMODIF, OMODIF[],
     OCODIST, OCODIST[],
     OLIFL, OLIFL[],
     OLIDI, OLIDI[],
     OSV, OSV[],
     OST, OST[],
     OCST, OCST[],
     OSCRT, OSCRT[],
     OCDT, OCDT[],
     OCSV, OCSV[],
     OBRS, OBRS[],
     OCBRS, OCBRS[].
 end-of-definition.</include_source>
   </include>
   <include NAME="LZBH5TOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="210" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL zbh5.                         &quot;MESSAGE-ID ..

TABLES: pernr, pcl1, pcl2, pc260.
INCLUDE:
  rpc2rx09,       &quot;Cluster RP data definition internat. part
  rpc2cd09,       &quot;Cluster CD data definition
  rpppxd00,       &quot;Data definition buffer PCL1/PCL2
  rpppxd10,       &quot;Common part buffer PCL1/PCL2
  rpppxm00.       &quot;Buffer handling routine
INCLUDE hzapaymacro .
*-- Country Specific Include
INCLUDE:
   rpcxrww0,       &quot;Cluster RQ data definition
   rpc2rww0.
* INCLUDE LZBH5D...                          &quot; Local class definition</include_source>
   </include>
   <include NAME="LZBH5TOP" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="S" RMAND="210" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
    <include_source>FUNCTION-POOL zbh5.                         &quot;MESSAGE-ID ..

TABLES: pernr, pcl1, pcl2, pc260.
INCLUDE:
  rpc2rx09,       &quot;Cluster RP data definition internat. part
  rpc2cd09,       &quot;Cluster CD data definition
  rpppxd00,       &quot;Data definition buffer PCL1/PCL2
  rpppxd10,       &quot;Common part buffer PCL1/PCL2
  rpppxm00.       &quot;Buffer handling routine
INCLUDE hzapaymacro .
*-- Country Specific Include
INCLUDE:
   rpcxrww0,       &quot;Cluster RQ data definition
   rpc2rww0.
* INCLUDE LZBH5D...                          &quot; Local class definition</include_source>
   </include>
   <include NAME="RPC2AR00" VARCL="X" SUBC="I" APPL="P" LEVL="30F" RSTAT="P" RMAND="000" RLOAD="D">
    <include_source>* 4.6C
* QNZAHRK052268 14071999 ARRRS, DDNTK moved to H99PAYDATA
* 3.1H
* XAIP30K129058 03021997 PRIO, UIT, URT, AOA, AV0 now here (RPCFDCX4)
* 3.0F
* XAIP30K100477 24.09.96 new
*---------------------------------------------------------------------*
* Data definitions Arrears, Cluster Rx database PCL2 Payroll results  *
*---------------------------------------------------------------------*

* Arrears Table
*ATA: BEGIN OF ARRRS OCCURS 20.                         &quot;QNZAHRK052268
*        INCLUDE STRUCTURE PC22Z.                             &quot;!
*ATA: END OF ARRRS.                                           &quot;!
*                                                             &quot;!
* Deductions not taken                                        &quot;!
*ATA: BEGIN OF DDNTK OCCURS 20.                               &quot;!
*        INCLUDE STRUCTURE PC23E.                             &quot;!
*ATA: END OF DDNTK.                                     &quot;QNZAHRK052268


* table of deductions for priority processing
DATA: BEGIN OF PRIO OCCURS 20.                            &quot;XAIP30K129058
        INCLUDE STRUCTURE RT.      &quot;whole info. of RT, espec. all splits
* value of priority for wage type
DATA:   PRIOR LIKE T51P6-PRIO,     &quot;value of priority for wage type
        SUBPR,                     &quot;value of sub priority, for garnishm.
        PERNR TYPE PERNR_D,        &quot;personnel assignment         &quot;XFG CE
        MIN_NET LIKE PC207-BETRG,  &quot;minimum net for that deduction
        ARIND LIKE T51P6-ARRS,     &quot;indicator how to process for arrears
      END OF PRIO.                                        &quot;XAIP30K129058

* necessary for initialization in iteration
 DATA: BEGIN OF UIT OCCURS 20.                            &quot;XAIP30K129058
         INCLUDE STRUCTURE PC207.                         &quot;
 DATA: END OF UIT.                                        &quot;XAIP30K129058

 DATA: BEGIN OF URT OCCURS 20.                            &quot;XAIP30K129058
         INCLUDE STRUCTURE PC207.                            &quot;
 DATA: END OF URT.                                        &quot;XAIP30K129058

 DATA: BEGIN OF AOA OCCURS 20.                            &quot;XAIP30K129058
         INCLUDE STRUCTURE PC22Z.                         &quot;
 DATA: END OF AOA.                                        &quot;XAIP30K129058

 DATA: BEGIN OF AV0 OCCURS 20.                            &quot;XAIP30K129058
         INCLUDE STRUCTURE PC20C.                         &quot;
 DATA: END OF AV0.                                        &quot;XAIP30K129058

 DATA: BEGIN OF ABENTAB OCCURS 20.
         INCLUDE STRUCTURE PC27S.
 DATA: END OF ABENTAB.</include_source>
   </include>
   <include NAME="RPC2CD09" VARCL="X" CLAS="PC00" SUBC="I" APPL="P" LEVL="30A" RSTAT="P" RMAND="000" RLOAD="D">
    <include_source>*---------------------------------------------------------------------*
* Name: RPC2CD09.                                                     *
*       Cluster Directory data definition                             *
*                                                                     *
*    Country-developers are not!!! allowed to change anything in this *
*    include!!!!!!!!!!                                                *
*---------------------------------------------------------------------*
* 4.6A
* XTWPH9K000955 22.04.1999 new structure for cd-version
* 4.0C
* XDOAHRK000000 26.01.1998 definition of cd-table included
* XDOAHRK000408 18.12.1997 Table dir2 in rp-imp and rp-exp included
* 3.0A                                                                *
* YUIK114295 950101 new definition for cluster CD (CU temporarily)    *
*    Key to Cluster directory                                         *
*---------------------------------------------------------------------*
DATA: BEGIN OF CD-KEY,
        PERNR LIKE P0001-PERNR,             &quot;key to cluster directory
      END OF CD-KEY.
*---------------------------------------------------------------------*
*    Input and Output fields used by Cluster Directory Manager        *
*---------------------------------------------------------------------*
DATA:
  BEGIN OF CD-VERSION.
*   INCLUDE STRUCTURE PC201.                             &quot;XTWPH9K000955
    include structure pc2_cd.                            &quot;XTWPH9K000955
*ATA:                                                    &quot;XTWPH9K000955
*   MOLGA  LIKE T001P-MOLGA,                             &quot;XTWPH9K000955
* END OF CD-VERSION.                                     &quot;XTWPH9K000955
data: end of cd-version.                                 &quot;XTWPH9K000955
*---- Cluster directory fields                                    ----*
DATA:
  CD-NEXT_SEQ    TYPE I,               &quot;Next available seq number
  CD-LAST_PAY    TYPE D,               &quot;Last payroll run date
  CD-TYPE.                             &quot;Cluster type identifier

*---- Table data containing directory to PCL2 payroll results file----*
DATA: BEGIN OF RGDIR OCCURS 100.
        INCLUDE STRUCTURE PC261.
DATA: END OF RGDIR.
*---- Table data containing directory to PCL2 alternate pay data file *
DATA: BEGIN OF DIR2 OCCURS 100.                          &quot;XDOAHRK000408
*       include structure pc260.                                     &quot;!
        INCLUDE STRUCTURE PC261.                                     &quot;!
DATA:   TYPE(4).                &quot;clust.direct.type                   &quot;!
DATA: END OF DIR2.                                       &quot;XDOAHRK000408

DATA: BEGIN OF %%_DIR2 OCCURS 100.                       &quot;XDOAHRK000000
*        include structure pc260.                        &quot;XDOAHRK000555
        INCLUDE STRUCTURE PC260_OLD.                     &quot;XDOAHRK000555
DATA:   TYPE(4).                &quot;clust.direct.type                   &quot;!
DATA: END OF %%_DIR2.                                    &quot;XDOAHRK000000

DATA: BEGIN OF CD_TABLE OCCURS 100.                      &quot;XDOAHRK000000
*       include structure pc260.                                     &quot;!
        INCLUDE STRUCTURE PC261.                                     &quot;!
DATA:   TYPE(4).                     &quot;clust.direct.type              &quot;!
DATA: END OF CD_TABLE.                                   &quot;XDOAHRK000000

*---- Output data from directory manager                          ----*
DATA:
  BEGIN OF OCD-VERSION.
*   INCLUDE STRUCTURE PC201.                             &quot;XTWPH9K000955
    INCLUDE STRUCTURE PC2_CD.
*ATA:                                                    &quot;XTWPH9K000955
*   MOLGA  LIKE T001P-MOLGA,                             &quot;XTWPH9K000955
* END OF OCD-VERSION.                                    &quot;XTWPH9K000955
data: end of ocd-version.                                &quot;XTWPH9K000955

DATA: BEGIN OF ORGDIR OCCURS 100.
        INCLUDE STRUCTURE PC261.
DATA:   TYPE(4).                 &quot;clust.direct.type      &quot;XDOAHRK000000
DATA: END OF ORGDIR.

DATA: RP-IMP-CD-SUBRC LIKE SY-SUBRC.        &quot;return code from import
DATA: CD-SUBRC LIKE SY-SUBRC.               &quot;return code from manager
DATA: CD-INDEX LIKE SY-INDEX.               &quot;index of current RGDIR line

INCLUDE RPCCCD09.                      &quot;constants for CD
INCLUDE RPCVCD09.                                         &quot;YUIK114295
CONSTANTS VERSION_NUMBER_CU LIKE PCL2-VERSN VALUE &apos;99&apos;.   &quot;XTWALRK008043
* due to incompatible type changes (sysaprl -&gt; saprelease)
DATA: g_dummy_for_saprl_cu TYPE saprelease.
************************************************************************
* Import macro for payroll directory   (new with YKMALRK008041)
* In case of chages here, you have to change RP-IMP-C2-CU-NOBUFF also
************************************************************************
DEFINE RP-IMP-C2-CU.
  IMPORT CD-VERSION TO OCD-VERSION
         CD-NEXT_SEQ
         CD-LAST_PAY
         RGDIR
         DIR2 TO %%_DIR2                                 &quot;XDOAHRK000000
*         dir2                                            &quot;XDOAHRK000408
  FROM DATABASE PCL2(CU)
  ID CD-KEY USING PCL2_EXP_IMP.
  CD-VERSION-NUMBER = VERSION_NUMBER_CU.                  &quot;XTWALRK049198
  RP-IMP-CD-SUBRC = SY-SUBRC.
  IF SY-SUBRC NE 0.
    CLEAR: CD-NEXT_SEQ,
           RGDIR,
           DIR2.                                         &quot;XDOAHRK000408
    REFRESH: RGDIR, DIR2.                                &quot;XDOAHRK000408
    CLEAR: %%_DIR2. REFRESH %%_DIR2.                     &quot;XDOAHRK000000
  ELSE.
    %%_CONVERT_IMPORT_DIR2.                              &quot;XDOAHRK000000
  ENDIF.
END-OF-DEFINITION.

************************************************************************
* Import macro for payroll directory   (new with XULALRK041164)
* Macro only !!!!!!!!! for archiving
************************************************************************
DEFINE RP-IMP-C2-CU-NOBUFF.

  IMPORT CD-VERSION TO OCD-VERSION
         CD-NEXT_SEQ
         CD-LAST_PAY
         RGDIR
         DIR2 TO %%_DIR2                                 &quot;XDOAHRK000000
*         dir2                                            &quot;XDOAHRK000408
  FROM DATABASE PCL2(CU)
  ID CD-KEY. &quot;using pcl2_exp_imp.    &quot;XULALRK041164
  RP-IMP-CD-SUBRC = SY-SUBRC.
  IF SY-SUBRC NE 0.
    CLEAR: CD-NEXT_SEQ,
           RGDIR,
           DIR2.                                         &quot;XDOAHRK000408
    REFRESH: RGDIR, DIR2.                                &quot;XDOAHRK000408
    CLEAR: %%_DIR2. REFRESH %%_DIR2.                     &quot;XDOAHRK000000
  ELSE.
    %%_CONVERT_IMPORT_DIR2.                              &quot;XDOAHRK000000
  ENDIF.
END-OF-DEFINITION.
************************************************************************
* Export macro for payroll directory   (new with YKMALRK008041)
* In case of chages here, you have to change RP-EXP-C2_CU-NOBUFF also
************************************************************************
DEFINE RP-EXP-C2-CU.
  CD-VERSION-NUMBER = VERSION_NUMBER_CU.                  &quot;XTWALRK008043
  PCL2-VERSN = VERSION_NUMBER_CU.                         &quot;XTWALRK008043
  CALL FUNCTION &apos;STRUCPACK_RELEASE_GET&apos;
    EXPORTING
      i_name_extension              = &apos;SAP_HR&apos;
    IMPORTING
      e_release                     = g_dummy_for_saprl_cu
    EXCEPTIONS
      OTHERS                        = 0.
  cd-version-saprl = g_dummy_for_saprl_cu(4).
  MOVE: SY-UNAME    TO CD-VERSION-UNAME,
        SY-DATUM    TO CD-VERSION-DATUM,
        SY-UZEIT    TO CD-VERSION-UZEIT,
        SY-REPID    TO CD-VERSION-PGMID,
        VERSC-MOLGA TO CD-VERSION-MOLGA.
  %%_CONVERT_EXPORT_DIR2.                                &quot;XDOAHRK000000
  EXPORT CD-VERSION
         CD-NEXT_SEQ
         CD-LAST_PAY
         RGDIR
         DIR2 FROM %%_DIR2                               &quot;XDOAHRK000000
*         dir2                                            &quot;XDOAHRK000408
  TO DATABASE PCL2(CU)
  ID CD-KEY USING PCL2_EXP_IMP.
  IF SY-SUBRC NE 0.
    CLEAR: CD-NEXT_SEQ,
           RGDIR,
           DIR2.                                         &quot;XDOAHRK000408
    REFRESH: RGDIR, DIR2.                                &quot;XDOAHRK000408
    CLEAR: %%_DIR2. REFRESH %%_DIR2.                     &quot;XDOAHRK000000
  ENDIF.
END-OF-DEFINITION.
************************************************************************
* Export macro for payroll directory   (new with XULALRK041164)
* Macro only !!!!!!!!! for archiving
************************************************************************
DEFINE RP-EXP-C2-CU-NOBUFF.
  CD-VERSION-NUMBER = VERSION_NUMBER_CU.                  &quot;XTWALRK008043
  PCL2-VERSN = VERSION_NUMBER_CU.                         &quot;XTWALRK008043
  CALL FUNCTION &apos;STRUCPACK_RELEASE_GET&apos;
    EXPORTING
      i_name_extension              = &apos;SAP_HR&apos;
    IMPORTING
      e_release                     = g_dummy_for_saprl_cu
    EXCEPTIONS
      OTHERS                        = 0.
  cd-version-saprl = g_dummy_for_saprl_cu(4).
  MOVE: SY-UNAME    TO CD-VERSION-UNAME,
        SY-DATUM    TO CD-VERSION-DATUM,
        SY-UZEIT    TO CD-VERSION-UZEIT,
        SY-REPID    TO CD-VERSION-PGMID,
        VERSC-MOLGA TO CD-VERSION-MOLGA.
  %%_CONVERT_EXPORT_DIR2.                                &quot;XDOAHRK000000
  EXPORT CD-VERSION
         CD-NEXT_SEQ
         CD-LAST_PAY
         RGDIR
         DIR2 FROM %%_DIR2                               &quot;XDOAHRK000000
*         dir2                                            &quot;XDOAHRK000408
  TO DATABASE PCL2(CU)
  ID CD-KEY. &quot;using pcl2_exp_imp.        &quot;XULALRK041164
  IF SY-SUBRC NE 0.
    CLEAR: CD-NEXT_SEQ,
           RGDIR,
           DIR2.                                         &quot;XDOAHRK000408
    REFRESH: RGDIR,DIR2.                                 &quot;XDOAHRK000408
    CLEAR: %%_DIR2. REFRESH %%_DIR2.                     &quot;XDOAHRK000000
  ENDIF.
END-OF-DEFINITION.

DEFINE %%_CONVERT_IMPORT_DIR2.                           &quot;XDOAHRK000000
  REFRESH DIR2.                                                      &quot;!
  LOOP AT %%_DIR2.                                                   &quot;!
    CLEAR: DIR2.                                                     &quot;!
    MOVE-CORRESPONDING %%_DIR2 TO DIR2.                              &quot;!
    APPEND DIR2.                                                     &quot;!
  ENDLOOP.                                                           &quot;!
END-OF-DEFINITION.                                                   &quot;!
                                                                     &quot;!
DEFINE %%_CONVERT_EXPORT_DIR2.                                       &quot;!
  REFRESH %%_DIR2.                                                   &quot;!
  LOOP AT DIR2.                                                      &quot;!
    CLEAR: %%_DIR2.                                                  &quot;!
    MOVE-CORRESPONDING DIR2 TO %%_DIR2.                              &quot;!
    APPEND %%_DIR2.                                                  &quot;!
  ENDLOOP.                                                           &quot;!
END-OF-DEFINITION.                                       &quot;XDOAHRK000000

DEFINE RP-IMP-C2-CD.                                     &quot;XDOAHRK000000
  RP-IMP-C2-CU.                                                      &quot;!
END-OF-DEFINITION.                                                   &quot;!
                                                                     &quot;!
DEFINE RP-IMP-C2-CD-NOBUFF.                                          &quot;!
  RP-IMP-C2-CU-NOBUFF.                                               &quot;!
END-OF-DEFINITION.                                                   &quot;!
                                                                     &quot;!
DEFINE RP-EXP-C2-CD.                                                 &quot;!
  RP-EXP-C2-CU.                                                      &quot;!
END-OF-DEFINITION.                                       &quot;XDOAHRK000000

DEFINE RP-EXP-C2-CD-NOBUFF.
  RP-EXP-C2-CU-NOBUFF.
END-OF-DEFINITION.</include_source>
   </include>
   <include NAME="RPC2RWW0" VARCL="X" CLAS="PCW0" SUBC="I" APPL="P" LEVL="21E" RSTAT="P" RMAND="000" RLOAD="E">
    <include_source>*--RPC2RWW0-----------------------------------------------------------*
*  Include for RPCALCW0
*---------------------------------------------------------------------*
* Changes:
* AHRK057327 QNZ 27.09.1999 include HZAPAYDATA -  not marked linewise
* AHRK030036 JdM 99A New IRP5 : CDT, CSV
* AHRK002792 AK@SAPSA (3.1H) 01.11.97 (Retro Tax Functionality)
*          - RRT    =&gt; Define structure for handling of forwardflux
*          - RRT-TE =&gt; Define structure for tax exemption handling
* KISK015894 CB: Add PFFXA to SV structure.
*---------------------------------------------------------------------*
include hzapaydata.                                       &quot;QNZAHRK057327

DATA: BEGIN OF RW-VERSION.
*       INCLUDE STRUCTURE PC201.       &quot;Version           &quot;XTWPH9K008656
        INCLUDE STRUCTURE PC201_pay.                      &quot;XTWPH9K008656
DATA: END OF RW-VERSION.

DATA: BEGIN OF ORW-VERSION.
*       INCLUDE STRUCTURE PC201.       &quot;Version, old      &quot;XTWPH9K008656
        INCLUDE STRUCTURE PC201_pay.                      &quot;XTWPH9K008656
DATA: END OF ORW-VERSION.

DATA: RP-IMP-RW-SUBRC                  &quot;RETURN-CODE FUER CLUSTER-IMPORT
                   LIKE SY-SUBRC.

*---------------------------------------------------------------------*
* INTERNAL TABLES FOR UIFPFMA DEDUCTIONS AND TAXES                    *
*---------------------------------------------------------------------*
* UIFPFMA
*DATA: BEGIN OF SV OCCURS 2.            &quot;RELATED TABLES: XSV,OSV
*        INCLUDE STRUCTURE PC235.       &quot;S11K139303
*DATA: END OF SV.

* TAXES
*DATA: BEGIN OF ST OCCURS 2.        &quot;RELATED TABLES: XST,OST
*        INCLUDE STRUCTURE PC236.       &quot;S11K139303
*DATA: END OF ST.

*DATA: BEGIN OF CST OCCURS 2.       &quot;RELATED TABLES: OCST
*        INCLUDE STRUCTURE PC237.   &quot;S11K139303
*DATA: END OF CST.

*DATA: BEGIN OF CSV OCCURS 2.       &quot;RELATED TABLES: OCSV
*        INCLUDE STRUCTURE PC235_C.
*DATA: END OF CSV.

*DATA: BEGIN OF SCRT OCCURS 15.    &quot;related tables:  OSCRT
*        INCLUDE STRUCTURE PC238.       &quot;S11K139303
*DATA: END OF SCRT.

*DATA: BEGIN OF CDT OCCURS 2.           &quot;table for lump sums and tax
*        INCLUDE STRUCTURE PC238_D.     &quot;directives on the lump sum
*DATA: END OF CDT.

* Closed Tax Year - Retro RT                                 AHRK002792

DATA: BEGIN OF RRT OCCURS 30.
        INCLUDE STRUCTURE PC207.
DATA: END OF RRT.

* Closed Tax Year - Tax Exemptions                           AHRK002792

DATA: BEGIN OF RRT-TE OCCURS 20,
        PAPER(6)       TYPE N,
        ABART          LIKE PC207-ABART,
        LGART          LIKE PC207-LGART,
        APZNR          LIKE PC207-APZNR,
        CNTR1          LIKE PC207-CNTR1,
        CNTR2          LIKE PC207-CNTR2,
        CNTR3          LIKE PC207-CNTR3,
        ANZHL          LIKE PC207-ANZHL,
        BETRG          LIKE PC207-BETRG,
        YTD_TAXEX      LIKE PC207-BETRG,
        YTD_PENINC     LIKE PC207-BETRG,
        YTD_EE_CONTR   LIKE PC207-BETRG,
        TAXDAYS_FACTOR(16) TYPE P DECIMALS 8,
        YTD_PEN_CONTR  LIKE PC207-BETRG,
      END OF RRT-TE.

*---------------------------------------------------------------------*

INCLUDE RPCXRWW0.                                         &quot;XTWALRK016400</include_source>
   </include>
   <include NAME="RPC2RX02" VARCL="X" SUBC="I" APPL="P" LEVL="5.0B" RMAND="000" RLOAD="D">
    <include_source>* 4.0A
* XUJALRK000854  new internal table partt for log
* XAYALRK008760 290797 table AB &apos;valid&apos; clause added
* 3.0A
* WPWK11K109813 table C1 with new CO-elements
*---------------------------------------------------------------------*
* Data definition Payroll results country independent                 *
*   used in the generation of wagetyps (SAPFP51T)                     *
*---------------------------------------------------------------------*

*data:  begin of partt occurs 5.                         &quot;XUJALRK000854
*         include structure pc2p0.
*data:  end   of partt .       &quot;valid between begda and endda.
*
* data:  begin of parta occurs 5.                         &quot;XUJALRK030402
*          include structure pc2p1.
* data:  end   of parta .       &quot;valid between begda and endda.

DATA:  BEGIN OF WPBP OCCURS 5.    &quot;conclusion 0007/0008/
         INCLUDE STRUCTURE PC205.
DATA:  END   OF WPBP VALID BETWEEN BEGDA AND ENDDA.


DATA:  BEGIN OF C1 OCCURS 10. &quot;cost-distribution several Pnnnn/P0027
*        INCLUDE STRUCTURE PC20B.                         &quot;WPWK11K109813
         INCLUDE STRUCTURE PC25X.                         &quot;WPWK11K109813
DATA:  END   OF C1.


DATA:  BEGIN OF ALP OCCURS 20. &quot;alternate payment/e.g.substitutions
         INCLUDE STRUCTURE PC20E.
DATA:  END   OF ALP.

DATA:  BEGIN OF AB OCCURS 10.     &quot;absences of the period
         INCLUDE STRUCTURE PC20I.
* data:  end   of ab.                             &quot;XAYALRK008760
DATA:  END   OF AB VALID BETWEEN BEGDA AND ENDDA. &quot;XAYALRK008760

DATA: APZNR LIKE WPBP-APZNR,
      C1ZNR LIKE C1-C1ZNR.
DATA: ALZNR LIKE ALP-ALZNR.
DATA: AB_HOURS type PTM_MARK_HOURS_TAB.</include_source>
   </include>
   <include NAME="RPC2RX09" SUBC="I" APPL="P" LEVL="0.62" RMAND="000" RLOAD="D">
    <include_source>* 3.0A
* VKIK012819    23101995 Include for constants
* 3.0A
* QXOS11K146693 01081995 Development brought to Standard
* YLLK64048     130292 Aufteilung in RPC2RX01 und RPC2RX02
*---------------------------------------------------------------------*
* Constants definition Payroll results country independent            *
*---------------------------------------------------------------------*
INCLUDE RPCCRX09.                                           &quot;VKIK012819
*---------------------------------------------------------------------*
* Data definition Payroll results country independent                 *
*---------------------------------------------------------------------*
INCLUDE RPC2RX19.                      &quot;QXOK146693
INCLUDE RPC2RX02.</include_source>
   </include>
   <include NAME="RPC2RX19" SUBC="I" APPL="P" LEVL="31H" RSTAT="P" RMAND="000" RLOAD="D">
    <include_source>* 3.1H
* YKMP30K137797 13.03.1997 Split of RPC2RX01 in BT-part and non BT-part

INCLUDE RPC2RX29.
INCLUDE RPC2RX39.</include_source>
   </include>
   <include NAME="RPC2RX29" VARCL="X" SUBC="I" APPL="P" LEVL="31H" RSTAT="P" RMAND="000" RLOAD="D">
    <include_source>* 4.6A
* QNZAHRK052268 14071999 tables for cluster RX moved to H99PAYDATA
* 4.5A
* XULPH4K002766 04061998 new table for frozen averages
* XULAHRK015788   031998 new table for fund management
* YLHAHRK000132 0901998 table ACCR (Accruals) added

DATA: BEGIN OF RX-KEY.            &quot;Cluster Key
         INCLUDE STRUCTURE PC200.
DATA: END   OF RX-KEY.

*---begin QNZAHRK052268

include h99paydata.

*DATA:  BEGIN OF VERSC.  &quot;Version RPCALCx0 (administration)
*         INCLUDE STRUCTURE PC202.
*DATA:  END OF   VERSC.
*
*
*DATA:  BEGIN OF ABC OCCURS 05. &quot;absence-class-cumulation
*         INCLUDE STRUCTURE PC206.
*DATA:  END   OF ABC.
*
*DATA:  BEGIN OF RT OCCURS 150. &quot;result table
*         INCLUDE STRUCTURE PC207.
*DATA:  END   OF RT.

*---end QNZAHRK052268

DATA:  BEGIN OF ART OCCURS 150. &quot;alternative result table
         INCLUDE STRUCTURE PC207.
DATA:  END   OF ART.

*---begin QNZAHRK052268

*DATA:  BEGIN OF CRT OCCURS 30. &quot;cumulated-result table
*        INCLUDE STRUCTURE PC22Y.                             &quot;QXO900465
*DATA:  END   OF CRT.
*
*DATA:  BEGIN OF C0 OCCURS 10. &quot;cost-distribution from p0027
*         INCLUDE STRUCTURE PC20A.
*DATA:  END   OF C0.
*
*DATA:  BEGIN OF V0 OCCURS 10. &quot;variable splits
*         INCLUDE STRUCTURE PC20C.
*DATA:  END   OF V0.
*
*DATA:  BEGIN OF VCP OCCURS 12. &quot;vacancies in this period
*         INCLUDE STRUCTURE PC20D.
*DATA:  END   OF VCP.
*
**---------------------------------------------------------------------*
** Differenztabelle fuer getrennte Brutto/Netto-Abrechnung             *
**---------------------------------------------------------------------*
*DATA:  BEGIN OF DFT OCCURS 10. &quot;difference table
*         INCLUDE STRUCTURE PC20F.
*DATA:  END   OF DFT.
*
**---------------------------------------------------------------------*
**   Tabelle die die Ergebnisse der Leistungslohnabrechnung aufnimmt.  *
**   Die Zuordnung zu den Lohnscheinen geschieht ueber                 *
**   Buchungstag, Rueckmeldenummer, -zaehler und Herkunftskennzeichen  *
**   und zusaetzlich der Gruppennummer im Gruppenleistungslohn.        *
**---------------------------------------------------------------------*
*DATA:  BEGIN OF LS  OCCURS 10.
*         INCLUDE STRUCTURE PC20G.
*DATA:  END   OF LS.
*
**---------------------------------------------------------------------*
**   Output-Tabelle aus dem Bruttoteil bei getrennter Brutto/Netto-    *
**   abrechnung. Dient als Eingabe im Nettoteil.                       *
**---------------------------------------------------------------------*
*DATA:  BEGIN OF GRT OCCURS 10.     &quot;GrossResultTable like RT
*         INCLUDE STRUCTURE PC207.
*DATA:  END   OF GRT.
*
*
**---------------------------------------------------------------------*
** Feldleiste Status                                                   *
** Diese Feldleiste wird von der Abrechnung ausgewertet und wird durch *
** die Operation STATU gesetzt.                                        *
** Jeder Schalter hat seine feste Bedeutung.                           *
**---------------------------------------------------------------------*
*DATA:  BEGIN OF STATUS.           &quot;status
*         INCLUDE STRUCTURE PC20J.
*DATA:  END   OF STATUS.

*---end QNZAHRK052268

DATA: BEGIN OF V0ZNR OCCURS 10,
        V0TYP LIKE V0-V0TYP,
        V0ZNR LIKE V0-V0ZNR,
      END OF V0ZNR.

DATA: BEGIN OF DOWP OCCURS 5.
  INCLUDE STRUCTURE PC27D.
DATA: END OF DOWP VALID BETWEEN BEGDA AND ENDDA.

DATA: BEGIN OF DOC0 OCCURS 10.
  INCLUDE STRUCTURE PC27E.
DATA: END OF DOC0.

* definition of tabels ARRRS and DDNTK for arrears functionality
INCLUDE RPC2AR00.

*---begin QNZAHRK052268

** Month end accruals table
*DATA ACCR LIKE PC23G OCCURS 100 WITH
*  HEADER LINE.         &quot;YLHAHRK000132
*
** Benefit tables                               new for 4.0C
*DATA: BEGIN OF BENTAB OCCURS 10.
*        INCLUDE STRUCTURE PC27S.
*DATA: END OF BENTAB.
**
*DATA: BEGIN OF OBENTAB OCCURS 10.
*        INCLUDE STRUCTURE PC27S.
*DATA: END OF OBENTAB.
*
** Table for fundsmanagement            new with XULAHRK015788
*DATA: FUND LIKE PC2FUND OCCURS 0 WITH HEADER LINE.
*
** Table for frozen averages            new with XULPH4K002766
*DATA: AVERAGE LIKE PC2AVERA OCCURS 0 WITH HEADER LINE.

*---end QNZAHRK052268

*---------------------------------------------------------------------*
* Data definition Cluster ES/ET                                       *
*---------------------------------------------------------------------*
INCLUDE RPCDES00.</include_source>
   </include>
   <include NAME="RPC2RX39" SUBC="I" APPL="P" LEVL="31H" RSTAT="P" RMAND="000" RLOAD="D">
    <include_source>DATA:  BEGIN OF BT OCCURS 3. &quot;bank-transfer
         INCLUDE STRUCTURE PC209.
DATA:  END   OF BT.

DATA: BTZNR LIKE BT-BTZNR.</include_source>
   </include>
   <include NAME="RPCCCD09" VARCL="X" SUBC="I" APPL="P" LEVL="30A" RSTAT="P" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>***INCLUDE RPCCCD09.
* WOGL9C        07.03.2000 replaced LIKE by TYPE
* WOGAHRK057370 12.10.1999 Constant out of sequenc reversal
* YKMP30K111725 13.11.1996 Constant &quot;NON_AUTH&quot; for non authorized manul
*                          checks added.
* Cluster-Directory - Constants
CONSTANTS:
  BEGIN OF cd_c,                       &quot;constants
*   void_true like pc261-void     value &apos;X&apos;,     &quot;void    &quot;XTWP40K001106
    reversal_true  TYPE void      VALUE &apos;R&apos;,   &quot;reversal
    reversal_false TYPE void      VALUE &apos; &apos;,   &quot;valid
    void_true      TYPE void      VALUE &apos;V&apos;,   &quot;void
    void_false     TYPE void      VALUE &apos; &apos;,   &quot;valid
    actual         TYPE srtza     VALUE &apos;A&apos;,   &quot;actual result
    previous       TYPE srtza     VALUE &apos;P&apos;,   &quot;previous result
    old            TYPE srtza     VALUE &apos;O&apos;,   &quot;old result
    regular        TYPE payty     VALUE &apos; &apos;,   &quot;regular result
    bonus          TYPE payty     VALUE &apos;A&apos;,   &quot;bonus   result
    correct        TYPE payty     VALUE &apos;B&apos;,   &quot;correction result
    non_auth       TYPE payty     VALUE &apos;C&apos;,   &quot;Non author. manual
    supplemental   TYPE payty     VALUE &apos;S&apos;,
  END OF cd_c.</include_source>
   </include>
   <include NAME="RPCCRX09" VARCL="X" SUBC="I" APPL="P" LEVL="30B" RSTAT="P" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>***INCLUDE RPCCRX09.
* Cluster RX        - Constants
* 4.6C (L9C)
*VKIK046117 14.03.2001 Cumul.type &apos;F&apos; + &apos;H&apos; table CRT added
*VKIK019960 17.08.2000 table CRT (when paid) added - Cumul.type &apos;K&apos;
Data:
  BEGIN OF RX_C,                       &quot;constants
    PPERM_YEAR     LIKE T54C6-CUMTY    VALUE &apos;Y&apos;,     &quot;yearly
    PPERM_YEAR_WP  LIKE T54C6-CUMTY    VALUE &apos;K&apos;,     &quot;yearly(when paid)
    PPERM_QUARTER  LIKE T54C6-CUMTY    VALUE &apos;Q&apos;,     &quot;quarterly
    PPERM_qrtr_WP  LIKE T54C6-CUMTY    VALUE &apos;H&apos;,     &quot;quart.(when paid)
    PPERM_MONTH    LIKE T54C6-CUMTY    VALUE &apos;M&apos;,     &quot;monthly
    PPERM_month_WP LIKE T54C6-CUMTY    VALUE &apos;F&apos;,     &quot;month (when paid)
    PPERM_UNLIMIT  LIKE T54C6-CUMTY    VALUE &apos;U&apos;,     &quot;unlimited
  END OF RX_C.</include_source>
   </include>
   <include NAME="RPCDES00" CLAS="PC00" SUBC="I" APPL="P" LEVL="5.0C" RSTAT="P" RMAND="000" RLOAD="D">
    <include_source>* 5.0C
* VVAK71557 05.08.1992 Cluster ES neu aufgebaut, Cluster ET neu;

*---------------------------------------------------------------------*
*                                                                     *
* Data definition of Cluster ES                                       *
*                                                                     *
*---------------------------------------------------------------------*
* 4.0A
* XNRALRK011682 04061997 Ablösung der RMAC für Cluster RA



*---------------------------------------------------------------------*
* Key of Cluster ES                                                   *
*---------------------------------------------------------------------*
DATA: BEGIN OF ES-KEY.                 &quot; Key of Cluster ES
        INCLUDE STRUCTURE PC22E.
DATA: END OF ES-KEY.

*---------------------------------------------------------------------*
* Key of Cluster ET (same key as Cluster ES)                          *
*---------------------------------------------------------------------*
DATA: BEGIN OF ET-KEY.                 &quot; Key of Cluster ET
        INCLUDE STRUCTURE PC22E.
DATA: END OF ET-KEY.

*---------------------------------------------------------------------*
* Version of Cluster ES                                               *
*---------------------------------------------------------------------*
DATA: BEGIN OF ES-VERSION.             &quot; Version
        INCLUDE STRUCTURE PC201.
*       SAPRL      LIKE PC201-SAPRL,   &quot; Release
*       NUMBER     LIKE PC201-NUMBER   &quot; Number of version
*                  VALUE &apos;01&apos;,
*       UNAME      LIKE PC201-UNAME,   &quot; Name
*       DATUM      LIKE PC201-DATUM,   &quot; Date
*       UZEIT      LIKE PC201-UZEIT,   &quot; Time
*       PGMID      LIKE PC201-PGMID,   &quot; Report
DATA: END OF ES-VERSION.

DATA: BEGIN OF OES-VERSION.            &quot; old Version
        INCLUDE STRUCTURE PC201.
DATA: END OF OES-VERSION.

*---------------------------------------------------------------------*
* Structure of table ES                                               *
*---------------------------------------------------------------------*
DATA: BEGIN OF ES OCCURS 20.           &quot; kumulated wagetypes
        INCLUDE STRUCTURE PC22C.
DATA: END OF ES.

DATA: BEGIN OF OES OCCURS 20.          &quot; kumulated wagetypes
        INCLUDE STRUCTURE PC22C.
DATA: END OF OES.

*---------------------------------------------------------------------*
* Structure of table EX                                               *
*---------------------------------------------------------------------*
DATA: BEGIN OF EX OCCURS 10.           &quot; variable information
        INCLUDE STRUCTURE PC22D.
DATA: END OF EX.

DATA: BEGIN OF OEX OCCURS 10.          &quot; variable information
        INCLUDE STRUCTURE PC22D.
DATA: END OF OEX.


*---------------------------------------------------------------------*
* Returncode after Import and Export                                  *
*---------------------------------------------------------------------*
DATA: RP-IMP-ES-SUBRC LIKE SY-SUBRC,   &quot; Returncode Import
      RP-EXP-ES-SUBRC LIKE SY-SUBRC.   &quot; Returncode Export

* Import-, Export- und Refresh-Bausteine                     &quot;XNRK011682
INCLUDE RPCXES00.                                            &quot;XNRK011682</include_source>
   </include>
   <include NAME="RPCVCD09" SUBC="I" APPL="P" LEVL="30A" RSTAT="P" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>*----------------------------------------------------------------------*
*   INCLUDE RPCVCD09                                                   *
*----------------------------------------------------------------------*
* Cluster-Directory - definitions of variables and tables

DEFINE DEF_RGDIR.
DATA:
  BEGIN OF &amp;1 OCCURS 50.
    INCLUDE STRUCTURE PC261.
DATA:
  END OF &amp;1.
END-OF-DEFINITION.</include_source>
   </include>
   <include NAME="RPCXES00" SUBC="I" APPL="P" LEVL="40A" RSTAT="P" RMAND="000" RLOAD="D" FIXPT="X">
    <include_source>***INCLUDE RPCXES00 .
* 4.0A
* XNRALRK011682 04061997 Ablösung der RMAC für Cluster ES
*                        INCLUDE NEU ERSTELLT

DEFINE RP-EXP-C2-ES .
***************************************
* CLUSTER ES: ABR.ERGEBNIS (SUMMEN)
* BEI AENDERUNGEN AUCH CLUSTER ET
* AENDERN!
*--------------------------------------
* NEU HINZUKOMMENDE STRUKTUREN SIND
* MIT EINEM ENTSPRECHENDEN LANGTEXT
* ZU VERSEHEN
***************************************
ES-VERSION-NUMBER = &apos;00&apos; .
EXPORT ES-VERSION
       ES
*                  SUMMEN
       EX
*                  VARIABLE ZUORDNUNG
TO   DATABASE PCL2(ES)
ID ES-KEY USING PCL2_EXP_IMP .
RP-EXP-ES-SUBRC = SY-SUBRC .
END-OF-DEFINITION.


DEFINE RP-EXP-C2-ET .
***************************************
* CLUSTER ET: ABR.ERGEBNIS (SUMMEN)
* GLEICHER AUFBAU WIE ES.
* BEI AENDERUNGEN AUCH CLUSTER ES
* AENDERN!
*--------------------------------------
* NEU HINZUKOMMENDE STRUKTUREN SIND
* MIT EINEM ENTSPRECHENDEN LANGTEXT
* ZU VERSEHEN
***************************************
ES-VERSION-NUMBER = &apos;00&apos; .
EXPORT ES-VERSION
       ES
*                  SUMMEN
       EX
*                  VARIABLE ZUORDNUNG
TO   DATABASE PCL2(ET)
ID ET-KEY USING PCL2_EXP_IMP .
RP-EXP-ES-SUBRC = SY-SUBRC .
END-OF-DEFINITION.


DEFINE RP-IMP-C2-ES .
***************************************
* CLUSTER ET: ABR.ERGEBNIS (SUMMEN)
* BEI AENDERUNGEN AUCH CLUSTER ET
* AENDERN!
*--------------------------------------
* NEU HINZUKOMMENDE STRUKTUREN SIND
* MIT EINEM ENTSPRECHENDEN LANGTEXT
* ZU VERSEHEN
***************************************
IMPORT ES-VERSION TO OES-VERSION
       ES
*                  SUMMEN
       EX
*                  VARIABLE ZUORDNUNG
FROM DATABASE PCL2(ES)
ID ES-KEY USING PCL2_EXP_IMP .
RP-IMP-ES-SUBRC = SY-SUBRC .
IF RP-IMP-ES-SUBRC &lt;&gt; 0 .
CLEAR: OES-VERSION,
       ES,
EX .
REFRESH: ES,
EX .
ENDIF .
ES-VERSION-NUMBER = &apos;00&apos; .
END-OF-DEFINITION.


DEFINE RP-IMP-C2-ES-O .
***************************************
* CLUSTER ES: ABR.ERGEBNIS (SUMMEN)
* BEI AENDERUNGEN AUCH CLUSTER ET
* AENDERN!
* BITTE BEACHTEN: DER IMPORT ERFOLGT
*       IN ALTERNATIV-STRUKTUREN!!!!!
*--------------------------------------
* NEU HINZUKOMMENDE STRUKTUREN MUESSEN
* MIT EINEM ENTSPRECHENDEN LANGTEXT
* VERSEHEN WERDEN
***************************************
IMPORT ES-VERSION TO OES-VERSION
       ES         TO OES
*                  SUMMEN
       EX         TO OEX
*                  VARIABLE ZUORDNUNG
FROM DATABASE PCL2(ES)
ID ES-KEY USING PCL2_EXP_IMP .
RP-IMP-ES-SUBRC = SY-SUBRC .
IF RP-IMP-ES-SUBRC &lt;&gt; 0 .
CLEAR: OES-VERSION,
       OES,
OEX .
REFRESH: OES,
OEX .
ENDIF .
ES-VERSION-NUMBER = &apos;00&apos; .
END-OF-DEFINITION.


DEFINE RP-IMP-C2-ET .
***************************************
* CLUSTER ET: ABR.ERGEBNIS (SUMMEN)
* GLEICHER AUFBAU WIE ES.
* BEI AENDERUNGEN AUCH CLUSTER ES
* AENDERN!
*--------------------------------------
* NEU HINZUKOMMENDE STRUKTUREN SIND
* MIT EINEM ENTSPRECHENDEN LANGTEXT
* ZU VERSEHEN
***************************************
IMPORT ES-VERSION TO OES-VERSION
       ES
*                  SUMMEN
       EX
*                  VARIABLE ZUORDNUNG
FROM DATABASE PCL2(ET)
ID ET-KEY USING PCL2_EXP_IMP .
RP-IMP-ES-SUBRC = SY-SUBRC .
IF RP-IMP-ES-SUBRC &lt;&gt; 0 .
CLEAR: OES-VERSION,
       ES,
EX .
REFRESH: ES,
EX .
ENDIF .
ES-VERSION-NUMBER = &apos;00&apos; .
END-OF-DEFINITION.


DEFINE RP-IMP-C2-ET-O .
***************************************
* CLUSTER ET: ABR.ERGEBNIS (SUMMEN)
* GLEICHER AUFBAU WIE ES.
* BEI AENDERUNGEN AUCH CLUSTER ES
* AENDERN!
* BITTE BEACHTEN: DER IMPORT ERFOLGT
*       IN ALTERNATIV-STRUKTUREN!!!!!
*--------------------------------------
* NEU HINZUKOMMENDE STRUKTUREN MUESSEN
* MIT EINEM ENTSPRECHENDEN LANGTEXT
* VERSEHEN WERDEN
***************************************
IMPORT ES-VERSION TO OES-VERSION
       ES         TO OES
*                  SUMMEN
       EX         TO OEX
*                  VARIABLE ZUORDNUNG
FROM DATABASE PCL2(ET)
ID ET-KEY USING PCL2_EXP_IMP .
RP-IMP-ES-SUBRC = SY-SUBRC .
IF RP-IMP-ES-SUBRC &lt;&gt; 0 .
CLEAR: OES-VERSION,
       OES,
OEX .
REFRESH: OES,
OEX .
ENDIF .
ES-VERSION-NUMBER = &apos;00&apos; .
END-OF-DEFINITION.</include_source>
   </include>
   <include NAME="RPCXRWW0" VARCL="X" DBAPL="S" DBNA="D$" SUBC="I" APPL="P" LEVL="40A" RSTAT="P" RMAND="000" RLOAD="D">
    <include_source>*--RPCXRWW0-------------------------------------------------------------
* RMAC&apos;s for import/export of SA cluster RW tables.
* 4.6A
* XULPH9K000032 26.04.1999 Macros generated in include HZAPAYMACRO
* 99A
* AHRK028668 (JdM) CSV, CDT added to cluster RW
* AHRK023287 table fund for fundsmanagement
* 4.0C
* AHRK008971 (JdM)          30.03.98 TW Exp&amp;Imp Macros defined
*
* 4.0A
* ALRK044233 (CB) (EPI-USE) 20.08.97
*            - Add arrears tables ARRRS and DDNTK.
*----------------------------------------------------------------------

include HZAPAYMACRO.                  &quot;XULPH9K000032

**----------------------------------------------------------------------
** CLUSTER RW: Pay.Res. (South Africa) *
**----------------------------------------------------------------------
*DEFINE RP-EXP-C2-RW .
* RW-VERSION-NUMBER = &apos;02&apos; .                              &quot;XTWALRK016400
* PCL2-VERSN = &apos;02&apos; .                                     &quot;XTWALRK016400
*  EXPORT RW-VERSION
*         VERSC
*         WPBP
*         ABC
*         RT
*         CRT
*         BT
*         C0
*         C1
*         V0
*         VCP
*         ALP
*         DFT
*         GRT
*         LS
*         SV
*         ST
*         CST
*         SCRT
*         STATUS
*        ARRRS                                               &quot;ALRK044233
*        DDNTK                                               &quot;ALRK044233
*        FUND                                                &quot;AHRK023287
*         CSV
*         CDT
*  TO   DATABASE PCL2(RW)
*  ID RX-KEY USING PCL2_EXP_IMP .
*  RP-IMP-RW-SUBRC = SY-SUBRC .
*END-OF-DEFINITION.
*
*
**----------------------------------------------------------------------
** CLUSTER RW: Pay.Res. (South Africa) *
**----------------------------------------------------------------------
*DEFINE RP-IMP-C2-RW .
* CLEAR FUND. REFRESH FUND.                                  &quot;AHRK023287
*  IMPORT RW-VERSION TO ORW-VERSION
*         VERSC
*         WPBP
*         ABC
*         RT
*         CRT
*         BT
*         C0
*         C1
*         V0
*         VCP
*         ALP
*         DFT
*         GRT
*         LS
*         SV
*         ST
*         CST
*         SCRT
*         STATUS
*        ARRRS                                               &quot;ALRK044233
*        DDNTK                                               &quot;ALRK044233
*        FUND                                                &quot;AHRK023287
*        CSV                                                 &quot;AHRK028668
*        CDT                                                 &quot;AHRK028668
*    FROM DATABASE PCL2(RW)
*    ID RX-KEY USING PCL2_EXP_IMP .
* RW-VERSION-NUMBER = &apos;02&apos; .                              &quot;XTWALRK016400
*  RP-IMP-RW-SUBRC = SY-SUBRC .
*  IF RP-IMP-RW-SUBRC NE 0 .
*    CLEAR: ORW-VERSION,  VERSC, ST, SV, CST, SCRT, WPBP, ABC, RT,
*           CRT, BT, C0, C1, V0, VCP, ALP, DFT, GRT, LS, STATUS,
*           ARRRS, DDNTK,                                    &quot;ALRK044233
*          FUND, CSV, CDT.                                   &quot;AHRK023287
*    REFRESH: WPBP, ABC, RT, CRT, BT, C0, C1, V0, VCP, ALP,
*           DFT, GRT, LS, ST, SV, CST, SCRT,
*           ARRRS, DDNTK,                                    &quot;ALRK044233
*          FUND, CSV, CDT.                                   &quot;AHRK023287
*  ENDIF .
*END-OF-DEFINITION.
*
*
**----------------------------------------------------------------------
** CLUSTER RX: PAYROLLRESULTS INTERNAT.
**----------------------------------------------------------------------
*DEFINE RP-IMP-C2-RW-BESCH .
*  IMPORT RW-VERSION TO ORW-VERSION
*         WPBP
*         RT
*         AB
*         ABC
*     FROM DATABASE PCL2(RW)
*     ID RX-KEY USING PCL2_EXP_IMP .
*  RP-IMP-Rw-SUBRC = SY-SUBRC .
*  IF RP-IMP-Rw-SUBRC NE 0 .
*    CLEAR: ORW-VERSION, WPBP, RT, ABC, AB .
*    REFRESH: WPBP, ABC, RT, AB .
*  ENDIF .
*END-OF-DEFINITION.
*
*
**----------------------------------------------------------------------
** CLUSTER RW: ABR.ERG. (X), CRT
**----------------------------------------------------------------------
*DEFINE RP-IMP-C2-RW-CRT .
*  IMPORT RW-VERSION TO ORW-VERSION
*         CRT
*     FROM DATABASE PCL2(RW)
*     ID RX-KEY USING PCL2_EXP_IMP .
*END-OF-DEFINITION.
*
*
**----------------------------------------------------------------------
** CLUSTER RW: Pay.Res.
**----------------------------------------------------------------------
*DEFINE RP-IMP-C2-RW-O .
* CLEAR OFUND. REFRESH OFUND.                                &quot;AHRK023287
*  IMPORT RW-VERSION TO ORW-VERSION
*         VERSC   TO OVERSC
*         WPBP    TO OWPBP
*         ABC     TO OABC
*         RT      TO ORT
*         CRT     TO OCRT
*         BT      TO OBT
*         C0      TO OC0
*         C1      TO OC1
*         V0      TO OV0
*         VCP     TO OVCP
*         ALP     TO OALP
*         DFT     TO ODFT
*         GRT     TO OGRT
*         LS      TO OLS
*         SV      TO OSV
*         ST      TO OST
*         CST     TO OCST
*         SCRT    TO OSCRT
*         STATUS  TO OSTATUS
*         ARRRS   TO OARRRS                                  &quot;ALRK044233
*         DDNTK   TO ODDNTK                                  &quot;ALRK044233
*         FUND    TO OFUND                                   &quot;AHRK023287
*         CSV     TO OCSV                                    &quot;AHRK028668
*         CDT     TO OCDT                                    &quot;AHRK028668
*     FROM DATABASE PCL2(RW)
*     ID ORX-KEY USING PCL2_EXP_IMP .
*  RW-VERSION-NUMBER = &apos;02&apos;.                              &quot;XTWALRK016400
*  RP-IMP-RW-SUBRC = SY-SUBRC .
*  IF RP-IMP-RW-SUBRC NE 0 .
*    CLEAR:   ORW-VERSION, OVERSC, OST, OSV, OCST, OSCRT, OWPBP, OABC,
*             ORT, OCRT, OBT, OC0, OC1, OV0, OVCP,
*             OALP, ODFT, OGRT, OLS, OSTATUS,
*             OARRRS,   ODDNTK,                            &quot;ALRK044233
*             OFUND, OCSV, OCDT.                           &quot;AHRK023287
*    REFRESH: OWPBP, OABC, ORT, OCRT, OBT, OC0, OC1, OV0, OVCP, OALP,
*             ODFT, OGRT, OLS, OSV, OST, OCST, OSCRT,
*             OARRRS, ODDNTK,                              &quot;ALRK044233
*             OFUND, OCSV, OCDT.                           &quot;AHRK023287
*  ENDIF .
*END-OF-DEFINITION.
*
*
**----------------------------------------------------------------------
** CLUSTER RW: ABR.ERG. (SA) UMS.KUMUL.
**----------------------------------------------------------------------
*DEFINE RP-IMP-C2-RW-UKU .
* CLEAR FUND. REFRESH FUND.                                  &quot;AHRK023287
*  IMPORT RW-VERSION TO ORW-VERSION
*         VERSC
*         WPBP
*         ABC
*         RT
*         CRT  TO  OCRT
*         BT
*         C0
*         C1
*         V0
*         VCP
*         ALP
*         DFT
*         GRT
*         LS
*         STATUS
*         SV
*         ST
*        FUND                                                &quot;AHRK023287
*  FROM DATABASE PCL2(RW)
*  ID RX-KEY USING PCL2_EXP_IMP .
*END-OF-DEFINITION.
*
*
**----------------------------------------------------------------------
** CLUSTER RX: ABR.ERG. (X), ALLE DATEN
**----------------------------------------------------------------------
*DEFINE RP-REF-C2-RW .
*  CLEAR: ORW-VERSION, VERSC, SV, ST, CST, SCRT, WPBP,  ABC,  RT, C0,
*         CRT, BT, V0, VCP, ALP, C1, DFT, GRT, LS, STATUS, RX-KEY,
*        FUND, CSV, CDT.                                     &quot;AHRK023287
*  REFRESH: WPBP,  ABC,  RT,  CRT,  BT, C0,  C1,  V0,  VCP,  ALP,
*         DFT, GRT, LS, ST, SV, CST, SCRT,
*        FUND, CSV, CDT.                                     &quot;AHRK023287
*END-OF-DEFINITION.
*
*
**----------------------------------------------------------------------
** CLUSTER RX: ABR.ERG. (X), ALLE DATEN
**----------------------------------------------------------------------
*DEFINE RP-REF-C2-RW-O .
*  CLEAR: ORW-VERSION, OVERSC, OST, OSV, OCST, OSCRT, OWPBP, OABC, ORT,
*         OCRT, OBT, OC0, OC1, OV0, OVCP, OALP,
*         ODFT, OGRT, OLS, OSTATUS, ORX-KEY,
*        OFUND, OCSV, OCDT.                                  &quot;AHRK023287
*  REFRESH: OWPBP, OABC, ORT, OCRT, OBT, OC0, OC1, OV0, OVCP, OALP,
*         ODFT, OGRT, OLS, OST, OSV, OCST, OSCRT,
*        OFUND, OCSV, OCDT.                                  &quot;AHRK023287
*END-OF-DEFINITION.

*----------------------------------------------------------------------
* CLUSTER TW: Import IP Table for cluster TW (ZA)
*----------------------------------------------------------------------
*DEFINE RP-IMP-C2-TW .
*
*  IMPORT IP FROM DATABASE PCL2(TW)
*    ID PERNR-PERNR USING PCL2_EXP_IMP.
*
*END-OF-DEFINITION.
*
*----------------------------------------------------------------------
* CLUSTER TW: Export IP Table for cluster TW (ZA)
*----------------------------------------------------------------------
*DEFINE RP-EXP-C2-TW .
*
*  EXPORT IP TO DATABASE PCL2(TW)
*    ID PERNR-PERNR USING PCL2_EXP_IMP.
*
*END-OF-DEFINITION.</include_source>
   </include>
   <include NAME="RPPPXD00" CLAS="PC00" SUBC="I" APPL="P" LEVL="30A" RSTAT="P" RMAND="000" RLOAD="D">
    <include_source>*----------------------------------------------------------------------*
*  R/3 data descriptions for PCL1- and PCL2-buffer, respectively
*----------------------------------------------------------------------*
TABLES: PCL3,
        PCL4.
DATA: SAVE-SGART(2).

DATA: MAIN-SUBRC      LIKE SY-SUBRC,
      READ-SUBRC      LIKE SY-SUBRC,
      READ-DIR-SUBRC  LIKE SY-SUBRC,
      READ-PCLX-SUBRC LIKE SY-SUBRC,
      DIR-TABIX       LIKE SY-TABIX,
      TBUFF-TABIX     LIKE SY-TABIX.

DATA: AUX_SRTF2 LIKE PCL1-SRTF2,
      AUX_ONUXT LIKE PCL1-SRTF2,
      AUX_NTABX LIKE SY-TABIX,
      AUX_OTABX LIKE SY-TABIX.
DATA: DEL-COUNTER TYPE P.
DATA: NTABX-LOW  LIKE SY-TABIX,
      NTABX-HIGH LIKE SY-TABIX,
      OTABX-LOW  LIKE SY-TABIX,
      OTABX-HIGH LIKE SY-TABIX.
DATA: PPPPP TYPE P.

DATA: SEQ-INPUT.
&quot;***********************************************************************</include_source>
   </include>
   <include NAME="RPPPXD10" VARCL="X" CLAS="PC00" SUBC="I" APPL="P" LEVL="5.0B" RSTAT="P" RMAND="000" RLOAD="D">
    <include_source>*----------------------------------------------------------------------*
* 4.0A
* YKMP40K011038 17.09.1997 NO_AUTHORITY_CHECK_CLUSTER for deactivation
*                          of the authority check.
* YKMALRK000847 25.06.1997 PAYR_BUFFER maintained (decoupling)
* 3.0E
* QICP30K074825  17.05.1996 returncode
* 3.0D
* YKMP30K048502  21.02.1996 Table PAYR_BUFFER added for interface to
*                           FI&apos;s check register.
* 3.0B
* XPMP30K014785  21.09.1995  occurs-Parameter veraendert
*
*----------------------------------------------------------------------*
*  R/3 Common-part pcl1(2)-buffer
*----------------------------------------------------------------------*

*data: begin of buffer_dir occurs 10,                       &quot;XPMK014785
DATA: BEGIN OF BUFFER_DIR OCCURS 2000,                      &quot;XPMK014785
        SGART(2),
        CLIENT LIKE PCL1-CLIENT,
        RELID LIKE PCL1-RELID,
        SRTFD LIKE PCL1-SRTFD,
        NTABX LIKE SY-TABIX, &quot;pointer auf aktuellen satz
        OTABX LIKE SY-TABIX, &quot;pointer auf alten satz (falls vorhanden)
        NNUXT LIKE PCL1-SRTF2, &quot;anzahl folgesaetze aktueller Satz
        ONUXT LIKE PCL1-SRTF2, &quot;anzahl folgesaetze alter Satz
*       ofset(3) type p,     &quot;offset innerhalb eines entry
      END OF BUFFER_DIR.
DATA: BEGIN OF DIR_KEY,
        SGART(2),
        CLIENT LIKE PCL1-CLIENT,
        RELID LIKE PCL1-RELID,
        SRTFD LIKE PCL1-SRTFD,
      END OF DIR_KEY.
DATA: BEGIN OF DEL_PCLX_TAB OCCURS 2,
        SGART(2),
        RELID LIKE PCL1-RELID,
        SRTFD LIKE PCL1-SRTFD,
        NUEXT LIKE PCL1-SRTF2,
      END OF DEL_PCLX_TAB.
*data: begin of tbuff occurs 5.                             &quot;XPMK014785
DATA: BEGIN OF TBUFF OCCURS 5000.                           &quot;XPMK014785
        INCLUDE STRUCTURE PCL1.
        DATA: SGART(2),
      END OF TBUFF.
*data: begin of before_image_pclx occurs 550.               &quot;XPMK014785
DATA: BEGIN OF BEFORE_IMAGE_PCLX OCCURS 5000.               &quot;XPMK014785
        INCLUDE STRUCTURE PCL1.
        DATA: SGART(2),
      END OF BEFORE_IMAGE_PCLX.
* Check register of FI.
DATA: BEGIN OF PAYR_BUFFER OCCURS 5.                      &quot;YKMP30K048502
*       INCLUDE STRUCTURE payr.                           &quot;YKMP30K048502
*       INCLUDE STRUCTURE PAYR_HR.               &quot; thk Decoupling 5.5.97
        INCLUDE STRUCTURE PAYR_FI.                        &quot;YKMALRK000847
DATA:   OSEQNR LIKE PAYR_FI-SEQNR.                        &quot;YKMALRK000847
DATA: END OF PAYR_BUFFER.                                 &quot;YKMP30K048502

DATA: PCLX_SUBRC LIKE SY-SUBRC.                           &quot;QICP30K074826

DATA: NO_AUTHORITY_CHECK_CLUSTER(1) TYPE C.               &quot;YKMP40K011038</include_source>
   </include>
   <include NAME="RPPPXM00" SQLX="R" VARCL="X" CLAS="PC00" SUBC="I" APPL="P" LEVL="30A" RSTAT="P" RMAND="000" RLOAD="D">
    <include_source>*4.7
*QICPL0K004475 080302 SLIN
*LCP XYVN0388630 03Mar2001 unicode
*4.6C
*QICAHRK053949 020899 authorization check for PCL4
*4.0A
* YKMP40K011038 17.09.1997 For importing results on an international
*                          basis, it is important to deactivate
*                          the authority check since the cluster id
*                          in the import statement will be switched
*                          to &apos;$$&apos; for example. This assumes that the
*                          calling program did the check already.
*3.0E
*QICP30K074825 170596 authority-check for simulation mode
*3.0
*LLB P30K067762 - 16.04.96 - Canadian payroll
*QICK11K126112 160294 extended syntax check
*QICK11K094643 150794 run time error during import
*-----------------------------------------------------------------------
* R/3 modules handling the PCL1(2)-buffer
*-----------------------------------------------------------------------




FORM PCL1_EXP_IMP USING OPERATION.
   SAVE-SGART = &apos;P1&apos;.
   PCL1-AEDTM = SY-DATUM.
   PCL1-UNAME = SY-UNAME.
   PCL1-PGMID = SY-REPID.
   TBUFF = PCL1.
   TBUFF-SGART = SAVE-SGART.
   PERFORM EXP_IMP USING OPERATION.
   PCL1 = TBUFF.
   SY-SUBRC = MAIN-SUBRC.             &quot;this must be the last statement
ENDFORM.  &quot;EXP_IMP_P1

FORM PCL2_EXP_IMP USING OPERATION.
   SAVE-SGART = &apos;P2&apos;.
   PCL2-AEDTM = SY-DATUM.
   PCL2-UNAME = SY-UNAME.
   PCL2-PGMID = SY-REPID.
   TBUFF = PCL2.
   TBUFF-SGART = SAVE-SGART.
   PERFORM EXP_IMP USING OPERATION.
   PCL2 = TBUFF.
   SY-SUBRC = MAIN-SUBRC.             &quot;this must be the last statement
ENDFORM.  &quot;EXP_IMP_P2

FORM PCL3_EXP_IMP USING OPERATION.    &quot;applicants
   SAVE-SGART = &apos;P3&apos;.
   PCL3-AEDTM = SY-DATUM.
   PCL3-UNAME = SY-UNAME.
   PCL3-PGMID = SY-REPID.
   TBUFF = PCL3.
   TBUFF-SGART = SAVE-SGART.
   PERFORM EXP_IMP USING OPERATION.
   PCL3 = TBUFF.
   SY-SUBRC = MAIN-SUBRC.&quot;this has to be the last statem.
ENDFORM.  &quot;EXP_IMP_P3

FORM PCL4_EXP_IMP USING OPERATION.
   SAVE-SGART = &apos;P4&apos;.
   PCL4-AEDTM = SY-DATUM.
   PCL4-UNAME = SY-UNAME.
   PCL4-PGMID = SY-REPID.
   TBUFF = PCL4.
   TBUFF-SGART = SAVE-SGART.
   PERFORM EXP_IMP USING OPERATION.
   PCL4 = TBUFF.
   SY-SUBRC = MAIN-SUBRC.&quot;this has to be the last statem.
ENDFORM.  &quot;EXP_IMP_P3
*-----------------------------------------------------------------------
* common part dealing with TBUFF-header
*
* new added from note 1911194 for performance.
* The result of authority check will store in a table
* we transform the majority of the form call of authority check
* to table access. This method will slightly affect the security but will
* boost the performance.
* The best way to do this is move this authority_check to very high level
* when the report just get loaded.
*-----------------------------------------------------------------------
FORM EXP_IMP USING OPERATION type clike.                    &quot;ANDUNI

DATA: BEGIN OF T_AUTH,                                    &quot;JGONG1911194
      RELID TYPE PCL2-RELID,
      OPERA TYPE STRING,
      SUBRC TYPE SY-SUBRC,
END OF T_AUTH.
STATICS lt_auth LIKE STANDARD TABLE OF t_auth WITH KEY relid.   &quot;jgong1911194
DATA: wa_auth LIKE t_auth.

CLEAR wa_auth.

  READ TABLE lt_auth INTO wa_auth WITH KEY relid = tbuff-relid  opera = operation.
  if sy-subrc eq 0.
    main-subrc = wa_auth-subrc.
  else.
    IF TBUFF-SRTF2 EQ 0.
    PERFORM AUTHORITY_CHECK USING OPERATION.
    t_auth-relid = tbuff-relid.
    t_auth-opera = operation.
    t_auth-subrc = main-subrc.
    INSERT t_auth INTO TABLE lt_auth.
   ENDIF.
  ENDIF.                                                  &quot;jgong1911194

   CHECK MAIN-SUBRC NE 12.
   DIR_KEY-SGART = TBUFF-SGART.
   DIR_KEY+2 = TBUFF.
   READ TABLE BUFFER_DIR WITH KEY DIR_KEY BINARY SEARCH.    &quot;#EC *
   READ-DIR-SUBRC = SY-SUBRC.
*  sy-tabix is not reliable in case of sy-subrc = 8.
   DIR-TABIX = SY-TABIX.
*  ENDIF.                                            (del) QICK11K094643

   CASE OPERATION.
     WHEN &apos;READ&apos;.
       IF READ-DIR-SUBRC EQ 0.
         IF BUFFER_DIR-NTABX NE 0.
           PERFORM READ_TBUFF.           &quot;data from buffer
         ELSE.
           READ-SUBRC = 4.               &quot;no record found entry
         ENDIF.
       ELSE.
         IF SEQ-INPUT EQ SPACE.
*          data from disk are selected if available
*          and stored in the buffer
           PERFORM READ_PCLX.
         ELSE.
           READ-SUBRC = 4.
         ENDIF.
       ENDIF.
       MAIN-SUBRC = READ-SUBRC.
*      READ-SUBRC = 0 indicates that the TBUFF-work-area has succesfully
*      been filled with the requested data. Otherwise READ-SUBRC = 4.
     WHEN &apos;UPDATE&apos;.
       APPEND TBUFF.
       TBUFF-TABIX = SY-TABIX.
       PERFORM MAINTAIN_DIR.
       MAIN-SUBRC = 0.
*    WHEN &apos;INSERT&apos;. only updates are being performed
   ENDCASE.

ENDFORM.   &quot;EXP_IMP


FORM READ_TBUFF.
* IF TBUFF+2(49) NE PCLX(49).
    PPPPP = BUFFER_DIR-NTABX + TBUFF-SRTF2.
    READ TABLE TBUFF INDEX PPPPP.
*   IF SY-SUBRC NE 0.
*     internal error: the directory does not fit to the buffer
*   ENDIF.
* ENDIF.
  READ-SUBRC = 0.
ENDFORM.    &quot;READ_TBUFF

FORM READ_PCLX.  &quot;selects data from disk and stores them in the buffer
*XYVN0388630
*  DATA: BEGIN OF T, &quot;dummy for abnormal end of program   &quot;QICK11K094643
*          P TYPE P,                                      &quot;QICK11K094643
*        END OF T.                                        &quot;QICK11K094643
*  IF TBUFF-SRTF2 NE 0. &quot;should not occur                 &quot;QICK11K094643
*    T = SPACE.         &quot;force abnormal end               &quot;QICK11K094643
*    ADD 1 TO T-P.                                        &quot;QICK11K094643
*  ENDIF. &quot;TBUFF-SRTF2 NE 0.                              &quot;QICK11K094643
*XYVN0388630
  IF TBUFF-SRTF2 &lt;&gt; 0. &quot;should not occur                   &quot;XYVN0388630
    MESSAGE X016(RP) WITH SPACE SPACE SPACE SPACE.         &quot;XYVN0388630
  ENDIF. &quot;TBUFF-SRTF2 NE 0.                                &quot;XYVN0388630
  BUFFER_DIR(47) = DIR_KEY.
* AUX_SRTF2 = TBUFF-SRTF2.                           (del) QICK11K094643
  CASE TBUFF-SGART.
    WHEN &apos;P1&apos;.
*     SELECT SINGLE * FROM PCL1                      (del) QICK11K094643
      SELECT * FROM PCL1                                  &quot;QICK11K094643
             WHERE RELID EQ BUFFER_DIR-RELID
             AND SRTFD EQ BUFFER_DIR-SRTFD
*            AND SRTF2 EQ AUX_SRTF2.                 (del) QICK11K094643
             ORDER BY PRIMARY KEY.                        &quot;QICK11K094643
        TBUFF = PCL1.
        TBUFF-SGART = SAVE-SGART.
        APPEND TBUFF.                                     &quot;QICK11K094643
        IF TBUFF-SRTF2 EQ 0.                              &quot;QICK11K094643
          TBUFF-TABIX = SY-TABIX.                         &quot;QICK11K094643
        ENDIF. &quot;TBUFF-SRTF2 EQ 0.                         &quot;QICK11K094643
      ENDSELECT. &quot;* FROM PCL1                             &quot;QICK11K094643
    WHEN &apos;P2&apos;.
*     SELECT SINGLE * FROM PCL2                      (del) QICK11K094643
      SELECT * FROM PCL2                                  &quot;QICK11K094643
             WHERE RELID EQ BUFFER_DIR-RELID
             AND SRTFD EQ BUFFER_DIR-SRTFD
*            AND SRTF2 EQ AUX_SRTF2.                 (del) QICK11K094643
             ORDER BY PRIMARY KEY.                        &quot;QICK11K094643
        TBUFF = PCL2.
        TBUFF-SGART = SAVE-SGART.
        APPEND TBUFF.                                     &quot;QICK11K094643
        IF TBUFF-SRTF2 EQ 0.                              &quot;QICK11K094643
          TBUFF-TABIX = SY-TABIX.                         &quot;QICK11K094643
        ENDIF. &quot;TBUFF-SRTF2 EQ 0.                         &quot;QICK11K094643
      ENDSELECT. &quot;* FROM PCL2                             &quot;QICK11K094643
    WHEN &apos;P3&apos;.
      SELECT * FROM PCL3                                  &quot;QICK11K094643
             WHERE RELID EQ BUFFER_DIR-RELID
             AND SRTFD EQ BUFFER_DIR-SRTFD
             ORDER BY PRIMARY KEY.                        &quot;QICK11K094643
      TBUFF = PCL3.
      TBUFF-SGART = SAVE-SGART.
      APPEND TBUFF.                                       &quot;QICK11K094643
      IF TBUFF-SRTF2 EQ 0.                                &quot;QICK11K094643
        TBUFF-TABIX = SY-TABIX.                           &quot;QICK11K094643
      ENDIF. &quot;TBUFF-SRTF2 EQ 0.                           &quot;QICK11K094643
    ENDSELECT. &quot;* FROM PCL3                               &quot;QICK11K094643
    WHEN &apos;P4&apos;.
      SELECT * FROM PCL4                                  &quot;QICK11K094643
             WHERE RELID EQ BUFFER_DIR-RELID
             AND SRTFD EQ BUFFER_DIR-SRTFD
             ORDER BY PRIMARY KEY.
      TBUFF = PCL4.
      TBUFF-SGART = SAVE-SGART.
      APPEND TBUFF.
      IF TBUFF-SRTF2 EQ 0.
        TBUFF-TABIX = SY-TABIX.
      ENDIF. &quot;TBUFF-SRTF2 EQ 0.
    ENDSELECT. &quot;* FROM PCL4
  ENDCASE.
  READ-PCLX-SUBRC = SY-SUBRC.
  IF READ-PCLX-SUBRC EQ 0.
*   APPEND TBUFF.                                    (del) QICK11K094643
*   TBUFF-TABIX = SY-TABIX.                          (del) QICK11K094643
    BUFFER_DIR-NNUXT = TBUFF-SRTF2.
    PERFORM READ_DB_SUB1.
    READ TABLE TBUFF INDEX TBUFF-TABIX.                   &quot;QICK11K094643
  ELSE.
    PERFORM READ_DB_SUB2.              &quot;no record found.
  ENDIF.
  READ-SUBRC = READ-PCLX-SUBRC.
ENDFORM. &quot;READ_PCLX

FORM READ_DB_SUB1.
* IF AUX_SRTF2 EQ 0.                                 (del) QICK11K094643
  BUFFER_DIR-NTABX = TBUFF-TABIX.    &quot;location of the record
  BUFFER_DIR-OTABX = 0.
  BUFFER_DIR-ONUXT = 0.
  PERFORM MOD_DIR.
* ELSE.                                              (del) QICK11K094643
*   MODIFY BUFFER_DIR INDEX DIR-TABIX.               (del) QICK11K094643
* ENDIF.                                             (del) QICK11K094643
ENDFORM. &quot;READ_DB_SUB1

FORM READ_DB_SUB2.
* IF AUX_SRTF2 EQ 0.                                 (del) QICK11K094643
  BUFFER_DIR-NTABX = 0.
  BUFFER_DIR-NNUXT = 0.
* no before-image:
  BUFFER_DIR-OTABX = &apos;77777-&apos;.
  BUFFER_DIR-ONUXT = 0.
  PERFORM MOD_DIR.
* ELSE.                                              (del) QICK11K094643
*   internal error:  handling of extents
* ENDIF.                                             (del) QICK11K094643
ENDFORM. &quot;READ_DB_SUB2


FORM MOD_DIR.
* to be performed only in case of SRTF2 = 0
  CASE READ-DIR-SUBRC.
    WHEN 8. APPEND BUFFER_DIR. DIR-TABIX = SY-TABIX.
    WHEN 4. INSERT BUFFER_DIR INDEX DIR-TABIX.
*   when 0. internal error in directory-maintainance
  ENDCASE.
ENDFORM. &quot;MOD_DIR


FORM MAINTAIN_DIR.    &quot;directory-maintainance when updating the buffer
   IF TBUFF-SRTF2 EQ 0.
     AUX_ONUXT = BUFFER_DIR-NNUXT.
   ENDIF.
   BUFFER_DIR-NNUXT = TBUFF-SRTF2.
   IF TBUFF-SRTF2 EQ 0.
     CASE READ-DIR-SUBRC.
       WHEN 0. &quot;update
         IF BUFFER_DIR-OTABX EQ 0.
           BUFFER_DIR-OTABX = - BUFFER_DIR-NTABX.
           BUFFER_DIR-ONUXT = AUX_ONUXT.
         ENDIF.
         BUFFER_DIR-NTABX = TBUFF-TABIX.
         MODIFY BUFFER_DIR INDEX DIR-TABIX.
       WHEN 4. &quot;insert
         PERFORM ASSIGN_DIR.
         INSERT BUFFER_DIR INDEX DIR-TABIX.
       WHEN 8. &quot;append
         PERFORM ASSIGN_DIR.
         APPEND BUFFER_DIR.
         DIR-TABIX = SY-TABIX.
     ENDCASE.
   ELSE.
     MODIFY BUFFER_DIR INDEX DIR-TABIX.
   ENDIF.
ENDFORM.  &quot;MAINTAIN_DIR


FORM ASSIGN_DIR.   &quot;assign header-values in case of INSERT or APPEND
   BUFFER_DIR(47) = DIR_KEY.
   BUFFER_DIR-NTABX = TBUFF-TABIX.
*  no before-image:
   BUFFER_DIR-OTABX = &apos;77777-&apos;.
   BUFFER_DIR-ONUXT = 0.
ENDFORM. &quot;ASSIGN_DIR




FORM PREPARE_UPDATE USING
            VERBUCHUNG   TYPE C.
*ORM PREPARE_UPDATE USING VERBUCHUNG.
*-----------------------------------------------------------------------
* BEFORE_IMAGE_PCLX and (after-image) TBUFF are prepared
* for delivery to APLZ
*-----------------------------------------------------------------------
* NTABX EQ 0 &lt;==&gt; &quot;no record found&quot; AND &quot;no update&quot;
* OTABX EQ 0 &lt;==&gt; &quot;record found&quot; AND &quot;no update&quot;
*-----------------------------------------------------------------------

  DEL-COUNTER = 0.
  LOOP AT TBUFF.
    TBUFF-TABIX = SY-TABIX.
    DIR_KEY-SGART = TBUFF-SGART.
    DIR_KEY+2 = TBUFF.
    PERFORM LOOP_VALUES.
    IF TBUFF-TABIX GE OTABX-LOW AND TBUFF-TABIX LE OTABX-HIGH.
*     before-image
*     append BEFORE_IMAGE_PCLX and delete entry from TBUFF
*     maintain directory-entry OTABX
      PERFORM FUNCTION_BEFORE_IMAGE.
    ELSE.
      IF TBUFF-TABIX GE NTABX-LOW AND TBUFF-TABIX LE NTABX-HIGH
                                  AND AUX_OTABX NE 0.
*       after-image
*       do nothing else than maintaining directory-entry NTABX
        PERFORM FUNCTION_AFTER_IMAGE.
      ELSE.
*       neither before-image nor after-image means rubbish
        ADD 1 TO DEL-COUNTER.
        DELETE TBUFF.
      ENDIF.
    ENDIF.
  ENDLOOP.   &quot;TBUFF

* delete unused directory-entries
* NTABX = 0 and OTABX = 0, respectively, indicate that no update
* has been made
  LOOP AT BUFFER_DIR WHERE NTABX EQ 0 OR OTABX EQ 0.
    DELETE BUFFER_DIR.
  ENDLOOP.

* final update of the database
  CASE VERBUCHUNG.
    WHEN &apos;P&apos;. &quot;payroll?
    WHEN &apos;V&apos;. &quot;update program
      PERFORM UPDATE_DATA(RPPPXV00).
      RP-INIT-BUFFER.
  ENDCASE.

ENDFORM.  &quot;prepare_update


FORM LOOP_VALUES.
  IF TBUFF-SRTF2 EQ 0.
    READ TABLE BUFFER_DIR WITH KEY DIR_KEY BINARY SEARCH.    &quot;#EC *
    IF SY-SUBRC EQ 0.
      DIR-TABIX = SY-TABIX.
      AUX_NTABX = BUFFER_DIR-NTABX.
      IF BUFFER_DIR-OTABX LE 0.
        AUX_OTABX = - BUFFER_DIR-OTABX.
      ELSE.
        AUX_OTABX = &apos;77777-&apos;.
      ENDIF.
    ELSE.
      CLEAR BUFFER_DIR.
      CLEAR AUX_OTABX.
      CLEAR AUX_NTABX.
    ENDIF.
  ENDIF.
  OTABX-LOW  = AUX_OTABX - DEL-COUNTER.
  OTABX-HIGH = OTABX-LOW + BUFFER_DIR-ONUXT.
  NTABX-LOW  = AUX_NTABX - DEL-COUNTER.
  NTABX-HIGH = NTABX-LOW + BUFFER_DIR-NNUXT.
ENDFORM. &quot;LOOP_VALUES


FORM FUNCTION_BEFORE_IMAGE.
  BEFORE_IMAGE_PCLX = TBUFF.
  APPEND BEFORE_IMAGE_PCLX.               &quot; &lt;------/
  IF TBUFF-SRTF2 EQ 0.                    &quot;       /  (sy-tabix)
    BUFFER_DIR-OTABX = SY-TABIX.          &quot; &lt;----/
    MODIFY BUFFER_DIR INDEX DIR-TABIX.
  ENDIF.
  ADD 1 TO DEL-COUNTER.
  DELETE TBUFF. &quot;#EC * caller only PREPARE_UPDATE QICPL0K004475
ENDFORM. &quot;before-image

FORM FUNCTION_AFTER_IMAGE.
  IF TBUFF-SRTF2 EQ 0.
    BUFFER_DIR-NTABX = TBUFF-TABIX.
    MODIFY BUFFER_DIR INDEX DIR-TABIX.
  ENDIF.
ENDFORM. &quot;after-image

FORM AUTHORITY_CHECK USING OPERATION type clike. &quot;ANDUNI  &quot;QICK11K126112
* data: authc(1).                     (del) QICP30K074825 &quot;QICK11K126112
* authc = operation.                  (del) QICP30K074825 &quot;QICK11K126112

  clear sy-subrc.
  IF OPERATION = &apos;READ&apos; AND                               &quot;YKMP40K011038
     NO_AUTHORITY_CHECK_CLUSTER = &apos;X&apos;.                    &quot;YKMP40K011038
    MAIN-SUBRC = 0.                                       &quot;YKMP40K011038
    EXIT.                                                 &quot;YKMP40K011038
  ENDIF.                                                  &quot;YKMP40K011038

  IF OPERATION EQ &apos;READ&apos;.                                 &quot;QICP30K074825
    AUTHORITY-CHECK OBJECT &apos;P_PCLX&apos;
      ID &apos;RELID&apos; FIELD TBUFF-RELID
      ID &apos;AUTHC&apos; FIELD &apos;R&apos;.                               &quot;QICP30K074825
  ELSE. &quot;operation eq &apos;UPDATE&apos;                            &quot;QICP30K074825
*   CHECK SAVE-SGART NE &apos;P4&apos;.          (del) QICAHRK053949 QICP30K074825
    if save-sgart ne &apos;P4&apos;.                                &quot;QICAHRK053949
      AUTHORITY-CHECK OBJECT &apos;P_PCLX&apos;                     &quot;QICK11K074825
        ID &apos;RELID&apos; FIELD TBUFF-RELID                      &quot;QICK11K074825
        ID &apos;AUTHC&apos; FIELD &apos;U&apos;.                             &quot;QICP30K074825
      IF SY-SUBRC NE 0.                                   &quot;QICP30K074825
        PCLX_SUBRC = 12.                                  &quot;QICP30K074825
*       second chance for simulation user                 &quot;QICP30K074825
        AUTHORITY-CHECK OBJECT &apos;P_PCLX&apos;                   &quot;QICK11K074825
          ID &apos;RELID&apos; FIELD TBUFF-RELID                    &quot;QICK11K074825
          ID &apos;AUTHC&apos; FIELD &apos;S&apos;.                           &quot;QICP30K074825
      ENDIF.                                              &quot;QICP30K074825
    else.                                                 &quot;QICAHRK053949
      main-subrc = 0.                                     &quot;QICAHRK053949
    endif.                                                &quot;QICAHRK053949
  ENDIF.                                                  &quot;QICP30K074825
  IF SY-SUBRC EQ 0.
    MAIN-SUBRC = 0.
  ELSE.
    MAIN-SUBRC = 12.
  ENDIF. &quot;SY-SUBRC EQ 0.

ENDFORM. &quot;AUTHORITY_CHECK USING OPERATION</include_source>
   </include>
  </includeprograms>
  <functionmodules>
   <functionmodule NAME="Z_PAYROLL_CLUSTER" STEXT="Read Payroll Clusters">
    <importing PARAMETER="PERNR" REFERENCE="X" TYP="PERNR_D"/>
    <tables PARAMETER="GT_RT" DBSTRUCT="PC207"/>
    <documentation PARAMETER="PERNR" KIND="P" STEXT="Personnel Number" INDEX=" 001"/>
    <documentation PARAMETER="GT_RT" KIND="P" STEXT="Payroll Results: Results Table" INDEX=" 002"/>
    <fm_source_new>*-- Import CU (Cluster Directory) Cluster
* CU Cluster have Table RGDIR which contains the directory of all of an Employee&apos;s Payroll results
  CLEAR rp-imp-cd-subrc.
  cd-key-pernr = pernr.   &quot;Fill the Key for reading CU cluste
  rp-imp-c2-cu.     &quot;MACRO to Import CU Cluster
  CHECK rp-imp-cd-subrc = 0.

* Deleting all srtza &lt;&gt; &apos;A&apos; ensures you only have &quot;Actual&quot; results (A for Actual/Current, P for Previous and O for Old).
  DELETE rgdir WHERE srtza &lt;&gt; &apos;A&apos;.
  IF rgdir[] IS INITIAL.
    REJECT.
  ENDIF.

  SORT rgdir BY fpper DESCENDING.

* So we have Table RGDIR, now what is left is opening cluster PCL2 with the rgdir key, so you can access RT, CRT, etc, etc.
  LOOP AT rgdir.
    CLEAR rx-key-pernr.
    CLEAR rx-key-seqno.

*-- Import RQ (Payroll Results South Africa) Cluster
    rx-key-pernr = pernr.   &quot;Fill the Key for reading RQ cluster
    rx-key-seqno = rgdir-seqnr.   &quot;Fill the Key for reading RQ cluster
    rp-imp-c2-rw.   &quot;MACRO to Import RQ Cluster
    CHECK sy-subrc = 0.
    GT_RT[] = RT[].
    EXIT.
  ENDLOOP.</fm_source_new>
   </functionmodule>
  </functionmodules>
 </FUGR>
 <PROG NAME="ZRSWIWILS" VARCL="X" DBAPL="S" DBNA="D$" SUBC="1" APPL="S" SECU="WF_ADMIN" LEVL="31A" RSTAT="P" RMAND="000" RLOAD="E" FIXPT="X" LDBNAME="D$S" UCCHECK="X">
  <textPool>
   <language SPRAS="D">
    <textElement ID="I" KEY="001" ENTRY="Workitems mit gelöschten Usern" LENGTH="45 "/>
    <textElement ID="I" KEY="006" ENTRY="Workitem-Selektion" LENGTH="60 "/>
    <textElement ID="I" KEY="007" ENTRY="Workitem als Administrator bearbeiten" LENGTH="60 "/>
    <textElement ID="I" KEY="008" ENTRY="Workitems ohne Bearbeiter" LENGTH="60 "/>
    <textElement ID="I" KEY="009" ENTRY="Workitems mit Bedingungen zum Starten oder Beenden" LENGTH="60 "/>
    <textElement ID="I" KEY="010" ENTRY="Workitems mit Bearbeitern" LENGTH="60 "/>
    <textElement ID="I" KEY="011" ENTRY="Restart von suspendierten Callbacks" LENGTH="60 "/>
    <textElement ID="I" KEY="012" ENTRY="Restart von suspendierten Deadline-Callbacks" LENGTH="60 "/>
    <textElement ID="I" KEY="013" ENTRY="Restart abgebrochene Hintergrund-Workitems" LENGTH="60 "/>
    <textElement ID="I" KEY="014" ENTRY="(&amp;1 Einträge)" LENGTH="20 "/>
    <textElement ID="I" KEY="015" ENTRY="(1 Eintrag)" LENGTH="20 "/>
    <textElement ID="I" KEY="100" ENTRY="Aufgabe über Methode" LENGTH="60 "/>
    <textElement ID="I" KEY="101" ENTRY="Bitte Objekttyp/Methode eingeben" LENGTH="60 "/>
    <textElement ID="I" KEY="A01" ENTRY="Selektion über Workitem-Kennung" LENGTH="60 "/>
    <textElement ID="I" KEY="A02" ENTRY="Selektion über Workitem-Eigenschaften" LENGTH="60 "/>
    <textElement ID="I" KEY="A03" ENTRY="Selektion über Zeitraum" LENGTH="60 "/>
    <textElement ID="I" KEY="A04" ENTRY="Ausgabeoptionen (+Version, +Administrator)" LENGTH="60 "/>
    <textElement ID="R" ENTRY="Selektionsreport für Workitems" LENGTH="30 "/>
    <textElement ID="S" KEY="CD" ENTRY="        Erzeugungsdatum" LENGTH="23 "/>
    <textElement ID="S" KEY="CT" ENTRY="        Erzeugungszeit" LENGTH="22 "/>
    <textElement ID="S" KEY="DHSTA" ENTRY="        Deadlinestatus" LENGTH="22 "/>
    <textElement ID="S" KEY="ID" ENTRY="        Kennung" LENGTH="15 "/>
    <textElement ID="S" KEY="KOSTL" ENTRY="        Cost Centre" LENGTH="19 "/>
    <textElement ID="S" KEY="PRIO" ENTRY="        Priorität" LENGTH="17 "/>
    <textElement ID="S" KEY="P_MORE" ENTRY="        Einschalten" LENGTH="19 "/>
    <textElement ID="S" KEY="STATE" ENTRY="        Status" LENGTH="14 "/>
    <textElement ID="S" KEY="TASK" ENTRY="        Aufgabe" LENGTH="15 "/>
    <textElement ID="S" KEY="TASKG" ENTRY="        Aufgabengruppe" LENGTH="22 "/>
    <textElement ID="S" KEY="TOP_ONLY" ENTRY="        Nur top-level Workitems" LENGTH="31 "/>
    <textElement ID="S" KEY="TYPE" ENTRY="        Typ" LENGTH="11 "/>
   </language>
   <language SPRAS="E">
    <textElement ID="I" KEY="001" ENTRY="Work Items with Deleted Users" LENGTH="45 "/>
    <textElement ID="I" KEY="006" ENTRY="Work Item Selection" LENGTH="60 "/>
    <textElement ID="I" KEY="007" ENTRY="Process Work Item As Administrator" LENGTH="60 "/>
    <textElement ID="I" KEY="008" ENTRY="Work Items Without Agents" LENGTH="60 "/>
    <textElement ID="I" KEY="009" ENTRY="Work Items with Conditions for Starting or Completing" LENGTH="60 "/>
    <textElement ID="I" KEY="010" ENTRY="Work Items With Agents" LENGTH="60 "/>
    <textElement ID="I" KEY="011" ENTRY="Restart Suspended Callbacks" LENGTH="60 "/>
    <textElement ID="I" KEY="012" ENTRY="Restart Suspended Deadline Callbacks" LENGTH="60 "/>
    <textElement ID="I" KEY="013" ENTRY="Restart Terminated Work Items" LENGTH="60 "/>
    <textElement ID="I" KEY="014" ENTRY="(&amp;1 Entries)" LENGTH="20 "/>
    <textElement ID="I" KEY="015" ENTRY="(1 Entry)" LENGTH="20 "/>
    <textElement ID="I" KEY="100" ENTRY="Task Using Method" LENGTH="60 "/>
    <textElement ID="I" KEY="101" ENTRY="Enter Object Type/Method" LENGTH="60 "/>
    <textElement ID="I" KEY="A01" ENTRY="Selection Using Work Item ID" LENGTH="60 "/>
    <textElement ID="I" KEY="A02" ENTRY="Selection Using Work Item Properties" LENGTH="60 "/>
    <textElement ID="I" KEY="A03" ENTRY="Selection Using Time Period" LENGTH="60 "/>
    <textElement ID="I" KEY="A04" ENTRY="Output Options (+Version, +Administrator)" LENGTH="60 "/>
    <textElement ID="R" ENTRY="Selection Report for Work Items" LENGTH="31 "/>
    <textElement ID="S" KEY="CD" ENTRY="        Creation Date" LENGTH="23 "/>
    <textElement ID="S" KEY="CT" ENTRY="        Creation Time" LENGTH="22 "/>
    <textElement ID="S" KEY="DHSTA" ENTRY="        Deadline Status" LENGTH="23 "/>
    <textElement ID="S" KEY="ID" ENTRY="        Identification" LENGTH="22 "/>
    <textElement ID="S" KEY="KOSTL" ENTRY="        Cost Centre" LENGTH="19 "/>
    <textElement ID="S" KEY="NOT_POST" ENTRY="        Completed but not posted" LENGTH="32 "/>
    <textElement ID="S" KEY="PERNR" ENTRY="        Personnel Number" LENGTH="24 "/>
    <textElement ID="S" KEY="PRIO" ENTRY="        Priority" LENGTH="17 "/>
    <textElement ID="S" KEY="P_MORE" ENTRY="        Switch On" LENGTH="19 "/>
    <textElement ID="S" KEY="STATE" ENTRY="        Status" LENGTH="14 "/>
    <textElement ID="S" KEY="TASK" ENTRY="        Task" LENGTH="15 "/>
    <textElement ID="S" KEY="TASKG" ENTRY="        Task Group" LENGTH="22 "/>
    <textElement ID="S" KEY="TOP_ONLY" ENTRY="        Top-Level Work Items Only" LENGTH="33 "/>
    <textElement ID="S" KEY="TYPE" ENTRY="        Type" LENGTH="12 "/>
   </language>
  </textPool>
  <pfstatus>
   <pfstatus_sta CODE="STANDARD" MODAL="D" ACTCODE="000015" PFKCODE="000018" BUTCODE="0001" INT_NOTE="Standard for Work Item Reporting"/>
   <pfstatus_fun CODE="%ML" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Folder" PATH="F"/>
   <pfstatus_fun CODE="%PC" TEXTNO="01" TEXT_TYPE="S" TEXT_NAME="ICON_EXPORT" ICON_ID="@49@" FUN_TEXT="Local File..." PATH="L"/>
   <pfstatus_fun CODE="%SC" TEXTNO="003" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH" ICON_ID="@13@" FUN_TEXT="Search" PATH="S"/>
   <pfstatus_fun CODE="%SC+" TEXTNO="01" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH_NEXT" ICON_ID="@4E@" FUN_TEXT="Find Next"/>
   <pfstatus_fun CODE="%SERP" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Report Tree" PATH="E"/>
   <pfstatus_fun CODE="%SL" TEXTNO="01" TEXT_TYPE="S" TEXT_NAME="ICON_MAIL" ICON_ID="@1S@" FUN_TEXT="Mail Recipient" PATH="M"/>
   <pfstatus_fun CODE="&amp;ALL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_ALL" ICON_ID="@4B@" FUN_TEXT="Select All" PATH="M"/>
   <pfstatus_fun CODE="&amp;AQW" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_WORD_PROCESSING" ICON_ID="@DK@" FUN_TEXT="Word Processing..." PATH="W"/>
   <pfstatus_fun CODE="&amp;AVE" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Saving..." PATH="S"/>
   <pfstatus_fun CODE="&amp;AVE" TEXTNO="002" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANT_SAVE" ICON_ID="@DN@" FUN_TEXT="Save Layout"/>
   <pfstatus_fun CODE="&amp;AVR" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Mean Value" PATH="M"/>
   <pfstatus_fun CODE="&amp;BS" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_OVERVIEW" ICON_ID="@3Q@" FUN_TEXT="Overview of List Sections"/>
   <pfstatus_fun CODE="&amp;BS+" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_PREVIOUS_VALUE" ICON_ID="@0H@" FUN_TEXT="Next Section"/>
   <pfstatus_fun CODE="&amp;CDF" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Unfreeze Columns" PATH="U"/>
   <pfstatus_fun CODE="&amp;CFI" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Freeze to Column" PATH="F"/>
   <pfstatus_fun CODE="&amp;COUNT" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Count" PATH="C"/>
   <pfstatus_fun CODE="&amp;CRB" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TOTAL_LEFT" ICON_ID="@0B@" FUN_TEXT="First Column"/>
   <pfstatus_fun CODE="&amp;CRE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TOTAL_RIGHT" ICON_ID="@0C@" FUN_TEXT="Last Column"/>
   <pfstatus_fun CODE="&amp;CRL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_COLUMN_LEFT" ICON_ID="@0D@" FUN_TEXT="Column Left"/>
   <pfstatus_fun CODE="&amp;CRR" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_COLUMN_RIGHT" ICON_ID="@0E@" FUN_TEXT="Column Right"/>
   <pfstatus_fun CODE="&amp;EB3" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TABLE_SETTINGS" ICON_ID="@36@" FUN_TEXT="More Reports"/>
   <pfstatus_fun CODE="&amp;ELP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYSTEM_HELP" ICON_ID="@35@" FUN_TEXT="Help"/>
   <pfstatus_fun CODE="&amp;ERW" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Administration" PATH="A"/>
   <pfstatus_fun CODE="&amp;ETA" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_DETAIL" ICON_ID="@3R@" FUN_TEXT="Choose Detail"/>
   <pfstatus_fun CODE="&amp;F03" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Back" PATH="B"/>
   <pfstatus_fun CODE="&amp;F12" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel" PATH="A"/>
   <pfstatus_fun CODE="&amp;F15" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Exit" PATH="X"/>
   <pfstatus_fun CODE="&amp;IC1" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SELECT_DETAIL" ICON_ID="@16@" FUN_TEXT="Choose"/>
   <pfstatus_fun CODE="&amp;ILD" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Delete Filter" PATH="L"/>
   <pfstatus_fun CODE="&amp;ILT" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_FILTER" ICON_ID="@4G@" FUN_TEXT="Set Filter" PATH="F"/>
   <pfstatus_fun CODE="&amp;LFO" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="List Status..." PATH="L"/>
   <pfstatus_fun CODE="&amp;LFO" TEXTNO="002" TEXT_TYPE="S" TEXT_NAME="ICON_INFORMATION" ICON_ID="@0S@" FUN_TEXT="List Status..."/>
   <pfstatus_fun CODE="&amp;LIS" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Basic List" PATH="G"/>
   <pfstatus_fun CODE="&amp;MAX" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Maximum" PATH="A"/>
   <pfstatus_fun CODE="&amp;MIN" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Minimum" PATH="I"/>
   <pfstatus_fun CODE="&amp;NFO" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INFORMATION" ICON_ID="@0S@" FUN_TEXT="Selections..." ICON_TEXT="Selections" PATH="E"/>
   <pfstatus_fun CODE="&amp;NTE" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Refresh"/>
   <pfstatus_fun CODE="&amp;OAD" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Choose..." PATH="H"/>
   <pfstatus_fun CODE="&amp;OAD" TEXTNO="002" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANT_CHOOSE" ICON_ID="@DM@" FUN_TEXT="Select Layout..."/>
   <pfstatus_fun CODE="&amp;ODN" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SORT_DOWN" ICON_ID="@3F@" FUN_TEXT="Sort in Descending Order" PATH="O"/>
   <pfstatus_fun CODE="&amp;OL0" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ALV_VARIANTS" ICON_ID="@LZ@" FUN_TEXT="Change Layout"/>
   <pfstatus_fun CODE="&amp;OLX" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_VARIANTS" ICON_ID="@0R@" FUN_TEXT="Change..." PATH="C"/>
   <pfstatus_fun CODE="&amp;OMP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_COLLAPSE" ICON_ID="@3T@" FUN_TEXT="Collapse"/>
   <pfstatus_fun CODE="&amp;OPT" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Optimize Width" PATH="P"/>
   <pfstatus_fun CODE="&amp;OUP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SORT_UP" ICON_ID="@3E@" FUN_TEXT="Sort in Ascending Order" PATH="I"/>
   <pfstatus_fun CODE="&amp;RNT" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_PRINT" ICON_ID="@0X@" FUN_TEXT="Print" PATH="P"/>
   <pfstatus_fun CODE="&amp;RNT_PREV" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_LAYOUT_CONTROL" ICON_ID="@3G@" FUN_TEXT="Print Preview" PATH="R"/>
   <pfstatus_fun CODE="&amp;SAL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_DESELECT_ALL" ICON_ID="@4D@" FUN_TEXT="Deselect All" PATH="K"/>
   <pfstatus_fun CODE="&amp;SUM" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INTERMEDIATE_SUM" ICON_ID="@5V@" FUN_TEXT="Subtotal..." PATH="Z"/>
   <pfstatus_fun CODE="&amp;UMC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SUM" ICON_ID="@3Z@" FUN_TEXT="Display Sum" PATH="D"/>
   <pfstatus_fun CODE="&amp;XINT" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Extended SAP Query Repository" PATH="E"/>
   <pfstatus_fun CODE="&amp;XML" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="XML Export..." PATH="X"/>
   <pfstatus_fun CODE="&amp;XPA" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXPAND" ICON_ID="@3S@" FUN_TEXT="Expand"/>
   <pfstatus_fun CODE="&amp;XXL" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_XXL" ICON_ID="@DJ@" FUN_TEXT="Spreadsheet..." PATH="A"/>
   <pfstatus_fun CODE="1REF" TEXTNO="01" TEXT_TYPE="S" TEXT_NAME="ICON_REFRESH" ICON_ID="@42@" FUN_TEXT="Refresh" PATH="A"/>
   <pfstatus_fun CODE="ADBA" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_WF_REPLACE_WORKITEM" ICON_ID="@D1@" FUN_TEXT="Replace Manually" ICON_TEXT="Replace Manually" PATH="M"/>
   <pfstatus_fun CODE="ADCA" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Logically Delete"/>
   <pfstatus_fun CODE="ADMC" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Logically Delete" PATH="L"/>
   <pfstatus_fun CODE="ADMF" TEXTNO="01" TEXT_TYPE="S" FUN_TEXT="Complete Manually" PATH="N"/>
   <pfstatus_fun CODE="ADMS" TEXTNO="01" TEXT_TYPE="S" FUN_TEXT="Restart After Error" PATH="R"/>
   <pfstatus_fun CODE="AEXE" TEXTNO="01" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Execute Without Check" ICON_TEXT="Without Check" PATH="U"/>
   <pfstatus_fun CODE="AGAS" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_BUSINAV_SYSORGI" ICON_ID="@4U@" FUN_TEXT="Maintain Possible Agents"/>
   <pfstatus_fun CODE="APRO" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Execute Work Item" PATH="I"/>
   <pfstatus_fun CODE="ASND" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_LETTER" ICON_ID="@KO@" FUN_TEXT="Administrator Forward" PATH="W"/>
   <pfstatus_fun CODE="COND" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_WORKFLOW_CONDITION" ICON_ID="@5I@" FUN_TEXT="Check Conditions" PATH="C"/>
   <pfstatus_fun CODE="CONT" TEXTNO="01" TEXT_TYPE="S" TEXT_NAME="ICON_WORKFLOW_CONT_OPERATION" ICON_ID="@5K@" FUN_TEXT="Display Container" INFO_TEXT="Display Work Item Container" PATH="D"/>
   <pfstatus_fun CODE="DISP" TEXTNO="01" TEXT_TYPE="S" TEXT_NAME="ICON_DISPLAY" ICON_ID="@10@" FUN_TEXT="Display Work Item" PATH="O"/>
   <pfstatus_fun CODE="PAAS" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_BUSINAV_SYSORGI" ICON_ID="@4U@" FUN_TEXT="Assign Possible Agents"/>
   <pfstatus_fun CODE="RULE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ROLE" ICON_ID="@IR@" FUN_TEXT="Execute Agent Rules" PATH="E"/>
   <pfstatus_fun CODE="SWP_SUSPEND_ACTIVE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ACTIVATE" ICON_ID="@3C@" FUN_TEXT="Reactivate Entry" PATH="E"/>
   <pfstatus_fun CODE="TECH" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="Technical Data" PATH="H"/>
   <pfstatus_fun CODE="WIFI" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_HISTORY" ICON_ID="@96@" FUN_TEXT="Display Workflow Log" PATH="K"/>
   <pfstatus_fun CODE="WIHI" TEXTNO="01" TEXT_TYPE="S" FUN_TEXT="History" PATH="H"/>
   <pfstatus_fun CODE="WIRH" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TASK" ICON_ID="@BK@" FUN_TEXT="Display Task" PATH="A"/>
   <pfstatus_fun CODE="WTOF" TEXTNO="01" TEXT_TYPE="S" FUN_TEXT="Switch Off Workflow Trace" PATH="C"/>
   <pfstatus_fun CODE="WTON" TEXTNO="01" TEXT_TYPE="S" FUN_TEXT="Switch On Workflow Trace" PATH="T"/>
   <pfstatus_men CODE="000024" NO="01" REF_TYPE="F" REF_CODE="&amp;RNT_PREV" REF_NO="001"/>
   <pfstatus_men CODE="000024" NO="02" REF_TYPE="F" REF_CODE="&amp;RNT" REF_NO="001"/>
   <pfstatus_men CODE="000024" NO="03" REF_TYPE="S"/>
   <pfstatus_men CODE="000024" NO="04" REF_TYPE="M" REF_CODE="000025"/>
   <pfstatus_men CODE="000024" NO="05" REF_TYPE="M" REF_CODE="000035"/>
   <pfstatus_men CODE="000024" NO="06" REF_TYPE="S"/>
   <pfstatus_men CODE="000024" NO="07" REF_TYPE="F" REF_CODE="&amp;F15" REF_NO="001"/>
   <pfstatus_men CODE="000025" NO="01" REF_TYPE="F" REF_CODE="&amp;AQW" REF_NO="001"/>
   <pfstatus_men CODE="000025" NO="02" REF_TYPE="F" REF_CODE="&amp;XXL" REF_NO="001"/>
   <pfstatus_men CODE="000025" NO="03" REF_TYPE="F" REF_CODE="%PC" REF_NO="01"/>
   <pfstatus_men CODE="000025" NO="04" REF_TYPE="F" REF_CODE="&amp;XINT" REF_NO="001"/>
   <pfstatus_men CODE="000025" NO="05" REF_TYPE="F" REF_CODE="&amp;XML" REF_NO="001"/>
   <pfstatus_men CODE="000026" NO="01" REF_TYPE="M" REF_CODE="000034"/>
   <pfstatus_men CODE="000026" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000026" NO="03" REF_TYPE="F" REF_CODE="&amp;ILT" REF_NO="001"/>
   <pfstatus_men CODE="000026" NO="04" REF_TYPE="F" REF_CODE="&amp;ILD" REF_NO="001"/>
   <pfstatus_men CODE="000026" NO="05" REF_TYPE="S"/>
   <pfstatus_men CODE="000026" NO="06" REF_TYPE="F" REF_CODE="&amp;OUP" REF_NO="001"/>
   <pfstatus_men CODE="000026" NO="07" REF_TYPE="F" REF_CODE="&amp;ODN" REF_NO="001"/>
   <pfstatus_men CODE="000026" NO="08" REF_TYPE="S"/>
   <pfstatus_men CODE="000026" NO="09" REF_TYPE="M" REF_CODE="000036"/>
   <pfstatus_men CODE="000026" NO="10" REF_TYPE="S"/>
   <pfstatus_men CODE="000026" NO="11" REF_TYPE="F" REF_CODE="%SC" REF_NO="003"/>
   <pfstatus_men CODE="000026" NO="12" REF_TYPE="S"/>
   <pfstatus_men CODE="000026" NO="13" REF_TYPE="F" REF_CODE="SWP_SUSPEND_ACTIVE" REF_NO="001"/>
   <pfstatus_men CODE="000026" NO="14" REF_TYPE="S"/>
   <pfstatus_men CODE="000026" NO="15" REF_TYPE="F" REF_CODE="&amp;F12" REF_NO="001"/>
   <pfstatus_men CODE="000027" NO="01" REF_TYPE="F" REF_CODE="WIHI" REF_NO="01"/>
   <pfstatus_men CODE="000027" NO="02" REF_TYPE="F" REF_CODE="CONT" REF_NO="01"/>
   <pfstatus_men CODE="000027" NO="03" REF_TYPE="S"/>
   <pfstatus_men CODE="000027" NO="04" REF_TYPE="F" REF_CODE="WIRH" REF_NO="001"/>
   <pfstatus_men CODE="000027" NO="05" REF_TYPE="S"/>
   <pfstatus_men CODE="000027" NO="06" REF_TYPE="F" REF_CODE="WTON" REF_NO="01"/>
   <pfstatus_men CODE="000027" NO="07" REF_TYPE="F" REF_CODE="WTOF" REF_NO="01"/>
   <pfstatus_men CODE="000027" NO="08" REF_TYPE="S"/>
   <pfstatus_men CODE="000027" NO="09" REF_TYPE="F" REF_CODE="&amp;F03" REF_NO="001"/>
   <pfstatus_men CODE="000028" NO="01" REF_TYPE="M" REF_CODE="000029"/>
   <pfstatus_men CODE="000028" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000028" NO="03" REF_TYPE="M" REF_CODE="000031"/>
   <pfstatus_men CODE="000028" NO="04" REF_TYPE="S"/>
   <pfstatus_men CODE="000028" NO="05" REF_TYPE="F" REF_CODE="&amp;NFO" REF_NO="001"/>
   <pfstatus_men CODE="000028" NO="06" REF_TYPE="F" REF_CODE="&amp;LFO" REF_NO="001"/>
   <pfstatus_men CODE="000029" NO="01" REF_TYPE="F" REF_CODE="&amp;OLX" REF_NO="001"/>
   <pfstatus_men CODE="000029" NO="02" REF_TYPE="F" REF_CODE="&amp;OAD" REF_NO="001"/>
   <pfstatus_men CODE="000029" NO="03" REF_TYPE="S"/>
   <pfstatus_men CODE="000029" NO="04" REF_TYPE="F" REF_CODE="&amp;AVE" REF_NO="001"/>
   <pfstatus_men CODE="000029" NO="05" REF_TYPE="S"/>
   <pfstatus_men CODE="000029" NO="06" REF_TYPE="F" REF_CODE="&amp;ERW" REF_NO="001"/>
   <pfstatus_men CODE="000031" NO="01" REF_TYPE="F" REF_CODE="&amp;OPT" REF_NO="001"/>
   <pfstatus_men CODE="000031" NO="02" REF_TYPE="S"/>
   <pfstatus_men CODE="000031" NO="03" REF_TYPE="F" REF_CODE="&amp;CFI" REF_NO="001"/>
   <pfstatus_men CODE="000031" NO="04" REF_TYPE="F" REF_CODE="&amp;CDF" REF_NO="001"/>
   <pfstatus_men CODE="000034" NO="01" REF_TYPE="F" REF_CODE="DISP" REF_NO="01"/>
   <pfstatus_men CODE="000034" NO="02" REF_TYPE="F" REF_CODE="WIFI" REF_NO="001"/>
   <pfstatus_men CODE="000034" NO="03" REF_TYPE="F" REF_CODE="ADMC" REF_NO="001"/>
   <pfstatus_men CODE="000034" NO="04" REF_TYPE="F" REF_CODE="ADMS" REF_NO="01"/>
   <pfstatus_men CODE="000034" NO="05" REF_TYPE="F" REF_CODE="ADMF" REF_NO="01"/>
   <pfstatus_men CODE="000034" NO="06" REF_TYPE="F" REF_CODE="ADBA" REF_NO="001"/>
   <pfstatus_men CODE="000034" NO="07" REF_TYPE="F" REF_CODE="AEXE" REF_NO="01"/>
   <pfstatus_men CODE="000034" NO="08" REF_TYPE="F" REF_CODE="APRO" REF_NO="001"/>
   <pfstatus_men CODE="000034" NO="09" REF_TYPE="F" REF_CODE="COND" REF_NO="001"/>
   <pfstatus_men CODE="000034" NO="10" REF_TYPE="F" REF_CODE="RULE" REF_NO="001"/>
   <pfstatus_men CODE="000034" NO="11" REF_TYPE="F" REF_CODE="ASND" REF_NO="001"/>
   <pfstatus_men CODE="000034" NO="12" REF_TYPE="S"/>
   <pfstatus_men CODE="000034" NO="13" REF_TYPE="F" REF_CODE="TECH" REF_NO="001"/>
   <pfstatus_men CODE="000035" NO="01" REF_TYPE="F" REF_CODE="%SL" REF_NO="01"/>
   <pfstatus_men CODE="000035" NO="02" REF_TYPE="F" REF_CODE="%ML" REF_NO="001"/>
   <pfstatus_men CODE="000035" NO="03" REF_TYPE="F" REF_CODE="%SERP" REF_NO="001"/>
   <pfstatus_men CODE="000036" NO="01" REF_TYPE="F" REF_CODE="&amp;UMC" REF_NO="001"/>
   <pfstatus_men CODE="000036" NO="02" REF_TYPE="F" REF_CODE="&amp;AVR" REF_NO="001"/>
   <pfstatus_men CODE="000036" NO="03" REF_TYPE="F" REF_CODE="&amp;MIN" REF_NO="001"/>
   <pfstatus_men CODE="000036" NO="04" REF_TYPE="F" REF_CODE="&amp;MAX" REF_NO="001"/>
   <pfstatus_men CODE="000036" NO="05" REF_TYPE="F" REF_CODE="&amp;COUNT" REF_NO="001"/>
   <pfstatus_mtx CODE="000024" TEXT_TYPE="S" TEXT="List" PATH="L"/>
   <pfstatus_mtx CODE="000025" TEXT_TYPE="S" TEXT="Export" PATH="E"/>
   <pfstatus_mtx CODE="000026" TEXT_TYPE="S" TEXT="Edit" PATH="E"/>
   <pfstatus_mtx CODE="000027" TEXT_TYPE="S" TEXT="Goto" PATH="G"/>
   <pfstatus_mtx CODE="000028" TEXT_TYPE="S" TEXT="Settings" PATH="S"/>
   <pfstatus_mtx CODE="000029" TEXT_TYPE="S" TEXT="Layout" PATH="A"/>
   <pfstatus_mtx CODE="000031" TEXT_TYPE="S" TEXT="Columns" PATH="C"/>
   <pfstatus_mtx CODE="000034" TEXT_TYPE="S" TEXT="Work Item" PATH="R"/>
   <pfstatus_mtx CODE="000035" TEXT_TYPE="S" TEXT="Send To" PATH="S"/>
   <pfstatus_mtx CODE="000036" TEXT_TYPE="S" TEXT="Calculate" PATH="C"/>
   <pfstatus_act CODE="000015" NO="01" MENUCODE="000024"/>
   <pfstatus_act CODE="000015" NO="02" MENUCODE="000026"/>
   <pfstatus_act CODE="000015" NO="03" MENUCODE="000027"/>
   <pfstatus_act CODE="000015" NO="04" MENUCODE="000028"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="01" PFNO="14"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="02" PFNO="39"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="03" PFNO="S"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="04" PFNO="08"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="05" PFNO="09"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="06" PFNO="47"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="07" PFNO="24"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="08" PFNO="46"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="09" PFNO="17"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="10" PFNO="22"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="11" PFNO="23"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="12" PFNO="48"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="13" PFNO="20"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="14" PFNO="42"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="15" PFNO="21"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="16" PFNO="94"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="17" PFNO="S"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="18" PFNO="41"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="19" PFNO="40"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="20" PFNO="38"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="21" PFNO="S"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="22" PFNO="32"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="23" PFNO="33"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="24" PFNO="36"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="25" PFNO="S"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="26" PFNO="16"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="27" PFNO="44"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="28" PFNO="18"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="29" PFNO="S"/>
   <pfstatus_but PFK_CODE="000018" CODE="0001" NO="30" PFNO="45"/>
   <pfstatus_pfk CODE="000018" PFNO="01" FUNCODE="&amp;ELP" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="02" FUNCODE="&amp;IC1" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="03" FUNCODE="&amp;F03" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="05" FUNCODE="&amp;ALL" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="06" FUNCODE="&amp;SAL" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="07" FUNCODE="&amp;NFO" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="08" FUNCODE="APRO" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="09" FUNCODE="SWP_SUSPEND_ACTIVE" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="12" FUNCODE="&amp;F12" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="13" FUNCODE="&amp;RNT" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="14" FUNCODE="1REF" FUNNO="01"/>
   <pfstatus_pfk CODE="000018" PFNO="15" FUNCODE="&amp;F15" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="16" FUNCODE="%SL" FUNNO="01"/>
   <pfstatus_pfk CODE="000018" PFNO="17" FUNCODE="AEXE" FUNNO="01"/>
   <pfstatus_pfk CODE="000018" PFNO="18" FUNCODE="&amp;AQW" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="19" FUNCODE="&amp;UMC" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="20" FUNCODE="WIFI" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="21" FUNCODE="WIRH" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="22" FUNCODE="ADBA" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="23" FUNCODE="ADMF" FUNNO="01"/>
   <pfstatus_pfk CODE="000018" PFNO="24" FUNCODE="ASND" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="25" FUNCODE="&amp;SUM" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="26" FUNCODE="&amp;CRL" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="27" FUNCODE="&amp;CRR" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="28" FUNCODE="&amp;CRE" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="29" FUNCODE="&amp;CRB" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="30" FUNCODE="&amp;XPA" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="31" FUNCODE="&amp;OMP" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="32" FUNCODE="&amp;OL0" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="33" FUNCODE="&amp;OAD" FUNNO="002"/>
   <pfstatus_pfk CODE="000018" PFNO="34" FUNCODE="&amp;BS" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="35" FUNCODE="&amp;LFO" FUNNO="002"/>
   <pfstatus_pfk CODE="000018" PFNO="36" FUNCODE="&amp;AVE" FUNNO="002"/>
   <pfstatus_pfk CODE="000018" PFNO="37" FUNCODE="&amp;EB3" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="38" FUNCODE="&amp;ILT" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="39" FUNCODE="&amp;ETA" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="40" FUNCODE="&amp;ODN" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="41" FUNCODE="&amp;OUP" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="42" FUNCODE="CONT" FUNNO="01"/>
   <pfstatus_pfk CODE="000018" PFNO="43" FUNCODE="&amp;BS+" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="44" FUNCODE="%PC" FUNNO="01"/>
   <pfstatus_pfk CODE="000018" PFNO="45" FUNCODE="&amp;RNT_PREV" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="46" FUNCODE="COND" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="47" FUNCODE="RULE" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="48" FUNCODE="DISP" FUNNO="01"/>
   <pfstatus_pfk CODE="000018" PFNO="71" FUNCODE="%SC" FUNNO="003"/>
   <pfstatus_pfk CODE="000018" PFNO="84" FUNCODE="%SC+" FUNNO="01"/>
   <pfstatus_pfk CODE="000018" PFNO="86" FUNCODE="&amp;RNT" FUNNO="001"/>
   <pfstatus_pfk CODE="000018" PFNO="94" FUNCODE="PAAS" FUNNO="001"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="%CH"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="%ML"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="%PC"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="%SC"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="%SC+"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="%SERP"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="%SL"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;ALL"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;AQW"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;AVE"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;AVR"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;BS"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;BS+"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;CDF"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;CFI"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;CRB"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;CRE"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;CRL"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;CRR"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;EB3"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;ELP"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;ERW"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;ETA"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;F03"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;F12"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;F15"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;IC1"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;ILD"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;ILT"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;LIS"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;MAX"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;MIN"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;NTE"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;OAD"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;ODN"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;OL0"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;OLX"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;OMP"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;OPT"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;OUP"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;RNT"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;RNT_PREV"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;SAL"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;SUM"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;UMC"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;XINT"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;XML"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;XPA"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="&amp;XXL"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="1REF"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="ADBA"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="ADCA"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="ADMC"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="ADMF"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="ADMS"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="AEXE"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="AGAS"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="APRO"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="ASND"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="COLX"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="COND"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="CONT"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="DISP"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="DISP"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="DRUK"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="LOAD"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="PAAS"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="PF09"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="PF13"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="PRIN"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="RULE"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="SAUF"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="SWP_SUSPEND_ACTIVE"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="TECH"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="VERW"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="WIFI"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="WIHI"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="WIRH"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="WTOF"/>
   <pfstatus_set STATUS="STANDARD" FUNCTION="WTON"/>
   <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000015" MODAL="D" INT_NOTE="Standard User Interace for Workflow Reporting"/>
   <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000018" MODAL="D" NORM="X" INT_NOTE="Standard for Workflow Reporting"/>
   <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000018" SUB_CODE="0001" MODAL="D" INT_NOTE="Standard for Workflow Reporting"/>
   <pfstatus_tit CODE="003" TEXT="&amp;"/>
   <pfstatus_tit CODE="1000" TEXT="Process Work Item As Administrator"/>
   <pfstatus_tit CODE="1001" TEXT="Work Items Without Agents"/>
   <pfstatus_tit CODE="1002" TEXT="Check Conditions in Work Item"/>
   <pfstatus_tit CODE="1003" TEXT="Execute Agent Rules for Work Item"/>
   <pfstatus_tit CODE="1004" TEXT="Restart Suspended Callbacks"/>
   <pfstatus_tit CODE="1005" TEXT="Restart Suspended Deadline Callbacks"/>
   <pfstatus_tit CODE="1006" TEXT="Restart Terminated Work Items"/>
   <pfstatus_tit CODE="1007" TEXT="Work Items with Deleted Users"/>
   <pfstatus_tit CODE="1099" TEXT="Agents of Workitems"/>
   <pfstatus_tit CODE="700" TEXT="Display Variant: Define"/>
   <pfstatus_tit CODE="DYN" TEXT="Choose &amp;"/>
   <pfstatus_tit CODE="FIL" TEXT="Set Filter"/>
   <pfstatus_tit CODE="POP" TEXT="&amp;"/>
   <pfstatus_tit CODE="TI1" TEXT="Detail: Display"/>
   <pfstatus_tit CODE="TP1" TEXT="Sort List: Sort Sequence"/>
  </pfstatus>
  <source>*------------------------------------------------------------------------------------*
* This is a copy of program RSWIWILS, which underlies SWIA,
* SWI1_USER etc.
*
* We have adapted it to provide an Agents report: list all current
* agents for a workitem. This reported is executed via transaction
* ZWF_AGENTS.
*
* Changes are marked with the text &apos;Agents&apos;
* If you&apos;re here because you want to include the texts for all other
* workflows, check Line 1088
*------------------------------------------------------------------------------------*
*------------------------------------------------------------------------------------*
*                    C H A N G E  H I S T O R Y                                      *
*------------------------------------------------------------------------------------*
*     Date      Programmer      IM/Change No  Search Term   Description              *
*------------------------------------------------------------------------------------*
* 23/03/2016    Preneshen G     CR1960        PG20160310    Enhancement to report to *
*                                                           include fields specific  *
*                                                           Nedbank Workflows        *
*------------------------------------------------------------------------------------*

REPORT zrswiwils MESSAGE-ID swf_rep_base.
INCLUDE rswlfcod.
INCLUDE rswuincl.
CLASS cl_swf_rdg_dispatcher DEFINITION LOAD.

************************************************************************
*  Begin of Data                                                       *
************************************************************************
&quot;Start - PG20160310
TYPES: BEGIN OF parentwi,
       cwiid TYPE sww_wiid,
       pwiid TYPE sww_wiid,
       wi_rh_task TYPE sww_task,
       wi_stat    TYPE sww_wistat,
       wi_nodid   TYPE swd_nodeid,
       wi_aagent  TYPE  sww_aagent,
       wi_aed     TYPE sww_aed,
       wi_forw_by TYPE  sww_forwby,
       wi_cd      TYPE  sww_cd,
       wi_ct      type SWW_CT,
       END OF parentwi.

DATA: gt_parentwi TYPE STANDARD TABLE OF parentwi,
      gt_childwi  TYPE STANDARD TABLE OF parentwi,
      gt_childwi2  TYPE STANDARD TABLE OF parentwi,
      gt_nodetab  TYPE STANDARD TABLE OF parentwi.

DATA:
  lv_lgart TYPE lgart.

RANGES:
  r_wtypes FOR lv_lgart.

DATA:
  steps TYPE i,
  idx   TYPE sy-tabix.
&quot;End - PG20160310

DATA: lv_act_object_ext TYPE rhobjects-object.
DATA: lt_task_list TYPE STANDARD TABLE OF swf_alltsk.
DATA: ls_task_list TYPE swf_alltsk.
DATA: adminexe TYPE xfeld.
DATA: append_ct TYPE xfeld.
* DATA: g_report_name TYPE sy-repid VALUE &apos;RSWIWILS&apos;.
DATA: g_report_name TYPE sy-repid VALUE &apos;ZRSWIWILS&apos;.   &quot;Agents
DATA: g_list_cnt TYPE sy-tabix.
DATA: g_admin_mode TYPE hrwfadmode.
DATA: lines TYPE sy-tabix.
DATA: g_wiheader TYPE swfatalvitm.
DATA: int TYPE REF TO if_swf_rep_workitem_selection.
DATA: lt_fields TYPE STANDARD TABLE OF sval WITH HEADER LINE.
DATA: l_returncode TYPE c.
DATA: l_popup_title TYPE c.
DATA: l_act_type TYPE hrs1201-methtype.
DATA: l_act_objtype TYPE hrs1201-swotp.
DATA: l_act_clsnam TYPE hrs1201-clsnam.
DATA: l_act_method TYPE hrs1201-swmtd.
DATA: lt_swhactor TYPE STANDARD TABLE OF swhactor WITH HEADER LINE.
DATA: tcode LIKE sy-tcode.
DATA: g_windows_titlebar TYPE string.

*- type pools
TYPE-POOLS: slis.
TABLES: swfawrkitm, pa0001.

*- additional button
* SELECTION-SCREEN FUNCTION KEY 1.

*- select options
SELECTION-SCREEN BEGIN OF BLOCK b1 WITH FRAME TITLE text-a01.

SELECT-OPTIONS: id FOR swfawrkitm-wi_id.
SELECTION-SCREEN END OF BLOCK b1.

SELECTION-SCREEN BEGIN OF BLOCK b2 WITH FRAME TITLE text-a02.
SELECT-OPTIONS:
    type   FOR swfawrkitm-wi_type DEFAULT &apos;W&apos;,       &quot;Agents - Dialog workitem
    state  FOR swfawrkitm-wi_stat DEFAULT &apos;READY&apos;,   &quot;Agents - Ready
    prio   FOR swfawrkitm-wi_prio,
    dhsta  FOR swfawrkitm-wi_dh_stat,
    task   FOR swfawrkitm-wi_rh_task DEFAULT &apos;TS90000050&apos;,
    taskg  FOR swfawrkitm-wi_rh_task NO INTERVALS,
    pernr  FOR pa0001-pernr,                         &quot;PG20160310 - Personnel Number
    kostl  FOR pa0001-kostl.                         &quot;PG20160310 - Cost Centre
PARAMETERS: top_only TYPE xfeld.
SELECTION-SCREEN END OF BLOCK b2.

SELECTION-SCREEN BEGIN OF BLOCK b3 WITH FRAME TITLE text-a03.
SELECT-OPTIONS:
    cd FOR swfawrkitm-wi_cd,
    ct FOR swfawrkitm-wi_ct NO-EXTENSION.
SELECTION-SCREEN END OF BLOCK b3.

SELECTION-SCREEN BEGIN OF BLOCK b4 WITH FRAME TITLE text-a04.
PARAMETERS: p_more    TYPE swi_params-option AS CHECKBOX.
PARAMETERS: not_post  TYPE xfeld AS CHECKBOX.       &quot;PG20160310 - Not posted check
PARAMETERS: filter TYPE swf_utl002-clsname NO-DISPLAY.
PARAMETERS: p_swia TYPE xfeld NO-DISPLAY DEFAULT space. &quot; note 1274031
SELECTION-SCREEN END OF BLOCK b4.

*-------------------------------------------------------------
INITIALIZATION.
*-------------------------------------------------------------

  IF sy-tcode CS &apos;SWF_XI_&apos;.                                 &quot;#EC NOTEXT
    tcode = sy-tcode+7.
  ELSE.
    tcode = sy-tcode.
  ENDIF.

*- check authority
  IF tcode = &apos;SWIA&apos;.
    SET TITLEBAR &apos;1000&apos;.
    IF sy-subrc = 0.
      MOVE &apos;X&apos; TO adminexe.
      SET TITLEBAR &apos;1000&apos;.
    ENDIF.
  ELSEIF tcode = &apos;SWI2_ADM1&apos;.
    SET TITLEBAR &apos;1001&apos;.
  ELSEIF tcode = &apos;SWI2_ADM2&apos;.
    SET TITLEBAR &apos;1007&apos;.
  ELSEIF tcode = &apos;SWI1_COND&apos;.
    SET TITLEBAR &apos;1002&apos;.
  ELSEIF tcode = &apos;SWI1_RULE&apos;.
    SET TITLEBAR &apos;1003&apos;.
  ELSEIF tcode = &apos;SWF_ADM_SUSPEND&apos;.
    SET TITLEBAR &apos;1004&apos;.
  ELSEIF tcode = &apos;SWF_ADM_SWWWIDH&apos;.
    SET TITLEBAR &apos;1005&apos;.
  ELSEIF tcode = &apos;SWIA_BATCH&apos;.    &quot;Context
    SET TITLEBAR &apos;1006&apos;.          &quot;Context
  ELSEIF tcode = &apos;ZWF_AGENTS&apos;.    &quot;Agents
    SET TITLEBAR &apos;1099&apos;.          &quot;Agents of Workitems
  ENDIF.

*- set default selection
  IF tcode EQ &apos;SWIA&apos; OR tcode EQ &apos;SWI1&apos;.
    ct-low = sy-uzeit - 3600.
    ct-high = &apos;235959&apos;.
    ct-sign = &apos;I&apos;.
    ct-option = &apos;BT&apos;.
    APPEND ct.
  ELSE.
    CLEAR ct.
    APPEND ct.
  ENDIF.

  cd-low = sy-datum.
  cd-sign = &apos;I&apos;.
  cd-option = &apos;EQ&apos;.
  APPEND cd.

  &quot;PG20160310 - Add Tasks for requirement
  PERFORM build_tasks.
*-------------------------------------------------------------
AT SELECTION-SCREEN OUTPUT.
*-------------------------------------------------------------


*-------------------------------------------------------------
AT SELECTION-SCREEN.
*-------------------------------------------------------------

  IF NOT cd[] IS INITIAL.
    DESCRIBE TABLE cd LINES lines.
    IF lines GT 1.
      REFRESH ct.
    ENDIF.
  ENDIF.

  DESCRIBE TABLE ct LINES lines.
  IF lines EQ 1.
    READ TABLE ct INDEX 1.
    IF ct-low IS INITIAL AND ct-high IS INITIAL.
      CLEAR ct. REFRESH ct.
    ENDIF.
  ENDIF.

  IF NOT ct[] IS INITIAL AND cd[] IS INITIAL.
    IF id[] IS INITIAL.
      MESSAGE w001.
    ENDIF.
  ENDIF.

  LOOP AT taskg.
    REFRESH lt_task_list.
    CALL FUNCTION &apos;SWF_TASKS_OF_TASK_GROUP_GET&apos;
      EXPORTING
        task_group = taskg-low
      TABLES
        task_list  = lt_task_list.
    CLEAR task.
    LOOP AT lt_task_list INTO ls_task_list.
      task-sign = taskg-sign.
      task-option = taskg-option.
      task-low = ls_task_list-object.
      APPEND task.
    ENDLOOP.
  ENDLOOP.

  SORT task BY sign option low high.
  DELETE ADJACENT DUPLICATES FROM task COMPARING ALL FIELDS.

*-------------------------------------------------------------
*- F4 functionality
*-------------------------------------------------------------
AT SELECTION-SCREEN ON VALUE-REQUEST FOR task-low.
  DATA: act_object_ext TYPE rhobjects-object.

  CALL FUNCTION &apos;RH_SEARCH_TASK&apos;
    IMPORTING
      act_object_ext         = act_object_ext
    EXCEPTIONS
      no_active_plvar        = 1
      no_org_object_selected = 2
      no_valid_task_type     = 3
      OTHERS                 = 4.
  IF sy-subrc EQ 0.
    task-low = act_object_ext.
  ENDIF.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR task-high.
  DATA: act_object_ext TYPE rhobjects-object.

  CALL FUNCTION &apos;RH_SEARCH_TASK&apos;
    IMPORTING
      act_object_ext         = act_object_ext
    EXCEPTIONS
      no_active_plvar        = 1
      no_org_object_selected = 2
      no_valid_task_type     = 3
      OTHERS                 = 4.
  IF sy-subrc EQ 0.
    task-high = act_object_ext.
  ENDIF.


*-------------------------------------------------------------
START-OF-SELECTION.
*-------------------------------------------------------------

  PERFORM main USING p_more.


*---------------------------------------------------------------------*
*       FORM MAIN                                                     *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM main USING p_more TYPE xfeld.
  DATA: field_lst TYPE slis_t_fieldcat_alv,
        field_cat TYPE slis_fieldcat_alv,
        is_layout TYPE slis_layout_alv,
        is_variant LIKE disvariant,
        it_sort TYPE slis_t_sortinfo_alv,
        l_string TYPE string,
        l_grid_title TYPE lvc_title.



  IF sy-tcode CS &apos;SWF_XI_&apos;.                                 &quot;#EC NOTEXT
    tcode = sy-tcode+7.
  ELSE.
    tcode = sy-tcode.
  ENDIF.

  IF sy-tcode = &apos;SWF_GMP&apos; AND  &quot; note 1274031
    p_swia = &apos;X&apos;.
    tcode = &apos;SWIA&apos;.
    MOVE &apos;X&apos; TO adminexe.
  ENDIF.

*- prepare the list format (determine columns...)
  PERFORM prepare_format CHANGING field_lst
                                  field_cat
                                  is_layout
                                  it_sort.
  is_variant-report = sy-repid.

  &quot;Start - PG20160310
  IF not_post = &apos;X&apos;.
    CLEAR state[].
    state-low = &apos;COMPLETED&apos;.
    state-option = &apos;EQ&apos;.
    state-sign   = &apos;I&apos;.
    APPEND state.
  ENDIF.
  &quot;End - PG20160310

*- get the list from the database.                                     *
  PERFORM get_workitem_header USING    p_more
                              CHANGING g_wiheader.


  PERFORM get_custom_data.                                  &quot;PG20160310

*- check empty                                                         *
  DATA: hits TYPE i.
  DESCRIBE TABLE  g_wiheader LINES hits.
  IF NOT hits IS INITIAL.

*- set table layout
    is_layout-cell_merge = &apos;X&apos;.

*- set title
    IF tcode = &apos;SWIA&apos;.
      is_layout-window_titlebar =
                &apos;Workitem als Administrator bearbeiten&apos;(007).
    ELSEIF tcode = &apos;SWI2_ADM1&apos;.
      is_layout-window_titlebar = &apos;Workitems ohne Bearbeiter&apos;(008).
    ELSEIF tcode = &apos;SWI2_ADM2&apos;.
      is_layout-window_titlebar = &apos;Workitems mit gelöschten Usern&apos;(001).
    ELSEIF tcode = &apos;SWI1_COND&apos;.
      is_layout-window_titlebar = &apos;Workitems mit Pre/-Postconditions&apos;(009).
    ELSEIF tcode = &apos;SWI1_RULE&apos;.
      is_layout-window_titlebar = &apos;Workitems mit Bearbeitern&apos;(010).
    ELSEIF tcode = &apos;SWF_ADM_SUSPEND&apos;.
      is_layout-window_titlebar = &apos;Restart von suspendierten Callbacks&apos;(011).
    ELSEIF tcode = &apos;SWF_ADM_SWWWIDH&apos;.
      is_layout-window_titlebar = &apos;Restart von suspendierten Deadline-Callbacks&apos;(012).
    ELSEIF tcode = &apos;SWIA_BATCH&apos;.
      is_layout-window_titlebar = &apos;Restart abgebrochene Hintergrund-Workitems&apos;(013).
    ELSE.
      is_layout-window_titlebar = &apos;Workitem-Selektion&apos;(006).
    ENDIF.
    g_windows_titlebar = is_layout-window_titlebar.
    PERFORM get_title USING hits
                            g_windows_titlebar
                            l_grid_title.
    is_layout-window_titlebar = l_grid_title.


*- get contol if filter is activated
    DATA: lt_event_exit TYPE slis_t_event_exit.
    DATA: ls_event_exit LIKE LINE OF lt_event_exit.
    ls_event_exit-ucomm = &apos;&amp;ILT&apos;.
    ls_event_exit-after = &apos;X&apos;.
    APPEND ls_event_exit TO lt_event_exit.

    is_layout-colwidth_optimize = &apos;X&apos;.

*- call the CO function to display the list.
    CALL FUNCTION &apos;REUSE_ALV_GRID_DISPLAY&apos;
      EXPORTING
*       i_grid_title             = l_grid_title
        i_callback_program       = g_report_name
        i_callback_user_command  = &apos;CALL_UCOMM_WILIST&apos;
        i_callback_pf_status_set = &apos;CALL_STATUS&apos;
        is_layout                = is_layout
        it_fieldcat              = field_lst
        it_sort                  = it_sort
        i_save                   = &apos;A&apos;
        is_variant               = is_variant
        it_event_exit            = lt_event_exit
      TABLES
        t_outtab                 = g_wiheader
      EXCEPTIONS
        OTHERS                   = 1.
  ELSE.
    MESSAGE s003.
  ENDIF.

ENDFORM.                    &quot;main

*---------------------------------------------------------------------*
*       FORM PREPARE_FORMAT                                           *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  FIELD_LST                                                     *
*  --&gt;  FIELD_CAT                                                     *
*  --&gt;  IS_LAYOUT                                                     *
*---------------------------------------------------------------------*
FORM prepare_format CHANGING field_lst TYPE slis_t_fieldcat_alv
                                 field_cat TYPE slis_fieldcat_alv
                                 is_layout TYPE slis_layout_alv
                                 it_sort   TYPE slis_t_sortinfo_alv.
  DATA: is_sort LIKE LINE OF it_sort.
  DATA: structure_name TYPE dd02l-tabname VALUE &apos;SWFAWRKITM&apos;.
  DATA: lt_fieldcat TYPE lvc_t_fcat.
  DATA: ls_fieldcat TYPE lvc_s_fcat.
  DATA: wf_settings TYPE swp_admin.
  FIELD-SYMBOLS: &lt;field_lst&gt; LIKE LINE OF field_lst.

  DATA: lt_2_fieldcat TYPE lvc_t_fcat.
  DATA: ls_2_fieldcat TYPE lvc_s_fcat.


  is_layout-box_fieldname = &apos;B_MARKED&apos;.
  is_layout-box_tabname   = &apos;WIHEADER&apos;.

*- prepare sort
  PERFORM set_sort_tab CHANGING it_sort.

*- get fieldcatalog
  CALL FUNCTION &apos;LVC_FIELDCATALOG_MERGE&apos;
    EXPORTING
      i_structure_name       = structure_name
    CHANGING
      ct_fieldcat            = lt_fieldcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.

  LOOP AT lt_fieldcat INTO ls_fieldcat.
    IF ls_fieldcat-fieldname EQ &apos;WI_RHTEXT&apos;.
      ls_fieldcat-lowercase = &apos;X&apos;.
    ENDIF.
    MOVE-CORRESPONDING ls_fieldcat TO field_cat.
    field_cat-seltext_s = ls_fieldcat-scrtext_s.
    field_cat-seltext_l = ls_fieldcat-scrtext_l.
    field_cat-seltext_m = ls_fieldcat-scrtext_m.
    APPEND field_cat TO field_lst.
  ENDLOOP.


  &quot;AK01 add append struct
  CALL FUNCTION &apos;LVC_FIELDCATALOG_MERGE&apos;
    EXPORTING
      i_structure_name       = &apos;ZWI_APPEND&apos; &quot;&apos;SWFAALVITM&apos;   &quot;PG20160310
    CHANGING
      ct_fieldcat            = lt_2_fieldcat
    EXCEPTIONS
      inconsistent_interface = 1
      program_error          = 2
      OTHERS                 = 3.

  LOOP AT lt_2_fieldcat INTO ls_2_fieldcat.
    IF ls_2_fieldcat-fieldname+0(2) EQ &apos;ZZ&apos;.
      MOVE-CORRESPONDING ls_2_fieldcat TO field_cat.
      field_cat-seltext_s = ls_2_fieldcat-scrtext_s.
      field_cat-seltext_l = ls_2_fieldcat-scrtext_l.
      field_cat-seltext_m = ls_2_fieldcat-scrtext_m.
      APPEND field_cat TO field_lst.
    ENDIF.
  ENDLOOP.

*- no reference for B_MARKED
  CLEAR field_cat-ref_tabname.
  field_cat-tech = &apos;X&apos;.
  field_cat-fieldname = &apos;B_MARKED&apos;.
  APPEND field_cat TO field_lst.
  CLEAR field_cat-tech.

*- set columns positions
  LOOP AT field_lst ASSIGNING &lt;field_lst&gt;.
    CASE &lt;field_lst&gt;-fieldname.
      WHEN &apos;WI_ID&apos;.
        &lt;field_lst&gt;-col_pos = 1.
      WHEN &apos;WI_STAT&apos;.
        &lt;field_lst&gt;-col_pos = 2.
      WHEN &apos;WI_CHCKWI&apos;.
        &lt;field_lst&gt;-col_pos = 3.
      WHEN &apos;TYPETEXT&apos;.
        &lt;field_lst&gt;-col_pos = 4.
        &lt;field_lst&gt;-outputlen = 15.
      WHEN &apos;WI_RH_TASK&apos;.
        &lt;field_lst&gt;-col_pos = 5.
        &lt;field_lst&gt;-outputlen = 11.
      WHEN &apos;WI_CD&apos;.
        &lt;field_lst&gt;-col_pos = 6.
        &lt;field_lst&gt;-outputlen = 10.
      WHEN &apos;WI_CT&apos;.
        &lt;field_lst&gt;-col_pos = 7.
        &lt;field_lst&gt;-outputlen = 8.
      WHEN &apos;WI_TEXT&apos;.
        &lt;field_lst&gt;-col_pos = 8.
        &lt;field_lst&gt;-outputlen = 80.
      WHEN &apos;WI_CONFIRM&apos;.
        &lt;field_lst&gt;-col_pos = 9.
      WHEN &apos;WI_REJECT&apos;.
        &lt;field_lst&gt;-col_pos = 10.
      WHEN &apos;WI_PRIOTXT&apos;.
        &lt;field_lst&gt;-col_pos = 11.
      WHEN &apos;RETRY_CNT&apos;.
        &lt;field_lst&gt;-col_pos = 12.
      WHEN OTHERS.
        &lt;field_lst&gt;-col_pos = 999999.
    ENDCASE.
  ENDLOOP.
  SORT field_lst BY col_pos.
  LOOP AT field_lst ASSIGNING &lt;field_lst&gt;.
    &lt;field_lst&gt;-col_pos = sy-tabix.
  ENDLOOP.

*- set standard layout
  CLEAR field_cat.
  field_cat-no_out = &apos;X&apos;.
  MODIFY field_lst FROM field_cat TRANSPORTING no_out
     WHERE fieldname EQ &apos;WI_LANG&apos; OR
           fieldname EQ &apos;WI_TYPE&apos; OR
           fieldname EQ &apos;VERSION&apos; OR
           fieldname EQ &apos;WI_PRIO&apos; OR
           fieldname EQ &apos;NOTE_CNT&apos; OR
           fieldname EQ &apos;WI_RELEASE&apos; OR
           fieldname EQ &apos;STATUSTEXT&apos; OR
           fieldname EQ &apos;TCLASS&apos; OR
           fieldname EQ &apos;WI_DH_STAT&apos; OR
           fieldname EQ &apos;RETRY_CNT&apos; OR
           fieldname EQ &apos;WLC_FLAGS&apos;.

*- set checkboxes
  CLEAR field_cat.
  field_cat-checkbox = &apos;X&apos;.
  MODIFY field_lst FROM field_cat TRANSPORTING checkbox
     WHERE fieldname EQ &apos;WI_CONFIRM&apos; OR
           fieldname EQ &apos;WI_REJECT&apos; OR
           fieldname EQ &apos;WI_DEADEX&apos; OR
           fieldname EQ &apos;NOTE_EXIST&apos; OR
           fieldname EQ &apos;ASYNCAGENT&apos;.

  IF tcode = &apos;SWI2_ADM1&apos;. &quot; workitems ohne bearbeiter
    CLEAR field_cat.
    field_cat-col_pos = &apos;0&apos;.
    field_cat-key = &apos;X&apos;.
    MODIFY field_lst FROM field_cat TRANSPORTING col_pos key
       WHERE fieldname EQ &apos;ASYNCAGENT&apos;.
  ELSE.
    CLEAR field_cat.
    field_cat-tech = &apos;X&apos;.
    MODIFY field_lst FROM field_cat TRANSPORTING tech
       WHERE fieldname EQ &apos;ASYNCAGENT&apos;.
  ENDIF.

*- delete agents if necessary
  CALL FUNCTION &apos;SWP_ADMIN_DATA_READ&apos;
    IMPORTING
      wf_settings = wf_settings
    EXCEPTIONS
      OTHERS      = 1.
  IF wf_settings-no_agents = &apos;X&apos;.
    field_cat-tech = &apos;X&apos;.
    MODIFY field_lst FROM field_cat TRANSPORTING tech
       WHERE fieldname EQ &apos;EXEUSER&apos; OR
             fieldname EQ &apos;FORW_BY&apos;.
  ENDIF.

ENDFORM.                    &quot;prepare_format

*---------------------------------------------------------------------*
*       FORM CALL_UCOMM_WILIST                                        *
*---------------------------------------------------------------------*
*       Dynamic call to process the keyboard input.                   *
*---------------------------------------------------------------------*
*  --&gt;  UCOMM                                                         *
*  --&gt;  SELFIELD                                                      *
*---------------------------------------------------------------------*
FORM call_ucomm_wilist   USING ucomm TYPE syucomm
                               selfield TYPE slis_selfield.
  DATA: old_list_cnt    LIKE g_list_cnt,
        s_return        LIKE swl_return,
        line_idx        LIKE sy-tabix,
        l_tabix         LIKE sy-tabix,
        linesel_cnt     LIKE sy-tabix,
        b_line_selected LIKE sy-binpt,
        ls_wiheader     TYPE LINE OF swfatalvitm.
  DATA: lt_wrkitm       TYPE swfatwrkitm.
  DATA: delta_list_cnt  TYPE sytabix.
  DATA: ls_por          TYPE sibflpor.
  DATA: lt_por          TYPE sibflport.
  DATA: lv_ucomm        TYPE syucomm.
  DATA: l_excp          TYPE REF TO cx_swf_ifs_exception.
  DATA: ls_suspend      TYPE swp_suspen.
  DATA: ls_swwwidh      TYPE swwwidh.
  DATA: l_wi_index      TYPE sytabix.
  DATA: lh_grid         TYPE REF TO cl_gui_alv_grid.
  DATA: l_grid_title    TYPE lvc_title.
  DATA: l_count         TYPE sytabix.


  PERFORM pick_line USING    selfield-tabindex
                             g_wiheader
                    CHANGING line_idx
                             linesel_cnt
                             b_line_selected.

  LOOP AT g_wiheader INTO ls_wiheader WHERE b_marked EQ &apos;X&apos;.
    ls_por-catid  = swfco_objtype_bc.
    ls_por-instid = ls_wiheader-wi_id.
    APPEND ls_por TO lt_por.
  ENDLOOP.

  IF lt_por[] IS INITIAL.
    READ TABLE g_wiheader INDEX line_idx INTO ls_wiheader.
    ls_por-catid  = swfco_objtype_bc.
    ls_por-instid = ls_wiheader-wi_id.
    APPEND ls_por TO lt_por.
  ENDIF.

************************************************************************
*    Refresh Instancemanager                                         *
************************************************************************
  TRY.
      CALL METHOD cl_swf_run_wim_factory=&gt;initialize( ).
    CATCH cx_swf_ifs_exception INTO l_excp.
      CALL METHOD cl_swf_utl_message=&gt;send_message_via_exception( l_excp ).
  ENDTRY.

  CASE ucomm.
************************************************************************
*    Filter                                                            *
************************************************************************
    WHEN &apos;&amp;ILT&apos;.

************************************************************************
*    Refresh                                                           *
************************************************************************
    WHEN &apos;1REF&apos;.
      CALL METHOD int-&gt;refresh
        IMPORTING
          ex_delta_count = delta_list_cnt.
      CALL METHOD int-&gt;get_entries
        IMPORTING
          ex_wientries = lt_wrkitm.
      CLEAR g_wiheader[].
      PERFORM convert_to_alv_list USING    lt_wrkitm
                                           p_more
                                  CHANGING g_wiheader.
      MESSAGE s811(w8) WITH delta_list_cnt.
      selfield-refresh    = &apos;X&apos;.
      selfield-row_stable = &apos;X&apos;.

************************************************************************
*   Pick                                                               *
************************************************************************
    WHEN &apos;&amp;IC1&apos;.
      IF linesel_cnt &gt; 1.
        MESSAGE s201(wi).
        EXIT.
      ENDIF.
      IF  line_idx     = 0.
        MESSAGE s004(0k).
        EXIT.
      ENDIF.

      READ TABLE g_wiheader INDEX line_idx INTO ls_wiheader.
      ls_por-catid  = &apos;BC&apos;.
      ls_por-instid = ls_wiheader-wi_id.

      IF ls_wiheader-wi_type = wi_flow.
        lv_ucomm = function_wi_workflow_display.
      ELSE.
        lv_ucomm = cl_swf_rdg_dispatcher=&gt;c_function_wi_display.
      ENDIF.
      CALL METHOD cl_swf_rdg_dispatcher=&gt;execute_dialog_request
        EXPORTING
          im_por      = ls_por
          im_function = lv_ucomm
        EXCEPTIONS
          OTHERS      = 1.
      IF sy-subrc &lt;&gt; 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                   WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.


    WHEN function_suspend_active.
      LOOP AT lt_por INTO ls_por.
        READ TABLE g_wiheader WITH KEY wi_id = ls_por-instid INTO ls_wiheader.
        l_wi_index = sy-tabix.
        IF sy-subrc EQ 0.
          IF tcode EQ &apos;SWF_ADM_SUSPEND&apos;.
            SELECT SINGLE * FROM swp_suspen INTO ls_suspend WHERE wi_id EQ ls_wiheader-wi_id
                                                              AND status EQ cl_swf_run_suspend_entry=&gt;c_status_error.
            IF sy-subrc EQ 0.
              ls_suspend-status = cl_swf_run_suspend_entry=&gt;c_status_active.
              GET TIME STAMP FIELD ls_suspend-timestamp.
              MODIFY swp_suspen FROM ls_suspend.
              COMMIT WORK.
            ENDIF.
          ELSEIF tcode EQ &apos;SWF_ADM_SWWWIDH&apos;.
            SELECT * FROM swwwidh INTO ls_swwwidh WHERE wi_id EQ ls_wiheader-wi_id
                                                    AND status EQ cl_swf_run_swwwidh_entry=&gt;c_status_error.
              ls_swwwidh-status = cl_swf_run_swwwidh_entry=&gt;c_status_active.
              GET TIME STAMP FIELD ls_swwwidh-timestamp.
              MODIFY swwwidh FROM ls_swwwidh.
            ENDSELECT.
            COMMIT WORK.
          ENDIF.
          DELETE g_wiheader INDEX l_wi_index.
        ENDIF.
        selfield-refresh    = &apos;X&apos;.
        selfield-row_stable = &apos;X&apos;.
      ENDLOOP.
    WHEN OTHERS.

*      IF  line_idx     = 0.  &quot;--- OSS note 1422569 ---
      IF linesel_cnt   = 0.
        MESSAGE s004(0k).
        EXIT.
      ENDIF.

      CALL METHOD cl_swf_rdg_dispatcher=&gt;execute_dialog_request_multi
        EXPORTING
          im_por      = lt_por
          im_function = ucomm
        EXCEPTIONS
          OTHERS      = 1.
      IF sy-subrc &lt;&gt; 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                   WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.

  ENDCASE.

  DATA: ls_layout TYPE slis_layout_alv.
  DATA: lt_filtered_entries TYPE  slis_t_filtered_entries.
  DATA: l_lines TYPE i.
  CALL FUNCTION &apos;REUSE_ALV_GRID_LAYOUT_INFO_GET&apos;
    IMPORTING
      es_layout           = ls_layout
      et_filtered_entries = lt_filtered_entries
    EXCEPTIONS
      OTHERS              = 1.
  IF sy-subrc EQ 0.
    DESCRIBE TABLE lt_filtered_entries LINES l_lines.
    DESCRIBE TABLE g_wiheader LINES l_count.
    l_count = l_count - l_lines.
    PERFORM get_title USING l_count
                            g_windows_titlebar
                            l_grid_title.
    ls_layout-window_titlebar = l_grid_title.
    CALL FUNCTION &apos;REUSE_ALV_GRID_LAYOUT_INFO_SET&apos;
      EXPORTING
        is_layout = ls_layout.
  ENDIF.


ENDFORM.                    &quot;call_ucomm_wilist

*---------------------------------------------------------------------*
*       FORM CALL_STATUS                                              *
*---------------------------------------------------------------------*
*       Dynamic call to set the gui status.                           *
*---------------------------------------------------------------------*
*  --&gt;  EXTAB                                                         *
*---------------------------------------------------------------------*
FORM call_status USING extab TYPE slis_t_extab.
  DATA: excl_functions TYPE syucomm_t.

  CALL FUNCTION &apos;SWF_REP_GET_EXCLUDED_FUNCTIONS&apos;
    EXPORTING
      tcode          = tcode &quot; note 1274031
    IMPORTING
      excl_functions = excl_functions.
  extab[] = excl_functions[].

  SET PF-STATUS &apos;STANDARD&apos; EXCLUDING extab.

ENDFORM.                    &quot;call_status

*&amp;---------------------------------------------------------------------*
*&amp;      Form  set_sort_tab
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_IT_SORT  sorttab (ALV format)
*----------------------------------------------------------------------*
FORM set_sort_tab CHANGING p_it_sort TYPE slis_t_sortinfo_alv.
  DATA: is_sort TYPE slis_sortinfo_alv.

  REFRESH p_it_sort.
  is_sort-tabname = &apos;WIHEADER&apos;.
  is_sort-spos = 1.
  is_sort-fieldname = &apos;WI_CD&apos;.
  is_sort-down = &apos;X&apos;.
  APPEND is_sort TO p_it_sort.

  is_sort-spos = 2.
  is_sort-fieldname = &apos;WI_CT&apos;.
  is_sort-down = &apos;X&apos;.
  APPEND is_sort TO p_it_sort.

  is_sort-spos = 3.
  is_sort-fieldname = &apos;WI_ID&apos;.
  is_sort-down = &apos;X&apos;.
  APPEND is_sort TO p_it_sort.

ENDFORM.                               &quot; set_sort_tab
*&amp;---------------------------------------------------------------------*
*&amp;      Form  get_workitem_header
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_WI_HEADER  text
*----------------------------------------------------------------------*
FORM get_workitem_header USING    p_more      TYPE xfeld
                         CHANGING p_wi_header TYPE swfatalvitm.

  DATA: rangetab_for_id TYPE swfartwiid.
  DATA: rangetab_for_type TYPE swfartwitp.
  DATA: rangetab_for_creation_date TYPE swfartcrdat.
  DATA: rangetab_for_creation_time TYPE swfartcrtim.
  DATA: rangetab_for_task TYPE swfartrhtsk.
  DATA: rangetab_for_state TYPE swfartwista.
  DATA: rangetab_for_priority TYPE swfartprio.
  DATA: rangetab_for_dhsta TYPE swfartdhsta.
  DATA: lt_wrkitm TYPE swfatwrkitm.
  DATA: ls_wrkitm TYPE LINE OF swfatwrkitm.
  DATA: ls_alvitm TYPE LINE OF swfatalvitm.

  IF int IS INITIAL.
    int = cl_swf_rep_manager=&gt;get_instance( ).
  ENDIF.

*- set selection properties
  IF p_more EQ &apos;X&apos;.
    CALL METHOD int-&gt;set_property
      EXPORTING
        im_name  = if_swf_rep_workitem_selection=&gt;c_get_administrator
        im_value = &apos;X&apos;.
  ENDIF.

*- convert parameters
  rangetab_for_id[] = id[].
  rangetab_for_type[] = type[].
  rangetab_for_creation_date[] = cd[].
  rangetab_for_creation_time[] = ct[].
  rangetab_for_task[] = task[].
  rangetab_for_state[] = state[].
  rangetab_for_priority[] = prio[].
  rangetab_for_dhsta[] = dhsta[].

  CALL METHOD int-&gt;clear( ).
  CALL METHOD int-&gt;set_filter_strategy( filter ).

  CALL METHOD int-&gt;set_range_tab( rangetab_for_id ).
  CALL METHOD int-&gt;set_range_tab( rangetab_for_type ).
  CALL METHOD int-&gt;set_range_tab( rangetab_for_creation_date ).
  CALL METHOD int-&gt;set_range_tab( rangetab_for_creation_time ).
  CALL METHOD int-&gt;set_range_tab( rangetab_for_task ).
  CALL METHOD int-&gt;set_range_tab( rangetab_for_state ).
  CALL METHOD int-&gt;set_range_tab( rangetab_for_priority ).
  CALL METHOD int-&gt;set_range_tab( rangetab_for_dhsta ).

  CALL METHOD int-&gt;read( ).

  CALL METHOD int-&gt;get_entries
    IMPORTING
      ex_wientries = lt_wrkitm.

  PERFORM convert_to_alv_list USING    lt_wrkitm
                                       p_more
                              CHANGING p_wi_header.


ENDFORM.                               &quot; get_workitem_header

*---------------------------------------------------------------------*
*       FORM convert_to_alv_list                                      *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  WIHEADER                                                      *
*  --&gt;  WIALVITM                                                      *
*---------------------------------------------------------------------*
FORM convert_to_alv_list USING    wiheader TYPE swfatwrkitm
                                  more     TYPE xfeld
                         CHANGING wialvitm TYPE swfatalvitm.
  DATA: ls_wrkitm TYPE LINE OF swfatwrkitm.
  DATA: ls_alvitm TYPE LINE OF swfatalvitm.
  DATA: lv_wi_handle TYPE REF TO if_swf_run_wim_internal.
  DATA: ls_admin TYPE swhactor.
  DATA: lt_agents TYPE tswhactor.

  LOOP AT wiheader INTO ls_wrkitm.
    MOVE-CORRESPONDING ls_wrkitm TO ls_alvitm.
    IF ls_wrkitm-wlc_flags O swfcr_p_asynchronous_rule.
      ls_alvitm-asyncagent = &apos;X&apos;.
    ENDIF.
    IF more EQ &apos;X&apos; AND ls_alvitm-wi_type EQ swfco_wi_flow.
      TRY.
          CALL METHOD cl_swf_run_wim_factory=&gt;find_by_wiid
            EXPORTING
              im_wiid     = ls_wrkitm-wi_id
            RECEIVING
              re_instance = lv_wi_handle.
          lt_agents = lv_wi_handle-&gt;get_administrator_agents( ).
          READ TABLE lt_agents INDEX 1 INTO ls_admin.
          ls_alvitm-adm_agent = ls_admin.
        CATCH cx_swf_run_wim.
      ENDTRY.
    ENDIF.
    IF top_only IS INITIAL.
      APPEND ls_alvitm TO wialvitm.
    ELSE.
      IF ls_alvitm-wi_chckwi IS INITIAL.
        APPEND ls_alvitm TO wialvitm.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    &quot;convert_to_alv_list

*---------------------------------------------------------------------*
*       FORM PICK_LINE                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  SELFIELD_IDX                                                  *
*  --&gt;  WIHEADER                                                      *
*  --&gt;  INDEX                                                         *
*  --&gt;  LINESEL_CNT                                                   *
*  --&gt;  B_OK                                                          *
*---------------------------------------------------------------------*
FORM pick_line USING    selfield_idx LIKE sy-tabix
                            wiheader     TYPE swfatalvitm
                   CHANGING index        LIKE sy-tabix
                            linesel_cnt  LIKE sy-tabix
                            b_ok         LIKE sy-binpt.
  DATA: lines_marked LIKE sy-tabix,
        marked_idx   LIKE sy-tabix,
        cursor_line  LIKE sy-binpt.

  IF selfield_idx &gt; 0.
    READ TABLE wiheader INDEX selfield_idx TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      cursor_line = &apos;X&apos;.
    ENDIF.
  ENDIF.

  LOOP AT wiheader TRANSPORTING NO FIELDS WHERE b_marked = &apos;X&apos;.
    ADD 1 TO lines_marked.
    marked_idx  = sy-tabix.
  ENDLOOP.

************************************************************************
*  List tool algorithm                                                 *
************************************************************************
  IF cursor_line = &apos;X&apos;.
    index = selfield_idx.
    IF lines_marked &lt; 2.
      linesel_cnt = 1.
    ELSE.
      linesel_cnt = lines_marked.
    ENDIF.
    b_ok = &apos;X&apos;.

  ELSEIF lines_marked = 1.
    index = marked_idx.
    linesel_cnt = 1.
    b_ok = &apos;X&apos;.

  ELSEIF lines_marked &gt; 1.
    linesel_cnt = lines_marked.
    b_ok = &apos;X&apos;.

  ENDIF.

ENDFORM.                    &quot;pick_line
*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_TITLE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_HITS  text
*      --&gt;P_L_STRING  text
*----------------------------------------------------------------------*
FORM get_title  USING p_hits TYPE sytabix
                      p_title_template TYPE string
                      p_title TYPE lvc_title.
  DATA: l_string TYPE string.
  DATA: l_count(6) TYPE n.

  IF p_hits &gt; 1.
    l_string = &apos;(&amp;1 entries)&apos;(014).
  ELSEIF p_hits EQ 1.
    l_string = &apos;(1 entry)&apos;(015).
  ENDIF.
  l_count = p_hits.
  SHIFT l_count LEFT DELETING LEADING &apos;0&apos;.
  CONCATENATE p_title_template l_string INTO p_title SEPARATED BY space.
  REPLACE &apos;&amp;1&apos; IN p_title WITH l_count.

ENDFORM.                    &quot;

*-- begin Agents
*---------------------------------------------------------------*
*       FORM get_workitem_agents                                *
*---------------------------------------------------------------*
* Augment the workitem list with agent information:
* if a DIALOG workitem is in status READY and has
* NO CURRENT AGENT, find all (responsible) agents
* who have this item in their inbox.
* Add one line to the list for each agent found.
*---------------------------------------------------------------*
*  &lt;-&gt;  PT_WIHEADER                                             *
*---------------------------------------------------------------*
FORM get_workitem_agents CHANGING pt_wiheader TYPE swfatalvitm.

  TYPES: BEGIN OF ty_user_name,
           user TYPE syuname,
           name TYPE ad_namtext,
         END OF ty_user_name.
  TYPES: BEGIN OF zwf_admin,
            uname TYPE xubname,
         END OF zwf_admin.
  DATA: lv_rfc TYPE string.
  DATA: lf_key2(30).
  DATA: lt_user_names TYPE SORTED TABLE OF ty_user_name
                      WITH UNIQUE KEY user,
        ls_user_name TYPE ty_user_name.

  DATA: lt_wi_agents TYPE swrtwiagent,
        lt_wi_admins TYPE TABLE OF zwf_admin,
        wa_wi_admins LIKE LINE OF lt_wi_admins,
        ls_wi_agents TYPE swr_wiagent,
        lt_wiheader TYPE swfatalvitm,
        ls_wiheader TYPE swfaalvitm,
        lt_wi_ids TYPE swrtwiid,
        lv_user_id TYPE xubname,
        ls_user_address TYPE addr3_val.
  CHECK pt_wiheader IS NOT INITIAL.

  LOOP AT pt_wiheader INTO ls_wiheader.
    CLEAR: lt_wi_ids, lt_wi_agents.
* Dialog workitem in status READY with no agents?
    IF ls_wiheader-wi_type EQ &apos;W&apos; AND         &quot;dialog workitem
       ls_wiheader-wi_aagent IS INITIAL AND   &quot;no agents
       ls_wiheader-wi_stat EQ &apos;READY&apos;.         &quot;ready
      APPEND ls_wiheader-wi_id TO lt_wi_ids.
* Get the current (responsible) agents, who would
* have the workitem in their inbox

      CALL FUNCTION &apos;SAP_WAPI_GET_WI_AGENTS&apos;
        EXPORTING
*         LANGUAGE         = SY-LANGU
          workitems        = lt_wi_ids
*         USER             = SY-UNAME
          with_substitutes = &apos;X&apos;
        IMPORTING
*         RETURN_CODE      =
*         TIMESTAMP        =
          wi_agents        = lt_wi_agents
*     TABLES
*         MESSAGE_LINES    =
*         MESSAGE_STRUCT   =
        .

*     Exclude our administrators from this list.
      IF sy-sysid(2) = &apos;D0&apos;.
        lf_key2 = &apos;SYSTEM D0&apos;.
      ELSEIF sy-sysid(2) = &apos;Q0&apos;.
        lf_key2 = &apos;SYSTEM Q0&apos;.
      ELSEIF sy-sysid(2) = &apos;P0&apos;.
        lf_key2 = &apos;SYSTEM P0&apos;.
      ENDIF.

      SELECT SINGLE zvalue FROM zconfig INTO lv_rfc
        WHERE zkeyfield1 = &apos;ZP000600&apos; AND
              zkeyfield2 = lf_key2.

      CALL FUNCTION &apos;ZWF_GET_ADMINS&apos; DESTINATION lv_rfc
        IMPORTING
          admins = lt_wi_admins.
      LOOP AT lt_wi_admins INTO wa_wi_admins.
        DELETE lt_wi_agents WHERE user = wa_wi_admins-uname.
      ENDLOOP.

* For every agent found, add a new line to the WI list
      IF lt_wi_agents[] IS INITIAL.
        &quot;just add a line with no agent
        APPEND ls_wiheader TO lt_wiheader.
      ELSE.

        LOOP AT lt_wi_agents INTO ls_wi_agents.
          &quot;add a new line for each agent
          ls_wiheader-wi_aagent = ls_wi_agents-user.
* get the user name
          CLEAR ls_user_address.
          lv_user_id = ls_wi_agents-user.
* try a local buffer first
          READ TABLE lt_user_names INTO ls_user_name
             WITH KEY user = lv_user_id.
          IF sy-subrc = 0.
            ls_wiheader-wi_aa_name = ls_user_name-name.
          ELSE.
* get the user name from the user address
            CALL FUNCTION &apos;SUSR_USER_ADDRESS_READ&apos;
              EXPORTING
                user_name              = lv_user_id
              IMPORTING
                user_address           = ls_user_address
              EXCEPTIONS
                user_address_not_found = 1
                OTHERS                 = 2.
            IF sy-subrc = 0.
              ls_wiheader-wi_aa_name = ls_user_address-name_text.
* store in a buffer table
              CLEAR ls_user_name.
              ls_user_name-user = lv_user_id.
              ls_user_name-name = ls_user_address-name_text.
              INSERT ls_user_name INTO TABLE lt_user_names.
            ENDIF.
          ENDIF.
          APPEND ls_wiheader TO lt_wiheader.
          CLEAR ls_wiheader-wi_aagent.
        ENDLOOP.
      ENDIF.
    ELSE.  &quot;if its not a dialog workitem, or already has an agent,
      &quot;just append it
      APPEND ls_wiheader TO lt_wiheader.
    ENDIF.
  ENDLOOP.

*Replace the original table with the extended table
  IF lt_wiheader[] IS NOT INITIAL.
    pt_wiheader[] = lt_wiheader[].
  ENDIF.
ENDFORM. &quot;get_workitem_agents
*-- end Agents
FORM get_workitem_decision CHANGING pt_wiheader TYPE swfatalvitm.
  DATA: lt_wiheader TYPE swfatalvitm,
        ls_wiheader TYPE swfaalvitm,
        lv_wi_ids TYPE swr_struct-workitemid,
        &quot;wa_wi_ids LIKE LINE OF lt_wi_ids,
        lt_simp_cont TYPE TABLE OF swr_cont,
        wa_simp_cont LIKE LINE OF lt_simp_cont,
        lv_htabix TYPE sy-tabix.

  LOOP AT pt_wiheader INTO ls_wiheader.
    CLEAR: lv_wi_ids, lt_simp_cont.
* Dialog workitem in status READY with no agents?
    IF ls_wiheader-wi_type EQ &apos;W&apos;.       &quot;dialog workitem
      lv_htabix = sy-tabix.
      lv_wi_ids = ls_wiheader-wi_id.

      CALL FUNCTION &apos;SAP_WAPI_READ_CONTAINER&apos;
        EXPORTING
          workitem_id      = lv_wi_ids
        TABLES
          simple_container = lt_simp_cont.

      READ TABLE lt_simp_cont INTO wa_simp_cont WITH KEY element = &apos;_WI_RESULT&apos;.
      IF sy-subrc = 0.
        &quot;Couldn&apos;t append a structure to the ALV type... so settling for changing the task description.
        ls_wiheader-zz_decision = wa_simp_cont-value+0(4).

        &quot;Struggling to find where the texts are stored...
        ls_wiheader-wi_rhtext = COND #( WHEN ls_wiheader-zz_decision = &apos;0001&apos; THEN &apos;Approved&apos;
                                        WHEN ls_wiheader-zz_decision = &apos;0002&apos; THEN &apos;Rejected&apos;
                                        ELSE ls_wiheader-wi_rhtext ).

        MODIFY pt_wiheader FROM ls_wiheader INDEX lv_htabix.
      ENDIF.
    ENDIF.
  ENDLOOP.
ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_LAST_AGENT_EMAIL
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_G_WIHEADER  text
*----------------------------------------------------------------------*
FORM get_last_agent_email  CHANGING p_g_wiheader  TYPE swfatalvitm.

  DATA:
    ls_wiheader TYPE swfaalvitm.

  LOOP AT p_g_wiheader INTO ls_wiheader.
    CLEAR
       ls_wiheader-zz_last_agent_email.

    SELECT SINGLE usrid_long INTO ls_wiheader-zz_last_agent_email
      FROM pa0105
     WHERE pernr = ls_wiheader-wi_aagent
       AND subty = &apos;0010&apos;
       AND endda GE sy-datum
       AND begda LE sy-datum.

    IF NOT ls_wiheader-zz_last_agent_email IS INITIAL.
      TRANSLATE ls_wiheader-zz_last_agent_email TO LOWER CASE.
      MODIFY p_g_wiheader FROM ls_wiheader.
    ENDIF.

  ENDLOOP.

ENDFORM.                    &quot; GET_LAST_AGENT_EMAIL

*&amp;---------------------------------------------------------------------*
*&amp;      Form  BUILD_TASKS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM build_tasks .
                                                            &quot;WS90000002
  CLEAR task.
  task-low = &apos;TS21500003&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

  CLEAR task.
  task-low = &apos;TS21500004&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

  CLEAR task.
  task-low = &apos;TS12300104&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

                                                            &quot;WS90000001
  CLEAR task.
  task-low = &apos;TS90000002&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

  CLEAR task.
  task-low = &apos;TS90000059&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

                                                            &quot;WS90000004
  CLEAR task.
  task-low = &apos;TS90000009&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

  CLEAR task.
  task-low = &apos;TS90000016&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

                                                            &quot;WS90000005
  CLEAR task.
  task-low = &apos;TS90000010&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

  CLEAR task.
  task-low = &apos;TS90000011&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

                                                            &quot;WS90000007
  CLEAR task.
  task-low = &apos;TS90000023&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

                                                            &quot;WS90000008
  CLEAR task.
  task-low = &apos;TS90000036&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

                                                            &quot;WS90000009
  CLEAR task.
  task-low = &apos;TS90000040&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

                                                            &quot;WS90000003
  CLEAR task.
  task-low = &apos;TS90000043&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

                                                            &quot;WS90000006
  CLEAR task.
  task-low = &apos;TS90000017&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

  CLEAR task.
  task-low = &apos;TS90000018&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

  CLEAR task.
  task-low = &apos;TS90000019&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

                                                            &quot;WS90000010
  CLEAR task.
  task-low = &apos;TS90000046&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

  CLEAR task.
  task-low = &apos;TS90000047&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

  CLEAR task.
  task-low = &apos;TS90000048&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

                                                            &quot;WS90000011
  CLEAR task.
  task-low = &apos;TS90000050&apos;.
  task-sign = &apos;I&apos;.
  task-option = &apos;EQ&apos;.
  APPEND task.

ENDFORM.                    &quot; BUILD_TASKS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_CUSTOM_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM get_custom_data .

  PERFORM build_wt_range.
  PERFORM handle_pernr_kostl_entries  CHANGING g_wiheader.  &quot;PG20160310
  PERFORM parent_work_item_ids        CHANGING g_wiheader.  &quot;PG20160310
  PERFORM get_approver_data           CHANGING g_wiheader.  &quot;PG20160310
  IF  not_post = &apos;X&apos;.                                       &quot;PG20160310
    PERFORM handle_completed_not_posted CHANGING g_wiheader. &quot;PG20160310
  ENDIF.



*-- begin Agents
* If the (dialog) workitem does not have an agent, then we want to
* list all current users who have this workitem in their inbox.
*  IF sy-tcode = &apos;ZWF_AGENTS&apos;.
  PERFORM get_workitem_agents CHANGING g_wiheader.
  PERFORM get_workitem_decision CHANGING g_wiheader.
  PERFORM get_last_agent_email CHANGING g_wiheader.
*  ENDIF.
*-- end Agents

ENDFORM.                    &quot; GET_CUSTOM_DATA

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_PERNR_ENTRIES
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM handle_pernr_kostl_entries CHANGING pt_wiheader TYPE swfatalvitm.
  DATA:
    ls_wiheader   TYPE swfaalvitm,
    init_pernr    TYPE pernr_d,
    init_kostl    TYPE kostl,
    pernr_retcode TYPE sy-subrc,
    del_indc      TYPE char1.


  CLEAR ls_wiheader.
  LOOP AT  pt_wiheader INTO ls_wiheader.
    CLEAR:
       init_pernr,
       del_indc.
    &quot;Only return records for specific personnel numbers
    CLEAR pernr_retcode.

    PERFORM get_workflow_initiator USING    ls_wiheader-wi_id
                                   CHANGING init_pernr
                                            pernr_retcode.

    IF NOT pernr[] IS INITIAL.
      IF NOT init_pernr IN pernr OR init_pernr = &apos;00000000&apos;.
        del_indc = &apos;X&apos;.
        DELETE TABLE pt_wiheader FROM ls_wiheader.
      ENDIF.
    ENDIF.

    &quot;Only return records for specific cost centres
    IF NOT kostl[] IS  INITIAL.
      CLEAR:
         init_kostl.

*      IF init_pernr = &apos;00000000&apos;.
*        PERFORM get_workflow_initiator USING  ls_wiheader-wi_id
*                                     CHANGING init_pernr
*                                              pernr_retcode.
*      ENDIF.
      IF init_pernr NE &apos;00000000&apos;.
        PERFORM get_workflow_initiator_kostl    USING init_pernr
                                             CHANGING init_kostl.


        IF NOT init_kostl IN kostl.
          del_indc = &apos;X&apos;.
          DELETE TABLE pt_wiheader FROM ls_wiheader.
        ENDIF.
      ENDIF.
    ENDIF.

    &quot;Handle Requester data
    IF del_indc NE &apos;X&apos;.
      IF init_pernr NE &apos;00000000&apos;.
        PERFORM get_requestor_data USING    init_pernr
                                   CHANGING ls_wiheader-zz_reqname
                                            ls_wiheader-zz_reqemail
                                            ls_wiheader-zz_reqkostl.

        MODIFY pt_wiheader FROM ls_wiheader.
      ENDIF.
    ENDIF.

    CLEAR ls_wiheader.
  ENDLOOP.
ENDFORM.                    &quot; HANDLE_PERNR_ENTRIES

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_WORKFLOW_INITIATOR
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LS_WIHEADER_WI_ID  text
*----------------------------------------------------------------------*
FORM get_workflow_initiator  USING    p_ls_wiheader_wi_id
                             CHANGING p_init_pernr
                                      p_pernr_retcode.

  DATA:
    p_wiid TYPE sww_wiid,
    s_container TYPE TABLE OF swr_cont,
    rtcode TYPE sy-subrc.

  DATA:
    ls_s_container TYPE swr_cont.

  CLEAR p_wiid.
  PERFORM get_parent_wiid USING    p_ls_wiheader_wi_id
                          CHANGING p_wiid.

  IF NOT p_wiid IS INITIAL.
    CLEAR s_container.
    PERFORM read_wf_container TABLES s_container
                               USING p_wiid
                            CHANGING rtcode.

    IF rtcode = 0.
      CLEAR ls_s_container.
      READ TABLE s_container INTO ls_s_container WITH KEY element = &apos;_WF_INITIATOR&apos;.
      IF sy-subrc = 0.
        PERFORM get_pernr_from_user USING    ls_s_container-value
                                    CHANGING p_init_pernr
                                             p_pernr_retcode.
      ENDIF.

    ENDIF.
  ENDIF.

ENDFORM.                    &quot; GET_WORKFLOW_INITIATOR

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PARENT_WIID
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_P_LS_WIHEADER_WI_ID  text
*      &lt;--P_P_WIID  text
*----------------------------------------------------------------------*
FORM get_parent_wiid  USING    p_p_ls_wiheader_wi_id
                      CHANGING p_p_wiid.

  DATA:
    wi_detail TYPE swr_widtl,
    retcode   TYPE sy-subrc.


  CLEAR:
     retcode,
     wi_detail.


  CALL FUNCTION &apos;SAP_WAPI_GET_WORKITEM_DETAIL&apos;
    EXPORTING
      workitem_id     = p_p_ls_wiheader_wi_id
    IMPORTING
      workitem_detail = wi_detail
      return_code     = retcode.

  IF retcode = 0.
    p_p_wiid = wi_detail-wi_chckwi.
  ENDIF.

ENDFORM.                    &quot; GET_PARENT_WIID

*&amp;---------------------------------------------------------------------*
*&amp;      Form  READ_WF_CONTAINER
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_INDC  text
*      &lt;--P_S_CONTAINER  text
*----------------------------------------------------------------------*
FORM read_wf_container  TABLES   p_s_container
                        USING    p_p_wiid
                        CHANGING p_rtcode.


  CALL FUNCTION &apos;SAP_WAPI_READ_CONTAINER&apos;
    EXPORTING
      workitem_id      = p_p_wiid
    IMPORTING
      return_code      = p_rtcode
    TABLES
      simple_container = p_s_container.

ENDFORM.                    &quot; READ_WF_CONTAINER

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_PERNR_FROM_USER
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_P_INIT_PERNR  text
*----------------------------------------------------------------------*
FORM get_pernr_from_user USING    p_ls_s_container_value
                         CHANGING p_p_init_pernr
                                  p_p_pernr_retcode.

  DATA:
    lv_usrid TYPE sysid.

  IF p_ls_s_container_value(2) = &apos;US&apos;.
    lv_usrid = p_ls_s_container_value+2(12).
  ELSE.
    lv_usrid = p_ls_s_container_value.
  ENDIF.

  SELECT SINGLE pernr INTO p_p_init_pernr
    FROM pa0105
   WHERE subty = &apos;0001&apos;
     AND endda GE sy-datum
     AND begda LE sy-datum
     AND usrid = lv_usrid.

  p_p_pernr_retcode = sy-subrc.

ENDFORM.                    &quot; GET_PERNR_FROM_USER

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_WORKFLOW_INITIATOR_KOSTL
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_INIT_PERNR  text
*      &lt;--P_INIT_KOSTL  text
*----------------------------------------------------------------------*
FORM get_workflow_initiator_kostl  USING    p_init_pernr
                                   CHANGING p_init_kostl.

  SELECT SINGLE kostl INTO p_init_kostl
    FROM pa0001
   WHERE pernr = p_init_pernr
     AND endda GE sy-datum
     AND begda LE sy-datum.



ENDFORM.                    &quot; GET_WORKFLOW_INITIATOR_KOSTL

*&amp;---------------------------------------------------------------------*
*&amp;      Form  HANDLE_COMPLETED_NOT_POSTED
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_G_WIHEADER  text
*----------------------------------------------------------------------*
FORM handle_completed_not_posted  CHANGING p_g_wiheader TYPE swfatalvitm.
  &quot;WF status from SWWWIHEAD wiid =&gt; 14005 and ws

  DATA:
        ls_wiheader TYPE swfaalvitm,
        p_wiid TYPE sww_wiid,
         wi_detail TYPE swr_widtl,
    retcode   TYPE sy-subrc.

  CLEAR ls_wiheader.

  &quot;Remove successfully posted workitems
  DELETE p_g_wiheader WHERE zz_postd = &apos;TRUE&apos;.

  &quot;Remove un-completed wi&apos;s
  LOOP AT p_g_wiheader INTO ls_wiheader.

    PERFORM get_parent_wiid
             USING
                ls_wiheader-wi_id
             CHANGING
                p_wiid.

    CLEAR:
       retcode,
       wi_detail.

    CALL FUNCTION &apos;SAP_WAPI_GET_WORKITEM_DETAIL&apos;
      EXPORTING
        workitem_id     = p_wiid
      IMPORTING
        workitem_detail = wi_detail
        return_code     = retcode.

    IF retcode = 0.
      IF wi_detail-wi_stat NE &apos;COMPLETED&apos;.
        DELETE TABLE p_g_wiheader FROM ls_wiheader.
      ELSE.
        CLEAR ls_wiheader-zz_winod.
        MODIFY p_g_wiheader FROM ls_wiheader.
      ENDIF.
    ELSE.
      CLEAR ls_wiheader-zz_winod.
      MODIFY p_g_wiheader FROM ls_wiheader.
    ENDIF.

    CLEAR ls_wiheader.
  ENDLOOP.
  &quot;check postings specific to ws
ENDFORM.                    &quot; HANDLE_COMPLETED_NOT_POSTED

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_APPROVER_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_G_WIHEADER  text
*----------------------------------------------------------------------*
FORM get_approver_data  CHANGING p_g_wiheader TYPE swfatalvitm.

  DATA:
    p0000 TYPE pa0000,
    p0001 TYPE pa0001,
    p0007 TYPE pa0007,
    p0008 TYPE pa0008,
    p2010 TYPE pa2010,
    p0015 TYPE pa0015,
    p3202 TYPE pa3202,
    p2002 TYPE pa2002,
    p0006 TYPE pa2006.

  DATA:
    p_wiid TYPE sww_wiid,
    s_container TYPE TABLE OF swr_cont,
    rtcode TYPE sy-subrc,
    retcode TYPE sy-subrc,
    ls_wiheader TYPE swfaalvitm,
    ls_parentwi TYPE parentwi,
    ls_childwi  TYPE parentwi,
    ls_childwi2  TYPE parentwi,
    ls_nodetab  TYPE parentwi.

  DATA:
   ls_s_container TYPE swr_cont.

  DATA:
    lv_app1_user TYPE swp_initia,
    lv_app2_user TYPE swp_initia,
    lv_app3_user TYPE swp_initia,
    lv_app4_user TYPE swp_initia.

  DATA:
      lv_pernr      TYPE pernr_d,
      lv_date       TYPE sy-datum,
      lv_tabix      TYPE sy-tabix,
      lv_subty      TYPE subty,
      lv_massn      TYPE massn,
      lv_massg      TYPE massg,
      lv_schkz      TYPE schkn,
      lv_new_plans  TYPE plans,
      lv_date_from TYPE sy-datum,
      lv_date_to TYPE sy-datum.

  CLEAR:
     p_wiid,
     ls_wiheader,
     ls_parentwi.

  LOOP AT gt_parentwi INTO ls_parentwi.
    CLEAR:
       ls_childwi,
       s_container[],
       gt_nodetab[].
    LOOP AT gt_childwi INTO ls_childwi WHERE pwiid = ls_parentwi-pwiid.
      CLEAR
         ls_wiheader.

      LOOP AT p_g_wiheader INTO ls_wiheader WHERE wi_id = ls_childwi-cwiid.
        CLEAR:
           lv_app1_user,
           lv_app2_user,
           lv_app3_user,
           lv_app4_user.

        IF s_container[] IS INITIAL.
          PERFORM read_wf_container TABLES s_container
                                   USING ls_parentwi-pwiid
                                CHANGING rtcode.
        ENDIF.

        IF gt_nodetab[] IS INITIAL.
          CLEAR:
          ls_childwi2,
          ls_nodetab,
          steps.

          LOOP AT gt_childwi2 INTO ls_childwi2 WHERE pwiid = ls_parentwi-pwiid.
            MOVE-CORRESPONDING ls_childwi2 TO ls_nodetab.
            APPEND ls_nodetab TO gt_nodetab.
            CLEAR:
               ls_childwi2,
               ls_nodetab.
          ENDLOOP.

          SORT gt_nodetab BY wi_cd DESCENDING wi_ct ASCENDING.
          DESCRIBE TABLE gt_nodetab LINES steps.
        ENDIF.


        CASE ls_parentwi-wi_rh_task.
          WHEN &apos;WS90000001&apos;.  &quot;Leave Encashment Workflow
            DATA:
              lt_pa0416 TYPE STANDARD TABLE OF pa0416,
              lv_numbr  TYPE ptm_qsettled.

            DATA:
              ls_pa0416 TYPE pa0416.

            CLEAR:
               ls_s_container,
               lv_pernr,
               lv_date,
               lt_pa0416[],
               ls_pa0416,
               lv_numbr.

            LOOP AT s_container INTO ls_s_container WHERE element = &apos;APPROVER&apos;
                                                       OR element = &apos;ADMINISTRATOR&apos;
                                                       OR element = &apos;PERNR&apos;
                                                       OR element = &apos;DATE&apos;.
              CASE ls_s_container-element.
                WHEN &apos;APPROVER&apos;.
                  lv_app1_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 1.
                    idx  = 1.
                  ENDIF.

                  PERFORM get_napprover_data     USING    lv_app1_user
                                                          idx
                                                 CHANGING ls_wiheader-zz_approver1
                                                          ls_wiheader-zz_appr1email
                                                          ls_wiheader-zz_appr1status
                                                          ls_wiheader-zz_wifwd.


                WHEN &apos;ADMINISTRATOR&apos;.
                  lv_app2_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 2.
                    idx  = 2.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app2_user
                                                       idx
                                              CHANGING ls_wiheader-zz_approver2
                                                       ls_wiheader-zz_appr2email
                                                       ls_wiheader-zz_appr2status
                                                       ls_wiheader-zz_wifwd.


                WHEN &apos;PERNR&apos;.
                  lv_pernr = ls_s_container-value.
                WHEN &apos;DATE&apos;.
                  lv_date = ls_s_container-value.
                WHEN OTHERS.
              ENDCASE.

              IF NOT lv_pernr IS INITIAL AND NOT lv_date IS INITIAL.
                SELECT * INTO TABLE lt_pa0416
                  FROM pa0416
                 WHERE pernr = lv_pernr
                   AND endda GE lv_date
                   AND begda LE lv_date.
                IF NOT lt_pa0416[] IS INITIAL.
                  DATA: lock_indc(1).
                  LOOP AT lt_pa0416 INTO ls_pa0416.
                    lv_numbr = lv_numbr + ls_pa0416-numbr.
                    IF ls_pa0416-sprps = &apos;X&apos;.
                      lock_indc = &apos;X&apos;.
                    ENDIF.
                  ENDLOOP.
                  ls_wiheader-zz_quantity = lv_numbr.
                  IF lock_indc = &apos;X&apos;.
                    ls_wiheader-zz_postd = &apos;FALSE&apos;.
                    ls_wiheader-zz_wimsg = &apos;IT0416 record still in locked status.&apos;.
                  ELSE.
                    ls_wiheader-zz_postd = &apos;TRUE&apos;.
                  ENDIF.
                ELSE.
                  ls_wiheader-zz_postd = &apos;FALSE&apos;.
                  ls_wiheader-zz_wimsg = &apos;IT0416 record does not exist.&apos;.
                ENDIF.
              ENDIF.

              CLEAR  ls_s_container.
            ENDLOOP.

            PERFORM get_no_days USING    ls_childwi-cwiid
                                CHANGING ls_wiheader-zz_winod.

          WHEN &apos;WS90000002&apos;. &quot;Leave Workflow - Issue with processing the approval levels as this is controlled on exit
            IF steps GT 0.
              DATA: lv_user TYPE xubname.
              IF steps LT 2.    &quot;1 WI
                CLEAR ls_nodetab.
                READ TABLE gt_nodetab INTO ls_nodetab INDEX 1.
                IF NOT ls_nodetab IS INITIAL.
                  CLEAR lv_user.
                  SELECT SINGLE user_id INTO lv_user
                    FROM swwuserwi
                   WHERE wi_id = ls_nodetab-cwiid.

                  IF NOT lv_user IS INITIAL.
                    lv_app1_user = lv_user.

                    CLEAR idx.
                    IF steps GE 1.
                      idx  = 1.
                    ENDIF.

                    PERFORM get_napprover_data     USING lv_app1_user
                                                         idx
                                                CHANGING ls_wiheader-zz_approver1
                                                         ls_wiheader-zz_appr1email
                                                         ls_wiheader-zz_appr1status
                                                         ls_wiheader-zz_wifwd.
                  ENDIF.
                ENDIF.
              ELSE.             &quot;2 WI
                &quot;1st WI
                CLEAR ls_nodetab.
                READ TABLE gt_nodetab INTO ls_nodetab INDEX 1.
                IF NOT ls_nodetab IS INITIAL.
                  CLEAR lv_user.
                  SELECT SINGLE user_id INTO lv_user
                    FROM swwuserwi
                   WHERE wi_id = ls_nodetab-cwiid.

                  IF NOT lv_user IS INITIAL.
                    lv_app1_user = lv_user.

                    CLEAR idx.
                    IF steps GE 1.
                      idx  = 1.
                    ENDIF.

                    PERFORM get_napprover_data     USING lv_app1_user
                                                         idx
                                                CHANGING ls_wiheader-zz_approver1
                                                         ls_wiheader-zz_appr1email
                                                         ls_wiheader-zz_appr1status
                                                         ls_wiheader-zz_wifwd.

                  ENDIF.
                ENDIF.

                &quot;2nd WI
                CLEAR ls_nodetab.
                READ TABLE gt_nodetab INTO ls_nodetab INDEX 2.
                IF NOT ls_nodetab IS INITIAL.
                  CLEAR lv_user.
                  SELECT SINGLE user_id INTO lv_user
                    FROM swwuserwi
                   WHERE wi_id = ls_nodetab-cwiid.

                  IF NOT lv_user IS INITIAL.
                    lv_app2_user = lv_user.

                    CLEAR idx.
                    IF steps GE 2.
                      idx  = 2.
                    ENDIF.

                    PERFORM get_napprover_data USING lv_app1_user
                                                     idx
                                            CHANGING ls_wiheader-zz_approver1
                                                     ls_wiheader-zz_appr1email
                                                     ls_wiheader-zz_appr1status
                                                     ls_wiheader-zz_wifwd.


                  ENDIF.
                ENDIF.
              ENDIF.
            ENDIF.

            &quot;Get wf container
            PERFORM get_leave_data USING    ls_parentwi-pwiid
                                   CHANGING ls_wiheader-zz_quantity
                                            ls_wiheader-zz_postd.

            IF ls_wiheader-zz_postd = &apos;FALSE&apos;.
              ls_wiheader-zz_wimsg = &apos;IT2001 record does not exist.&apos;.
            ENDIF.

            PERFORM get_no_days USING    ls_childwi-cwiid
                                CHANGING ls_wiheader-zz_winod.
          WHEN &apos;WS90000003&apos;. &quot;Out of Cycle Increase
            CLEAR: ls_s_container,
                   lv_pernr,
                   lv_date.

            LOOP AT s_container INTO ls_s_container WHERE element = &apos;APPROVER1&apos;
                                                       OR element = &apos;APPROVER2&apos;
                                                       OR element = &apos;APPROVER3&apos;
                                                       OR element = &apos;DATE&apos;
                                                       OR element = &apos;PERNR&apos;.
              CASE ls_s_container-element.
                WHEN &apos;APPROVER1&apos;.

                  lv_app1_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 1.
                    idx  = 1.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app1_user
                                                       idx
                                              CHANGING ls_wiheader-zz_approver1
                                                       ls_wiheader-zz_appr1email
                                                       ls_wiheader-zz_appr1status
                                                       ls_wiheader-zz_wifwd.


                WHEN &apos;APPROVER2&apos;.
                  lv_app2_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 2.
                    idx  = 2.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app2_user
                                                     idx
                                            CHANGING ls_wiheader-zz_approver2
                                                     ls_wiheader-zz_appr2email
                                                     ls_wiheader-zz_appr2status
                                                     ls_wiheader-zz_wifwd.


                WHEN &apos;APPROVER3&apos;.

                  lv_app3_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 3.
                    idx  = 3.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app3_user
                                                 idx
                                        CHANGING ls_wiheader-zz_approver3
                                                 ls_wiheader-zz_appr3email
                                                 ls_wiheader-zz_appr3status
                                                 ls_wiheader-zz_wifwd.



                WHEN &apos;DATE&apos;.
                  lv_date = ls_s_container-value.
                WHEN &apos;PERNR&apos;.
                  lv_pernr = ls_s_container-value.
                WHEN OTHERS.
              ENDCASE.
              CLEAR  ls_s_container.
            ENDLOOP.

            CLEAR p0008.
            PERFORM get_posting_data USING    lv_pernr
                                              lv_date
                                              &apos;99991231&apos;
                                              &apos;0&apos;
                                              &apos;PA0008&apos;
                                     CHANGING p0008
                                              ls_wiheader-zz_postd.

            IF ls_wiheader-zz_postd = &apos;FALSE&apos;.
              ls_wiheader-zz_wimsg = &apos;IT0008 record is either locked or does not exist.&apos;.
            ENDIF.

* To add the following commented logic when out of cycle qty required.
*            IF not p0008 is INITIAL.
*             ls_wiheader-zz_quantity = p0008-ansal.
*            ENDIF.

            PERFORM get_no_days USING    ls_childwi-cwiid
                                CHANGING ls_wiheader-zz_winod.

          WHEN &apos;WS90000004&apos;.  &quot;Additional Pay Workflow
            CLEAR:
               ls_s_container,
               lv_pernr,
               lv_date,
               lv_lgart.

            LOOP AT s_container INTO ls_s_container WHERE element = &apos;KOSTL_OWNER&apos;
                                                       OR element = &apos;HRADMINID&apos;
                                                       OR element = &apos;LGART&apos;
                                                       OR element = &apos;PERNR&apos;
                                                       OR element = &apos;BEGDA&apos;
                                                       OR element = &apos;ANZHL&apos;.
              CASE ls_s_container-element.
                WHEN &apos;KOSTL_OWNER&apos;.

                  lv_app1_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 1.
                    idx  = 1.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app1_user
                                                      idx
                                             CHANGING ls_wiheader-zz_approver1
                                                      ls_wiheader-zz_appr1email
                                                      ls_wiheader-zz_appr1status
                                                      ls_wiheader-zz_wifwd.



                WHEN &apos;HRADMINID&apos;.
                  lv_app2_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 2.
                    idx  = 2.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app2_user
                                                      idx
                                             CHANGING ls_wiheader-zz_approver2
                                                      ls_wiheader-zz_appr2email
                                                      ls_wiheader-zz_appr2status
                                                      ls_wiheader-zz_wifwd.


                WHEN &apos;PERNR&apos;.
                  lv_pernr = ls_s_container-value.
                WHEN &apos;BEGDA&apos;.
                  lv_date = ls_s_container-value.
                WHEN &apos;LGART&apos;.
                  lv_lgart = ls_s_container-value.
                WHEN &apos;ANZHL&apos;.
                  ls_wiheader-zz_quantity = ls_s_container-value.
                WHEN OTHERS.
              ENDCASE.
              CLEAR  ls_s_container.
            ENDLOOP.

            IF lv_lgart IN r_wtypes.                        &quot;IT2010

              CLEAR p2010.
              PERFORM get_posting_data USING    lv_pernr
                                                lv_date
                                                lv_date
                                                lv_lgart
                                                &apos;PA2010&apos;
                                       CHANGING p2010
                                                ls_wiheader-zz_postd.

              IF ls_wiheader-zz_postd = &apos;FALSE&apos;.
                ls_wiheader-zz_wimsg = &apos;IT2010 record is either locked or does not exist.&apos;.
              ENDIF.

            ELSE.                                           &quot;IT0015

              CLEAR p0015.
              PERFORM get_posting_data USING    lv_pernr
                                                lv_date
                                                lv_date
                                                lv_lgart
                                                &apos;PA0015&apos;
                                       CHANGING p0015
                                                ls_wiheader-zz_postd.

              IF ls_wiheader-zz_postd = &apos;FALSE&apos;.
                ls_wiheader-zz_wimsg = &apos;IT0015 record is either locked or does not exist.&apos;.
              ENDIF.

            ENDIF.

            PERFORM get_no_days USING    ls_childwi-cwiid
                                CHANGING ls_wiheader-zz_winod.

          WHEN &apos;WS90000005&apos;.  &quot;Car Allowance Workflow
            CLEAR:
               ls_s_container,
               lv_pernr.
            LOOP AT s_container INTO ls_s_container WHERE element = &apos;USER&apos;
                                                       OR element = &apos;_WF_INITIATOR&apos;
                                                       OR element = &apos;BETRG&apos;
                                                       OR element = &apos;PERNR&apos;.

              CASE ls_s_container-element.
                WHEN &apos;USER&apos;.

                  lv_app1_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 1.
                    idx  = 1.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app1_user
                                                       idx
                                              CHANGING ls_wiheader-zz_approver1
                                                       ls_wiheader-zz_appr1email
                                                       ls_wiheader-zz_appr1status
                                                       ls_wiheader-zz_wifwd.

                  lv_app3_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 3.
                    idx  = 3.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app3_user
                                                     idx
                                            CHANGING ls_wiheader-zz_approver3
                                                     ls_wiheader-zz_appr3email
                                                     ls_wiheader-zz_appr3status
                                                     ls_wiheader-zz_wifwd.


                WHEN &apos;_WF_INITIATOR&apos;.
                  lv_app2_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 2.
                    idx  = 2.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app2_user
                                                     idx
                                            CHANGING ls_wiheader-zz_approver2
                                                     ls_wiheader-zz_appr2email
                                                     ls_wiheader-zz_appr2status
                                                     ls_wiheader-zz_wifwd.

                WHEN &apos;BETRG&apos;.
*                  Following line to be uncommented if qty required.
*                  ls_wiheader-zz_quantity = ls_s_container-value.
                WHEN &apos;PERNR&apos;.
                  lv_pernr = ls_s_container-value.
                WHEN OTHERS.
              ENDCASE.
              CLEAR  ls_s_container.
            ENDLOOP.

            IF steps GT 1.
              CLEAR ls_nodetab.
              READ TABLE gt_nodetab INTO ls_nodetab INDEX 2.
              IF NOT ls_nodetab IS INITIAL.
                DATA: w_date TYPE sy-datum,
                      day_in TYPE sy-datum.

                day_in = ls_nodetab-wi_aed.

                CALL FUNCTION &apos;FKK_LAST_DAY_OF_MONTH&apos;
                  EXPORTING
                    day_in            = day_in
                  IMPORTING
                    last_day_of_month = w_date
                  EXCEPTIONS
                    day_in_no_date    = 1
                    OTHERS            = 2.

                ADD 1 TO w_date.

                CLEAR p0008.
                PERFORM get_posting_data USING    lv_pernr
                                                  w_date
                                                  &apos;99991231&apos;
                                                  &apos;0&apos;
                                                  &apos;PA0008&apos;
                                         CHANGING p0008
                                                  ls_wiheader-zz_postd.

                IF ls_wiheader-zz_postd = &apos;FALSE&apos;.
                  ls_wiheader-zz_wimsg = &apos;IT0008 record is either locked or does not exist.&apos;.
                ENDIF.

              ENDIF.
            ELSE.
              ls_wiheader-zz_postd = &apos;FALSE&apos;.
              ls_wiheader-zz_wimsg = &apos;IT0008 record does not exist.&apos;.
            ENDIF.


            PERFORM get_no_days USING    ls_childwi-cwiid
                                CHANGING ls_wiheader-zz_winod.

          WHEN &apos;WS90000006&apos;.  &quot;Terminations Workflow
            CLEAR ls_s_container.
            DATA: err_indc(1),
                  return TYPE bapireturn1.
            CLEAR: err_indc,
                   lv_tabix,
                   return.
            LOOP AT s_container INTO ls_s_container WHERE element = &apos;HRBP_USER&apos;
                                                       OR element = &apos;EE_USER&apos;
                                                       OR element = &apos;HRADMIN_USER&apos;
                                                       OR element = &apos;RETURN&apos;
                                                       OR element = &apos;RETURN_0000&apos;
                                                       OR element = &apos;RETURN_0001&apos;
                                                       OR element = &apos;RETURN_9001&apos;.
              CASE ls_s_container-element.
                WHEN &apos;HRBP_USER&apos;.

                  lv_app1_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 1.
                    idx  = 1.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app1_user
                                                       idx
                                              CHANGING ls_wiheader-zz_approver1
                                                       ls_wiheader-zz_appr1email
                                                       ls_wiheader-zz_appr1status
                                                       ls_wiheader-zz_wifwd.

                WHEN &apos;EE_USER&apos;.
                  lv_app2_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 2.
                    idx  = 2.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app2_user
                                                     idx
                                            CHANGING ls_wiheader-zz_approver2
                                                     ls_wiheader-zz_appr2email
                                                     ls_wiheader-zz_appr2status
                                                     ls_wiheader-zz_wifwd.

                WHEN &apos;HRADMIN_USER&apos;.

                  lv_app3_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 3.
                    idx  = 3.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app3_user
                                                      idx
                                             CHANGING ls_wiheader-zz_approver3
                                                      ls_wiheader-zz_appr3email
                                                      ls_wiheader-zz_appr3status
                                                      ls_wiheader-zz_wifwd.

                WHEN &apos;RETURN&apos;.
                  IF err_indc IS INITIAL AND lv_tabix IS INITIAL.
                    IF ls_s_container-value = &apos;E&apos;.
                      return-type = ls_s_container-value.
                      err_indc = &apos;X&apos;.
                      lv_tabix = sy-tabix + 3.
                    ENDIF.
                  ELSE.
                    IF lv_tabix = sy-tabix.
                      return-message = ls_s_container-value.
                    ENDIF.
                  ENDIF.
                WHEN &apos;RETURN_0000&apos;.
                  IF err_indc IS INITIAL AND lv_tabix IS INITIAL.
                    IF ls_s_container-value = &apos;E&apos;.
                      return-type = ls_s_container-value.
                      err_indc = &apos;X&apos;.
                      lv_tabix = sy-tabix + 3.
                    ENDIF.
                  ELSE.
                    IF lv_tabix = sy-tabix.
                      return-message = ls_s_container-value.
                    ENDIF.
                  ENDIF.
                WHEN &apos;RETURN_0001&apos;.
                  IF err_indc IS INITIAL AND lv_tabix IS INITIAL.
                    IF ls_s_container-value = &apos;E&apos;.
                      return-type = ls_s_container-value.
                      err_indc = &apos;X&apos;.
                      lv_tabix = sy-tabix + 3.
                    ENDIF.
                  ELSE.
                    IF lv_tabix = sy-tabix.
                      return-message = ls_s_container-value.
                    ENDIF.
                  ENDIF.
                WHEN &apos;RETURN_9001&apos;.
                  IF err_indc IS INITIAL AND lv_tabix IS INITIAL.
                    IF ls_s_container-value = &apos;E&apos;.
                      return-type = ls_s_container-value.
                      err_indc = &apos;X&apos;.
                      lv_tabix = sy-tabix + 3.
                    ENDIF.
                  ELSE.
                    IF lv_tabix = sy-tabix.
                      return-message = ls_s_container-value.
                    ENDIF.
                  ENDIF.
                WHEN OTHERS.
              ENDCASE.
              CLEAR  ls_s_container.
            ENDLOOP.

            IF return-type = &apos;E&apos;.
              ls_wiheader-zz_postd = &apos;FALSE&apos;.
              ls_wiheader-zz_wimsg = return-message.
            ELSE.
              ls_wiheader-zz_postd = &apos;TRUE&apos;.
            ENDIF.


            PERFORM get_no_days USING    ls_childwi-cwiid
                                CHANGING ls_wiheader-zz_winod.

          WHEN &apos;WS90000007&apos;.  &quot;Labour Relations Workflow
            CLEAR:
               ls_s_container,
               lv_pernr,
               lv_date,
               lv_subty.
            LOOP AT s_container INTO ls_s_container WHERE element = &apos;LR_USER&apos;
                                                       OR element = &apos;ADMINISTRATOR&apos;
                                                       OR element = &apos;PERNR&apos;
                                                       OR element = &apos;BEGDA&apos;
                                                       OR element = &apos;SUBTY&apos;.
              CASE ls_s_container-element.
                WHEN &apos;LR_USER&apos;.
                  lv_app1_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 1.
                    idx  = 1.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app1_user
                                                      idx
                                             CHANGING ls_wiheader-zz_approver1
                                                      ls_wiheader-zz_appr1email
                                                      ls_wiheader-zz_appr1status
                                                      ls_wiheader-zz_wifwd.


                WHEN &apos;ADMINISTRATOR&apos;.
                  lv_app2_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 2.
                    idx  = 2.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app2_user
                                                      idx
                                             CHANGING ls_wiheader-zz_approver2
                                                      ls_wiheader-zz_appr2email
                                                      ls_wiheader-zz_appr2status
                                                      ls_wiheader-zz_wifwd.


                WHEN &apos;PERNR&apos;.
                  lv_pernr = ls_s_container-value.
                WHEN &apos;BEGDA&apos;.
                  lv_date = ls_s_container-value.
                WHEN &apos;SUBTY&apos;.
                  lv_subty = ls_s_container-value.
                WHEN OTHERS.
              ENDCASE.
              CLEAR  ls_s_container.
            ENDLOOP.

            CLEAR p3202.
            SELECT SINGLE * INTO p3202
              FROM pa3202
             WHERE pernr = lv_pernr
               AND subty = lv_subty
               AND sprps NE &apos;X&apos;
               AND endda GE lv_date
               AND begda LE lv_date.

            IF sy-subrc = 0.
              ls_wiheader-zz_postd = &apos;TRUE&apos;.
            ELSE.
              ls_wiheader-zz_postd = &apos;FALSE&apos;.
              ls_wiheader-zz_wimsg = &apos;IT3202 record is either locked or does not exist.&apos;.
            ENDIF.


            PERFORM get_no_days USING    ls_childwi-cwiid
                                            CHANGING ls_wiheader-zz_winod.
          WHEN &apos;WS90000008&apos;.  &quot;Organisational Reassignment Workflow

            CLEAR:
               ls_s_container,
               lv_massn,
               lv_massg,
               lv_schkz,
               lv_new_plans,
               lv_date,
               lv_pernr.

            LOOP AT s_container INTO ls_s_container WHERE element = &apos;NEW_MGR_USER&apos;
                                                       OR element = &apos;NEXT_MGR_USER&apos;
                                                       OR element = &apos;HRBP_USER&apos;
                                                       OR element = &apos;OCI_MGR_USER&apos;
                                                       OR element = &apos;MASSN&apos;
                                                       OR element = &apos;MASSG&apos;
                                                       OR element = &apos;SCHKZ&apos;
                                                       OR element = &apos;NEW_PLANS&apos;
                                                       OR element = &apos;BEGDA&apos;
                                                       OR element = &apos;PERNR&apos;.

              CASE ls_s_container-element.
                WHEN &apos;NEW_MGR_USER&apos;.
                  lv_app1_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 1.
                    idx  = 1.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app1_user
                                                     idx
                                            CHANGING ls_wiheader-zz_approver1
                                                     ls_wiheader-zz_appr1email
                                                     ls_wiheader-zz_appr1status
                                                     ls_wiheader-zz_wifwd.

                WHEN &apos;NEXT_MGR_USER&apos;.
                  lv_app2_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 2.
                    idx  = 2.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app2_user
                                                      idx
                                             CHANGING ls_wiheader-zz_approver2
                                                      ls_wiheader-zz_appr2email
                                                      ls_wiheader-zz_appr2status
                                                      ls_wiheader-zz_wifwd.

                WHEN &apos;HRBP_USER&apos;.
                  lv_app3_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 3.
                    idx  = 3.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app3_user
                                                       idx
                                              CHANGING ls_wiheader-zz_approver3
                                                       ls_wiheader-zz_appr3email
                                                       ls_wiheader-zz_appr3status
                                                       ls_wiheader-zz_wifwd.

                WHEN &apos;OCI_MGR_USER&apos;.
                  lv_app4_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 4.
                    idx  = 4.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app4_user
                                                       idx
                                              CHANGING ls_wiheader-zz_approver4
                                                       ls_wiheader-zz_appr4email
                                                       ls_wiheader-zz_appr4status
                                                       ls_wiheader-zz_wifwd.

                WHEN &apos;MASSN&apos;.
                  lv_massn = ls_s_container-value.
                WHEN &apos;MASSG&apos;.
                  lv_massg = ls_s_container-value.
                WHEN &apos;SCHKZ&apos;.
                  lv_schkz = ls_s_container-value.
                WHEN &apos;NEW_PLANS&apos;.
                  lv_new_plans = ls_s_container-value.
                WHEN &apos;BEGDA&apos;.
                  lv_date = ls_s_container-value.
                WHEN &apos;PERNR&apos;.
                  lv_pernr = ls_s_container-value.
                WHEN OTHERS.
              ENDCASE.
              CLEAR  ls_s_container.
            ENDLOOP.

            PERFORM get_org_reas_data USING    lv_pernr
                                               lv_date
                                               lv_new_plans
                                               lv_schkz
                                               lv_massg
                                               lv_massn
                                      CHANGING ls_wiheader-zz_postd
                                               ls_wiheader-zz_wimsg.

            PERFORM get_no_days USING    ls_childwi-cwiid
                                CHANGING ls_wiheader-zz_winod.

          WHEN &apos;WS90000009&apos;.  &quot;Timesheet Approval
            CLEAR:
               ls_s_container,
               lv_date_from,
               lv_date_to,
               lv_pernr.
            LOOP AT s_container INTO ls_s_container WHERE element = &apos;APPROVER&apos;
                                                      AND element = &apos;DATE_FROM&apos;
                                                      AND element = &apos;DATE_TO&apos;
                                                      AND element = &apos;PERNR&apos;.
              CASE ls_s_container-element.
                WHEN &apos;APPROVER&apos;.
                  lv_app1_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 1.
                    idx  = 1.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app1_user
                                                       idx
                                              CHANGING ls_wiheader-zz_approver1
                                                       ls_wiheader-zz_appr1email
                                                       ls_wiheader-zz_appr1status
                                                       ls_wiheader-zz_wifwd.


                WHEN &apos;DATE_FROM&apos;.
                  lv_date_from = ls_s_container-value.
                WHEN &apos;DATE_TO&apos;.
                  lv_date_to = ls_s_container-value.
                WHEN &apos;PERNR&apos;.
                  lv_pernr = ls_s_container-value.
                WHEN OTHERS.
              ENDCASE.
              CLEAR  ls_s_container.
            ENDLOOP.

            IF NOT ( lv_date_from IS INITIAL AND lv_date_to IS INITIAL ).
              WHILE lv_date_from NE lv_date_to.

                PERFORM get_posting_data USING     lv_pernr
                                                   lv_date_from
                                                   lv_date_from
                                                   &apos;1000&apos;
                                                   &apos;PA2002&apos;
                                          CHANGING p2002
                                                   ls_wiheader-zz_postd.

                IF ls_wiheader-zz_postd = &apos;TRUE&apos;.
                  EXIT.
                ENDIF.

                lv_date_from = lv_date_from + 1.
              ENDWHILE.
            ENDIF.

            IF ls_wiheader-zz_postd = &apos;FALSE&apos;.
              ls_wiheader-zz_wimsg = &apos;IT2002 records do not exist.&apos;.
            ENDIF.


            PERFORM get_no_days USING    ls_childwi-cwiid
                                            CHANGING ls_wiheader-zz_winod.
          WHEN &apos;WS90000010&apos;.  &quot;Learning Workflow
            CLEAR:
               ls_s_container,
               lv_pernr,
               lv_lgart,
               lv_date.
            LOOP AT s_container INTO ls_s_container WHERE element = &apos;KOSTL_USER&apos;
                                                       OR element = &apos;LD_USER&apos;
                                                       OR element = &apos;MGR_USER&apos;
                                                       OR element = &apos;PERNR&apos;
                                                       OR element = &apos;BETRG&apos;
                                                       OR element = &apos;LGART&apos;.

              CASE ls_s_container-element.
                WHEN &apos;PERNR&apos;.
                  lv_pernr = ls_s_container-value.
                WHEN &apos;BETRG&apos;.
                  ls_wiheader-zz_quantity = ls_s_container-value.
                WHEN &apos;LGART&apos;.
                  lv_lgart = ls_s_container-value.
                WHEN &apos;KOSTL_USER&apos;.
                  CLEAR ls_nodetab.
                  READ TABLE gt_nodetab INTO ls_nodetab INDEX 1.
                  IF sy-subrc = 0.
                    IF ls_s_container-value = ls_nodetab-wi_aagent.
                      lv_app1_user = ls_s_container-value.

                      CLEAR idx.
                      IF steps GE 1.
                        idx  = 1.
                      ENDIF.

                      PERFORM get_napprover_data     USING lv_app1_user
                                                           idx
                                                  CHANGING ls_wiheader-zz_approver1
                                                           ls_wiheader-zz_appr1email
                                                           ls_wiheader-zz_appr1status
                                                           ls_wiheader-zz_wifwd.


                      IF ls_nodetab-wi_aed IS INITIAL.
                        ls_wiheader-zz_postd = &apos;FALSE&apos;.
                        ls_wiheader-zz_wimsg = &apos;WS90000010 - Cannot derive posting date.&apos;.
                      ELSE.
                        lv_date = ls_nodetab-wi_aed.
                      ENDIF.

                    ELSE.
                      IF steps GT 0 AND steps NE 1.

                        lv_app3_user = ls_s_container-value.

                        CLEAR idx.
                        IF steps GE 3.
                          idx  = 3.
                        ENDIF.

                        PERFORM get_napprover_data     USING lv_app3_user
                                                             idx
                                                    CHANGING ls_wiheader-zz_approver3
                                                             ls_wiheader-zz_appr3email
                                                             ls_wiheader-zz_appr3status
                                                             ls_wiheader-zz_wifwd.

                        CLEAR ls_nodetab.
                        READ TABLE gt_nodetab INTO ls_nodetab INDEX idx.
                        IF NOT ls_nodetab IS INITIAL.
                          IF ls_nodetab-wi_aed IS INITIAL.
                            ls_wiheader-zz_postd = &apos;FALSE&apos;.
                            ls_wiheader-zz_wimsg = &apos;WS90000010 - Cannot derive posting date.&apos;.
                          ELSE.
                            lv_date = ls_nodetab-wi_aed.
                          ENDIF.
                        ENDIF.

                      ELSE.
                        IF steps GT 0.
                          lv_app1_user = ls_s_container-value.

                          CLEAR idx.
                          IF steps GE 1.
                            idx  = 1.
                          ENDIF.

                          PERFORM get_napprover_data     USING lv_app1_user
                                                               idx
                                                      CHANGING ls_wiheader-zz_approver1
                                                               ls_wiheader-zz_appr1email
                                                               ls_wiheader-zz_appr1status
                                                               ls_wiheader-zz_wifwd.


                          IF ls_nodetab-wi_aed IS INITIAL.
                            ls_wiheader-zz_postd = &apos;FALSE&apos;.
                            ls_wiheader-zz_wimsg = &apos;WS90000010 - Cannot derive posting date.&apos;.
                          ELSE.
                            lv_date = ls_nodetab-wi_aed.
                          ENDIF.

                        ENDIF.
                      ENDIF.
                    ENDIF.
                  ENDIF.
                WHEN &apos;LD_USER&apos;.
                  lv_app2_user = ls_s_container-value.

                  CLEAR idx.
                  IF steps GE 2.
                    idx  = 2.
                  ENDIF.

                  PERFORM get_napprover_data     USING lv_app2_user
                                                     idx
                                            CHANGING ls_wiheader-zz_approver2
                                                     ls_wiheader-zz_appr2email
                                                     ls_wiheader-zz_appr2status
                                                     ls_wiheader-zz_wifwd.

                WHEN &apos;MGR_USER&apos;.
                  CLEAR ls_nodetab.
                  READ TABLE gt_nodetab INTO ls_nodetab INDEX 1.
                  IF NOT ls_nodetab IS INITIAL.
                    IF ls_s_container-value = ls_nodetab-wi_aagent.
                      lv_app1_user = ls_s_container-value.

                      CLEAR idx.
                      IF steps GE 1.
                        idx  = 1.
                      ENDIF.

                      PERFORM get_napprover_data     USING lv_app1_user
                                                             idx
                                                    CHANGING ls_wiheader-zz_approver1
                                                             ls_wiheader-zz_appr1email
                                                             ls_wiheader-zz_appr1status
                                                             ls_wiheader-zz_wifwd.

                    ENDIF.
                  ENDIF.
                WHEN OTHERS.
              ENDCASE.
              CLEAR  ls_s_container.
            ENDLOOP.

            IF ls_wiheader-zz_postd NE &apos;FALSE&apos; AND NOT lv_date IS INITIAL.
              CLEAR p0015.
              PERFORM get_posting_data USING    lv_pernr
                                                lv_date
                                                lv_date
                                                lv_lgart
                                                &apos;PA0015&apos;
                                       CHANGING p0015
                                                ls_wiheader-zz_postd.

*              IF ls_wiheader-zz_postd = &apos;TRUE&apos;.
*                CLEAR p2010.
*                PERFORM get_posting_data USING    lv_pernr
*                                                  lv_date
*                                                  lv_date
*                                                  lv_lgart
*                                                  &apos;PA2010&apos;
*                                         CHANGING p2010
*                                                  ls_wiheader-zz_postd.
*
*                IF ls_wiheader-zz_postd = &apos;FALSE&apos;.
*                  ls_wiheader-zz_wimsg = &apos;IT2010 record is either locked or does not exist.&apos;.
*                ENDIF.

*              ELSE.
*                ls_wiheader-zz_wimsg = &apos;IT0015 record is either locked or does not exist.&apos;.
*              ENDIF.
              IF ls_wiheader-zz_postd = &apos;FALSE&apos;.
                ls_wiheader-zz_wimsg = &apos;IT0015 record is either locked or does not exist.&apos;.
              ENDIF.
            ENDIF.

            PERFORM get_no_days USING    ls_childwi-cwiid
                                CHANGING ls_wiheader-zz_winod.
          WHEN &apos;WS90000011&apos;. &quot;Move Plan Workflow
            DATA:
              lo_zcl_move_plan TYPE REF TO zcl_move_plan,
              lv_mpid          TYPE reorpompid,
              lv_ccea          TYPE bu_partner,
              lv_man           TYPE bu_partner,
              lv_bpid          TYPE bu_partner,
              lv_ccea_pernr    TYPE pernr_d,
              lv_ccea_user     TYPE sysid,
              lv_man_pernr     TYPE pernr_d,
              lv_man_user      TYPE sysid,
              wa0006           TYPE p0006.

            CLEAR:
               ls_s_container,
               lv_pernr,
               wa0006.
            READ TABLE s_container INTO ls_s_container WITH KEY element = &apos;MPID&apos;.
            IF NOT ls_s_container IS INITIAL.
              lv_mpid = ls_s_container-value.
              CREATE OBJECT lo_zcl_move_plan
                EXPORTING
                  mpid = lv_mpid.

              IF sy-subrc = 0.
                lv_ccea  = lo_zcl_move_plan-&gt;ccea_bpid.
                lv_man   = lo_zcl_move_plan-&gt;man_bpid.
                lv_bpid  = lo_zcl_move_plan-&gt;bpid.

                IF lv_ccea(2) = &apos;NB&apos; OR lv_ccea(2) = &apos;EE&apos;.
                  lv_ccea_pernr = lv_ccea+2(8).
                ELSE.
                  lv_ccea_pernr = lv_ccea.
                ENDIF.

                IF lv_man(2) = &apos;NB&apos; OR lv_man(2) = &apos;EE&apos;.
                  lv_man_pernr = lv_man+2(8).
                ELSE.
                  lv_man_pernr = lv_man.
                ENDIF.

                LOOP AT lo_zcl_move_plan-&gt;t_0006 INTO wa0006.
                  CLEAR p0006.
                  PERFORM get_posting_data USING  wa0006-pernr
                                                  wa0006-begda
                                                  wa0006-endda
                                                  wa0006-subty
                                                  &apos;PA0006&apos;
                                        CHANGING  p0006
                                                  ls_wiheader-zz_postd.

                  IF ls_wiheader-zz_postd = &apos;FALSE&apos;.
                    ls_wiheader-zz_wimsg = &apos;IT0006, SUBTY 90 record is either locked or does not exist.&apos;.
                    EXIT.
                  ENDIF.
                  CLEAR wa0006.
                ENDLOOP.
              ENDIF.

            ENDIF.

            IF NOT lv_ccea_pernr IS INITIAL.
              SELECT SINGLE usrid INTO lv_ccea_user
                FROM pa0105
               WHERE pernr = lv_ccea_pernr
                 AND subty = &apos;0001&apos;
                 AND endda GE sy-datum
                 AND begda LE sy-datum.
            ENDIF.

            IF NOT lv_man_pernr IS INITIAL.
              SELECT SINGLE usrid INTO lv_man_user
               FROM pa0105
              WHERE pernr = lv_man_pernr
                AND subty = &apos;0001&apos;
                AND endda GE sy-datum
                AND begda LE sy-datum.
            ENDIF.

            IF NOT lv_man_user IS INITIAL.
              lv_app1_user = lv_man_user.

              CLEAR idx.
              IF steps GE 1.
                idx  = 1.
              ENDIF.

              PERFORM get_napprover_data     USING lv_app1_user
                                               idx
                                      CHANGING ls_wiheader-zz_approver1
                                               ls_wiheader-zz_appr1email
                                               ls_wiheader-zz_appr1status
                                               ls_wiheader-zz_wifwd.

            ENDIF.

            IF NOT lv_ccea_user IS INITIAL.
              lv_app2_user = lv_ccea_user.

              CLEAR idx.
              IF steps GE 2.
                idx  = 2.
              ENDIF.

              PERFORM get_napprover_data     USING lv_app2_user
                                             idx
                                    CHANGING ls_wiheader-zz_approver2
                                             ls_wiheader-zz_appr2email
                                             ls_wiheader-zz_appr2status
                                             ls_wiheader-zz_wifwd.
            ENDIF.


            PERFORM get_no_days USING    ls_childwi-cwiid
                                CHANGING ls_wiheader-zz_winod.
          WHEN OTHERS.
        ENDCASE.
        TRANSLATE ls_wiheader-zz_appr1email TO LOWER CASE.
        TRANSLATE ls_wiheader-zz_appr2email TO LOWER CASE.
        TRANSLATE ls_wiheader-zz_appr3email TO LOWER CASE.
        TRANSLATE ls_wiheader-zz_appr4email TO LOWER CASE.
        TRANSLATE ls_wiheader-zz_last_agent_email TO LOWER CASE.
        TRANSLATE ls_wiheader-zz_reqemail TO LOWER CASE.
        MODIFY p_g_wiheader FROM ls_wiheader.
      ENDLOOP.
    ENDLOOP.
    CLEAR ls_parentwi.
  ENDLOOP.
ENDFORM.                    &quot; GET_APPROVER_DATA

*&amp;---------------------------------------------------------------------*
*&amp;      Form  PARENT_WORK_ITEM_IDS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
FORM parent_work_item_ids CHANGING pt_wiheader TYPE swfatalvitm..

  DATA:
    ls_parentwi TYPE parentwi,
    ls_wiheader TYPE swfaalvitm,
    lt_swwwihead TYPE STANDARD TABLE OF swwwihead.

  DATA:
    wi_detail     TYPE swr_widtl,
    retcode       TYPE sy-subrc,
    lv_pwiid      TYPE sww_chckwi,
    wa_swwwihead  TYPE swwwihead,
    lv_wi_rh_task TYPE sww_task.

  REFRESH gt_parentwi.

  LOOP AT pt_wiheader INTO ls_wiheader.

    CLEAR:
       ls_parentwi,
       lv_pwiid,
       lt_swwwihead[],
       lv_wi_rh_task.

    &quot;Get Parent WI
    SELECT SINGLE wi_chckwi INTO lv_pwiid
      FROM swwwihead
     WHERE wi_id = ls_wiheader-wi_id.

    IF sy-subrc = 0.

      SELECT * INTO TABLE lt_swwwihead
        FROM swwwihead
       WHERE wi_type   = &apos;W&apos;
         AND wi_chckwi = lv_pwiid.

      IF NOT lt_swwwihead IS INITIAL.
        CLEAR wa_swwwihead.
        LOOP AT lt_swwwihead INTO wa_swwwihead.

          &quot;Get Work Item Detail
          CLEAR:
             retcode,
             wi_detail.

          CALL FUNCTION &apos;SAP_WAPI_GET_WORKITEM_DETAIL&apos;
            EXPORTING
              workitem_id     = wa_swwwihead-wi_id
            IMPORTING
              workitem_detail = wi_detail
              return_code     = retcode.

          IF retcode = 0.
            ls_parentwi-cwiid       = wa_swwwihead-wi_id.
            ls_parentwi-pwiid       = wi_detail-wi_chckwi.
            ls_parentwi-wi_stat     = wi_detail-wi_stat.
            ls_parentwi-wi_aed      = wi_detail-wi_aed.
            ls_parentwi-wi_forw_by  = wi_detail-wi_forw_by.
            ls_parentwi-wi_cd       = wi_detail-wi_cd.
            ls_parentwi-wi_ct       = wi_detail-wi_ct.

            IF wi_detail-wi_stat NE &apos;COMPLETED&apos;.
              DATA:
                lv_user TYPE xubname.

              SELECT SINGLE user_id INTO lv_user
                FROM swwuserwi
               WHERE wi_id = ls_wiheader-wi_id.

              IF NOT lv_user IS INITIAL.
                CONCATENATE &apos;US&apos; lv_user INTO ls_parentwi-wi_aagent.
              ENDIF.

            ELSE.
              CONCATENATE &apos;US&apos;  wi_detail-wi_aagent INTO ls_parentwi-wi_aagent.
            ENDIF.

            SELECT SINGLE nodeid INTO ls_parentwi-wi_nodid
              FROM swp_nodewi
             WHERE wf_id = ls_parentwi-pwiid
               AND wi_id = ls_parentwi-cwiid.

            CLEAR:
               wi_detail,
               retcode.

            CALL FUNCTION &apos;SAP_WAPI_GET_WORKITEM_DETAIL&apos;
              EXPORTING
                workitem_id     = ls_parentwi-pwiid
              IMPORTING
                workitem_detail = wi_detail
                return_code     = retcode.

            IF lv_wi_rh_task IS INITIAL.
              SELECT SINGLE wi_rh_task INTO lv_wi_rh_task
                FROM swwwihead
               WHERE wi_id = ls_parentwi-pwiid
                 AND wi_type = &apos;F&apos;.
            ENDIF.
            ls_parentwi-wi_rh_task = lv_wi_rh_task.


            APPEND ls_parentwi TO gt_parentwi.
            CLEAR wa_swwwihead.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.
    CLEAR ls_wiheader.
  ENDLOOP.

  SORT gt_parentwi BY cwiid ASCENDING.
  DELETE ADJACENT DUPLICATES FROM gt_parentwi COMPARING cwiid.

  SORT gt_parentwi BY pwiid ASCENDING.

  gt_childwi2[] = gt_childwi[] = gt_parentwi[].

  DELETE ADJACENT DUPLICATES FROM gt_parentwi COMPARING pwiid.

ENDFORM.                    &quot; PARENT_WORK_ITEM_IDS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_EMAIL_FROM_PERNR
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LS_WIHEADER_ZZ_APPROVER1  text
*      &lt;--P_LS_WIHEADER_ZZ_APPR1EMAIL  text
*----------------------------------------------------------------------*
FORM get_email_from_pernr  USING    p_ls_wiheader_zz_approver1
                           CHANGING p_ls_wiheader_zz_appr1email.

  SELECT SINGLE usrid_long INTO p_ls_wiheader_zz_appr1email
    FROM pa0105
   WHERE pernr = p_ls_wiheader_zz_approver1
     AND subty = &apos;0010&apos;
     AND endda GE sy-datum
     AND begda LE sy-datum.

ENDFORM.                    &quot; GET_EMAIL_FROM_PERNR

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_NAPPROVER_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LV_APP1_USER  text
*      &lt;--P_LS_WIHEADER_ZZ_APPROVER1  text
*      &lt;--P_LS_WIHEADER_ZZ_APPR1EMAIL  text
*      &lt;--P_LS_WIHEADER_ZZ_APPR1STATUS  text
*----------------------------------------------------------------------*
FORM get_napprover_data  USING    p_lv_appn_user
                                  p_idx
                         CHANGING p_ls_wiheader_zz_approvern
                                  p_ls_wiheader_zz_apprnemail
                                  p_ls_wiheader_zz_apprnstatus
                                  p_ls_wiheader_zz_wifwd.

  DATA:
    ls_nodetab  TYPE parentwi.

  DATA:
    retcode TYPE sy-subrc.

  PERFORM get_pernr_from_user
                              USING
                                 p_lv_appn_user
                              CHANGING
                                 p_ls_wiheader_zz_approvern
                                 retcode.

  IF p_ls_wiheader_zz_approvern NE &apos;00000000&apos; AND retcode = 0.
    PERFORM get_email_from_pernr USING    p_ls_wiheader_zz_approvern
                                 CHANGING p_ls_wiheader_zz_apprnemail.
  ENDIF.

  IF NOT p_idx IS INITIAL.
    CLEAR ls_nodetab.
    READ TABLE gt_nodetab INTO ls_nodetab INDEX p_idx .
    IF NOT ls_nodetab IS INITIAL.
      p_ls_wiheader_zz_apprnstatus = ls_nodetab-wi_stat.
      IF ls_nodetab-wi_forw_by IS INITIAL.
        p_ls_wiheader_zz_wifwd = &apos;N&apos;.
      ELSE.
        p_ls_wiheader_zz_wifwd = &apos;Y&apos;.
      ENDIF.
    ENDIF.
  ENDIF.

ENDFORM.                    &quot; GET_NAPPROVER_DATA

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_REQUESTOR_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_INIT_PERNR  text
*      &lt;--P_LS_WIHEADER_ZZ_REQNAME  text
*      &lt;--P_LS_WIHEADER_ZZ_REQEMAIL  text
*      &lt;--P_LS_WIHEADER_ZZ_REQKOSTL  text
*----------------------------------------------------------------------*
FORM get_requestor_data  USING    p_init_pernr
                         CHANGING p_ls_wiheader_zz_reqname
                                  p_ls_wiheader_zz_reqemail
                                  p_ls_wiheader_zz_reqkostl.

  DATA:
    ls_return    LIKE bapireturn,
    lt_org_data  TYPE STANDARD TABLE OF  bapip0001b,
    lt_pers_data TYPE STANDARD TABLE OF  bapip0002b,
    lt_comm_data TYPE STANDARD TABLE OF  bapip0105b.

  DATA:
    ls_org_data  TYPE bapip0001b,
    ls_pers_data TYPE bapip0002b,
    ls_comm_data TYPE bapip0105b.

  CLEAR:
     ls_return,
     lt_org_data[],
     lt_pers_data[],
     lt_comm_data[],
     ls_org_data,
     ls_pers_data,
     ls_comm_data.


  CALL FUNCTION &apos;BAPI_EMPLOYEE_GETDATA&apos;
    EXPORTING
      employee_id    = p_init_pernr
    IMPORTING
      return         = ls_return
    TABLES
      org_assignment = lt_org_data
      personal_data  = lt_pers_data
      communication  = lt_comm_data.

  IF ls_return IS INITIAL.
    LOOP AT lt_org_data INTO ls_org_data WHERE to_date GE sy-datum
                                           AND from_date LE sy-datum.

      p_ls_wiheader_zz_reqkostl = ls_org_data-costcenter.

    ENDLOOP.

    LOOP AT lt_pers_data INTO ls_pers_data WHERE to_date GE sy-datum
                                             AND from_date LE sy-datum.

      CONCATENATE ls_pers_data-firstname ls_pers_data-last_name
             INTO p_ls_wiheader_zz_reqname SEPARATED BY space.

    ENDLOOP.

    LOOP AT lt_comm_data INTO ls_comm_data WHERE subtype = &apos;0010&apos;
                                           AND to_date GE sy-datum
                                           AND from_date LE sy-datum.

      p_ls_wiheader_zz_reqemail = ls_comm_data-usrid_long.

    ENDLOOP.
  ENDIF.

ENDFORM.                    &quot; GET_REQUESTOR_DATA

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_LEAVE_QTY
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LS_PARENTWI_PWIID  text
*      &lt;--P_LS_WIHEADER_ZZ_QUANTITY  text
*----------------------------------------------------------------------*
FORM get_leave_data  USING    p_ls_parentwi_pwiid
                     CHANGING p_ls_wiheader_zz_quantity
                              p_ls_wiheader_zz_postd.

  CONSTANTS:
        typeid TYPE sibftypeid VALUE &apos;CL_PT_REQ_WF_ATTRIBS&apos;,
        catid  TYPE sibfcatid VALUE &apos;CL&apos;.

  DATA: lcl_instance  TYPE REF TO cl_pt_req_wf_attribs,
        l_request     TYPE REF TO cl_pt_req_request,
        lcl_attribs   TYPE ptreq_request_struc_flat,
        l_oid         TYPE os_guid.

  DATA: lpor TYPE sibflpor,
        reqid TYPE tim_req_id,
        lt_items_tab TYPE ptreq_items_tab_flat,
        ws_items_tab TYPE ptreq_items_struc_flat,
        wa_attribs   TYPE name2value_table,
        ws_attribs   TYPE name2value,
        wa_pa2001    TYPE pa2001,
        lv_pernr     TYPE persno,
        lv_subty     TYPE subty,
        lv_endda     TYPE endda,
        lv_begda     TYPE begda.

  SELECT SINGLE request_id INTO reqid
    FROM ptreq_header
   WHERE workitem_id = p_ls_parentwi_pwiid.

  IF NOT reqid IS INITIAL.
    lpor-instid = reqid.
  ENDIF.

  CHECK NOT lpor-instid IS INITIAL.

  lpor-typeid = typeid.
  lpor-catid  = catid.

  CREATE OBJECT lcl_instance
    EXPORTING
      im_lpor = lpor.

*---Get request
  l_oid = lpor-instid.

  TRY.

      l_request ?= ca_pt_req_header=&gt;agent-&gt;if_os_ca_persistency~get_persistent_by_oid( l_oid ).

*---Get all attributes of request
      CALL METHOD l_request-&gt;if_pt_req_request~get_all_attribs
        IMPORTING
          ex_attribs_struc = lcl_attribs.
**---Use current version instead of workarea version
*      lcl_attribs-version-version_no = l_request-&gt;current_version_no.
**---Set workflow attributes
*      CALL METHOD lcl_instance-&gt;set_wf_attribs
*        EXPORTING
*          im_attribs      = lcl_attribs
*          im_workarea     = l_request-&gt;workarea_version
*          im_version_list = l_request-&gt;if_pt_req_request~list_of_versions.
*      result ?= lcl_instance.
    CATCH cx_os_error cx_os_system_error.
*----- exception: there is no instance for this key; key is not valid
*-----            leave the methos without returning an instance
      RETURN.
  ENDTRY.

*  READ TABLE LCL_ATTRIBS-VERSION-ITEM_TAB INTO wa_attabs INDEX 1.

  lt_items_tab = lcl_attribs-version-item_tab.

  READ TABLE lt_items_tab INTO ws_items_tab INDEX 1.
  wa_attribs = ws_items_tab-attribs_tab.

  CLEAR ws_attribs.
  READ TABLE wa_attribs INTO ws_attribs WITH KEY name = &apos;ATTABS_HOURS&apos;.
  IF NOT ws_attribs IS INITIAL.
    p_ls_wiheader_zz_quantity = ws_attribs-value.
  ENDIF.



  CLEAR ws_attribs.
  READ TABLE wa_attribs INTO ws_attribs WITH KEY name = &apos;PERNR&apos;.
  IF NOT ws_attribs IS INITIAL.
    lv_pernr = ws_attribs-value.
  ENDIF.

  CLEAR ws_attribs.
  READ TABLE wa_attribs INTO ws_attribs WITH KEY name = &apos;SUBTY&apos;.
  IF NOT ws_attribs IS INITIAL.
    lv_subty = ws_attribs-value.
  ENDIF.

  CLEAR ws_attribs.
  READ TABLE wa_attribs INTO ws_attribs WITH KEY name = &apos;ENDDA&apos;.
  IF NOT ws_attribs IS INITIAL.
    lv_endda = ws_attribs-value.
  ENDIF.

  CLEAR ws_attribs.
  READ TABLE wa_attribs INTO ws_attribs WITH KEY name = &apos;BEGDA&apos;.
  IF NOT ws_attribs IS INITIAL.
    lv_begda = ws_attribs-value.
  ENDIF.

  IF  NOT lv_pernr IS INITIAL
  AND NOT lv_subty IS INITIAL
  AND NOT lv_endda IS INITIAL
  AND NOT lv_begda IS INITIAL.

    CLEAR wa_pa2001.

    SELECT SINGLE * INTO wa_pa2001
      FROM pa2001
     WHERE pernr = lv_pernr
       AND subty = lv_subty
       AND endda = lv_endda
       AND begda = lv_begda.

    IF NOT wa_pa2001 IS INITIAL.
      p_ls_wiheader_zz_postd = &apos;TRUE&apos;.
    ELSE.
      p_ls_wiheader_zz_postd = &apos;FALSE&apos;.
    ENDIF.
  ENDIF.

ENDFORM.                    &quot; GET_LEAVE_QTY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_POSTING_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LV_PERNR  text
*      --&gt;P_LV_DATE  text
*      --&gt;P_4191   text
*      &lt;--P_LS_WIHEADER_ZZ_QUANTITY  text
*      &lt;--P_LS_WIHEADER_ZZ_POSTD  text
*----------------------------------------------------------------------*
FORM get_posting_data  USING    p_lv_pernr
                                p_lv_start_date
                                p_lv_end_date
                                p_subty
                                p_infty
                       CHANGING pnnnn
                                p_ls_wiheader_zz_postd.

  FIELD-SYMBOLS:
   &lt;pnnnn&gt; TYPE any.

  DATA:
    ref_infotype TYPE REF TO data,
    lv_typename  TYPE hrpclx_type.

  lv_typename = p_infty.
  CREATE DATA ref_infotype TYPE (lv_typename).
  ASSIGN ref_infotype-&gt;* TO &lt;pnnnn&gt;.

  SELECT SINGLE * INTO &lt;pnnnn&gt;
    FROM (p_infty)
   WHERE pernr =  p_lv_pernr
     AND subty =  p_subty
     AND sprps NE &apos;X&apos;
     AND endda = p_lv_end_date
     AND begda = p_lv_start_date.

  IF sy-subrc = 0.
    p_ls_wiheader_zz_postd = &apos;TRUE&apos;.
    pnnnn = &lt;pnnnn&gt;.
  ELSE.
    p_ls_wiheader_zz_postd = &apos;FALSE&apos;.
  ENDIF.

ENDFORM.                    &quot; GET_POSTING_DATA

*&amp;---------------------------------------------------------------------*
*&amp;      Form  BUILD_WT_RANGE
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      &lt;--P_R_WTYPES  text
*----------------------------------------------------------------------*
FORM build_wt_range.

  DATA:
  lt_t512z TYPE STANDARD TABLE OF t512z.

  DATA:
    ls_t512z TYPE t512z.

  CLEAR: lt_t512z,
         ls_t512z.

  SELECT * INTO TABLE lt_t512z
    FROM t512z
   WHERE infty = &apos;2010&apos;
     AND molga = &apos;16&apos;
     AND endda GE sy-datum
     AND begda LE sy-datum.

  IF NOT lt_t512z[] IS INITIAL.
    REFRESH r_wtypes.
    LOOP AT lt_t512z INTO ls_t512z.
      r_wtypes-sign = &apos;I&apos;.
      r_wtypes-option = &apos;EQ&apos;.
      r_wtypes-low = ls_t512z-lgart.
      APPEND r_wtypes.
      CLEAR:
         r_wtypes,
         ls_t512z.
    ENDLOOP.
  ENDIF.

ENDFORM.                    &quot; BUILD_WT_RANGE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_ORG_REAS_DATA
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LV_PERNR  text
*      --&gt;P_LV_DATE  text
*      --&gt;P_LV_NEW_PLANS  text
*      --&gt;P_LV_SCHKZ  text
*      --&gt;P_LV_MASSG  text
*      --&gt;P_LV_MASSN  text
*      &lt;--P_LS_WIHEADER_ZZ_POSTD  text
*----------------------------------------------------------------------*
FORM get_org_reas_data  USING    p_lv_pernr
                                 p_lv_date
                                 p_lv_new_plans
                                 p_lv_schkz
                                 p_lv_massg
                                 p_lv_massn
                        CHANGING p_ls_wiheader_zz_postd
                                 p_ls_wiheader_zz_wimsg.

  DATA:
    p0000 TYPE pa0000,
    p0001 TYPE pa0001,
    p0007 TYPE pa0007,
    p0008 TYPE pa0008.

  CLEAR:
     p0000,
     p0001,
     p0007,
     p0008.

  SELECT SINGLE * INTO p0000
    FROM pa0000
   WHERE pernr =  p_lv_pernr
     AND endda GE p_lv_date
     AND begda LE p_lv_date
     AND massn =  p_lv_massn
     AND massg =  p_lv_massg.

  IF sy-subrc NE 0.
    p_ls_wiheader_zz_postd = &apos;FALSE&apos;.
    p_ls_wiheader_zz_wimsg = &apos;IT0000 record does not exist.&apos;.
  ELSE.
    p_ls_wiheader_zz_postd = &apos;TRUE&apos;.
  ENDIF.

  IF  p_ls_wiheader_zz_postd = &apos;TRUE&apos;.
    SELECT SINGLE * INTO p0001
      FROM pa0001
     WHERE pernr =  p_lv_pernr
       AND endda GE p_lv_date
       AND begda LE p_lv_date
       AND plans =  p_lv_new_plans.

    IF sy-subrc NE 0.
      p_ls_wiheader_zz_postd = &apos;FALSE&apos;.
      p_ls_wiheader_zz_wimsg = &apos;IT0001 record does not exist.&apos;.
    ELSE.
      p_ls_wiheader_zz_postd = &apos;TRUE&apos;.
    ENDIF.
  ENDIF.

  IF  p_ls_wiheader_zz_postd = &apos;TRUE&apos;.
    SELECT SINGLE * INTO p0007
      FROM pa0007
     WHERE pernr =  p_lv_pernr
       AND endda GE p_lv_date
       AND begda LE p_lv_date
       AND schkz =  p_lv_schkz.

    IF sy-subrc NE 0.
      p_ls_wiheader_zz_postd = &apos;FALSE&apos;.
      p_ls_wiheader_zz_wimsg = &apos;IT0007 record does not exist.&apos;.
    ELSE.
      p_ls_wiheader_zz_postd = &apos;TRUE&apos;.
    ENDIF.
  ENDIF.

  IF  p_ls_wiheader_zz_postd = &apos;TRUE&apos;.
    SELECT SINGLE * INTO p0008
      FROM pa0008
     WHERE pernr =  p_lv_pernr
       AND endda GE p_lv_date
       AND begda LE p_lv_date.

    IF sy-subrc NE 0.
      p_ls_wiheader_zz_postd = &apos;FALSE&apos;.
      p_ls_wiheader_zz_wimsg = &apos;IT0007 record does not exist.&apos;.
    ELSE.
      p_ls_wiheader_zz_postd = &apos;TRUE&apos;.
    ENDIF.
  ENDIF.

ENDFORM.                    &quot; GET_ORG_REAS_DATA

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_NO_DAYS
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_LS_CHILDWI_CWIID  text
*      &lt;--P_LS_WIHEADER_ZZ_WINOD  text
*----------------------------------------------------------------------*
FORM get_no_days  USING    p_ls_childwi_cwiid
                  CHANGING p_ls_wiheader_zz_winod.

  DATA: ls_nodetab  TYPE parentwi,
        lv_days     TYPE i.

  CLEAR:
     ls_nodetab,
     lv_days.

  READ TABLE gt_nodetab INTO ls_nodetab WITH KEY cwiid = p_ls_childwi_cwiid.

  IF  ls_nodetab-wi_stat NE &apos;COMMITTED&apos; AND
      ls_nodetab-wi_stat NE &apos;COMPLETED&apos; AND
      ls_nodetab-wi_stat NE &apos;CANCELLED&apos; AND
      ls_nodetab-wi_stat NE &apos;EXCPCAUGHT&apos; AND
      ls_nodetab-wi_stat NE &apos;EXCPHANDLR&apos;.

    lv_days = sy-datum - ls_nodetab-wi_cd.

    IF NOT lv_days IS INITIAL.
      p_ls_wiheader_zz_winod = lv_days.
    ENDIF.

  ENDIF.

ENDFORM.                    &quot; GET_NO_DAYS</source>
 </PROG>
</nugget>
